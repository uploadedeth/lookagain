"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addAdminServicesToServer = exports.registerAdminService = void 0;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({ getServiceDefinition, getHandlers });\n}\nexports.registerAdminService = registerAdminService;\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n}\nexports.addAdminServicesToServer = addAdminServicesToServer;\n//# sourceMappingURL=admin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9hZG1pbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLDRCQUE0QjtBQUMvRDtBQUNBO0FBQ0EsbUNBQW1DLG1DQUFtQztBQUN0RTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9hZG1pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBleHBvcnRzLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlID0gdm9pZCAwO1xuY29uc3QgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMgPSBbXTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQWRtaW5TZXJ2aWNlKGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycykge1xuICAgIHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzLnB1c2goeyBnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMgfSk7XG59XG5leHBvcnRzLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlID0gcmVnaXN0ZXJBZG1pblNlcnZpY2U7XG5mdW5jdGlvbiBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIoc2VydmVyKSB7XG4gICAgZm9yIChjb25zdCB7IGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycyB9IG9mIHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzKSB7XG4gICAgICAgIHNlcnZlci5hZGRTZXJ2aWNlKGdldFNlcnZpY2VEZWZpbml0aW9uKCksIGdldEhhbmRsZXJzKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyID0gYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRtaW4uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options) {\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */\n        this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */\n        this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */\n        this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */\n        this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */\n        this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */\n        this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */\n        this.startTime = new Date();\n        /**\n         * The approximate time that the currently running timer will end. Only valid\n         * if running is true.\n         */\n        this.endTime = new Date();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(() => { }, 0);\n        clearTimeout(this.timerId);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        this.endTime = this.startTime;\n        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(() => {\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */\n    runOnce() {\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay =\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */\n    stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */\n    reset() {\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            }\n            else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */\n    isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */\n    ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */\n    unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Get the approximate timestamp of when the timer will fire. Only valid if\n     * this.isRunning() is true.\n     */\n    getEndTime() {\n        return this.endTime;\n    }\n}\nexports.BackoffTimeout = BackoffTimeout;\n//# sourceMappingURL=backoff-timeout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9iYWNrb2ZmLXRpbWVvdXQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gdm9pZCAwO1xuY29uc3QgSU5JVElBTF9CQUNLT0ZGX01TID0gMTAwMDtcbmNvbnN0IEJBQ0tPRkZfTVVMVElQTElFUiA9IDEuNjtcbmNvbnN0IE1BWF9CQUNLT0ZGX01TID0gMTIwMDAwO1xuY29uc3QgQkFDS09GRl9KSVRURVIgPSAwLjI7XG4vKipcbiAqIEdldCBhIG51bWJlciB1bmlmb3JtbHkgYXQgcmFuZG9tIGluIHRoZSByYW5nZSBbbWluLCBtYXgpXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKi9cbmZ1bmN0aW9uIHVuaWZvcm1SYW5kb20obWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuY2xhc3MgQmFja29mZlRpbWVvdXQge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWxheSB0aW1lIGF0IHRoZSBzdGFydCwgYW5kIGFmdGVyIGVhY2ggcmVzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxEZWxheSA9IElOSVRJQUxfQkFDS09GRl9NUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBleHBvbmVudGlhbCBiYWNrb2ZmIG11bHRpcGxpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBCQUNLT0ZGX01VTFRJUExJRVI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBkZWxheSB0aW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heERlbGF5ID0gTUFYX0JBQ0tPRkZfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBmcmFjdGlvbiBieSB3aGljaCB0aGUgZGVsYXkgdGltZSBjYW4gcmFuZG9tbHkgdmFyeSBhZnRlclxuICAgICAgICAgKiBhcHBseWluZyB0aGUgbXVsdGlwbGllci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaml0dGVyID0gQkFDS09GRl9KSVRURVI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZXIgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aW1lciBzaG91bGQga2VlcCB0aGUgTm9kZSBwcm9jZXNzIHJ1bm5pbmcgaWYgbm9cbiAgICAgICAgICogb3RoZXIgYXN5bmMgb3BlcmF0aW9uIGlzIGRvaW5nIHNvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNSZWYgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgdGhhdCB0aGUgY3VycmVudGx5IHJ1bm5pbmcgdGltZXIgd2FzIHN0YXJ0ZWQuIE9ubHkgdmFsaWQgaWZcbiAgICAgICAgICogcnVubmluZyBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFwcHJveGltYXRlIHRpbWUgdGhhdCB0aGUgY3VycmVudGx5IHJ1bm5pbmcgdGltZXIgd2lsbCBlbmQuIE9ubHkgdmFsaWRcbiAgICAgICAgICogaWYgcnVubmluZyBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmluaXRpYWxEZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gb3B0aW9ucy5pbml0aWFsRGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gb3B0aW9ucy5tdWx0aXBsaWVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaml0dGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5qaXR0ZXIgPSBvcHRpb25zLmppdHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhEZWxheSA9IG9wdGlvbnMubWF4RGVsYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPSB0aGlzLmluaXRpYWxEZWxheTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICB9XG4gICAgcnVuVGltZXIoZGVsYXkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIHRoaXMuZW5kVGltZS5zZXRNaWxsaXNlY29uZHModGhpcy5lbmRUaW1lLmdldE1pbGxpc2Vjb25kcygpICsgdGhpcy5uZXh0RGVsYXkpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzUmVmKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVySWQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgY2FsbGJhY2sgYWZ0ZXIgdGhlIGN1cnJlbnQgYW1vdW50IG9mIGRlbGF5IHRpbWVcbiAgICAgKi9cbiAgICBydW5PbmNlKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMucnVuVGltZXIodGhpcy5uZXh0RGVsYXkpO1xuICAgICAgICBjb25zdCBuZXh0QmFja29mZiA9IE1hdGgubWluKHRoaXMubmV4dERlbGF5ICogdGhpcy5tdWx0aXBsaWVyLCB0aGlzLm1heERlbGF5KTtcbiAgICAgICAgY29uc3Qgaml0dGVyTWFnbml0dWRlID0gbmV4dEJhY2tvZmYgKiB0aGlzLmppdHRlcjtcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPVxuICAgICAgICAgICAgbmV4dEJhY2tvZmYgKyB1bmlmb3JtUmFuZG9tKC1qaXR0ZXJNYWduaXR1ZGUsIGppdHRlck1hZ25pdHVkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHRpbWVyLiBUaGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIHVudGlsIGBydW5PbmNlYCBpcyBjYWxsZWRcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBkZWxheSB0aW1lIHRvIGl0cyBpbml0aWFsIHZhbHVlLiBJZiB0aGUgdGltZXIgaXMgc3RpbGwgcnVubmluZyxcbiAgICAgKiByZXRyb2FjdGl2ZWx5IGFwcGx5IHRoYXQgcmVzZXQgdG8gdGhlIGN1cnJlbnQgdGltZXIuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubmV4dERlbGF5ID0gdGhpcy5pbml0aWFsRGVsYXk7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBuZXdFbmRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgICAgICBuZXdFbmRUaW1lLnNldE1pbGxpc2Vjb25kcyhuZXdFbmRUaW1lLmdldE1pbGxpc2Vjb25kcygpICsgdGhpcy5uZXh0RGVsYXkpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICAgICAgICBpZiAobm93IDwgbmV3RW5kVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZXIobmV3RW5kVGltZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAqL1xuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVubmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoYXQgd2hpbGUgdGhlIHRpbWVyIGlzIHJ1bm5pbmcsIGl0IHNob3VsZCBrZWVwIHRoZSBOb2RlIHByb2Nlc3NcbiAgICAgKiBydW5uaW5nLlxuICAgICAqL1xuICAgIHJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5oYXNSZWYgPSB0cnVlO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVySWQpLnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhhdCB3aGlsZSB0aGUgdGltZXIgaXMgcnVubmluZywgaXQgc2hvdWxkIG5vdCBrZWVwIHRoZSBOb2RlIHByb2Nlc3NcbiAgICAgKiBydW5uaW5nLlxuICAgICAqL1xuICAgIHVucmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmhhc1JlZiA9IGZhbHNlO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVySWQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXBwcm94aW1hdGUgdGltZXN0YW1wIG9mIHdoZW4gdGhlIHRpbWVyIHdpbGwgZmlyZS4gT25seSB2YWxpZCBpZlxuICAgICAqIHRoaXMuaXNSdW5uaW5nKCkgaXMgdHJ1ZS5cbiAgICAgKi9cbiAgICBnZXRFbmRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRUaW1lO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFja29mZlRpbWVvdXQgPSBCYWNrb2ZmVGltZW91dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tvZmYtdGltZW91dC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return ('getRequestHeaders' in client &&\n        typeof client.getRequestHeaders === 'function');\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nclass CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */\n    static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */\n    static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback) => {\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            }\n            else {\n                getHeaders = new Promise((resolve, reject) => {\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        if (!headers) {\n                            reject(new Error('Headers not set by metadata plugin'));\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then(headers => {\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)) {\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, err => {\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds) {\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));\n        for (const gen of generated) {\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([other]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index) => value._equals(other.creds[index]));\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator) {\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject) => {\n            this.metadataGenerator(options, (err, metadata) => {\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([this, other]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n}\n//# sourceMappingURL=call-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5mdW5jdGlvbiBpc0N1cnJlbnRPYXV0aDJDbGllbnQoY2xpZW50KSB7XG4gICAgcmV0dXJuICgnZ2V0UmVxdWVzdEhlYWRlcnMnIGluIGNsaWVudCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50LmdldFJlcXVlc3RIZWFkZXJzID09PSAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSBnZW5lcmljIG1ldGhvZCBvZiBhZGRpbmcgYXV0aGVudGljYXRpb24tcmVsYXRlZFxuICogbWV0YWRhdGEgb24gYSBwZXItcmVxdWVzdCBiYXNpcy5cbiAqL1xuY2xhc3MgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENhbGxDcmVkZW50aWFscyBvYmplY3QgZnJvbSBhIGdpdmVuIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzXG4gICAgICogTWV0YWRhdGEgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0gbWV0YWRhdGFHZW5lcmF0b3IgQSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSBzZXQgb2Ygb3B0aW9ucywgYW5kXG4gICAgICogZ2VuZXJhdGVzIGEgTWV0YWRhdGEgb2JqZWN0IGJhc2VkIG9uIHRoZXNlIG9wdGlvbnMsIHdoaWNoIGlzIHBhc3NlZCBiYWNrXG4gICAgICogdG8gdGhlIGNhbGxlciB2aWEgYSBzdXBwbGllZCAoZXJyLCBtZXRhZGF0YSkgY2FsbGJhY2suXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcihtZXRhZGF0YUdlbmVyYXRvcikge1xuICAgICAgICByZXR1cm4gbmV3IFNpbmdsZUNhbGxDcmVkZW50aWFscyhtZXRhZGF0YUdlbmVyYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGdSUEMgY3JlZGVudGlhbCBmcm9tIGEgR29vZ2xlIGNyZWRlbnRpYWwgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBnb29nbGVDcmVkZW50aWFscyBUaGUgYXV0aGVudGljYXRpb24gY2xpZW50IHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwoZ29vZ2xlQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIENhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IoKG9wdGlvbnMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBsZXQgZ2V0SGVhZGVycztcbiAgICAgICAgICAgIGlmIChpc0N1cnJlbnRPYXV0aDJDbGllbnQoZ29vZ2xlQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVycyA9IGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RIZWFkZXJzKG9wdGlvbnMuc2VydmljZV91cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0SGVhZGVycyA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ29vZ2xlQ3JlZGVudGlhbHMuZ2V0UmVxdWVzdE1ldGFkYXRhKG9wdGlvbnMuc2VydmljZV91cmwsIChlcnIsIGhlYWRlcnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdIZWFkZXJzIG5vdCBzZXQgYnkgbWV0YWRhdGEgcGx1Z2luJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2V0SGVhZGVycy50aGVuKGhlYWRlcnMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5hZGQoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUNhbGxDcmVkZW50aWFscygpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gQ2FsbENyZWRlbnRpYWxzO1xuY2xhc3MgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNyZWRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY3JlZHMgPSBjcmVkcztcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWQgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNyZWRzLm1hcChjcmVkID0+IGNyZWQuZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSkpO1xuICAgICAgICBmb3IgKGNvbnN0IGdlbiBvZiBnZW5lcmF0ZWQpIHtcbiAgICAgICAgICAgIGJhc2UubWVyZ2UoZ2VuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKHRoaXMuY3JlZHMuY29uY2F0KFtvdGhlcl0pKTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVkcy5ldmVyeSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZS5fZXF1YWxzKG90aGVyLmNyZWRzW2luZGV4XSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgU2luZ2xlQ2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRhZGF0YUdlbmVyYXRvcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhR2VuZXJhdG9yID0gbWV0YWRhdGFHZW5lcmF0b3I7XG4gICAgfVxuICAgIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvcihvcHRpb25zLCAoZXJyLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wb3NlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHMoW3RoaXMsIG90aGVyXSk7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBTaW5nbGVDYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1ldGFkYXRhR2VuZXJhdG9yID09PSBvdGhlci5tZXRhZGF0YUdlbmVyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEVtcHR5Q2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpKTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgRW1wdHlDYWxsQ3JlZGVudGlhbHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-interface.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nfunction isInterceptingListener(listener) {\n    return (listener.onReceiveMetadata !== undefined &&\n        listener.onReceiveMetadata.length === 1);\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener) {\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, metadata => {\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */\n        this.processingMessage = true;\n        this.listener.onReceiveMessage(message, msg => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            }\n            else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, processedStatus => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            }\n            else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\n//# sourceMappingURL=call-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLDhCQUE4QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsID0gZXhwb3J0cy5pc0ludGVyY2VwdGluZ0xpc3RlbmVyID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHJldHVybiAobGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YS5sZW5ndGggPT09IDEpO1xufVxuZXhwb3J0cy5pc0ludGVyY2VwdGluZ0xpc3RlbmVyID0gaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcjtcbmNsYXNzIEludGVyY2VwdGluZ0xpc3RlbmVySW1wbCB7XG4gICAgY29uc3RydWN0b3IobGlzdGVuZXIsIG5leHRMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMubmV4dExpc3RlbmVyID0gbmV4dExpc3RlbmVyO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gbnVsbDtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNQZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSh0aGlzLnBlbmRpbmdNZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nU3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nU3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXModGhpcy5wZW5kaW5nU3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEsIG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ1N0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogSWYgdGhpcyBsaXN0ZW5lciBwcm9jZXNzZXMgbWVzc2FnZXMgYXN5bmNocm9ub3VzbHksIHRoZSBsYXN0IG1lc3NhZ2UgbWF5XG4gICAgICAgICAqIGJlIHJlb3JkZXJlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIHN0YXR1cyAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UsIG1zZyA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVTdGF0dXMoc3RhdHVzLCBwcm9jZXNzZWRTdGF0dXMgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBwcm9jZXNzZWRTdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMocHJvY2Vzc2VkU3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwgPSBJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNextCallNumber = void 0;\nlet nextCallNumber = 0;\nfunction getNextCallNumber() {\n    return nextCallNumber++;\n}\nexports.getNextCallNumber = getNextCallNumber;\n//# sourceMappingURL=call-number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLW51bWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1udW1iZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0TmV4dENhbGxOdW1iZXIgPSB2b2lkIDA7XG5sZXQgbmV4dENhbGxOdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ2V0TmV4dENhbGxOdW1iZXIoKSB7XG4gICAgcmV0dXJuIG5leHRDYWxsTnVtYmVyKys7XG59XG5leHBvcnRzLmdldE5leHRDYWxsTnVtYmVyID0gZ2V0TmV4dENhbGxOdW1iZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLW51bWJlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nfunction callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, { stack });\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor() {\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize) {\n        super({ objectMode: true });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;\n//# sourceMappingURL=call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsOEJBQThCLEdBQUcsZ0NBQWdDLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQ2hLLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWEsRUFBRSxnQ0FBZ0MsSUFBSSxlQUFlO0FBQ3pGO0FBQ0EscUJBQXFCLFlBQVksaUJBQWlCLFlBQVk7QUFDOUQsdURBQXVELE9BQU87QUFDOUQ7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudER1cGxleFN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gZXhwb3J0cy5jYWxsRXJyb3JGcm9tU3RhdHVzID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIENvbnN0cnVjdCBhIFNlcnZpY2VFcnJvciBmcm9tIGEgU3RhdHVzT2JqZWN0LiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBwcmltYXJpbHlcbiAqIGFzIGFuIGF0dGVtcHQgdG8gbWFrZSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgY2xlYXJseSBjb21tdW5pY2F0ZSB0aGF0IHRoZVxuICogZXJyb3IgaXMgbm90IG5lY2Vzc2FyaWx5IGEgcHJvYmxlbSBpbiBnUlBDIGl0c2VsZi5cbiAqIEBwYXJhbSBzdGF0dXNcbiAqL1xuZnVuY3Rpb24gY2FsbEVycm9yRnJvbVN0YXR1cyhzdGF0dXMsIGNhbGxlclN0YWNrKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGAke3N0YXR1cy5jb2RlfSAke2NvbnN0YW50c18xLlN0YXR1c1tzdGF0dXMuY29kZV19OiAke3N0YXR1cy5kZXRhaWxzfWA7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgY29uc3Qgc3RhY2sgPSBgJHtlcnJvci5zdGFja31cXG5mb3IgY2FsbCBhdFxcbiR7Y2FsbGVyU3RhY2t9YDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IobWVzc2FnZSksIHN0YXR1cywgeyBzdGFjayB9KTtcbn1cbmV4cG9ydHMuY2FsbEVycm9yRnJvbVN0YXR1cyA9IGNhbGxFcnJvckZyb21TdGF0dXM7XG5jbGFzcyBDbGllbnRVbmFyeUNhbGxJbXBsIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50VW5hcnlDYWxsSW1wbCA9IENsaWVudFVuYXJ5Q2FsbEltcGw7XG5jbGFzcyBDbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZGVzZXJpYWxpemUpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydFJlYWQoKTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCA9IENsaWVudFJlYWRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIENsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLldyaXRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemUpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZsYWdzID0gTnVtYmVyKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XG4gICAgfVxuICAgIF9maW5hbChjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbGZDbG9zZSgpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsID0gQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmbGFncyA9IE51bWJlcihlbmNvZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGZsYWdzKSkge1xuICAgICAgICAgICAgY29udGV4dC5mbGFncyA9IGZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgY2h1bmspO1xuICAgIH1cbiAgICBfZmluYWwoY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYWxmQ2xvc2UoKTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudER1cGxleFN0cmVhbUltcGwgPSBDbGllbnREdXBsZXhTdHJlYW1JbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChannelCredentials = void 0;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nclass ChannelCredentials {\n    constructor(callCredentials) {\n        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n    }\n    /**\n     * Gets the set of per-call credentials associated with this instance.\n     */\n    _getCallCredentials() {\n        return this.callCredentials;\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */\n    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, 'Root certificate');\n        verifyIsBufferOrNull(privateKey, 'Private key');\n        verifyIsBufferOrNull(certChain, 'Certificate chain');\n        if (privateKey && !certChain) {\n            throw new Error('Private key must be given with accompanying certificate chain');\n        }\n        if (!privateKey && certChain) {\n            throw new Error('Certificate chain must be given with accompanying private key');\n        }\n        const secureContext = (0, tls_1.createSecureContext)({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES,\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */\n    static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */\n    static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(callCredentials) {\n        super(callCredentials);\n    }\n    compose(callCredentials) {\n        throw new Error('Cannot compose insecure credentials');\n    }\n    _getConnectionOptions() {\n        return null;\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions) {\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n        this.connectionOptions = {\n            secureContext,\n        };\n        // Node asserts that this option is a function, so we cannot pass undefined\n        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n            this.connectionOptions.checkServerIdentity =\n                verifyOptions.checkServerIdentity;\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        // Copy to prevent callers from mutating this.connectionOptions\n        return Object.assign({}, this.connectionOptions);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return (this.secureContext === other.secureContext &&\n                this.verifyOptions.checkServerIdentity ===\n                    other.verifyOptions.checkServerIdentity);\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCreds) {\n        super(callCreds);\n        this.channelCredentials = channelCredentials;\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        return this.channelCredentials._getConnectionOptions();\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return (this.channelCredentials._equals(other.channelCredentials) &&\n                this.callCredentials._equals(other.callCredentials));\n        }\n        else {\n            return false;\n        }\n    }\n}\n//# sourceMappingURL=channel-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDdkQsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNJQUFzSTtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSUFBc0k7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLWNyZWRlbnRpYWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IGNhbGxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHNcIik7XG5jb25zdCB0bHNfaGVscGVyc18xID0gcmVxdWlyZShcIi4vdGxzLWhlbHBlcnNcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdmVyaWZ5SXNCdWZmZXJPck51bGwob2JqLCBmcmllbmRseU5hbWUpIHtcbiAgICBpZiAob2JqICYmICEob2JqIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2ZyaWVuZGx5TmFtZX0sIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgQnVmZmVyLmApO1xuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNvbnRhaW5zIGNyZWRlbnRpYWxzIGZvciBjb21tdW5pY2F0aW5nIG92ZXIgYSBjaGFubmVsLCBhcyB3ZWxsXG4gKiBhcyBhIHNldCBvZiBwZXItY2FsbCBjcmVkZW50aWFscywgd2hpY2ggYXJlIGFwcGxpZWQgdG8gZXZlcnkgbWV0aG9kIGNhbGwgbWFkZVxuICogb3ZlciBhIGNoYW5uZWwgaW5pdGlhbGl6ZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICovXG5jbGFzcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscyA9IGNhbGxDcmVkZW50aWFscyB8fCBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNldCBvZiBwZXItY2FsbCBjcmVkZW50aWFscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBfZ2V0Q2FsbENyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsQ3JlZGVudGlhbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBhIGdpdmVuIHNldCBvZiBjcmVkZW50aWFscy5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIGluc3RhbmNlIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXNcbiAgICAgKiBvdmVyIFRMUy5cbiAgICAgKiBAcGFyYW0gcm9vdENlcnRzIFRoZSByb290IGNlcnRpZmljYXRlIGRhdGEuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBwcml2YXRlIGtleSwgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSBjZXJ0Q2hhaW4gVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBrZXkgY2hhaW4sIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gdmVyaWZ5T3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gbW9kaWZ5IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTc2wocm9vdENlcnRzLCBwcml2YXRlS2V5LCBjZXJ0Q2hhaW4sIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChyb290Q2VydHMsICdSb290IGNlcnRpZmljYXRlJyk7XG4gICAgICAgIHZlcmlmeUlzQnVmZmVyT3JOdWxsKHByaXZhdGVLZXksICdQcml2YXRlIGtleScpO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChjZXJ0Q2hhaW4sICdDZXJ0aWZpY2F0ZSBjaGFpbicpO1xuICAgICAgICBpZiAocHJpdmF0ZUtleSAmJiAhY2VydENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaXZhdGUga2V5IG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgY2VydGlmaWNhdGUgY2hhaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByaXZhdGVLZXkgJiYgY2VydENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIGNoYWluIG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWN1cmVDb250ZXh0ID0gKDAsIHRsc18xLmNyZWF0ZVNlY3VyZUNvbnRleHQpKHtcbiAgICAgICAgICAgIGNhOiAoX2EgPSByb290Q2VydHMgIT09IG51bGwgJiYgcm9vdENlcnRzICE9PSB2b2lkIDAgPyByb290Q2VydHMgOiAoMCwgdGxzX2hlbHBlcnNfMS5nZXREZWZhdWx0Um9vdHNEYXRhKSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBrZXk6IHByaXZhdGVLZXkgIT09IG51bGwgJiYgcHJpdmF0ZUtleSAhPT0gdm9pZCAwID8gcHJpdmF0ZUtleSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlcnQ6IGNlcnRDaGFpbiAhPT0gbnVsbCAmJiBjZXJ0Q2hhaW4gIT09IHZvaWQgMCA/IGNlcnRDaGFpbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNpcGhlcnM6IHRsc19oZWxwZXJzXzEuQ0lQSEVSX1NVSVRFUyxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zICE9PSBudWxsICYmIHZlcmlmeU9wdGlvbnMgIT09IHZvaWQgMCA/IHZlcmlmeU9wdGlvbnMgOiB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBjcmVkZW50aWFscyBjcmVhdGVkIHVzaW5nXG4gICAgICogdGhlIHByb3ZpZGVkIHNlY3VyZUNvbnRleHQuIFRoZSByZXN1bHRpbmcgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIHRvXG4gICAgICogY29uc3RydWN0IGEgQ2hhbm5lbCB0aGF0IGNvbW11bmljYXRlcyBvdmVyIFRMUy4gZ1JQQyB3aWxsIG5vdCBvdmVycmlkZVxuICAgICAqIGFueXRoaW5nIGluIHRoZSBwcm92aWRlZCBzZWN1cmVDb250ZXh0LCBzbyB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gICAgICogR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUyBhbmQgR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEggd2lsbFxuICAgICAqIG5vdCBiZSBhcHBsaWVkLlxuICAgICAqIEBwYXJhbSBzZWN1cmVDb250ZXh0IFRoZSByZXR1cm4gdmFsdWUgb2YgdGxzLmNyZWF0ZVNlY3VyZUNvbnRleHQoKVxuICAgICAqIEBwYXJhbSB2ZXJpZnlPcHRpb25zIEFkZGl0aW9uYWwgb3B0aW9ucyB0byBtb2RpZnkgY2VydGlmaWNhdGUgdmVyaWZpY2F0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21TZWN1cmVDb250ZXh0KHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMgIT09IG51bGwgJiYgdmVyaWZ5T3B0aW9ucyAhPT0gdm9pZCAwID8gdmVyaWZ5T3B0aW9ucyA6IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIG5vIGNyZWRlbnRpYWxzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVJbnNlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoKTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IENoYW5uZWxDcmVkZW50aWFscztcbmNsYXNzIEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHN1cGVyKGNhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBvc2UgaW5zZWN1cmUgY3JlZGVudGlhbHMnKTtcbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb25PcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsO1xuICAgIH1cbn1cbmNsYXNzIFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zZWN1cmVDb250ZXh0ID0gc2VjdXJlQ29udGV4dDtcbiAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zID0gdmVyaWZ5T3B0aW9ucztcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNlY3VyZUNvbnRleHQsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vZGUgYXNzZXJ0cyB0aGF0IHRoaXMgb3B0aW9uIGlzIGEgZnVuY3Rpb24sIHNvIHdlIGNhbm5vdCBwYXNzIHVuZGVmaW5lZFxuICAgICAgICBpZiAodmVyaWZ5T3B0aW9ucyA9PT0gbnVsbCB8fCB2ZXJpZnlPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9XG4gICAgICAgICAgICAgICAgdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jYWxsQ3JlZGVudGlhbHMuY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCh0aGlzLCBjb21iaW5lZENhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgLy8gQ29weSB0byBwcmV2ZW50IGNhbGxlcnMgZnJvbSBtdXRhdGluZyB0aGlzLmNvbm5lY3Rpb25PcHRpb25zXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5zZWN1cmVDb250ZXh0ID09PSBvdGhlci5zZWN1cmVDb250ZXh0ICYmXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPT09XG4gICAgICAgICAgICAgICAgICAgIG90aGVyLnZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDcmVkZW50aWFscywgY2FsbENyZWRzKSB7XG4gICAgICAgIHN1cGVyKGNhbGxDcmVkcyk7XG4gICAgICAgIHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzID0gY2hhbm5lbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBjb21iaW5lZENhbGxDcmVkZW50aWFscyA9IHRoaXMuY2FsbENyZWRlbnRpYWxzLmNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcy5jaGFubmVsQ3JlZGVudGlhbHMsIGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb25PcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsQ3JlZGVudGlhbHMuX2dldENvbm5lY3Rpb25PcHRpb25zKCk7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5jaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jaGFubmVsQ3JlZGVudGlhbHMpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMuX2VxdWFscyhvdGhlci5jYWxsQ3JlZGVudGlhbHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.channelOptionsEqual = exports.recognizedOptions = void 0;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */\nexports.recognizedOptions = {\n    'grpc.ssl_target_name_override': true,\n    'grpc.primary_user_agent': true,\n    'grpc.secondary_user_agent': true,\n    'grpc.default_authority': true,\n    'grpc.keepalive_time_ms': true,\n    'grpc.keepalive_timeout_ms': true,\n    'grpc.keepalive_permit_without_calls': true,\n    'grpc.service_config': true,\n    'grpc.max_concurrent_streams': true,\n    'grpc.initial_reconnect_backoff_ms': true,\n    'grpc.max_reconnect_backoff_ms': true,\n    'grpc.use_local_subchannel_pool': true,\n    'grpc.max_send_message_length': true,\n    'grpc.max_receive_message_length': true,\n    'grpc.enable_http_proxy': true,\n    'grpc.enable_channelz': true,\n    'grpc.dns_min_time_between_resolutions_ms': true,\n    'grpc.enable_retries': true,\n    'grpc.per_rpc_retry_buffer_size': true,\n    'grpc.retry_buffer_size': true,\n    'grpc.max_connection_age_ms': true,\n    'grpc.max_connection_age_grace_ms': true,\n    'grpc-node.max_session_memory': true,\n    'grpc.service_config_disable_resolution': true,\n    'grpc.client_idle_timeout_ms': true,\n    'grpc-node.tls_enable_trace': true,\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let i = 0; i < keys1.length; i += 1) {\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.channelOptionsEqual = channelOptionsEqual;\n//# sourceMappingURL=channel-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLW9wdGlvbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyx5QkFBeUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NoYW5uZWwtb3B0aW9ucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGFubmVsT3B0aW9uc0VxdWFsID0gZXhwb3J0cy5yZWNvZ25pemVkT3B0aW9ucyA9IHZvaWQgMDtcbi8qKlxuICogVGhpcyBpcyBmb3IgY2hlY2tpbmcgcHJvdmlkZWQgb3B0aW9ucyBhdCBydW50aW1lLiBUaGlzIGlzIGFuIG9iamVjdCBmb3JcbiAqIGVhc2llciBtZW1iZXJzaGlwIGNoZWNraW5nLlxuICovXG5leHBvcnRzLnJlY29nbml6ZWRPcHRpb25zID0ge1xuICAgICdncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSc6IHRydWUsXG4gICAgJ2dycGMucHJpbWFyeV91c2VyX2FnZW50JzogdHJ1ZSxcbiAgICAnZ3JwYy5zZWNvbmRhcnlfdXNlcl9hZ2VudCc6IHRydWUsXG4gICAgJ2dycGMuZGVmYXVsdF9hdXRob3JpdHknOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV90aW1lX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcyc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJzogdHJ1ZSxcbiAgICAnZ3JwYy5zZXJ2aWNlX2NvbmZpZyc6IHRydWUsXG4gICAgJ2dycGMubWF4X2NvbmN1cnJlbnRfc3RyZWFtcyc6IHRydWUsXG4gICAgJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyc6IHRydWUsXG4gICAgJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCc6IHRydWUsXG4gICAgJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnOiB0cnVlLFxuICAgICdncnBjLmVuYWJsZV9odHRwX3Byb3h5JzogdHJ1ZSxcbiAgICAnZ3JwYy5lbmFibGVfY2hhbm5lbHonOiB0cnVlLFxuICAgICdncnBjLmRuc19taW5fdGltZV9iZXR3ZWVuX3Jlc29sdXRpb25zX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy5lbmFibGVfcmV0cmllcyc6IHRydWUsXG4gICAgJ2dycGMucGVyX3JwY19yZXRyeV9idWZmZXJfc2l6ZSc6IHRydWUsXG4gICAgJ2dycGMucmV0cnlfYnVmZmVyX3NpemUnOiB0cnVlLFxuICAgICdncnBjLm1heF9jb25uZWN0aW9uX2FnZV9tcyc6IHRydWUsXG4gICAgJ2dycGMubWF4X2Nvbm5lY3Rpb25fYWdlX2dyYWNlX21zJzogdHJ1ZSxcbiAgICAnZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeSc6IHRydWUsXG4gICAgJ2dycGMuc2VydmljZV9jb25maWdfZGlzYWJsZV9yZXNvbHV0aW9uJzogdHJ1ZSxcbiAgICAnZ3JwYy5jbGllbnRfaWRsZV90aW1lb3V0X21zJzogdHJ1ZSxcbiAgICAnZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNoYW5uZWxPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvcHRpb25zMSkuc29ydCgpO1xuICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob3B0aW9uczIpLnNvcnQoKTtcbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChrZXlzMVtpXSAhPT0ga2V5czJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uczFba2V5czFbaV1dICE9PSBvcHRpb25zMltrZXlzMltpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hhbm5lbE9wdGlvbnNFcXVhbCA9IGNoYW5uZWxPcHRpb25zRXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChannelImplementation = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\nclass ChannelImplementation {\n    constructor(target, credentials, options) {\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object') {\n                throw new TypeError('Channel options must be an object');\n            }\n        }\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\n    }\n    close() {\n        this.internalChannel.close();\n    }\n    getTarget() {\n        return this.internalChannel.getTarget();\n    }\n    getConnectivityState(tryToConnect) {\n        return this.internalChannel.getConnectivityState(tryToConnect);\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.internalChannel.getChannelzRef();\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.ChannelImplementation = ChannelImplementation;\n//# sourceMappingURL=channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLDhCQUE4QixtQkFBTyxDQUFDLDZHQUF1QjtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYW5uZWxJbXBsZW1lbnRhdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNoYW5uZWxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtY3JlZGVudGlhbHNcIik7XG5jb25zdCBpbnRlcm5hbF9jaGFubmVsXzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC1jaGFubmVsXCIpO1xuY2xhc3MgQ2hhbm5lbEltcGxlbWVudGF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCB0YXJnZXQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNyZWRlbnRpYWxzIGluc3RhbmNlb2YgY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgY3JlZGVudGlhbHMgbXVzdCBiZSBhIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDaGFubmVsID0gbmV3IGludGVybmFsX2NoYW5uZWxfMS5JbnRlcm5hbENoYW5uZWwodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbC5jbG9zZSgpO1xuICAgIH1cbiAgICBnZXRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQ2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQ2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpO1xuICAgIH1cbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDaGFubmVsLndhdGNoQ29ubmVjdGl2aXR5U3RhdGUoY3VycmVudFN0YXRlLCBkZWFkbGluZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgY2hhbm5lbC4gVGhlIHJldHVybmVkIHZhbHVlIGlzXG4gICAgICogZ2FyYmFnZSBpZiBjaGFubmVseiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQ2hhbm5lbC5nZXRDaGFubmVselJlZigpO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBkZWFkbGluZSBtdXN0IGJlIGEgbnVtYmVyIG9yIERhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncyk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsSW1wbGVtZW50YXRpb24gPSBDaGFubmVsSW1wbGVtZW50YXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name,\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name,\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id,\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name,\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n    constructor() {\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined,\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map(event => {\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel\n                        ? channelRefToMessage(event.childChannel)\n                        : null,\n                    subchannel_ref: event.childSubchannel\n                        ? subchannelRefToMessage(event.childSubchannel)\n                        : null,\n                };\n            }),\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor() {\n        this.channelChildren = new Map();\n        this.subchannelChildren = new Map();\n        this.socketChildren = new Map();\n    }\n    refChild(child) {\n        var _a, _b, _c;\n        switch (child.kind) {\n            case 'channel': {\n                const trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n                    ref: child,\n                    count: 0,\n                };\n                trackedChild.count += 1;\n                this.channelChildren.set(child.id, trackedChild);\n                break;\n            }\n            case 'subchannel': {\n                const trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n                    ref: child,\n                    count: 0,\n                };\n                trackedChild.count += 1;\n                this.subchannelChildren.set(child.id, trackedChild);\n                break;\n            }\n            case 'socket': {\n                const trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n                    ref: child,\n                    count: 0,\n                };\n                trackedChild.count += 1;\n                this.socketChildren.set(child.id, trackedChild);\n                break;\n            }\n        }\n    }\n    unrefChild(child) {\n        switch (child.kind) {\n            case 'channel': {\n                const trackedChild = this.channelChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.channelChildren.delete(child.id);\n                    }\n                    else {\n                        this.channelChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n            case 'subchannel': {\n                const trackedChild = this.subchannelChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.subchannelChildren.delete(child.id);\n                    }\n                    else {\n                        this.subchannelChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n            case 'socket': {\n                const trackedChild = this.socketChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.socketChildren.delete(child.id);\n                    }\n                    else {\n                        this.socketChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n        }\n    }\n    getChildLists() {\n        const channels = [];\n        for (const { ref } of this.channelChildren.values()) {\n            channels.push(ref);\n        }\n        const subchannels = [];\n        for (const { ref } of this.subchannelChildren.values()) {\n            subchannels.push(ref);\n        }\n        const sockets = [];\n        for (const { ref } of this.socketChildren.values()) {\n            sockets.push(ref);\n        }\n        return { channels, subchannels, sockets };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n    constructor() {\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n    return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'channel' };\n    if (channelzEnabled) {\n        channels[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'subchannel' };\n    if (channelzEnabled) {\n        subchannels[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, kind: 'server' };\n    if (channelzEnabled) {\n        servers[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'socket' };\n    if (channelzEnabled) {\n        sockets[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n    switch (ref.kind) {\n        case 'channel':\n            delete channels[ref.id];\n            return;\n        case 'subchannel':\n            delete subchannels[ref.id];\n            return;\n        case 'server':\n            delete servers[ref.id];\n            return;\n        case 'socket':\n            delete sockets[ref.id];\n            return;\n    }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [(numberValue / 256) | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n    if (addressChunk === '') {\n        return [];\n    }\n    const bytePairs = addressChunk\n        .split(':')\n        .map(section => parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n    if ((0, net_1.isIPv4)(ipAddress)) {\n        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n    }\n    else if ((0, net_1.isIPv6)(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf('::');\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = '';\n        }\n        else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n    }\n    else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch (state) {\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: 'CONNECTING',\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: 'IDLE',\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: 'READY',\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: 'SHUTDOWN',\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: 'TRANSIENT_FAILURE',\n            };\n        default:\n            return {\n                state: 'UNKNOWN',\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: (millisSinceEpoch / 1000) | 0,\n        nanos: (millisSinceEpoch % 1000) * 1000000,\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n        subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref)),\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = Number.parseInt(call.request.channel_id);\n    const channelEntry = channels[channelId];\n    if (channelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No channel data found for id ' + channelId,\n        });\n        return;\n    }\n    callback(null, { channel: getChannelMessage(channelEntry) });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_channel_id);\n    for (; i < channels.length; i++) {\n        const channelEntry = channels[i];\n        if (channelEntry === undefined) {\n            continue;\n        }\n        resultList.push(getChannelMessage(channelEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        channel: resultList,\n        end: i >= servers.length,\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref)),\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No server data found for id ' + serverId,\n        });\n        return;\n    }\n    callback(null, { server: getServerMessage(serverEntry) });\n}\nfunction GetServers(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_server_id);\n    for (; i < servers.length; i++) {\n        const serverEntry = servers[i];\n        if (serverEntry === undefined) {\n            continue;\n        }\n        resultList.push(getServerMessage(serverEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        server: resultList,\n        end: i >= servers.length,\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\n    const subchannelEntry = subchannels[subchannelId];\n    if (subchannelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No subchannel data found for id ' + subchannelId,\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref)),\n    };\n    callback(null, { subchannel: subchannelMessage });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\n        return {\n            address: 'tcpip_address',\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port,\n            },\n        };\n    }\n    else {\n        return {\n            address: 'uds_address',\n            uds_address: {\n                filename: subchannelAddress.path,\n            },\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = Number.parseInt(call.request.socket_id);\n    const socketEntry = sockets[socketId];\n    if (socketEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No socket data found for id ' + socketId,\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security\n        ? {\n            model: 'tls',\n            tls: {\n                cipher_suite: resolvedInfo.security.cipherSuiteStandardName\n                    ? 'standard_name'\n                    : 'other_name',\n                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined,\n            },\n        }\n        : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress\n            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)\n            : null,\n        remote: resolvedInfo.remoteAddress\n            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)\n            : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow\n                ? { value: resolvedInfo.localFlowControlWindow }\n                : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow\n                ? { value: resolvedInfo.remoteFlowControlWindow }\n                : null,\n        },\n    };\n    callback(null, { socket: socketMessage });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No server data found for id ' + serverId,\n        });\n        return;\n    }\n    const startId = Number.parseInt(call.request.start_socket_id);\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n    const resultList = [];\n    let i = 0;\n    for (; i < allSockets.length; i++) {\n        if (allSockets[i].id >= startId) {\n            resultList.push(socketRefToMessage(allSockets[i]));\n            if (resultList.length >= maxResults) {\n                break;\n            }\n        }\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i >= allSockets.length,\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets,\n    };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */\n    const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(action-browser)/./node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync('channelz.proto', {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [`${__dirname}/../../proto`],\n    });\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\n    loadedChannelzDefinition =\n        channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup;\n//# sourceMappingURL=channelz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsei5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxvQ0FBb0MsR0FBRywyQkFBMkIsR0FBRyw2QkFBNkIsR0FBRyw4QkFBOEIsR0FBRyw4QkFBOEIsR0FBRyxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRywyQkFBMkIsR0FBRywrQkFBK0IsR0FBRyxxQkFBcUI7QUFDblYsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6Qyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsaUZBQVM7QUFDakMsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBMEM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsdUNBQXVDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUlBQ1Y7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsei5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwgPSBleHBvcnRzLkNoYW5uZWx6Q2FsbFRyYWNrZXIgPSBleHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gZXhwb3J0cy5DaGFubmVselRyYWNlID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xuZnVuY3Rpb24gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsX2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YmNoYW5uZWxfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcnZlclJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2ZXJfaWQ6IHJlZi5pZCxcbiAgICB9O1xufVxuZnVuY3Rpb24gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNvY2tldF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZSxcbiAgICB9O1xufVxuLyoqXG4gKiBUaGUgbG9vc2UgdXBwZXIgYm91bmQgb24gdGhlIG51bWJlciBvZiBldmVudHMgdGhhdCBzaG91bGQgYmUgcmV0YWluZWQgaW4gYVxuICogdHJhY2UuIFRoaXMgbWF5IGJlIGV4Y2VlZGVkIGJ5IHVwIHRvIGEgZmFjdG9yIG9mIDIuIEFyYml0cmFyaWx5IGNob3NlbiBhcyBhXG4gKiBudW1iZXIgdGhhdCBzaG91bGQgYmUgbGFyZ2UgZW5vdWdoIHRvIGNvbnRhaW4gdGhlIHJlY2VudCByZWxldmFudFxuICogaW5mb3JtYXRpb24sIGJ1dCBzbWFsbCBlbm91Z2ggdG8gbm90IHVzZSBleGNlc3NpdmUgbWVtb3J5LlxuICovXG5jb25zdCBUQVJHRVRfUkVUQUlORURfVFJBQ0VTID0gMzI7XG5jbGFzcyBDaGFubmVselRyYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgPSAwO1xuICAgICAgICB0aGlzLmNyZWF0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkVHJhY2Uoc2V2ZXJpdHksIGRlc2NyaXB0aW9uLCBjaGlsZCkge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHNldmVyaXR5OiBzZXZlcml0eSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLFxuICAgICAgICAgICAgY2hpbGRDaGFubmVsOiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmtpbmQpID09PSAnY2hhbm5lbCcgPyBjaGlsZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoaWxkU3ViY2hhbm5lbDogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5raW5kKSA9PT0gJ3N1YmNoYW5uZWwnID8gY2hpbGQgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXaGVuZXZlciB0aGUgdHJhY2UgYXJyYXkgZ2V0cyB0b28gbGFyZ2UsIGRpc2NhcmQgdGhlIGZpcnN0IGhhbGZcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmxlbmd0aCA+PSBUQVJHRVRfUkVUQUlORURfVFJBQ0VTICogMikge1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLmV2ZW50cy5zbGljZShUQVJHRVRfUkVUQUlORURfVFJBQ0VTKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCArPSAxO1xuICAgIH1cbiAgICBnZXRUcmFjZU1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGlvbl90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHRoaXMuY3JlYXRpb25UaW1lc3RhbXApLFxuICAgICAgICAgICAgbnVtX2V2ZW50c19sb2dnZWQ6IHRoaXMuZXZlbnRzTG9nZ2VkLFxuICAgICAgICAgICAgZXZlbnRzOiB0aGlzLmV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBldmVudC5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2V2ZXJpdHk6IGV2ZW50LnNldmVyaXR5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKGV2ZW50LnRpbWVzdGFtcCksXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfcmVmOiBldmVudC5jaGlsZENoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZENoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxfcmVmOiBldmVudC5jaGlsZFN1YmNoYW5uZWxcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZFN1YmNoYW5uZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IENoYW5uZWx6VHJhY2U7XG5jbGFzcyBDaGFubmVsekNoaWxkcmVuVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSAoX2EgPSB0aGlzLmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSAoX2IgPSB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7XG4gICAgICAgICAgICAgICAgICAgIHJlZjogY2hpbGQsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc29ja2V0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRDaGlsZCA9IChfYyA9IHRoaXMuc29ja2V0Q2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVmQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgc3dpdGNoIChjaGlsZC5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdjaGFubmVsJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYWNrZWRDaGlsZCA9IHRoaXMuY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbi5kZWxldGUoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc3ViY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZGVsZXRlKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NvY2tldCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0aGlzLnNvY2tldENoaWxkcmVuLmdldChjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkLmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGlsZExpc3RzKCkge1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5jaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGNoYW5uZWxzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJjaGFubmVscyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyByZWYgfSBvZiB0aGlzLnNvY2tldENoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXRzLnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBjaGFubmVscywgc3ViY2hhbm5lbHMsIHNvY2tldHMgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXI7XG5jbGFzcyBDaGFubmVsekNhbGxUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N0YXJ0ZWQgPSAwO1xuICAgICAgICB0aGlzLmNhbGxzU3VjY2VlZGVkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsc0ZhaWxlZCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbnVsbDtcbiAgICB9XG4gICAgYWRkQ2FsbFN0YXJ0ZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkICs9IDE7XG4gICAgICAgIHRoaXMubGFzdENhbGxTdGFydGVkVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCArPSAxO1xuICAgIH1cbiAgICBhZGRDYWxsRmFpbGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzRmFpbGVkICs9IDE7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gQ2hhbm5lbHpDYWxsVHJhY2tlcjtcbmxldCBuZXh0SWQgPSAxO1xuZnVuY3Rpb24gZ2V0TmV4dElkKCkge1xuICAgIHJldHVybiBuZXh0SWQrKztcbn1cbmNvbnN0IGNoYW5uZWxzID0gW107XG5jb25zdCBzdWJjaGFubmVscyA9IFtdO1xuY29uc3Qgc2VydmVycyA9IFtdO1xuY29uc3Qgc29ja2V0cyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWwobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnY2hhbm5lbCcgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIGNoYW5uZWxzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gcmVnaXN0ZXJDaGFubmVsekNoYW5uZWw7XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbChuYW1lLCBnZXRJbmZvLCBjaGFubmVsekVuYWJsZWQpIHtcbiAgICBjb25zdCBpZCA9IGdldE5leHRJZCgpO1xuICAgIGNvbnN0IHJlZiA9IHsgaWQsIG5hbWUsIGtpbmQ6ICdzdWJjaGFubmVsJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc3ViY2hhbm5lbHNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwgPSByZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbDtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXIoZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBraW5kOiAnc2VydmVyJyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc2VydmVyc1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gcmVnaXN0ZXJDaGFubmVselNlcnZlcjtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnc29ja2V0JyB9O1xuICAgIGlmIChjaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgc29ja2V0c1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gcmVnaXN0ZXJDaGFubmVselNvY2tldDtcbmZ1bmN0aW9uIHVucmVnaXN0ZXJDaGFubmVselJlZihyZWYpIHtcbiAgICBzd2l0Y2ggKHJlZi5raW5kKSB7XG4gICAgICAgIGNhc2UgJ2NoYW5uZWwnOlxuICAgICAgICAgICAgZGVsZXRlIGNoYW5uZWxzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3N1YmNoYW5uZWwnOlxuICAgICAgICAgICAgZGVsZXRlIHN1YmNoYW5uZWxzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ3NlcnZlcic6XG4gICAgICAgICAgICBkZWxldGUgc2VydmVyc1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzb2NrZXQnOlxuICAgICAgICAgICAgZGVsZXRlIHNvY2tldHNbcmVmLmlkXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG59XG5leHBvcnRzLnVucmVnaXN0ZXJDaGFubmVselJlZiA9IHVucmVnaXN0ZXJDaGFubmVselJlZjtcbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgc2VjdGlvbiBvZiBhbiBJUHY2IGFkZHJlc3MgYXMgdHdvIGJ5dGVzXG4gKiBAcGFyYW0gYWRkcmVzc1NlY3Rpb24gQSBoZXhhZGVjaW1hbCBzdHJpbmcgb2YgbGVuZ3RoIHVwIHRvIDRcbiAqIEByZXR1cm5zIFRoZSBwYWlyIG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3Mgc2VjdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZUlQdjZTZWN0aW9uKGFkZHJlc3NTZWN0aW9uKSB7XG4gICAgY29uc3QgbnVtYmVyVmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoYWRkcmVzc1NlY3Rpb24sIDE2KTtcbiAgICByZXR1cm4gWyhudW1iZXJWYWx1ZSAvIDI1NikgfCAwLCBudW1iZXJWYWx1ZSAlIDI1Nl07XG59XG4vKipcbiAqIFBhcnNlIGEgY2h1bmsgb2YgYW4gSVB2NiBhZGRyZXNzIHN0cmluZyB0byBzb21lIG51bWJlciBvZiBieXRlc1xuICogQHBhcmFtIGFkZHJlc3NDaHVuayBTb21lIG51bWJlciBvZiBzZWdtZW50cyBvZiB1cCB0byA0IGhleGFkZWNpbWFsXG4gKiAgIGNoYXJhY3RlcnMgZWFjaCwgam9pbmVkIGJ5IGNvbG9ucy5cbiAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGlzIGFkZHJlc3MgY2h1bmtcbiAqL1xuZnVuY3Rpb24gcGFyc2VJUHY2Q2h1bmsoYWRkcmVzc0NodW5rKSB7XG4gICAgaWYgKGFkZHJlc3NDaHVuayA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBieXRlUGFpcnMgPSBhZGRyZXNzQ2h1bmtcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLm1hcChzZWN0aW9uID0+IHBhcnNlSVB2NlNlY3Rpb24oc2VjdGlvbikpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJldHVybiByZXN1bHQuY29uY2F0KC4uLmJ5dGVQYWlycyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgb3IgSVB2NiBhZGRyZXNzIGZyb20gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIGJpbmFyeVxuICogcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBpcEFkZHJlc3MgYW4gSVAgYWRkcmVzcyBpbiBzdGFuZGFyZCBJUHY0IG9yIElQdjYgdGV4dCBmb3JtYXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcykge1xuICAgIGlmICgoMCwgbmV0XzEuaXNJUHY0KShpcEFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShVaW50OEFycmF5LmZyb20oaXBBZGRyZXNzLnNwbGl0KCcuJykubWFwKHNlZ21lbnQgPT4gTnVtYmVyLnBhcnNlSW50KHNlZ21lbnQpKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoMCwgbmV0XzEuaXNJUHY2KShpcEFkZHJlc3MpKSB7XG4gICAgICAgIGxldCBsZWZ0U2VjdGlvbjtcbiAgICAgICAgbGV0IHJpZ2h0U2VjdGlvbjtcbiAgICAgICAgY29uc3QgZG91YmxlQ29sb25JbmRleCA9IGlwQWRkcmVzcy5pbmRleE9mKCc6OicpO1xuICAgICAgICBpZiAoZG91YmxlQ29sb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGxlZnRTZWN0aW9uID0gaXBBZGRyZXNzO1xuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcy5zdWJzdHJpbmcoMCwgZG91YmxlQ29sb25JbmRleCk7XG4gICAgICAgICAgICByaWdodFNlY3Rpb24gPSBpcEFkZHJlc3Muc3Vic3RyaW5nKGRvdWJsZUNvbG9uSW5kZXggKyAyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsobGVmdFNlY3Rpb24pKTtcbiAgICAgICAgY29uc3QgcmlnaHRCdWZmZXIgPSBCdWZmZXIuZnJvbShwYXJzZUlQdjZDaHVuayhyaWdodFNlY3Rpb24pKTtcbiAgICAgICAgY29uc3QgbWlkZGxlQnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2IC0gbGVmdEJ1ZmZlci5sZW5ndGggLSByaWdodEJ1ZmZlci5sZW5ndGgsIDApO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbbGVmdEJ1ZmZlciwgbWlkZGxlQnVmZmVyLCByaWdodEJ1ZmZlcl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2Uoc3RhdGUpIHtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORzpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdDT05ORUNUSU5HJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdJRExFJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFk6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnUkVBRFknLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTjpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdTSFVURE9XTicsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1RSQU5TSUVOVF9GQUlMVVJFJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnVU5LTk9XTicsXG4gICAgICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRhdGVUb1Byb3RvVGltZXN0YW1wKGRhdGUpIHtcbiAgICBpZiAoIWRhdGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG1pbGxpc1NpbmNlRXBvY2ggPSBkYXRlLmdldFRpbWUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWNvbmRzOiAobWlsbGlzU2luY2VFcG9jaCAvIDEwMDApIHwgMCxcbiAgICAgICAgbmFub3M6IChtaWxsaXNTaW5jZUVwb2NoICUgMTAwMCkgKiAxMDAwMDAwLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIHtcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBjaGFubmVsRW50cnkuZ2V0SW5mbygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZjogY2hhbm5lbFJlZlRvTWVzc2FnZShjaGFubmVsRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxuICAgICAgICB9LFxuICAgICAgICBjaGFubmVsX3JlZjogcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLmNoYW5uZWxzLm1hcChyZWYgPT4gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpKSxcbiAgICAgICAgc3ViY2hhbm5lbF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5zdWJjaGFubmVscy5tYXAocmVmID0+IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldENoYW5uZWwoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBjaGFubmVsSWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LmNoYW5uZWxfaWQpO1xuICAgIGNvbnN0IGNoYW5uZWxFbnRyeSA9IGNoYW5uZWxzW2NoYW5uZWxJZF07XG4gICAgaWYgKGNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgY2hhbm5lbElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IGNoYW5uZWw6IGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRUb3BDaGFubmVscyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGkgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X2NoYW5uZWxfaWQpO1xuICAgIGZvciAoOyBpIDwgY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbEVudHJ5ID0gY2hhbm5lbHNbaV07XG4gICAgICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldENoYW5uZWxNZXNzYWdlKGNoYW5uZWxFbnRyeSkpO1xuICAgICAgICBpZiAocmVzdWx0TGlzdC5sZW5ndGggPj0gbWF4UmVzdWx0cykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICBjaGFubmVsOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGgsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZjogc2VydmVyUmVmVG9NZXNzYWdlKHNlcnZlckVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKCksXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3Rlbl9zb2NrZXQ6IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMubWFwKHJlZiA9PiBzb2NrZXRSZWZUb01lc3NhZ2UocmVmKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEdldFNlcnZlcihjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQpO1xuICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7IHNlcnZlcjogZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfc2VydmVyX2lkKTtcbiAgICBmb3IgKDsgaSA8IHNlcnZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGlzdC5wdXNoKGdldFNlcnZlck1lc3NhZ2Uoc2VydmVyRW50cnkpKTtcbiAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgc2VydmVyOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gc2VydmVycy5sZW5ndGgsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBHZXRTdWJjaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc3ViY2hhbm5lbElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdWJjaGFubmVsX2lkKTtcbiAgICBjb25zdCBzdWJjaGFubmVsRW50cnkgPSBzdWJjaGFubmVsc1tzdWJjaGFubmVsSWRdO1xuICAgIGlmIChzdWJjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHN1YmNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHN1YmNoYW5uZWxJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc3ViY2hhbm5lbEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBzdWJjaGFubmVsTWVzc2FnZSA9IHtcbiAgICAgICAgcmVmOiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHN1YmNoYW5uZWxFbnRyeS5yZWYpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHJlc29sdmVkSW5mby50YXJnZXQsXG4gICAgICAgICAgICBzdGF0ZTogY29ubmVjdGl2aXR5U3RhdGVUb01lc3NhZ2UocmVzb2x2ZWRJbmZvLnN0YXRlKSxcbiAgICAgICAgICAgIGNhbGxzX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBjYWxsc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIGNhbGxzX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIHRyYWNlOiByZXNvbHZlZEluZm8udHJhY2UuZ2V0VHJhY2VNZXNzYWdlKCksXG4gICAgICAgIH0sXG4gICAgICAgIHNvY2tldF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5zb2NrZXRzLm1hcChyZWYgPT4gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikpLFxuICAgIH07XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsTWVzc2FnZSB9KTtcbn1cbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShzdWJjaGFubmVsQWRkcmVzcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKHN1YmNoYW5uZWxBZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogJ3RjcGlwX2FkZHJlc3MnLFxuICAgICAgICAgICAgdGNwaXBfYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGlwX2FkZHJlc3M6IChfYSA9IGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKHN1YmNoYW5uZWxBZGRyZXNzLmhvc3QpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcG9ydDogc3ViY2hhbm5lbEFkZHJlc3MucG9ydCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogJ3Vkc19hZGRyZXNzJyxcbiAgICAgICAgICAgIHVkc19hZGRyZXNzOiB7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IHN1YmNoYW5uZWxBZGRyZXNzLnBhdGgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIEdldFNvY2tldChjYWxsLCBjYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3Qgc29ja2V0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNvY2tldF9pZCk7XG4gICAgY29uc3Qgc29ja2V0RW50cnkgPSBzb2NrZXRzW3NvY2tldElkXTtcbiAgICBpZiAoc29ja2V0RW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNvY2tldCBkYXRhIGZvdW5kIGZvciBpZCAnICsgc29ja2V0SWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNvY2tldEVudHJ5LmdldEluZm8oKTtcbiAgICBjb25zdCBzZWN1cml0eU1lc3NhZ2UgPSByZXNvbHZlZEluZm8uc2VjdXJpdHlcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBtb2RlbDogJ3RscycsXG4gICAgICAgICAgICB0bHM6IHtcbiAgICAgICAgICAgICAgICBjaXBoZXJfc3VpdGU6IHJlc29sdmVkSW5mby5zZWN1cml0eS5jaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZVxuICAgICAgICAgICAgICAgICAgICA/ICdzdGFuZGFyZF9uYW1lJ1xuICAgICAgICAgICAgICAgICAgICA6ICdvdGhlcl9uYW1lJyxcbiAgICAgICAgICAgICAgICBzdGFuZGFyZF9uYW1lOiAoX2EgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBvdGhlcl9uYW1lOiAoX2IgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVPdGhlck5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBsb2NhbF9jZXJ0aWZpY2F0ZTogKF9jID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmxvY2FsQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZW1vdGVfY2VydGlmaWNhdGU6IChfZCA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5yZW1vdGVDZXJ0aWZpY2F0ZSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3Qgc29ja2V0TWVzc2FnZSA9IHtcbiAgICAgICAgcmVmOiBzb2NrZXRSZWZUb01lc3NhZ2Uoc29ja2V0RW50cnkucmVmKSxcbiAgICAgICAgbG9jYWw6IHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3NcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3MpXG4gICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIHJlbW90ZTogcmVzb2x2ZWRJbmZvLnJlbW90ZUFkZHJlc3NcbiAgICAgICAgICAgID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzKVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICByZW1vdGVfbmFtZTogKF9lID0gcmVzb2x2ZWRJbmZvLnJlbW90ZU5hbWUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc2VjdXJpdHk6IHNlY3VyaXR5TWVzc2FnZSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAga2VlcF9hbGl2ZXNfc2VudDogcmVzb2x2ZWRJbmZvLmtlZXBBbGl2ZXNTZW50LFxuICAgICAgICAgICAgc3RyZWFtc19zdGFydGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N0YXJ0ZWQsXG4gICAgICAgICAgICBzdHJlYW1zX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNTdWNjZWVkZWQsXG4gICAgICAgICAgICBzdHJlYW1zX2ZhaWxlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2xvY2FsX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbGFzdF9yZW1vdGVfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbWVzc2FnZXNfcmVjZWl2ZWQ6IHJlc29sdmVkSW5mby5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgICAgICAgbWVzc2FnZXNfc2VudDogcmVzb2x2ZWRJbmZvLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9yZWNlaXZlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxhc3RfbWVzc2FnZV9zZW50X3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsb2NhbF9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ubG9jYWxGbG93Q29udHJvbFdpbmRvd1xuICAgICAgICAgICAgICAgID8geyB2YWx1ZTogcmVzb2x2ZWRJbmZvLmxvY2FsRmxvd0NvbnRyb2xXaW5kb3cgfVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIHJlbW90ZV9mbG93X2NvbnRyb2xfd2luZG93OiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3dcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHJlc29sdmVkSW5mby5yZW1vdGVGbG93Q29udHJvbFdpbmRvdyB9XG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzb2NrZXQ6IHNvY2tldE1lc3NhZ2UgfSk7XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXJTb2NrZXRzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VydmVySWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCk7XG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcbiAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIHNlcnZlciBkYXRhIGZvdW5kIGZvciBpZCAnICsgc2VydmVySWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X3NvY2tldF9pZCk7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcbiAgICAvLyBJZiB3ZSB3YW50ZWQgdG8gaW5jbHVkZSBsaXN0ZW5lciBzb2NrZXRzIGluIHRoZSByZXN1bHQsIHRoaXMgbGluZSB3b3VsZFxuICAgIC8vIGluc3RlYWQgc2F5XG4gICAgLy8gY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMuY29uY2F0KHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cykuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xuICAgIGNvbnN0IGFsbFNvY2tldHMgPSByZXNvbHZlZEluZm8uc2Vzc2lvbkNoaWxkcmVuLnNvY2tldHMuc29ydCgocmVmMSwgcmVmMikgPT4gcmVmMS5pZCAtIHJlZjIuaWQpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBhbGxTb2NrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhbGxTb2NrZXRzW2ldLmlkID49IHN0YXJ0SWQpIHtcbiAgICAgICAgICAgIHJlc3VsdExpc3QucHVzaChzb2NrZXRSZWZUb01lc3NhZ2UoYWxsU29ja2V0c1tpXSkpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHNvY2tldF9yZWY6IHJlc3VsdExpc3QsXG4gICAgICAgIGVuZDogaSA+PSBhbGxTb2NrZXRzLmxlbmd0aCxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWx6SGFuZGxlcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgR2V0Q2hhbm5lbCxcbiAgICAgICAgR2V0VG9wQ2hhbm5lbHMsXG4gICAgICAgIEdldFNlcnZlcixcbiAgICAgICAgR2V0U2VydmVycyxcbiAgICAgICAgR2V0U3ViY2hhbm5lbCxcbiAgICAgICAgR2V0U29ja2V0LFxuICAgICAgICBHZXRTZXJ2ZXJTb2NrZXRzLFxuICAgIH07XG59XG5leHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBnZXRDaGFubmVsekhhbmRsZXJzO1xubGV0IGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiA9IG51bGw7XG5mdW5jdGlvbiBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uKCkge1xuICAgIGlmIChsb2FkZWRDaGFubmVsekRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcbiAgICB9XG4gICAgLyogVGhlIHB1cnBvc2Ugb2YgdGhpcyBjb21wbGV4aXR5IGlzIHRvIGF2b2lkIGxvYWRpbmcgQGdycGMvcHJvdG8tbG9hZGVyIGF0XG4gICAgICogcnVudGltZSBmb3IgdXNlcnMgd2hvIHdpbGwgbm90IHVzZS9lbmFibGUgY2hhbm5lbHouICovXG4gICAgY29uc3QgbG9hZGVyTG9hZFN5bmMgPSByZXF1aXJlKCdAZ3JwYy9wcm90by1sb2FkZXInKVxuICAgICAgICAubG9hZFN5bmM7XG4gICAgY29uc3QgbG9hZGVkUHJvdG8gPSBsb2FkZXJMb2FkU3luYygnY2hhbm5lbHoucHJvdG8nLCB7XG4gICAgICAgIGtlZXBDYXNlOiB0cnVlLFxuICAgICAgICBsb25nczogU3RyaW5nLFxuICAgICAgICBlbnVtczogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0czogdHJ1ZSxcbiAgICAgICAgb25lb2ZzOiB0cnVlLFxuICAgICAgICBpbmNsdWRlRGlyczogW2Ake19fZGlybmFtZX0vLi4vLi4vcHJvdG9gXSxcbiAgICB9KTtcbiAgICBjb25zdCBjaGFubmVsekdycGNPYmplY3QgPSAoMCwgbWFrZV9jbGllbnRfMS5sb2FkUGFja2FnZURlZmluaXRpb24pKGxvYWRlZFByb3RvKTtcbiAgICBsb2FkZWRDaGFubmVsekRlZmluaXRpb24gPVxuICAgICAgICBjaGFubmVsekdycGNPYmplY3QuZ3JwYy5jaGFubmVsei52MS5DaGFubmVsei5zZXJ2aWNlO1xuICAgIHJldHVybiBsb2FkZWRDaGFubmVsekRlZmluaXRpb247XG59XG5leHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2UpKGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24sIGdldENoYW5uZWx6SGFuZGxlcnMpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbHouanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InterceptorConfigurationError';\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor() {\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status,\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor() {\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel,\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n    onReceiveMetadata: (metadata, next) => {\n        next(metadata);\n    },\n    onReceiveMessage: (message, next) => {\n        next(message);\n    },\n    onReceiveStatus: (status, next) => {\n        next(status);\n    },\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n    start: (metadata, listener, next) => {\n        next(metadata, listener);\n    },\n    sendMessage: (message, next) => {\n        next(message);\n    },\n    halfClose: next => {\n        next();\n    },\n    cancel: next => {\n        next();\n    },\n};\nclass InterceptingCall {\n    constructor(nextCall, requester) {\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */\n        this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */\n        this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,\n            };\n        }\n        else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(() => {\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata => { }),\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message => { }),\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status => { }),\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\n                finalInterceptingListener = listener;\n            }\n            else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,\n                };\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, finalMessage => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            }\n            else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(() => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            }\n            else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n    constructor(call, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition) {\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        }\n        catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: metadata => {\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: message => {\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                }\n                catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\n                        metadata: new metadata_1.Metadata(),\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: status => {\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                }\n                else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            },\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition) {\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata => { }),\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message) => {\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status) => {\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            },\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    }\n    else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 &&\n        interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +\n            'to the client constructor. Only one of these is allowed.');\n    }\n    if (interceptorArgs.callInterceptors.length > 0 &&\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +\n            'options. Only one of these is allowed.');\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 ||\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = []\n            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))\n            .filter(interceptor => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    else {\n        interceptors = []\n            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))\n            .filter(interceptor => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition,\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */\n    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n        return currentOptions => nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;\n//# sourceMappingURL=client-interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQtaW50ZXJjZXB0b3JzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsd0JBQXdCLEdBQUcsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcscUNBQXFDO0FBQ25KLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvUkFBb1I7QUFDcFIsaVJBQWlSO0FBQ2pSLDhRQUE4UTtBQUM5UTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLGdDQUFnQztBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsZ0NBQWdDO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvT0FBb087QUFDcE87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRJbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBleHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY2FsbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2NhbGwtaW50ZXJmYWNlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBlcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JcIik7XG4vKipcbiAqIEVycm9yIGNsYXNzIGFzc29jaWF0ZWQgd2l0aCBwYXNzaW5nIGJvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvclxuICogcHJvdmlkZXJzIHRvIGEgY2xpZW50IGNvbnN0cnVjdG9yIG9yIGFzIGNhbGwgb3B0aW9ucy5cbiAqL1xuY2xhc3MgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yJztcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IpO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjtcbmNsYXNzIExpc3RlbmVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXRhZGF0YShvblJlY2VpdmVNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gb25SZWNlaXZlTWV0YWRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlTWVzc2FnZShvblJlY2VpdmVNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG9uUmVjZWl2ZU1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlU3RhdHVzKG9uUmVjZWl2ZVN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IG9uUmVjZWl2ZVN0YXR1cztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuTGlzdGVuZXJCdWlsZGVyID0gTGlzdGVuZXJCdWlsZGVyO1xuY2xhc3MgUmVxdWVzdGVyQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aXRoU3RhcnQoc3RhcnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aFNlbmRNZXNzYWdlKHNlbmRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHNlbmRNZXNzYWdlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aEhhbGZDbG9zZShoYWxmQ2xvc2UpIHtcbiAgICAgICAgdGhpcy5oYWxmQ2xvc2UgPSBoYWxmQ2xvc2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoQ2FuY2VsKGNhbmNlbCkge1xuICAgICAgICB0aGlzLmNhbmNlbCA9IGNhbmNlbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICAgICAgICBzZW5kTWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgaGFsZkNsb3NlOiB0aGlzLmhhbGZDbG9zZSxcbiAgICAgICAgICAgIGNhbmNlbDogdGhpcy5jYW5jZWwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gUmVxdWVzdGVyQnVpbGRlcjtcbi8qKlxuICogQSBMaXN0ZW5lciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcbiAqIGZvciBmaWxsaW5nIG91dCBMaXN0ZW5lcnMgd2l0aCBzb21lIG1ldGhvZHMgb21pdHRlZC5cbiAqL1xuY29uc3QgZGVmYXVsdExpc3RlbmVyID0ge1xuICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAobWV0YWRhdGEsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXRhZGF0YSk7XG4gICAgfSxcbiAgICBvblJlY2VpdmVNZXNzYWdlOiAobWVzc2FnZSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgb25SZWNlaXZlU3RhdHVzOiAoc3RhdHVzLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQoc3RhdHVzKTtcbiAgICB9LFxufTtcbi8qKlxuICogQSBSZXF1ZXN0ZXIgd2l0aCBhIGRlZmF1bHQgcGFzcy10aHJvdWdoIGltcGxlbWVudGF0aW9uIG9mIGVhY2ggbWV0aG9kLiBVc2VkXG4gKiBmb3IgZmlsbGluZyBvdXQgUmVxdWVzdGVycyB3aXRoIHNvbWUgbWV0aG9kcyBvbWl0dGVkLlxuICovXG5jb25zdCBkZWZhdWx0UmVxdWVzdGVyID0ge1xuICAgIHN0YXJ0OiAobWV0YWRhdGEsIGxpc3RlbmVyLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWV0YWRhdGEsIGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIHNlbmRNZXNzYWdlOiAobWVzc2FnZSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1lc3NhZ2UpO1xuICAgIH0sXG4gICAgaGFsZkNsb3NlOiBuZXh0ID0+IHtcbiAgICAgICAgbmV4dCgpO1xuICAgIH0sXG4gICAgY2FuY2VsOiBuZXh0ID0+IHtcbiAgICAgICAgbmV4dCgpO1xuICAgIH0sXG59O1xuY2xhc3MgSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IobmV4dENhbGwsIHJlcXVlc3Rlcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHRoaXMubmV4dENhbGwgPSBuZXh0Q2FsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IG1ldGFkYXRhIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgcmVxdWVzdGVyJ3Mgc3RhcnRcbiAgICAgICAgICogbWV0aG9kIGJ1dCBpdCBoYXMgbm90IGJlZW4gcGFzc2VkIHRvIHRoZSBjb3JyZXNwb25kaW5nIG5leHQgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXNzYWdlIGNvbnRleHQgZm9yIGEgcGVuZGluZyBtZXNzYWdlIHRoYXQgaXMgd2FpdGluZyBmb3JcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGEgbWVzc2FnZSBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHJlcXVlc3RlcidzIHNlbmRNZXNzYWdlXG4gICAgICAgICAqIG1ldGhvZCBidXQgaXQgaGFzIG5vdCBiZWVuIHBhc3NlZCB0byB0aGUgY29ycmVzcG9uZGluZyBuZXh0IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIHN0YXR1cyB3YXMgcmVjZWl2ZWQgYnV0IGNvdWxkIG5vdCBiZSBwcm9wYWdhdGVkIGJlY2F1c2VcbiAgICAgICAgICogYSBtZXNzYWdlIHdhcyBzdGlsbCBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlcXVlc3Rlcikge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IChfYSA9IHJlcXVlc3Rlci5zdGFydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFJlcXVlc3Rlci5zdGFydCxcbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZTogKF9iID0gcmVxdWVzdGVyLnNlbmRNZXNzYWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0UmVxdWVzdGVyLnNlbmRNZXNzYWdlLFxuICAgICAgICAgICAgICAgIGhhbGZDbG9zZTogKF9jID0gcmVxdWVzdGVyLmhhbGZDbG9zZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFJlcXVlc3Rlci5oYWxmQ2xvc2UsXG4gICAgICAgICAgICAgICAgY2FuY2VsOiAoX2QgPSByZXF1ZXN0ZXIuY2FuY2VsKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0UmVxdWVzdGVyLmNhbmNlbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlciA9IGRlZmF1bHRSZXF1ZXN0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuY2FuY2VsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ01lc3NhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0LCB0aGlzLnBlbmRpbmdNZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBpbnRlcmNlcHRpbmdMaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3QgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyID0ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYiA9IChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAobWV0YWRhdGEgPT4geyB9KSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChfZCA9IChfYyA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IChtZXNzYWdlID0+IHsgfSksXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IChfZiA9IChfZSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogKHN0YXR1cyA9PiB7IH0pLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLnN0YXJ0KG1ldGFkYXRhLCBmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIsIChtZCwgbGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyO1xuICAgICAgICAgICAgaWYgKCgwLCBjYWxsX2ludGVyZmFjZV8xLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIpKGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgICAgIGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYSA9IGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChfYiA9IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IChfYyA9IGxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSBuZXcgY2FsbF9pbnRlcmZhY2VfMS5JbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwoZnVsbExpc3RlbmVyLCBmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydChtZCwgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLnNlbmRNZXNzYWdlKG1lc3NhZ2UsIGZpbmFsTWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgZmluYWxNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHt9LCBtZXNzYWdlKTtcbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLmhhbGZDbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBJbnRlcmNlcHRpbmdDYWxsO1xuZnVuY3Rpb24gZ2V0Q2FsbChjaGFubmVsLCBwYXRoLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBkZWFkbGluZSA9IChfYSA9IG9wdGlvbnMuZGVhZGxpbmUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IEluZmluaXR5O1xuICAgIGNvbnN0IGhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgY29uc3QgcGFyZW50ID0gKF9iID0gb3B0aW9ucy5wYXJlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGw7XG4gICAgY29uc3QgcHJvcGFnYXRlRmxhZ3MgPSBvcHRpb25zLnByb3BhZ2F0ZV9mbGFncztcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHM7XG4gICAgY29uc3QgY2FsbCA9IGNoYW5uZWwuY3JlYXRlQ2FsbChwYXRoLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50LCBwcm9wYWdhdGVGbGFncyk7XG4gICAgaWYgKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbDtcbn1cbi8qKlxuICogSW50ZXJjZXB0aW5nQ2FsbCBpbXBsZW1lbnRhdGlvbiB0aGF0IGRpcmVjdGx5IG93bnMgdGhlIHVuZGVybHlpbmcgQ2FsbFxuICogb2JqZWN0IGFuZCBoYW5kbGVzIHNlcmlhbGl6YXRpb24gYW5kIGRlc2VyYWl6bGlhdGlvbi5cbiAqL1xuY2xhc3MgQmFzZUludGVyY2VwdGluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGhvZERlZmluaXRpb24gPSBtZXRob2REZWZpbml0aW9uO1xuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB0aGlzLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IHNlcmlhbGl6ZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0gdGhpcy5tZXRob2REZWZpbml0aW9uLnJlcXVlc3RTZXJpYWxpemUobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgYFJlcXVlc3QgbWVzc2FnZSBzZXJpYWxpemF0aW9uIGZhaWx1cmU6ICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlKX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBzZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7fSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBpbnRlcmNlcHRpbmdMaXN0ZW5lcikge1xuICAgICAgICBsZXQgcmVhZEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0KG1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgbGV0IGRlc2VyaWFsaXplZDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWQgPSB0aGlzLm1ldGhvZERlZmluaXRpb24ucmVzcG9uc2VEZXNlcmlhbGl6ZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlc3BvbnNlIG1lc3NhZ2UgcGFyc2luZyBlcnJvcjogJHsoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGUpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMocmVhZEVycm9yLmNvZGUsIHJlYWRFcnJvci5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIGRlc2VyaWFsaXplZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgcmVhZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB3aXRoIHNwZWNpYWwtY2FzZWQgYmVoYXZpb3IgZm9yIG1ldGhvZHMgd2l0aCB1bmFyeVxuICogcmVzcG9uc2VzLlxuICovXG5jbGFzcyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICBzdXBlcihjYWxsLCBtZXRob2REZWZpbml0aW9uKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZWNlaXZlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgd3JhcHBlckxpc3RlbmVyID0ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYiA9IChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQobGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAobWV0YWRhdGEgPT4geyB9KSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIChfYSA9IGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChsaXN0ZW5lciwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY2VpdmVkTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2IgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChsaXN0ZW5lciwgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyLnN0YXJ0KG1ldGFkYXRhLCB3cmFwcGVyTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB3aXRoIHNwZWNpYWwtY2FzZWQgYmVoYXZpb3IgZm9yIG1ldGhvZHMgd2l0aCBzdHJlYW1pbmdcbiAqIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgQmFzZVN0cmVhbWluZ0ludGVyY2VwdGluZ0NhbGwgZXh0ZW5kcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG59XG5mdW5jdGlvbiBnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsKGNoYW5uZWwsIG9wdGlvbnMsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbm1ldGhvZERlZmluaXRpb24pIHtcbiAgICBjb25zdCBjYWxsID0gZ2V0Q2FsbChjaGFubmVsLCBtZXRob2REZWZpbml0aW9uLnBhdGgsIG9wdGlvbnMpO1xuICAgIGlmIChtZXRob2REZWZpbml0aW9uLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmFzZVN0cmVhbWluZ0ludGVyY2VwdGluZ0NhbGwoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VVbmFyeUludGVyY2VwdGluZ0NhbGwoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvckFyZ3MsIFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbm1ldGhvZERlZmluaXRpb24sIG9wdGlvbnMsIGNoYW5uZWwpIHtcbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9ycy5sZW5ndGggPiAwICYmXG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBvcHRpb25zICcgK1xuICAgICAgICAgICAgJ3RvIHRoZSBjbGllbnQgY29uc3RydWN0b3IuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgfVxuICAgIGlmIChpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9ycy5sZW5ndGggPiAwICYmXG4gICAgICAgIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgY2FsbCAnICtcbiAgICAgICAgICAgICdvcHRpb25zLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgIH1cbiAgICBsZXQgaW50ZXJjZXB0b3JzID0gW107XG4gICAgLy8gSW50ZXJjZXB0b3JzIHBhc3NlZCB0byB0aGUgY2FsbCBvdmVycmlkZSBpbnRlcmNlcHRvcnMgcGFzc2VkIHRvIHRoZSBjbGllbnQgY29uc3RydWN0b3JcbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCB8fFxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW50ZXJjZXB0b3JzID0gW11cbiAgICAgICAgICAgIC5jb25jYXQoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMsIGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMubWFwKHByb3ZpZGVyID0+IHByb3ZpZGVyKG1ldGhvZERlZmluaXRpb24pKSlcbiAgICAgICAgICAgIC5maWx0ZXIoaW50ZXJjZXB0b3IgPT4gaW50ZXJjZXB0b3IpO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IGZhbHN5IHZhbHVlcyB3aGVuIHByb3ZpZGVycyByZXR1cm4gbm90aGluZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW50ZXJjZXB0b3JzID0gW11cbiAgICAgICAgICAgIC5jb25jYXQoaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9ycywgaW50ZXJjZXB0b3JBcmdzLmNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcChwcm92aWRlciA9PiBwcm92aWRlcihtZXRob2REZWZpbml0aW9uKSkpXG4gICAgICAgICAgICAuZmlsdGVyKGludGVyY2VwdG9yID0+IGludGVyY2VwdG9yKTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBmYWxzeSB2YWx1ZXMgd2hlbiBwcm92aWRlcnMgcmV0dXJuIG5vdGhpbmdcbiAgICB9XG4gICAgY29uc3QgaW50ZXJjZXB0b3JPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBtZXRob2RfZGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICB9KTtcbiAgICAvKiBGb3IgZWFjaCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdGhlIG5leHRDYWxsIGZ1bmN0aW9uIHBhc3NlZCB0byBpdCBpc1xuICAgICAqIGJhc2VkIG9uIHRoZSBuZXh0IGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCB1c2luZyBhIG5leHRDYWxsIGZ1bmN0aW9uXG4gICAgICogY29uc3RydWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCBhbmQgc28gb24uIFRoZVxuICAgICAqIGluaXRpYWxWYWx1ZSwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgaXMgYSBuZXh0Q2FsbFxuICAgICAqIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsLCB0aGUgcmVzdWx0IG9mIHdoaWNoXG4gICAgICogaGFuZGxlcyAoZGUpc2VyaWFsaXphdGlvbiBhbmQgYWxzbyBnZXRzIHRoZSB1bmRlcmx5aW5nIGNhbGwgZnJvbSB0aGVcbiAgICAgKiBjaGFubmVsLiAqL1xuICAgIGNvbnN0IGdldENhbGwgPSBpbnRlcmNlcHRvcnMucmVkdWNlUmlnaHQoKG5leHRDYWxsLCBuZXh0SW50ZXJjZXB0b3IpID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRPcHRpb25zID0+IG5leHRJbnRlcmNlcHRvcihjdXJyZW50T3B0aW9ucywgbmV4dENhbGwpO1xuICAgIH0sIChmaW5hbE9wdGlvbnMpID0+IGdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwoY2hhbm5lbCwgZmluYWxPcHRpb25zLCBtZXRob2REZWZpbml0aW9uKSk7XG4gICAgcmV0dXJuIGdldENhbGwoaW50ZXJjZXB0b3JPcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2V0SW50ZXJjZXB0aW5nQ2FsbCA9IGdldEludGVyY2VwdGluZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQtaW50ZXJjZXB0b3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\nfunction getErrorStackString(error) {\n    return error.stack.split('\\n').slice(1).join('\\n');\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n    constructor(address, credentials, options = {}) {\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 &&\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\n                'to the client constructor. Only one of these is allowed.');\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\n            options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        }\n        else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        }\n        else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err) => {\n            if (err) {\n                callback(new Error('Failed to connect before the deadline'));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            }\n            catch (e) {\n                callback(new Error('The channel has been closed'));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            }\n            else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                }\n                catch (e) {\n                    callback(new Error('The channel has been closed'));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\n        }\n        else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return { metadata: arg1, options: {}, callback: arg2 };\n            }\n            else {\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\n            }\n        }\n        else {\n            if (!(arg1 instanceof metadata_1.Metadata &&\n                arg2 instanceof Object &&\n                isFunction(arg3))) {\n                throw new Error('Incorrect arguments passed');\n            }\n            return { metadata: arg1, options: arg2, callback: arg3 };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: metadata => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'No message received',\n                            metadata: status.metadata,\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                emitter.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: metadata => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'No message received',\n                            metadata: status.metadata,\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                emitter.emit('status', status);\n            },\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            }\n            else {\n                options = {};\n            }\n        }\n        else {\n            if (arg1) {\n                options = arg1;\n            }\n            else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return { metadata, options };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                stream.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                stream.emit('status', status);\n            },\n        });\n        return stream;\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsZUFBZSxtQkFBTyxDQUFDLCtFQUFRO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFXO0FBQ3JDLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyw4QkFBOEIsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnREFBZ0Q7QUFDckU7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDJCQUEyQjtBQUNwRDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBjYWxsXzEgPSByZXF1aXJlKFwiLi9jYWxsXCIpO1xuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjbGllbnRfaW50ZXJjZXB0b3JzXzEgPSByZXF1aXJlKFwiLi9jbGllbnQtaW50ZXJjZXB0b3JzXCIpO1xuY29uc3QgQ0hBTk5FTF9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IElOVEVSQ0VQVE9SX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JTdGFja1N0cmluZyhlcnJvcikge1xuICAgIHJldHVybiBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMSkuam9pbignXFxuJyk7XG59XG4vKipcbiAqIEEgZ2VuZXJpYyBnUlBDIGNsaWVudC4gUHJpbWFyaWx5IHVzZWZ1bCBhcyBhIGJhc2UgY2xhc3MgZm9yIGFsbCBnZW5lcmF0ZWRcbiAqIGNsaWVudHMuXG4gKi9cbmNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSA9IChfYSA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW50ZXJjZXB0b3JzO1xuICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0gPSAoX2IgPSBvcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycztcbiAgICAgICAgaWYgKHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIG9wdGlvbnMgJyArXG4gICAgICAgICAgICAgICAgJ3RvIHRoZSBjbGllbnQgY29uc3RydWN0b3IuIE9ubHkgb25lIG9mIHRoZXNlIGlzIGFsbG93ZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSA9XG4gICAgICAgICAgICBvcHRpb25zLmNhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXI7XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmNhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXI7XG4gICAgICAgIGlmIChvcHRpb25zLmNoYW5uZWxPdmVycmlkZSkge1xuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBvcHRpb25zLmNoYW5uZWxPdmVycmlkZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUgPSBvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGU7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBjaGFubmVsRmFjdG9yeU92ZXJyaWRlKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gbmV3IGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb24oYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXS5jbG9zZSgpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tDSEFOTkVMX1NZTUJPTF07XG4gICAgfVxuICAgIHdhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2hlY2tTdGF0ZSA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb25uZWN0IGJlZm9yZSB0aGUgZGVhZGxpbmUnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5ld1N0YXRlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLmdldENvbm5lY3Rpdml0eVN0YXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjaGFubmVsIGhhcyBiZWVuIGNsb3NlZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdLndhdGNoQ29ubmVjdGl2aXR5U3RhdGUobmV3U3RhdGUsIGRlYWRsaW5lLCBjaGVja1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZXRJbW1lZGlhdGUoY2hlY2tTdGF0ZSk7XG4gICAgfVxuICAgIGNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLCBvcHRpb25zOiB7fSwgY2FsbGJhY2s6IGFyZzEgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGFyZzIpKSB7XG4gICAgICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogYXJnMSwgb3B0aW9uczoge30sIGNhbGxiYWNrOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSwgb3B0aW9uczogYXJnMSwgY2FsbGJhY2s6IGFyZzIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhICYmXG4gICAgICAgICAgICAgICAgYXJnMiBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oYXJnMykpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvcnJlY3QgYXJndW1lbnRzIHBhc3NlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IGFyZzEsIG9wdGlvbnM6IGFyZzIsIGNhbGxiYWNrOiBhcmczIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWFrZVVuYXJ5UmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGFyZ3VtZW50LCBtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMobWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBhcmd1bWVudCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRVbmFyeUNhbGxJbXBsKCksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ05vIG1lc3NhZ2UgcmVjZWl2ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKGFyZ3VtZW50KTtcbiAgICAgICAgY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgfVxuICAgIG1ha2VDbGllbnRTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwoc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjazogY2hlY2tlZEFyZ3VtZW50cy5jYWxsYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIGVtaXR0ZXIuY2FsbCA9IGNhbGw7XG4gICAgICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGxlclN0YWNrRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsICdUb28gbWFueSByZXNwb25zZXMgcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKCgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnTm8gbWVzc2FnZSByZWNlaXZlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1cy5tZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhudWxsLCByZXNwb25zZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKCgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgIH1cbiAgICBjaGVja01ldGFkYXRhQW5kT3B0aW9ucyhhcmcxLCBhcmcyKSB7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBhcmcxO1xuICAgICAgICAgICAgaWYgKGFyZzIpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhcmcxKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGEsIG9wdGlvbnMgfTtcbiAgICB9XG4gICAgbWFrZVNlcnZlclN0cmVhbVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBhcmd1bWVudCwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMobWV0YWRhdGEsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsKGRlc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKGFyZ3VtZW50KTtcbiAgICAgICAgY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgbWFrZUJpZGlTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMobWV0YWRhdGEsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnREdXBsZXhTdHJlYW1JbXBsKHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgc3RyZWFtLmNhbGwgPSBjYWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgbGV0IGNhbGxlclN0YWNrRXJyb3IgPSBuZXcgRXJyb3IoKTtcbiAgICAgICAgY2FsbC5zdGFydChjYWxsUHJvcGVydGllcy5tZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsICgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function (CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {}));\n//# sourceMappingURL=compression-algorithms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qiw2QkFBNkIsNkJBQTZCO0FBQ3ZGIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IHZvaWQgMDtcbnZhciBDb21wcmVzc2lvbkFsZ29yaXRobXM7XG4oZnVuY3Rpb24gKENvbXByZXNzaW9uQWxnb3JpdGhtcykge1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJpZGVudGl0eVwiXSA9IDBdID0gXCJpZGVudGl0eVwiO1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJkZWZsYXRlXCJdID0gMV0gPSBcImRlZmxhdGVcIjtcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiZ3ppcFwiXSA9IDJdID0gXCJnemlwXCI7XG59KShDb21wcmVzc2lvbkFsZ29yaXRobXMgfHwgKGV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zID0gQ29tcHJlc3Npb25BbGdvcml0aG1zID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbXByZXNzaW9uLWFsZ29yaXRobXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key) => {\n    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n    async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    constructor(maxRecvMessageLength) {\n        super();\n        this.maxRecvMessageLength = maxRecvMessageLength;\n    }\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.deflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            let totalLength = 0;\n            const messageParts = [];\n            const decompresser = zlib.createInflate();\n            decompresser.on('data', (chunk) => {\n                messageParts.push(chunk);\n                totalLength += chunk.byteLength;\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n                    decompresser.destroy();\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n                    });\n                }\n            });\n            decompresser.on('end', () => {\n                resolve(Buffer.concat(messageParts));\n            });\n            decompresser.write(message);\n            decompresser.end();\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    constructor(maxRecvMessageLength) {\n        super();\n        this.maxRecvMessageLength = maxRecvMessageLength;\n    }\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.gzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            let totalLength = 0;\n            const messageParts = [];\n            const decompresser = zlib.createGunzip();\n            decompresser.on('data', (chunk) => {\n                messageParts.push(chunk);\n                totalLength += chunk.byteLength;\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n                    decompresser.destroy();\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n                    });\n                }\n            });\n            decompresser.on('end', () => {\n                resolve(Buffer.concat(messageParts));\n            });\n            decompresser.write(message);\n            decompresser.end();\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName) {\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName, maxReceiveMessageSize) {\n    switch (compressionName) {\n        case 'identity':\n            return new IdentityHandler();\n        case 'deflate':\n            return new DeflateHandler(maxReceiveMessageSize);\n        case 'gzip':\n            return new GzipHandler(maxReceiveMessageSize);\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig) {\n        var _a, _b;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_b = sharedFilterConfig.serverSupportedEncodingHeader) === null || _b === void 0 ? void 0 : _b.split(',');\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */\n                if (!serverSupportedEncodings ||\n                    serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);\n                }\n            }\n            else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n        headers.set('accept-encoding', 'identity');\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === 'identity') {\n            headers.remove('grpc-encoding');\n        }\n        else {\n            headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get('grpc-encoding');\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === 'string') {\n                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\n            }\n        }\n        metadata.remove('grpc-encoding');\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader =\n                serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = 'identity';\n            }\n        }\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */\n        const resolvedMessage = await message;\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        }\n        else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags,\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */\n        return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options) {\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter() {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;\n//# sourceMappingURL=compression-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyx5QkFBeUI7QUFDNUQsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlDQUFpQyxtQkFBTyxDQUFDLG1IQUEwQjtBQUNuRSxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsMEJBQTBCO0FBQ3ZILHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDBCQUEwQjtBQUN2SCxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcscUJBQXFCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxxQkFBcUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUlBQXFJLHdCQUF3QjtBQUM3SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NvbXByZXNzaW9uLWZpbHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyID0gdm9pZCAwO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb24tYWxnb3JpdGhtc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGlzQ29tcHJlc3Npb25BbGdvcml0aG1LZXkgPSAoa2V5KSA9PiB7XG4gICAgcmV0dXJuICh0eXBlb2Yga2V5ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtc1trZXldID09PSAnc3RyaW5nJyk7XG59O1xuY2xhc3MgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBSYXcgdW5jb21wcmVzc2VkIG1lc3NhZ2UgYnl0ZXNcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIG1lc3NhZ2Ugc2hvdWxkIGJlIGNvbXByZXNzZWRcbiAgICAgKiBAcmV0dXJuIEZyYW1lZCBtZXNzYWdlLCBjb21wcmVzc2VkIGlmIGFwcGxpY2FibGVcbiAgICAgKi9cbiAgICBhc3luYyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3MpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBtZXNzYWdlO1xuICAgICAgICBpZiAoY29tcHJlc3MpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VCdWZmZXIgPSBhd2FpdCB0aGlzLmNvbXByZXNzTWVzc2FnZShtZXNzYWdlQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdXRwdXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVzc2FnZUJ1ZmZlci5sZW5ndGggKyA1KTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoY29tcHJlc3MgPyAxIDogMCwgMCk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKG1lc3NhZ2VCdWZmZXIubGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZUJ1ZmZlci5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhIEZyYW1lZCBtZXNzYWdlLCBwb3NzaWJseSBjb21wcmVzc2VkXG4gICAgICogQHJldHVybiBVbmNvbXByZXNzZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRNZXNzYWdlKGRhdGEpIHtcbiAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IGRhdGEucmVhZFVJbnQ4KDApID09PSAxO1xuICAgICAgICBsZXQgbWVzc2FnZUJ1ZmZlciA9IGRhdGEuc2xpY2UoNSk7XG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5kZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZUJ1ZmZlcjtcbiAgICB9XG59XG5jbGFzcyBJZGVudGl0eUhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGFzeW5jIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3luYyB3cml0ZU1lc3NhZ2UobWVzc2FnZSwgY29tcHJlc3MpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lc3NhZ2UubGVuZ3RoICsgNSk7XG4gICAgICAgIC8qIFdpdGggXCJpZGVudGl0eVwiIGNvbXByZXNzaW9uLCBtZXNzYWdlcyBzaG91bGQgYWx3YXlzIGJlIG1hcmtlZCBhc1xuICAgICAgICAgKiB1bmNvbXByZXNzZWQgKi9cbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoMCwgMCk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKG1lc3NhZ2UubGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZS5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignUmVjZWl2ZWQgY29tcHJlc3NlZCBtZXNzYWdlIGJ1dCBcImdycGMtZW5jb2RpbmdcIiBoZWFkZXIgd2FzIGlkZW50aXR5JykpO1xuICAgIH1cbn1cbmNsYXNzIERlZmxhdGVIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoID0gbWF4UmVjdk1lc3NhZ2VMZW5ndGg7XG4gICAgfVxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLmRlZmxhdGUobWVzc2FnZSwgKGVyciwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlSW5mbGF0ZSgpO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGggIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIHRoYXQgZGVjb21wcmVzc2VzIHRvIGEgc2l6ZSBsYXJnZXIgdGhhbiAke3RoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChtZXNzYWdlUGFydHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLndyaXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBHemlwSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IobWF4UmVjdk1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCA9IG1heFJlY3ZNZXNzYWdlTGVuZ3RoO1xuICAgIH1cbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5nemlwKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVBhcnRzID0gW107XG4gICAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZXIgPSB6bGliLmNyZWF0ZUd1bnppcCgpO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGggIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIHRoYXQgZGVjb21wcmVzc2VzIHRvIGEgc2l6ZSBsYXJnZXIgdGhhbiAke3RoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGh9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChtZXNzYWdlUGFydHMpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLndyaXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgZGVjb21wcmVzc2VyLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBVbmtub3duSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25OYW1lID0gY29tcHJlc3Npb25OYW1lO1xuICAgIH1cbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIGNvbXByZXNzZWQgd2l0aCB1bnN1cHBvcnRlZCBjb21wcmVzc2lvbiBtZXRob2QgJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XG4gICAgfVxuICAgIGRlY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGVcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgQ29tcHJlc3Npb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQ6ICR7dGhpcy5jb21wcmVzc2lvbk5hbWV9YCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldENvbXByZXNzaW9uSGFuZGxlcihjb21wcmVzc2lvbk5hbWUsIG1heFJlY2VpdmVNZXNzYWdlU2l6ZSkge1xuICAgIHN3aXRjaCAoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgICAgIGNhc2UgJ2lkZW50aXR5JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlSGFuZGxlcihtYXhSZWNlaXZlTWVzc2FnZVNpemUpO1xuICAgICAgICBjYXNlICdnemlwJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3ppcEhhbmRsZXIobWF4UmVjZWl2ZU1lc3NhZ2VTaXplKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5rbm93bkhhbmRsZXIoY29tcHJlc3Npb25OYW1lKTtcbiAgICB9XG59XG5jbGFzcyBDb21wcmVzc2lvbkZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxPcHRpb25zLCBzaGFyZWRGaWx0ZXJDb25maWcpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcgPSBzaGFyZWRGaWx0ZXJDb25maWc7XG4gICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLnJlY2VpdmVDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSAnaWRlbnRpdHknO1xuICAgICAgICBjb25zdCBjb21wcmVzc2lvbkFsZ29yaXRobUtleSA9IGNoYW5uZWxPcHRpb25zWydncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtJ107XG4gICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGggPSAoX2EgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICBpZiAoY29tcHJlc3Npb25BbGdvcml0aG1LZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3Npb25BbGdvcml0aG1LZXkoY29tcHJlc3Npb25BbGdvcml0aG1LZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50U2VsZWN0ZWRFbmNvZGluZyA9IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXNbY29tcHJlc3Npb25BbGdvcml0aG1LZXldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyA9IChfYiA9IHNoYXJlZEZpbHRlckNvbmZpZy5zZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ0hlYWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlcmUgYXJlIHR3byBwb3NzaWJsZSBzaXR1YXRpb25zIGhlcmU6XG4gICAgICAgICAgICAgICAgICogMSkgV2UgZG9uJ3QgaGF2ZSBhbnkgaW5mbyB5ZXQgZnJvbSB0aGUgc2VydmVyIGFib3V0IHdoYXQgY29tcHJlc3Npb24gaXQgc3VwcG9ydHNcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIGp1c3QgdXNlIHdoYXQgdGhlIGNsaWVudCB0ZWxscyB1cyB0byB1c2VcbiAgICAgICAgICAgICAgICAgKiAyKSBXZSd2ZSBwcmV2aW91c2x5IHJlY2VpdmVkIGEgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyIGluY2x1ZGluZyBhIGdycGMtYWNjZXB0LWVuY29kaW5nIGhlYWRlclxuICAgICAgICAgICAgICAgICAqICAgIEluIHRoYXQgY2FzZSB3ZSBvbmx5IHdhbnQgdG8gdXNlIHRoZSBlbmNvZGluZyBjaG9zZW4gYnkgdGhlIGNsaWVudCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIGl0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCFzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKGNsaWVudFNlbGVjdGVkRW5jb2RpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gY2xpZW50U2VsZWN0ZWRFbmNvZGluZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbkhhbmRsZXIodGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0sIC0xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBJbnZhbGlkIHZhbHVlIHByb3ZpZGVkIGZvciBncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtIG9wdGlvbjogJHtjb21wcmVzc2lvbkFsZ29yaXRobUtleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IG1ldGFkYXRhO1xuICAgICAgICBoZWFkZXJzLnNldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHksZGVmbGF0ZSxnemlwJyk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHknKTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZW5kIHRoZSBoZWFkZXIgaWYgaXQncyBcImlkZW50aXR5XCIgLSAgYmVoYXZpb3IgaXMgaWRlbnRpY2FsOyBzYXZlIHRoZSBiYW5kd2lkdGhcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtZW5jb2RpbmcnLCB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCByZWNlaXZlRW5jb2RpbmcgPSBtZXRhZGF0YS5nZXQoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgaWYgKHJlY2VpdmVFbmNvZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlY2VpdmVFbmNvZGluZ1swXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbkhhbmRsZXIoZW5jb2RpbmcsIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICAvKiBDaGVjayB0byBzZWUgaWYgdGhlIGNvbXByZXNzaW9uIHdlJ3JlIHVzaW5nIHRvIHNlbmQgbWVzc2FnZXMgaXMgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICAgICAgICogSWYgbm90LCByZXNldCB0aGUgc2VuZENvbXByZXNzaW9uIGZpbHRlciBhbmQgaGF2ZSBpdCB1c2UgdGhlIGRlZmF1bHQgSWRlbnRpdHlIYW5kbGVyICovXG4gICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlciA9IG1ldGFkYXRhLmdldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKVswXTtcbiAgICAgICAgaWYgKHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIgPVxuICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyA9IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlci5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgaWYgKCFzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MuaW5jbHVkZXModGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0gPSAnaWRlbnRpdHknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgc3BlY2lhbC4gVGhlIGlucHV0IG1lc3NhZ2UgaXMgdGhlIGJhcmUgbWVzc2FnZSBieXRlcyxcbiAgICAgICAgICogYW5kIHRoZSBvdXRwdXQgaXMgYSBmcmFtZWQgYW5kIHBvc3NpYmx5IGNvbXByZXNzZWQgbWVzc2FnZS4gRm9yIHRoaXNcbiAgICAgICAgICogcmVhc29uLCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZmlsdGVyIHN0YWNrICovXG4gICAgICAgIGNvbnN0IHJlc29sdmVkTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgIGxldCBjb21wcmVzcztcbiAgICAgICAgaWYgKHRoaXMuc2VuZENvbXByZXNzaW9uIGluc3RhbmNlb2YgSWRlbnRpdHlIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3MgPSAoKChfYSA9IHJlc29sdmVkTWVzc2FnZS5mbGFncykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCkgJiAyIC8qIFdyaXRlRmxhZ3MuTm9Db21wcmVzcyAqLykgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHRoaXMuc2VuZENvbXByZXNzaW9uLndyaXRlTWVzc2FnZShyZXNvbHZlZE1lc3NhZ2UubWVzc2FnZSwgY29tcHJlc3MpLFxuICAgICAgICAgICAgZmxhZ3M6IHJlc29sdmVkTWVzc2FnZS5mbGFncyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBUaGlzIGZpbHRlciBpcyBhbHNvIHNwZWNpYWwuIFRoZSBpbnB1dCBtZXNzYWdlIGlzIGZyYW1lZCBhbmQgcG9zc2libHlcbiAgICAgICAgICogY29tcHJlc3NlZCwgYW5kIHRoZSBvdXRwdXQgbWVzc2FnZSBpcyBkZWZyYW1lZCBhbmQgdW5jb21wcmVzc2VkLiBTb1xuICAgICAgICAgKiB0aGlzIGlzIGFub3RoZXIgcmVhc29uIHRoYXQgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAgICAqIGZpbHRlciBzdGFjay4gKi9cbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uLnJlYWRNZXNzYWdlKGF3YWl0IG1lc3NhZ2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXIgPSBDb21wcmVzc2lvbkZpbHRlcjtcbmNsYXNzIENvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyA9IHt9O1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3Npb25GaWx0ZXIodGhpcy5vcHRpb25zLCB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBDb21wcmVzc2lvbkZpbHRlckZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function (ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {}));\n//# sourceMappingURL=connectivity-state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25uZWN0aXZpdHktc3RhdGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3Qix5QkFBeUIseUJBQXlCO0FBQzNFIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25uZWN0aXZpdHktc3RhdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSB2b2lkIDA7XG52YXIgQ29ubmVjdGl2aXR5U3RhdGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpdml0eVN0YXRlKSB7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJJRExFXCJdID0gMF0gPSBcIklETEVcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIkNPTk5FQ1RJTkdcIl0gPSAxXSA9IFwiQ09OTkVDVElOR1wiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiUkVBRFlcIl0gPSAyXSA9IFwiUkVBRFlcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlRSQU5TSUVOVF9GQUlMVVJFXCJdID0gM10gPSBcIlRSQU5TSUVOVF9GQUlMVVJFXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJTSFVURE9XTlwiXSA9IDRdID0gXCJTSFVURE9XTlwiO1xufSkoQ29ubmVjdGl2aXR5U3RhdGUgfHwgKGV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSBDb25uZWN0aXZpdHlTdGF0ZSA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0aXZpdHktc3RhdGUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function (Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status || (exports.Status = Status = {}));\nvar LogVerbosity;\n(function (LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */\nvar Propagate;\n(function (Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate || (exports.Propagate = Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQ0FBMEMsR0FBRyx1Q0FBdUMsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxjQUFjO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhLGNBQWMsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQixvQkFBb0Isb0JBQW9CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSwwQ0FBMEM7QUFDMUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIID0gZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gZXhwb3J0cy5Qcm9wYWdhdGUgPSBleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuU3RhdHVzID0gdm9pZCAwO1xudmFyIFN0YXR1cztcbihmdW5jdGlvbiAoU3RhdHVzKSB7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5LTk9XTlwiXSA9IDJdID0gXCJVTktOT1dOXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIklOVkFMSURfQVJHVU1FTlRcIl0gPSAzXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJERUFETElORV9FWENFRURFRFwiXSA9IDRdID0gXCJERUFETElORV9FWENFRURFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJOT1RfRk9VTkRcIl0gPSA1XSA9IFwiTk9UX0ZPVU5EXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkFMUkVBRFlfRVhJU1RTXCJdID0gNl0gPSBcIkFMUkVBRFlfRVhJU1RTXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlJFU09VUkNFX0VYSEFVU1RFRFwiXSA9IDhdID0gXCJSRVNPVVJDRV9FWEhBVVNURURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkFCT1JURURcIl0gPSAxMF0gPSBcIkFCT1JURURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiT1VUX09GX1JBTkdFXCJdID0gMTFdID0gXCJPVVRfT0ZfUkFOR0VcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJJTlRFUk5BTFwiXSA9IDEzXSA9IFwiSU5URVJOQUxcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5BVkFJTEFCTEVcIl0gPSAxNF0gPSBcIlVOQVZBSUxBQkxFXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVVUSEVOVElDQVRFRFwiXSA9IDE2XSA9IFwiVU5BVVRIRU5USUNBVEVEXCI7XG59KShTdGF0dXMgfHwgKGV4cG9ydHMuU3RhdHVzID0gU3RhdHVzID0ge30pKTtcbnZhciBMb2dWZXJib3NpdHk7XG4oZnVuY3Rpb24gKExvZ1ZlcmJvc2l0eSkge1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJERUJVR1wiXSA9IDBdID0gXCJERUJVR1wiO1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJJTkZPXCJdID0gMV0gPSBcIklORk9cIjtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiRVJST1JcIl0gPSAyXSA9IFwiRVJST1JcIjtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiTk9ORVwiXSA9IDNdID0gXCJOT05FXCI7XG59KShMb2dWZXJib3NpdHkgfHwgKGV4cG9ydHMuTG9nVmVyYm9zaXR5ID0gTG9nVmVyYm9zaXR5ID0ge30pKTtcbi8qKlxuICogTk9URTogVGhpcyBlbnVtIGlzIG5vdCBjdXJyZW50bHkgdXNlZCBpbiBhbnkgaW1wbGVtZW50ZWQgQVBJIGluIHRoaXNcbiAqIGxpYnJhcnkuIEl0IGlzIGluY2x1ZGVkIG9ubHkgZm9yIHR5cGUgcGFyaXR5IHdpdGggdGhlIG90aGVyIGltcGxlbWVudGF0aW9uLlxuICovXG52YXIgUHJvcGFnYXRlO1xuKGZ1bmN0aW9uIChQcm9wYWdhdGUpIHtcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiREVBRExJTkVcIl0gPSAxXSA9IFwiREVBRExJTkVcIjtcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiQ0VOU1VTX1NUQVRTX0NPTlRFWFRcIl0gPSAyXSA9IFwiQ0VOU1VTX1NUQVRTX0NPTlRFWFRcIjtcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiQ0VOU1VTX1RSQUNJTkdfQ09OVEVYVFwiXSA9IDRdID0gXCJDRU5TVVNfVFJBQ0lOR19DT05URVhUXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNBTkNFTExBVElPTlwiXSA9IDhdID0gXCJDQU5DRUxMQVRJT05cIjtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2luY2x1ZGUvZ3JwYy9pbXBsL2NvZGVnZW4vcHJvcGFnYXRpb25fYml0cy5oI0w0M1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJERUZBVUxUU1wiXSA9IDY1NTM1XSA9IFwiREVGQVVMVFNcIjtcbn0pKFByb3BhZ2F0ZSB8fCAoZXhwb3J0cy5Qcm9wYWdhdGUgPSBQcm9wYWdhdGUgPSB7fSkpO1xuLy8gLTEgbWVhbnMgdW5saW1pdGVkXG5leHBvcnRzLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEggPSAtMTtcbi8vIDQgTUIgZGVmYXVsdFxuZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIID0gNCAqIDEwMjQgKiAxMDI0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/control-plane-status.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.restrictControlPlaneStatusCode = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS,\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`,\n        };\n    }\n    else {\n        return { code, details };\n    }\n}\nexports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;\n//# sourceMappingURL=control-plane-status.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb250cm9sLXBsYW5lLXN0YXR1cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNDQUFzQztBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELE1BQU0sRUFBRSwwQkFBMEIsRUFBRSxRQUFRO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb250cm9sLXBsYW5lLXN0YXR1cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUyA9IFtcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLklOVkFMSURfQVJHVU1FTlQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUxSRUFEWV9FWElTVFMsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkZBSUxFRF9QUkVDT05ESVRJT04sXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkFCT1JURUQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk9VVF9PRl9SQU5HRSxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuREFUQV9MT1NTLFxuXTtcbmZ1bmN0aW9uIHJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZShjb2RlLCBkZXRhaWxzKSB7XG4gICAgaWYgKElOQVBQUk9QUklBVEVfQ09OVFJPTF9QTEFORV9DT0RFUy5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgZGV0YWlsczogYEludmFsaWQgc3RhdHVzIGZyb20gY29udHJvbCBwbGFuZTogJHtjb2RlfSAke2NvbnN0YW50c18xLlN0YXR1c1tjb2RlXX0gJHtkZXRhaWxzfWAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBjb2RlLCBkZXRhaWxzIH07XG4gICAgfVxufVxuZXhwb3J0cy5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUgPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb250cm9sLXBsYW5lLXN0YXR1cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deadlineToString = exports.getRelativeTimeout = exports.getDeadlineTimeoutString = exports.minDeadline = void 0;\nfunction minDeadline(...deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList) {\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nexports.minDeadline = minDeadline;\nconst units = [\n    ['m', 1],\n    ['S', 1000],\n    ['M', 60 * 1000],\n    ['H', 60 * 60 * 1000],\n];\nfunction getDeadlineTimeoutString(deadline) {\n    const now = new Date().getTime();\n    if (deadline instanceof Date) {\n        deadline = deadline.getTime();\n    }\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units) {\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error('Deadline is too far in the future');\n}\nexports.getDeadlineTimeoutString = getDeadlineTimeoutString;\n/**\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\n * This number of milliseconds is almost 25 days.\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n/**\n * Get the timeout value that should be passed to setTimeout now for the timer\n * to end at the deadline. For any deadline before now, the timer should end\n * immediately, represented by a value of 0. For any deadline more than\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\n * end at that time, so it is treated as infinitely far in the future.\n * @param deadline\n * @returns\n */\nfunction getRelativeTimeout(deadline) {\n    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\n    const now = new Date().getTime();\n    const timeout = deadlineMs - now;\n    if (timeout < 0) {\n        return 0;\n    }\n    else if (timeout > MAX_TIMEOUT_TIME) {\n        return Infinity;\n    }\n    else {\n        return timeout;\n    }\n}\nexports.getRelativeTimeout = getRelativeTimeout;\nfunction deadlineToString(deadline) {\n    if (deadline instanceof Date) {\n        return deadline.toISOString();\n    }\n    else {\n        const dateDeadline = new Date(deadline);\n        if (Number.isNaN(dateDeadline.getTime())) {\n            return '' + deadline;\n        }\n        else {\n            return dateDeadline.toISOString();\n        }\n    }\n}\nexports.deadlineToString = deadlineToString;\n//# sourceMappingURL=deadline.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kZWFkbGluZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLDBCQUEwQixHQUFHLGdDQUFnQyxHQUFHLG1CQUFtQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kZWFkbGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWFkbGluZVRvU3RyaW5nID0gZXhwb3J0cy5nZXRSZWxhdGl2ZVRpbWVvdXQgPSBleHBvcnRzLmdldERlYWRsaW5lVGltZW91dFN0cmluZyA9IGV4cG9ydHMubWluRGVhZGxpbmUgPSB2b2lkIDA7XG5mdW5jdGlvbiBtaW5EZWFkbGluZSguLi5kZWFkbGluZUxpc3QpIHtcbiAgICBsZXQgbWluVmFsdWUgPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGRlYWRsaW5lIG9mIGRlYWRsaW5lTGlzdCkge1xuICAgICAgICBjb25zdCBkZWFkbGluZU1zZWNzID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgICAgIGlmIChkZWFkbGluZU1zZWNzIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gZGVhZGxpbmVNc2VjcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluVmFsdWU7XG59XG5leHBvcnRzLm1pbkRlYWRsaW5lID0gbWluRGVhZGxpbmU7XG5jb25zdCB1bml0cyA9IFtcbiAgICBbJ20nLCAxXSxcbiAgICBbJ1MnLCAxMDAwXSxcbiAgICBbJ00nLCA2MCAqIDEwMDBdLFxuICAgIFsnSCcsIDYwICogNjAgKiAxMDAwXSxcbl07XG5mdW5jdGlvbiBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmcoZGVhZGxpbmUpIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBpZiAoZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRlYWRsaW5lID0gZGVhZGxpbmUuZ2V0VGltZSgpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lb3V0TXMgPSBNYXRoLm1heChkZWFkbGluZSAtIG5vdywgMCk7XG4gICAgZm9yIChjb25zdCBbdW5pdCwgZmFjdG9yXSBvZiB1bml0cykge1xuICAgICAgICBjb25zdCBhbW91bnQgPSB0aW1lb3V0TXMgLyBmYWN0b3I7XG4gICAgICAgIGlmIChhbW91bnQgPCAxZTgpIHtcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoTWF0aC5jZWlsKGFtb3VudCkpICsgdW5pdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlYWRsaW5lIGlzIHRvbyBmYXIgaW4gdGhlIGZ1dHVyZScpO1xufVxuZXhwb3J0cy5nZXREZWFkbGluZVRpbWVvdXRTdHJpbmcgPSBnZXREZWFkbGluZVRpbWVvdXRTdHJpbmc7XG4vKipcbiAqIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3NldHRpbWVvdXRjYWxsYmFjay1kZWxheS1hcmdzXG4gKiBJbiBwYXJ0aWN1bGFyLCBcIldoZW4gZGVsYXkgaXMgbGFyZ2VyIHRoYW4gMjE0NzQ4MzY0NyBvciBsZXNzIHRoYW4gMSwgdGhlXG4gKiBkZWxheSB3aWxsIGJlIHNldCB0byAxLiBOb24taW50ZWdlciBkZWxheXMgYXJlIHRydW5jYXRlZCB0byBhbiBpbnRlZ2VyLlwiXG4gKiBUaGlzIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXMgYWxtb3N0IDI1IGRheXMuXG4gKi9cbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xuLyoqXG4gKiBHZXQgdGhlIHRpbWVvdXQgdmFsdWUgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHNldFRpbWVvdXQgbm93IGZvciB0aGUgdGltZXJcbiAqIHRvIGVuZCBhdCB0aGUgZGVhZGxpbmUuIEZvciBhbnkgZGVhZGxpbmUgYmVmb3JlIG5vdywgdGhlIHRpbWVyIHNob3VsZCBlbmRcbiAqIGltbWVkaWF0ZWx5LCByZXByZXNlbnRlZCBieSBhIHZhbHVlIG9mIDAuIEZvciBhbnkgZGVhZGxpbmUgbW9yZSB0aGFuXG4gKiBNQVhfVElNRU9VVF9USU1FIG1pbGxpc2Vjb25kcyBpbiB0aGUgZnV0dXJlLCBhIHRpbWVyIGNhbm5vdCBiZSBzZXQgdGhhdCB3aWxsXG4gKiBlbmQgYXQgdGhhdCB0aW1lLCBzbyBpdCBpcyB0cmVhdGVkIGFzIGluZmluaXRlbHkgZmFyIGluIHRoZSBmdXR1cmUuXG4gKiBAcGFyYW0gZGVhZGxpbmVcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFJlbGF0aXZlVGltZW91dChkZWFkbGluZSkge1xuICAgIGNvbnN0IGRlYWRsaW5lTXMgPSBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUgPyBkZWFkbGluZS5nZXRUaW1lKCkgOiBkZWFkbGluZTtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCB0aW1lb3V0ID0gZGVhZGxpbmVNcyAtIG5vdztcbiAgICBpZiAodGltZW91dCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRpbWVvdXQgPiBNQVhfVElNRU9VVF9USU1FKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0aW1lb3V0O1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0UmVsYXRpdmVUaW1lb3V0ID0gZ2V0UmVsYXRpdmVUaW1lb3V0O1xuZnVuY3Rpb24gZGVhZGxpbmVUb1N0cmluZyhkZWFkbGluZSkge1xuICAgIGlmIChkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRlYWRsaW5lLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBkYXRlRGVhZGxpbmUgPSBuZXcgRGF0ZShkZWFkbGluZSk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oZGF0ZURlYWRsaW5lLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIGRlYWRsaW5lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVEZWFkbGluZS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWFkbGluZVRvU3RyaW5nID0gZGVhZGxpbmVUb1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlYWRsaW5lLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDuration = exports.durationToMs = exports.msToDuration = void 0;\nfunction msToDuration(millis) {\n    return {\n        seconds: (millis / 1000) | 0,\n        nanos: ((millis % 1000) * 1000000) | 0,\n    };\n}\nexports.msToDuration = msToDuration;\nfunction durationToMs(duration) {\n    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;\n}\nexports.durationToMs = durationToMs;\nfunction isDuration(value) {\n    return typeof value.seconds === 'number' && typeof value.nanos === 'number';\n}\nexports.isDuration = isDuration;\n//# sourceMappingURL=duration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kdXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQixHQUFHLG9CQUFvQixHQUFHLG9CQUFvQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNEdXJhdGlvbiA9IGV4cG9ydHMuZHVyYXRpb25Ub01zID0gZXhwb3J0cy5tc1RvRHVyYXRpb24gPSB2b2lkIDA7XG5mdW5jdGlvbiBtc1RvRHVyYXRpb24obWlsbGlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogKG1pbGxpcyAvIDEwMDApIHwgMCxcbiAgICAgICAgbmFub3M6ICgobWlsbGlzICUgMTAwMCkgKiAxMDAwMDAwKSB8IDAsXG4gICAgfTtcbn1cbmV4cG9ydHMubXNUb0R1cmF0aW9uID0gbXNUb0R1cmF0aW9uO1xuZnVuY3Rpb24gZHVyYXRpb25Ub01zKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIChkdXJhdGlvbi5zZWNvbmRzICogMTAwMCArIGR1cmF0aW9uLm5hbm9zIC8gMTAwMDAwMCkgfCAwO1xufVxuZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBkdXJhdGlvblRvTXM7XG5mdW5jdGlvbiBpc0R1cmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5zZWNvbmRzID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUubmFub3MgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWR1cmF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getErrorCode = exports.getErrorMessage = void 0;\nfunction getErrorMessage(error) {\n    if (error instanceof Error) {\n        return error.message;\n    }\n    else {\n        return String(error);\n    }\n}\nexports.getErrorMessage = getErrorMessage;\nfunction getErrorCode(error) {\n    if (typeof error === 'object' &&\n        error !== null &&\n        'code' in error &&\n        typeof error.code === 'number') {\n        return error.code;\n    }\n    else {\n        return null;\n    }\n}\nexports.getErrorCode = getErrorCode;\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2Vycm9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEVycm9yQ29kZSA9IGV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGVycm9yKTtcbiAgICB9XG59XG5leHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZTtcbmZ1bmN0aW9uIGdldEVycm9yQ29kZShlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGVycm9yICE9PSBudWxsICYmXG4gICAgICAgICdjb2RlJyBpbiBlcnJvciAmJlxuICAgICAgICB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLmNvZGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmdldEVycm9yQ29kZSA9IGdldEVycm9yQ29kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OutlierDetectionLoadBalancingConfig = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.subchannelAddressToString = exports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.durationToMs = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({ enumerable: true, get: function () { return logging_1.trace; } }));\nObject.defineProperty(exports, \"log\", ({ enumerable: true, get: function () { return logging_1.log; } }));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({ enumerable: true, get: function () { return resolver_1.registerResolver; } }));\nObject.defineProperty(exports, \"createResolver\", ({ enumerable: true, get: function () { return resolver_1.createResolver; } }));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({ enumerable: true, get: function () { return uri_parser_1.uriToString; } }));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({ enumerable: true, get: function () { return duration_1.durationToMs; } }));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({ enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } }));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({ enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } }));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({ enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } }));\nObject.defineProperty(exports, \"getFirstUsableConfig\", ({ enumerable: true, get: function () { return load_balancer_1.getFirstUsableConfig; } }));\nObject.defineProperty(exports, \"validateLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_1.validateLoadBalancingConfig; } }));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({ enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } }));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({ enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } }));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({ enumerable: true, get: function () { return picker_1.UnavailablePicker; } }));\nObject.defineProperty(exports, \"QueuePicker\", ({ enumerable: true, get: function () { return picker_1.QueuePicker; } }));\nObject.defineProperty(exports, \"PickResultType\", ({ enumerable: true, get: function () { return picker_1.PickResultType; } }));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({ enumerable: true, get: function () { return filter_1.BaseFilter; } }));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({ enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } }));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({ enumerable: true, get: function () { return admin_1.registerAdminService; } }));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({ enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } }));\nvar load_balancer_outlier_detection_1 = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nObject.defineProperty(exports, \"OutlierDetectionLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig; } }));\n//# sourceMappingURL=experimental.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9leHBlcmltZW50YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkNBQTJDLEdBQUcsNkJBQTZCLEdBQUcsNEJBQTRCLEdBQUcsMEJBQTBCLEdBQUcsa0JBQWtCLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsZ0NBQWdDLEdBQUcsaUNBQWlDLEdBQUcsbUNBQW1DLEdBQUcsNEJBQTRCLEdBQUcsZ0NBQWdDLEdBQUcsdUNBQXVDLEdBQUcsc0JBQXNCLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsd0JBQXdCLEdBQUcsV0FBVyxHQUFHLGFBQWE7QUFDeGxCLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DLHlDQUF3QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMzRyx1Q0FBc0MsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDdkcsaUJBQWlCLG1CQUFPLENBQUMsdUZBQVk7QUFDckMsb0RBQW1ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ2xJLGtEQUFpRCxFQUFFLHFDQUFxQyxxQ0FBcUMsRUFBQztBQUM5SCxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBYztBQUN6QywrQ0FBOEMsRUFBRSxxQ0FBcUMsb0NBQW9DLEVBQUM7QUFDMUgsaUJBQWlCLG1CQUFPLENBQUMsdUZBQVk7QUFDckMsZ0RBQStDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzFILHdCQUF3QixtQkFBTyxDQUFDLHFHQUFtQjtBQUNuRCxrREFBaUQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDckksc0JBQXNCLG1CQUFPLENBQUMsaUdBQWlCO0FBQy9DLG1FQUFrRSxFQUFFLHFDQUFxQywyREFBMkQsRUFBQztBQUNySyw0REFBMkQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDdkosd0RBQXVELEVBQUUscUNBQXFDLGdEQUFnRCxFQUFDO0FBQy9JLCtEQUE4RCxFQUFFLHFDQUFxQyx1REFBdUQsRUFBQztBQUM3SiwyQkFBMkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDekQsNkRBQTRELEVBQUUscUNBQXFDLDBEQUEwRCxFQUFDO0FBQzlKLG9DQUFvQyxtQkFBTyxDQUFDLDZIQUErQjtBQUMzRSw0REFBMkQsRUFBRSxxQ0FBcUMsa0VBQWtFLEVBQUM7QUFDckssZUFBZSxtQkFBTyxDQUFDLG1GQUFVO0FBQ2pDLHFEQUFvRCxFQUFFLHFDQUFxQyxzQ0FBc0MsRUFBQztBQUNsSSwrQ0FBOEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdEgsa0RBQWlELEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQzVILGVBQWUsbUJBQU8sQ0FBQyxtRkFBVTtBQUNqQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsK0JBQStCLEVBQUM7QUFDcEgscUJBQXFCLG1CQUFPLENBQUMsK0ZBQWdCO0FBQzdDLHNEQUFxRCxFQUFFLHFDQUFxQyw2Q0FBNkMsRUFBQztBQUMxSSxjQUFjLG1CQUFPLENBQUMsaUZBQVM7QUFDL0Isd0RBQXVELEVBQUUscUNBQXFDLHdDQUF3QyxFQUFDO0FBQ3ZJLDZCQUE2QixtQkFBTyxDQUFDLCtHQUF3QjtBQUM3RCx5REFBd0QsRUFBRSxxQ0FBcUMsd0RBQXdELEVBQUM7QUFDeEosd0NBQXdDLG1CQUFPLENBQUMscUlBQW1DO0FBQ25GLHVFQUFzRSxFQUFFLHFDQUFxQyxpRkFBaUYsRUFBQztBQUMvTCIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyA9IGV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IGV4cG9ydHMuRmlsdGVyU3RhY2tGYWN0b3J5ID0gZXhwb3J0cy5CYXNlRmlsdGVyID0gZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IGV4cG9ydHMuUXVldWVQaWNrZXIgPSBleHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSBleHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcgPSBleHBvcnRzLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IGV4cG9ydHMuZ2V0Rmlyc3RVc2FibGVDb25maWcgPSBleHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IGV4cG9ydHMuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9IGV4cG9ydHMuQmFja29mZlRpbWVvdXQgPSBleHBvcnRzLmR1cmF0aW9uVG9NcyA9IGV4cG9ydHMudXJpVG9TdHJpbmcgPSBleHBvcnRzLmNyZWF0ZVJlc29sdmVyID0gZXhwb3J0cy5yZWdpc3RlclJlc29sdmVyID0gZXhwb3J0cy5sb2cgPSBleHBvcnRzLnRyYWNlID0gdm9pZCAwO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLnRyYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dnaW5nXzEubG9nOyB9IH0pO1xudmFyIHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyUmVzb2x2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlcl8xLmNyZWF0ZVJlc29sdmVyOyB9IH0pO1xudmFyIHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1cmlUb1N0cmluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nOyB9IH0pO1xudmFyIGR1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9kdXJhdGlvblwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImR1cmF0aW9uVG9Nc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHVyYXRpb25fMS5kdXJhdGlvblRvTXM7IH0gfSk7XG52YXIgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYWNrb2ZmVGltZW91dFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmFja29mZl90aW1lb3V0XzEuQmFja29mZlRpbWVvdXQ7IH0gfSk7XG52YXIgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0Rmlyc3RVc2FibGVDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS5nZXRGaXJzdFVzYWJsZUNvbmZpZzsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZzsgfSB9KTtcbnZhciBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmc7IH0gfSk7XG52YXIgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGlsZExvYWRCYWxhbmNlckhhbmRsZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlcjsgfSB9KTtcbnZhciBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuYXZhaWxhYmxlUGlja2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlF1ZXVlUGlja2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwaWNrZXJfMS5RdWV1ZVBpY2tlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBpY2tSZXN1bHRUeXBlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZTsgfSB9KTtcbnZhciBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkJhc2VGaWx0ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcl8xLkJhc2VGaWx0ZXI7IH0gfSk7XG52YXIgZmlsdGVyX3N0YWNrXzEgPSByZXF1aXJlKFwiLi9maWx0ZXItc3RhY2tcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJGaWx0ZXJTdGFja0ZhY3RvcnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeTsgfSB9KTtcbnZhciBhZG1pbl8xID0gcmVxdWlyZShcIi4vYWRtaW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlckFkbWluU2VydmljZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYWRtaW5fMS5yZWdpc3RlckFkbWluU2VydmljZTsgfSB9KTtcbnZhciBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlU3ViY2hhbm5lbFdyYXBwZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEuQmFzZVN1YmNoYW5uZWxXcmFwcGVyOyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb25fMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbl8xLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnOyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhwZXJpbWVudGFsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters) {\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for (let i = 0; i < this.filters.length; i++) {\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for (let i = 0; i < this.filters.length; i++) {\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories) {\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    clone() {\n        return new FilterStackFactory([...this.factories]);\n    }\n    createFilter() {\n        return new FilterStack(this.factories.map(factory => factory.createFilter()));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory;\n//# sourceMappingURL=filter-stack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXItc3RhY2suanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEIsR0FBRyxtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuRmlsdGVyU3RhY2sgPSB2b2lkIDA7XG5jbGFzcyBGaWx0ZXJTdGFjayB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXRhZGF0YShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWV0YWRhdGEocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXNzYWdlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RhdHVzO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZVRyYWlsZXJzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcHVzaChmaWx0ZXJzKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy51bnNoaWZ0KC4uLmZpbHRlcnMpO1xuICAgIH1cbiAgICBnZXRGaWx0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVyU3RhY2sgPSBGaWx0ZXJTdGFjaztcbmNsYXNzIEZpbHRlclN0YWNrRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoZmFjdG9yaWVzKSB7XG4gICAgICAgIHRoaXMuZmFjdG9yaWVzID0gZmFjdG9yaWVzO1xuICAgIH1cbiAgICBwdXNoKGZpbHRlckZhY3Rvcmllcykge1xuICAgICAgICB0aGlzLmZhY3Rvcmllcy51bnNoaWZ0KC4uLmZpbHRlckZhY3Rvcmllcyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlclN0YWNrRmFjdG9yeShbLi4udGhpcy5mYWN0b3JpZXNdKTtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlclN0YWNrKHRoaXMuZmFjdG9yaWVzLm1hcChmYWN0b3J5ID0+IGZhY3RvcnkuY3JlYXRlRmlsdGVyKCkpKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IEZpbHRlclN0YWNrRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci1zdGFjay5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n}\nexports.BaseFilter = BaseFilter;\n//# sourceMappingURL=filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhc2VGaWx0ZXIgPSB2b2lkIDA7XG5jbGFzcyBCYXNlRmlsdGVyIHtcbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICByZWNlaXZlVHJhaWxlcnMoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlRmlsdGVyID0gQmFzZUZpbHRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst resolver_dns_1 = __webpack_require__(/*! ./resolver-dns */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = '';\n    let envVar = '';\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */\n    if (process.env.grpc_proxy) {\n        envVar = 'grpc_proxy';\n        proxyEnv = process.env.grpc_proxy;\n    }\n    else if (process.env.https_proxy) {\n        envVar = 'https_proxy';\n        proxyEnv = process.env.https_proxy;\n    }\n    else if (process.env.http_proxy) {\n        envVar = 'http_proxy';\n        proxyEnv = process.env.http_proxy;\n    }\n    else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    }\n    catch (e) {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== 'http:') {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        }\n        else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */\n    if (port === '') {\n        port = '80';\n    }\n    const result = {\n        address: `${hostname}:${port}`,\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n    let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = 'no_grpc_proxy';\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = 'no_proxy';\n    }\n    if (noProxyStr) {\n        trace('No proxy server list set by environment variable ' + envVar);\n        return noProxyStr.split(',');\n    }\n    else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {},\n    };\n    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === 'unix') {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()) {\n        if (host === serverHost) {\n            trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target),\n    };\n    if (proxyInfo.creds) {\n        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: 'dns',\n            path: proxyInfo.address,\n        },\n        extraOptions: extraOptions,\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    var _a;\n    if (!('grpc.http_connect_target' in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions['grpc.http_connect_target'];\n    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\n    if (splitHostPost === null) {\n        return Promise.resolve({});\n    }\n    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\n    const options = {\n        method: 'CONNECT',\n        path: hostPort,\n    };\n    const headers = {\n        Host: hostPort,\n    };\n    // Connect to the subchannel address as a proxy\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    }\n    else {\n        options.socketPath = address.path;\n    }\n    if ('grpc.http_connect_creds' in channelOptions) {\n        headers['Proxy-Authorization'] =\n            'Basic ' +\n                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n    }\n    options.headers = headers;\n    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n    return new Promise((resolve, reject) => {\n        const request = http.request(options);\n        request.once('connect', (res, socket, head) => {\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace('Successfully connected to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString);\n                if ('secureContext' in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n                    const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {\n                        trace('Successfully established a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString);\n                        resolve({ socket: cts, realTarget: parsedTarget });\n                    });\n                    cts.on('error', (error) => {\n                        trace('Failed to establish a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString +\n                            ' with error ' +\n                            error.message);\n                        reject();\n                    });\n                }\n                else {\n                    trace('Successfully established a plaintext connection to ' +\n                        options.path +\n                        ' through proxy ' +\n                        proxyAddressString);\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget,\n                    });\n                }\n            }\n            else {\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with status ' +\n                    res.statusCode);\n                reject();\n            }\n        });\n        request.once('error', err => {\n            request.removeAllListeners();\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +\n                proxyAddressString +\n                ' with error ' +\n                err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection;\n//# sourceMappingURL=http_proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9odHRwX3Byb3h5LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsb0JBQW9CO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHFGQUFXO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELHFCQUFxQixtQkFBTyxDQUFDLDJGQUFjO0FBQzNDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQix1QkFBdUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsT0FBTztBQUM1RjtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsa0JBQWtCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0IsR0FBRyxrQkFBa0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLEdBQUcsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHdCQUF3QixtQkFBbUIsR0FBRyx1RkFBdUY7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDBEQUEwRDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1Q0FBdUM7QUFDekUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2h0dHBfcHJveHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UHJveGllZENvbm5lY3Rpb24gPSBleHBvcnRzLm1hcFByb3h5TmFtZSA9IHZvaWQgMDtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IHJlc29sdmVyX2Ruc18xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncHJveHknO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5mdW5jdGlvbiBnZXRQcm94eUluZm8oKSB7XG4gICAgbGV0IHByb3h5RW52ID0gJyc7XG4gICAgbGV0IGVudlZhciA9ICcnO1xuICAgIC8qIFByZWZlciB1c2luZyAnZ3JwY19wcm94eScuIEZhbGxiYWNrIG9uICdodHRwX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LlxuICAgICAqIEFsc28gcHJlZmVyIHVzaW5nICdodHRwc19wcm94eScgd2l0aCBmYWxsYmFjayBvbiAnaHR0cF9wcm94eScuIFRoZVxuICAgICAqIGZhbGxiYWNrIGJlaGF2aW9yIGNhbiBiZSByZW1vdmVkIGlmIHRoZXJlJ3MgYSBkZW1hbmQgZm9yIGl0LlxuICAgICAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5ncnBjX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdncnBjX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5ncnBjX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwc19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cHNfcHJveHknO1xuICAgICAgICBwcm94eUVudiA9IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdodHRwX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgcHJveHlVcmw7XG4gICAgdHJ5IHtcbiAgICAgICAgcHJveHlVcmwgPSBuZXcgdXJsXzEuVVJMKHByb3h5RW52KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYGNhbm5vdCBwYXJzZSB2YWx1ZSBvZiBcIiR7ZW52VmFyfVwiIGVudiB2YXJgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAocHJveHlVcmwucHJvdG9jb2wgIT09ICdodHRwOicpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYFwiJHtwcm94eVVybC5wcm90b2NvbH1cIiBzY2hlbWUgbm90IHN1cHBvcnRlZCBpbiBwcm94eSBVUklgKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgdXNlckNyZWQgPSBudWxsO1xuICAgIGlmIChwcm94eVVybC51c2VybmFtZSkge1xuICAgICAgICBpZiAocHJveHlVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTywgJ3VzZXJpbmZvIGZvdW5kIGluIHByb3h5IFVSSScpO1xuICAgICAgICAgICAgdXNlckNyZWQgPSBgJHtwcm94eVVybC51c2VybmFtZX06JHtwcm94eVVybC5wYXNzd29yZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlckNyZWQgPSBwcm94eVVybC51c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBob3N0bmFtZSA9IHByb3h5VXJsLmhvc3RuYW1lO1xuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcbiAgICAvKiBUaGUgcHJveHkgVVJMIHVzZXMgdGhlIHNjaGVtZSBcImh0dHA6XCIsIHdoaWNoIGhhcyBhIGRlZmF1bHQgcG9ydCBudW1iZXIgb2ZcbiAgICAgKiA4MC4gV2UgbmVlZCB0byBzZXQgdGhhdCBleHBsaWNpdGx5IGhlcmUgaWYgaXQgaXMgb21pdHRlZCBiZWNhdXNlIG90aGVyd2lzZVxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xuICAgIGlmIChwb3J0ID09PSAnJykge1xuICAgICAgICBwb3J0ID0gJzgwJztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRyZXNzOiBgJHtob3N0bmFtZX06JHtwb3J0fWAsXG4gICAgfTtcbiAgICBpZiAodXNlckNyZWQpIHtcbiAgICAgICAgcmVzdWx0LmNyZWRzID0gdXNlckNyZWQ7XG4gICAgfVxuICAgIHRyYWNlKCdQcm94eSBzZXJ2ZXIgJyArIHJlc3VsdC5hZGRyZXNzICsgJyBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5vUHJveHlIb3N0TGlzdCgpIHtcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ25vX2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnbm9fcHJveHknIGlmIGl0IGlzIG5vdCBzZXQuICovXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xuICAgIGxldCBlbnZWYXIgPSAnbm9fZ3JwY19wcm94eSc7XG4gICAgaWYgKCFub1Byb3h5U3RyKSB7XG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICAgICAgZW52VmFyID0gJ25vX3Byb3h5JztcbiAgICB9XG4gICAgaWYgKG5vUHJveHlTdHIpIHtcbiAgICAgICAgdHJhY2UoJ05vIHByb3h5IHNlcnZlciBsaXN0IHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlTdHIuc3BsaXQoJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBQcm94eU5hbWUodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG5vUHJveHlSZXN1bHQgPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBleHRyYU9wdGlvbnM6IHt9LFxuICAgIH07XG4gICAgaWYgKCgoX2EgPSBvcHRpb25zWydncnBjLmVuYWJsZV9odHRwX3Byb3h5J10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gJ3VuaXgnKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBwcm94eUluZm8gPSBnZXRQcm94eUluZm8oKTtcbiAgICBpZiAoIXByb3h5SW5mby5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0LnBhdGgpO1xuICAgIGlmICghaG9zdFBvcnQpIHtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHNlcnZlckhvc3QgPSBob3N0UG9ydC5ob3N0O1xuICAgIGZvciAoY29uc3QgaG9zdCBvZiBnZXROb1Byb3h5SG9zdExpc3QoKSkge1xuICAgICAgICBpZiAoaG9zdCA9PT0gc2VydmVySG9zdCkge1xuICAgICAgICAgICAgdHJhY2UoJ05vdCB1c2luZyBwcm94eSBmb3IgdGFyZ2V0IGluIG5vX3Byb3h5IGxpc3Q6ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcbiAgICAgICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dHJhT3B0aW9ucyA9IHtcbiAgICAgICAgJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCc6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgfTtcbiAgICBpZiAocHJveHlJbmZvLmNyZWRzKSB7XG4gICAgICAgIGV4dHJhT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSA9IHByb3h5SW5mby5jcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBzY2hlbWU6ICdkbnMnLFxuICAgICAgICAgICAgcGF0aDogcHJveHlJbmZvLmFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhT3B0aW9uczogZXh0cmFPcHRpb25zLFxuICAgIH07XG59XG5leHBvcnRzLm1hcFByb3h5TmFtZSA9IG1hcFByb3h5TmFtZTtcbmZ1bmN0aW9uIGdldFByb3hpZWRDb25uZWN0aW9uKGFkZHJlc3MsIGNoYW5uZWxPcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoISgnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JyBpbiBjaGFubmVsT3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGNvbnN0IHJlYWxUYXJnZXQgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0J107XG4gICAgY29uc3QgcGFyc2VkVGFyZ2V0ID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkocmVhbFRhcmdldCk7XG4gICAgaWYgKHBhcnNlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3Qgc3BsaXRIb3N0UG9zdCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkocGFyc2VkVGFyZ2V0LnBhdGgpO1xuICAgIGlmIChzcGxpdEhvc3RQb3N0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9IGAke3NwbGl0SG9zdFBvc3QuaG9zdH06JHsoX2EgPSBzcGxpdEhvc3RQb3N0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHJlc29sdmVyX2Ruc18xLkRFRkFVTFRfUE9SVH1gO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogJ0NPTk5FQ1QnLFxuICAgICAgICBwYXRoOiBob3N0UG9ydCxcbiAgICB9O1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgIEhvc3Q6IGhvc3RQb3J0LFxuICAgIH07XG4gICAgLy8gQ29ubmVjdCB0byB0aGUgc3ViY2hhbm5lbCBhZGRyZXNzIGFzIGEgcHJveHlcbiAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLmlzVGNwU3ViY2hhbm5lbEFkZHJlc3MpKGFkZHJlc3MpKSB7XG4gICAgICAgIG9wdGlvbnMuaG9zdCA9IGFkZHJlc3MuaG9zdDtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xuICAgIH1cbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJyBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgICAgICAgJ0Jhc2ljICcgK1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF9jcmVkcyddKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgY29uc3QgcHJveHlBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpO1xuICAgIHRyYWNlKCdVc2luZyBwcm94eSAnICsgcHJveHlBZGRyZXNzU3RyaW5nICsgJyB0byBjb25uZWN0IHRvICcgKyBvcHRpb25zLnBhdGgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucyk7XG4gICAgICAgIHJlcXVlc3Qub25jZSgnY29ubmVjdCcsIChyZXMsIHNvY2tldCwgaGVhZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmVxdWVzdC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBjb25uZWN0ZWQgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoZSBwcm94eSBpcyBjb25uZWN0aW5nIHRvIGEgVExTIHNlcnZlciwgc28gdXBncmFkZSB0aGlzIHNvY2tldFxuICAgICAgICAgICAgICAgICAgICAgKiBjb25uZWN0aW9uIHRvIGEgVExTIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAqIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzMyOTIyXG4gICAgICAgICAgICAgICAgICAgICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjLW5vZGUvcHVsbC8xMzY5IGZvciBtb3JlIGluZm8uICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KShwYXJzZWRUYXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUhvc3QgPSAoX2EgPSBob3N0UG9ydCA9PT0gbnVsbCB8fCBob3N0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdFBvcnQuaG9zdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGFyZ2V0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3RzID0gdGxzLmNvbm5lY3QoT2JqZWN0LmFzc2lnbih7IGhvc3Q6IHJlbW90ZUhvc3QsIHNlcnZlcm5hbWU6IHJlbW90ZUhvc3QsIHNvY2tldDogc29ja2V0IH0sIGNvbm5lY3Rpb25PcHRpb25zKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIFRMUyBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc29ja2V0OiBjdHMsIHJlYWxUYXJnZXQ6IHBhcnNlZFRhcmdldCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKCdGYWlsZWQgdG8gZXN0YWJsaXNoIGEgVExTIGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnU3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIGEgcGxhaW50ZXh0IGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsVGFyZ2V0OiBwYXJzZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsICdGYWlsZWQgdG8gY29ubmVjdCB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAnIHdpdGggc3RhdHVzICcgK1xuICAgICAgICAgICAgICAgICAgICByZXMuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gcHJveHkgJyArXG4gICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LmVuZCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRQcm94aWVkQ29ubmVjdGlvbiA9IGdldFByb3hpZWRDb25uZWN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHR0cF9wcm94eS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.experimental = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({ enumerable: true, get: function () { return call_credentials_1.CallCredentials; } }));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({ enumerable: true, get: function () { return channel_1.ChannelImplementation; } }));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({ enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } }));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({ enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } }));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({ enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } }));\nconst client_1 = __webpack_require__(/*! ./client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({ enumerable: true, get: function () { return client_1.Client; } }));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({ enumerable: true, get: function () { return constants_1.LogVerbosity; } }));\nObject.defineProperty(exports, \"status\", ({ enumerable: true, get: function () { return constants_1.Status; } }));\nObject.defineProperty(exports, \"propagate\", ({ enumerable: true, get: function () { return constants_1.Propagate; } }));\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({ enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } }));\nObject.defineProperty(exports, \"makeClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({ enumerable: true, get: function () { return metadata_1.Metadata; } }));\nconst server_1 = __webpack_require__(/*! ./server */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({ enumerable: true, get: function () { return server_1.Server; } }));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({ enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } }));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({ enumerable: true, get: function () { return status_builder_1.StatusBuilder; } }));\n/**** Client Credentials ****/\n// Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */\n    combineChannelCredentials: (channelCredentials, ...callCredentials) => {\n        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */\n    combineCallCredentials: (first, ...additional) => {\n        return additional.reduce((acc, other) => acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty,\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */\nconst closeClient = (client) => client.close();\nexports.closeClient = closeClient;\nconst waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);\nexports.waitForClientReady = waitForClientReady;\n/* eslint-enable @typescript-eslint/no-explicit-any */\n/**** Unimplemented function stubs ****/\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst loadObject = (value, options) => {\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\nexports.loadObject = loadObject;\nconst load = (filename, format, options) => {\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\nexports.load = load;\nconst setLogger = (logger) => {\n    logging.setLogger(logger);\n};\nexports.setLogger = setLogger;\nconst setLogVerbosity = (verbosity) => {\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.setLogVerbosity = setLogVerbosity;\nconst getClientChannel = (client) => {\n    return client_1.Client.prototype.getChannel.call(client);\n};\nexports.getClientChannel = getClientChannel;\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } }));\nObject.defineProperty(exports, \"RequesterBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } }));\nObject.defineProperty(exports, \"InterceptingCall\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } }));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } }));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({ enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } }));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({ enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } }));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({ enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } }));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n(() => {\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    channelz.setup();\n})();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLG9DQUFvQyxHQUFHLHFDQUFxQyxHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHFCQUFxQixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLGNBQWMsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxZQUFZLEdBQUcsa0JBQWtCLEdBQUcsdUJBQXVCLEdBQUcsMEJBQTBCLEdBQUcsMEJBQTBCLEdBQUcsbUJBQW1CLEdBQUcsZUFBZSxHQUFHLG9DQUFvQyxHQUFHLDZCQUE2QixHQUFHLDZCQUE2QixHQUFHLGNBQWMsR0FBRyw2QkFBNkIsR0FBRyxpQkFBaUIsR0FBRyx5QkFBeUIsR0FBRyxjQUFjLEdBQUcsb0JBQW9CLEdBQUcsZ0JBQWdCLEdBQUcsbUJBQW1CO0FBQzN6QiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBb0I7QUFDdkQsbURBQWtELEVBQUUscUNBQXFDLDhDQUE4QyxFQUFDO0FBQ3hJLGtCQUFrQixtQkFBTyxDQUFDLHFGQUFXO0FBQ3JDLDJDQUEwQyxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUM3SCxpQ0FBaUMsbUJBQU8sQ0FBQyxtSEFBMEI7QUFDbkUseURBQXdELEVBQUUscUNBQXFDLDBEQUEwRCxFQUFDO0FBQzFKLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxxREFBb0QsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDOUksOEJBQThCLG1CQUFPLENBQUMsNkdBQXVCO0FBQzdELHNEQUFxRCxFQUFFLHFDQUFxQyxvREFBb0QsRUFBQztBQUNqSixpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsZ0RBQStDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzNILDBDQUF5QyxFQUFFLHFDQUFxQyw4QkFBOEIsRUFBQztBQUMvRyw2Q0FBNEMsRUFBRSxxQ0FBcUMsaUNBQWlDLEVBQUM7QUFDckgsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0MseURBQXdELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQy9JLHlEQUF3RCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMvSSxnRUFBK0QsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDdEosbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsNENBQTJDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ2xILGlCQUFpQixtQkFBTyxDQUFDLG1GQUFVO0FBQ25DLDBDQUF5QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUM1Ryw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxpREFBZ0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDbEk7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw0QkFBNEIsbUJBQU8sQ0FBQyw2R0FBdUI7QUFDM0QsbURBQWtELEVBQUUscUNBQXFDLGlEQUFpRCxFQUFDO0FBQzNJLG9EQUFtRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM3SSxvREFBbUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDN0ksaUVBQWdFLEVBQUUscUNBQXFDLCtEQUErRCxFQUFDO0FBQ3ZLLGlCQUFpQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3JDLGdFQUErRCxFQUFFLHFDQUFxQyxtREFBbUQsRUFBQztBQUMxSix1REFBc0QsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDeEksY0FBYyxtQkFBTyxDQUFDLGlGQUFTO0FBQy9CLDREQUEyRCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMvSSxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDN0Msb0JBQW9CO0FBQ3BCLHFCQUFxQixtQkFBTyxDQUFDLCtGQUFnQjtBQUM3QyxxQkFBcUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDN0Msb0JBQW9CLG1CQUFPLENBQUMsNkZBQWU7QUFDM0MsaUNBQWlDLG1CQUFPLENBQUMsdUhBQTRCO0FBQ3JFLGtDQUFrQyxtQkFBTyxDQUFDLHlIQUE2QjtBQUN2RSx3Q0FBd0MsbUJBQU8sQ0FBQyxxSUFBbUM7QUFDbkYsaUJBQWlCLG1CQUFPLENBQUMsdUZBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBleHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBleHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBleHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gZXhwb3J0cy5SZXF1ZXN0ZXJCdWlsZGVyID0gZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBleHBvcnRzLlN0YXR1c0J1aWxkZXIgPSBleHBvcnRzLmdldENsaWVudENoYW5uZWwgPSBleHBvcnRzLlNlcnZlckNyZWRlbnRpYWxzID0gZXhwb3J0cy5TZXJ2ZXIgPSBleHBvcnRzLnNldExvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuc2V0TG9nZ2VyID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5sb2FkT2JqZWN0ID0gZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHMgPSBleHBvcnRzLkNoYW5uZWxDcmVkZW50aWFscyA9IGV4cG9ydHMud2FpdEZvckNsaWVudFJlYWR5ID0gZXhwb3J0cy5jbG9zZUNsaWVudCA9IGV4cG9ydHMuQ2hhbm5lbCA9IGV4cG9ydHMubWFrZUdlbmVyaWNDbGllbnRDb25zdHJ1Y3RvciA9IGV4cG9ydHMubWFrZUNsaWVudENvbnN0cnVjdG9yID0gZXhwb3J0cy5sb2FkUGFja2FnZURlZmluaXRpb24gPSBleHBvcnRzLkNsaWVudCA9IGV4cG9ydHMuY29tcHJlc3Npb25BbGdvcml0aG1zID0gZXhwb3J0cy5wcm9wYWdhdGUgPSBleHBvcnRzLmNvbm5lY3Rpdml0eVN0YXRlID0gZXhwb3J0cy5zdGF0dXMgPSBleHBvcnRzLmxvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuTWV0YWRhdGEgPSBleHBvcnRzLmNyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgY2FsbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2FsbC1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNhbGxDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFsczsgfSB9KTtcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGFubmVsXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsXzEuQ2hhbm5lbEltcGxlbWVudGF0aW9uOyB9IH0pO1xuY29uc3QgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb24tYWxnb3JpdGhtc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbXByZXNzaW9uQWxnb3JpdGhtc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tcHJlc3Npb25fYWxnb3JpdGhtc18xLkNvbXByZXNzaW9uQWxnb3JpdGhtczsgfSB9KTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29ubmVjdGl2aXR5U3RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlOyB9IH0pO1xuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYW5uZWxDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFsczsgfSB9KTtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfMS5DbGllbnQ7IH0gfSk7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1ZlcmJvc2l0eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic3RhdHVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5TdGF0dXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9wYWdhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLlByb3BhZ2F0ZTsgfSB9KTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZFBhY2thZ2VEZWZpbml0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLmxvYWRQYWNrYWdlRGVmaW5pdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VDbGllbnRDb25zdHJ1Y3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5tYWtlQ2xpZW50Q29uc3RydWN0b3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLm1ha2VDbGllbnRDb25zdHJ1Y3RvcjsgfSB9KTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk1ldGFkYXRhXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXRhZGF0YV8xLk1ldGFkYXRhOyB9IH0pO1xuY29uc3Qgc2VydmVyXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl8xLlNlcnZlcjsgfSB9KTtcbmNvbnN0IHNlcnZlcl9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vc2VydmVyLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNlcnZlcl9jcmVkZW50aWFsc18xLlNlcnZlckNyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3Qgc3RhdHVzX2J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXR1cy1idWlsZGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3RhdHVzQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdHVzX2J1aWxkZXJfMS5TdGF0dXNCdWlsZGVyOyB9IH0pO1xuLyoqKiogQ2xpZW50IENyZWRlbnRpYWxzICoqKiovXG4vLyBVc2luZyBhc3NpZ24gb25seSBjb3BpZXMgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLCB3aGljaCBpcyB3aGF0IHdlIHdhbnRcbmV4cG9ydHMuY3JlZGVudGlhbHMgPSB7XG4gICAgLyoqXG4gICAgICogQ29tYmluZSBhIENoYW5uZWxDcmVkZW50aWFscyB3aXRoIGFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIGludG8gYVxuICAgICAqIHNpbmdsZSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjaGFubmVsQ3JlZGVudGlhbHMgVGhlIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICogQHBhcmFtIGNhbGxDcmVkZW50aWFscyBBbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBvYmplY3RzLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbWJpbmVDaGFubmVsQ3JlZGVudGlhbHM6IChjaGFubmVsQ3JlZGVudGlhbHMsIC4uLmNhbGxDcmVkZW50aWFscykgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbENyZWRlbnRpYWxzLnJlZHVjZSgoYWNjLCBvdGhlcikgPT4gYWNjLmNvbXBvc2Uob3RoZXIpLCBjaGFubmVsQ3JlZGVudGlhbHMpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ29tYmluZSBhbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBpbnRvIGEgc2luZ2xlIENhbGxDcmVkZW50aWFsc1xuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZmlyc3QgVGhlIGZpcnN0IENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICogQHBhcmFtIGFkZGl0aW9uYWwgQW55IG51bWJlciBvZiBhZGRpdGlvbmFsIENhbGxDcmVkZW50aWFscyBvYmplY3RzLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3VsdGluZyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbWJpbmVDYWxsQ3JlZGVudGlhbHM6IChmaXJzdCwgLi4uYWRkaXRpb25hbCkgPT4ge1xuICAgICAgICByZXR1cm4gYWRkaXRpb25hbC5yZWR1Y2UoKGFjYywgb3RoZXIpID0+IGFjYy5jb21wb3NlKG90aGVyKSwgZmlyc3QpO1xuICAgIH0sXG4gICAgLy8gZnJvbSBjaGFubmVsLWNyZWRlbnRpYWxzLnRzXG4gICAgY3JlYXRlSW5zZWN1cmU6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlSW5zZWN1cmUsXG4gICAgY3JlYXRlU3NsOiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZVNzbCxcbiAgICBjcmVhdGVGcm9tU2VjdXJlQ29udGV4dDogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVGcm9tU2VjdXJlQ29udGV4dCxcbiAgICAvLyBmcm9tIGNhbGwtY3JlZGVudGlhbHMudHNcbiAgICBjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3I6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yLFxuICAgIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsLFxuICAgIGNyZWF0ZUVtcHR5OiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5LFxufTtcbi8qKlxuICogQ2xvc2UgYSBDbGllbnQgb2JqZWN0LlxuICogQHBhcmFtIGNsaWVudCBUaGUgY2xpZW50IHRvIGNsb3NlLlxuICovXG5jb25zdCBjbG9zZUNsaWVudCA9IChjbGllbnQpID0+IGNsaWVudC5jbG9zZSgpO1xuZXhwb3J0cy5jbG9zZUNsaWVudCA9IGNsb3NlQ2xpZW50O1xuY29uc3Qgd2FpdEZvckNsaWVudFJlYWR5ID0gKGNsaWVudCwgZGVhZGxpbmUsIGNhbGxiYWNrKSA9PiBjbGllbnQud2FpdEZvclJlYWR5KGRlYWRsaW5lLCBjYWxsYmFjayk7XG5leHBvcnRzLndhaXRGb3JDbGllbnRSZWFkeSA9IHdhaXRGb3JDbGllbnRSZWFkeTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqKiogVW5pbXBsZW1lbnRlZCBmdW5jdGlvbiBzdHVicyAqKioqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgbG9hZE9iamVjdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGF2YWlsYWJsZSBpbiB0aGlzIGxpYnJhcnkuIFVzZSBAZ3JwYy9wcm90by1sb2FkZXIgYW5kIGxvYWRQYWNrYWdlRGVmaW5pdGlvbiBpbnN0ZWFkJyk7XG59O1xuZXhwb3J0cy5sb2FkT2JqZWN0ID0gbG9hZE9iamVjdDtcbmNvbnN0IGxvYWQgPSAoZmlsZW5hbWUsIGZvcm1hdCwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGF2YWlsYWJsZSBpbiB0aGlzIGxpYnJhcnkuIFVzZSBAZ3JwYy9wcm90by1sb2FkZXIgYW5kIGxvYWRQYWNrYWdlRGVmaW5pdGlvbiBpbnN0ZWFkJyk7XG59O1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmNvbnN0IHNldExvZ2dlciA9IChsb2dnZXIpID0+IHtcbiAgICBsb2dnaW5nLnNldExvZ2dlcihsb2dnZXIpO1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyID0gc2V0TG9nZ2VyO1xuY29uc3Qgc2V0TG9nVmVyYm9zaXR5ID0gKHZlcmJvc2l0eSkgPT4ge1xuICAgIGxvZ2dpbmcuc2V0TG9nZ2VyVmVyYm9zaXR5KHZlcmJvc2l0eSk7XG59O1xuZXhwb3J0cy5zZXRMb2dWZXJib3NpdHkgPSBzZXRMb2dWZXJib3NpdHk7XG5jb25zdCBnZXRDbGllbnRDaGFubmVsID0gKGNsaWVudCkgPT4ge1xuICAgIHJldHVybiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLmdldENoYW5uZWwuY2FsbChjbGllbnQpO1xufTtcbmV4cG9ydHMuZ2V0Q2xpZW50Q2hhbm5lbCA9IGdldENsaWVudENoYW5uZWw7XG52YXIgY2xpZW50X2ludGVyY2VwdG9yc18xID0gcmVxdWlyZShcIi4vY2xpZW50LWludGVyY2VwdG9yc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkxpc3RlbmVyQnVpbGRlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2ludGVyY2VwdG9yc18xLkxpc3RlbmVyQnVpbGRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJlcXVlc3RlckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5SZXF1ZXN0ZXJCdWlsZGVyOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJjZXB0aW5nQ2FsbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2ludGVyY2VwdG9yc18xLkludGVyY2VwdGluZ0NhbGw7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50X2ludGVyY2VwdG9yc18xLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yOyB9IH0pO1xudmFyIGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENoYW5uZWx6U2VydmljZURlZmluaXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWx6XzEuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldENoYW5uZWx6SGFuZGxlcnNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWx6XzEuZ2V0Q2hhbm5lbHpIYW5kbGVyczsgfSB9KTtcbnZhciBhZG1pbl8xID0gcmVxdWlyZShcIi4vYWRtaW5cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyOyB9IH0pO1xuY29uc3QgZXhwZXJpbWVudGFsID0gcmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xuZXhwb3J0cy5leHBlcmltZW50YWwgPSBleHBlcmltZW50YWw7XG5jb25zdCByZXNvbHZlcl9kbnMgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1kbnNcIik7XG5jb25zdCByZXNvbHZlcl91ZHMgPSByZXF1aXJlKFwiLi9yZXNvbHZlci11ZHNcIik7XG5jb25zdCByZXNvbHZlcl9pcCA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLWlwXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0ID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0XCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9yb3VuZF9yb2JpbiA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcm91bmQtcm9iaW5cIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvblwiKTtcbmNvbnN0IGNoYW5uZWx6ID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG4oKCkgPT4ge1xuICAgIHJlc29sdmVyX2Rucy5zZXR1cCgpO1xuICAgIHJlc29sdmVyX3Vkcy5zZXR1cCgpO1xuICAgIHJlc29sdmVyX2lwLnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0LnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9yb3VuZF9yb2Jpbi5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24uc2V0dXAoKTtcbiAgICBjaGFubmVsei5zZXR1cCgpO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/internal-channel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InternalChannel = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst load_balancing_call_1 = __webpack_require__(/*! ./load-balancing-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst resolving_call_1 = __webpack_require__(/*! ./resolving-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst retrying_call_1 = __webpack_require__(/*! ./retrying-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\nconst RETRY_THROTTLER_MAP = new Map();\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, channel) {\n        super(childSubchannel);\n        this.channel = channel;\n        this.refCount = 0;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {\n            channel.throttleKeepalive(keepaliveTime);\n        };\n        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            this.child.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channel.removeWrappedSubchannel(this);\n        }\n    }\n}\nclass InternalChannel {\n    constructor(target, credentials, options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */\n        this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */\n        this.currentResolutionError = null;\n        this.wrappedSubchannels = new Set();\n        this.callCount = 0;\n        this.idleTimer = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object') {\n                throw new TypeError('Channel options must be an object');\n            }\n        }\n        this.originalTarget = target;\n        const originalTargetUri = (0, uri_parser_1.parseUri)(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */\n        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n        }\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\n        }\n        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */\n        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\n        this.keepaliveTime = (_f = options['grpc.keepalive_time_ms']) !== null && _f !== void 0 ? _f : -1;\n        this.idleTimeoutMs = Math.max((_g = options['grpc.client_idle_timeout_ms']) !== null && _g !== void 0 ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n                subchannel.throttleKeepalive(this.keepaliveTime);\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n                }\n                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n                this.wrappedSubchannels.add(wrappedSubchannel);\n                return wrappedSubchannel;\n            },\n            updateState: (connectivityState, picker) => {\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                if (queueCopy.length > 0) {\n                    this.callRefTimerUnref();\n                }\n                for (const call of queueCopy) {\n                    call.doPick();\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: () => {\n                // This should never be called.\n                throw new Error('Resolving load balancer should never call requestReresolution');\n            },\n            addChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.childrenTracker.unrefChild(child);\n                }\n            },\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => {\n            if (serviceConfig.retryThrottling) {\n                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n            }\n            else {\n                RETRY_THROTTLER_MAP.delete(this.getTarget());\n            }\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n            }\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */\n            process.nextTick(() => {\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                if (localQueue.length > 0) {\n                    this.callRefTimerUnref();\n                }\n                for (const call of localQueue) {\n                    call.getConfig();\n                }\n            });\n        }, status => {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' +\n                    status.code +\n                    ' and details \"' +\n                    status.details +\n                    '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace('Name resolution failed with calls queued for config selection');\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            if (localQueue.length > 0) {\n                this.callRefTimerUnref();\n            }\n            for (const call of localQueue) {\n                call.reportResolverError(status);\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new compression_filter_1.CompressionFilterFactory(this, this.options),\n        ]);\n        this.trace('Channel constructed with options ' +\n            JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +\n            this.channelzRef.id +\n            ') ' +\n            'Channel constructed \\n' +\n            ((_h = error.stack) === null || _h === void 0 ? void 0 : _h.substring(error.stack.indexOf('\\n') + 1)));\n        this.lastActivityTimestamp = new Date();\n    }\n    getChannelzInfo() {\n        return {\n            target: this.originalTarget,\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n        };\n    }\n    trace(text, verbosityOverride) {\n        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace('callRefTimer.ref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n            this.trace('callRefTimer.unref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +\n            this.channelzRef.id +\n            ') ' +\n            (0, uri_parser_1.uriToString)(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy) {\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n            for (const wrappedSubchannel of this.wrappedSubchannels) {\n                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n            }\n        }\n    }\n    removeWrappedSubchannel(wrappedSubchannel) {\n        this.wrappedSubchannels.delete(wrappedSubchannel);\n    }\n    doPick(metadata, extraPickInfo) {\n        return this.currentPicker.pick({\n            metadata: metadata,\n            extraPickInfo: extraPickInfo,\n        });\n    }\n    queueCallForPick(call) {\n        this.pickQueue.push(call);\n        this.callRefTimerRef();\n    }\n    getConfig(method, metadata) {\n        this.resolvingLoadBalancer.exitIdle();\n        if (this.configSelector) {\n            return {\n                type: 'SUCCESS',\n                config: this.configSelector(method, metadata),\n            };\n        }\n        else {\n            if (this.currentResolutionError) {\n                return {\n                    type: 'ERROR',\n                    error: this.currentResolutionError,\n                };\n            }\n            else {\n                return {\n                    type: 'NONE',\n                };\n            }\n        }\n    }\n    queueCallForConfig(call) {\n        this.configSelectionQueue.push(call);\n        this.callRefTimerRef();\n    }\n    enterIdle() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE);\n        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n            this.idleTimer = null;\n        }\n    }\n    startIdleTimeout(timeoutMs) {\n        var _a, _b;\n        this.idleTimer = setTimeout(() => {\n            if (this.callCount > 0) {\n                /* If there is currently a call, the channel will not go idle for a\n                 * period of at least idleTimeoutMs, so check again after that time.\n                 */\n                this.startIdleTimeout(this.idleTimeoutMs);\n                return;\n            }\n            const now = new Date();\n            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();\n            if (timeSinceLastActivity >= this.idleTimeoutMs) {\n                this.trace('Idle timer triggered after ' +\n                    this.idleTimeoutMs +\n                    'ms of inactivity');\n                this.enterIdle();\n            }\n            else {\n                /* Whenever the timer fires with the latest activity being too recent,\n                 * set the timer again for the time when the time since the last\n                 * activity is equal to the timeout. This should result in the timer\n                 * firing no more than once every idleTimeoutMs/2 on average. */\n                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\n            }\n        }, timeoutMs);\n        (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    maybeStartIdleTimer() {\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && !this.idleTimer) {\n            this.startIdleTimeout(this.idleTimeoutMs);\n        }\n    }\n    onCallStart() {\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n        }\n        this.callCount += 1;\n    }\n    onCallEnd(status) {\n        if (this.channelzEnabled) {\n            if (status.code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            }\n            else {\n                this.callTracker.addCallFailed();\n            }\n        }\n        this.callCount -= 1;\n        this.lastActivityTimestamp = new Date();\n        this.maybeStartIdleTimer();\n    }\n    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"');\n        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n    }\n    createRetryingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createRetryingCall [' + callNumber + '] method=\"' + method + '\"');\n        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\n    }\n    createInnerCall(callConfig, method, host, credentials, deadline) {\n        // Create a RetryingCall if retries are enabled\n        if (this.options['grpc.enable_retries'] === 0) {\n            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);\n        }\n        else {\n            return this.createRetryingCall(callConfig, method, host, credentials, deadline);\n        }\n    }\n    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createResolvingCall [' +\n            callNumber +\n            '] method=\"' +\n            method +\n            '\", deadline=' +\n            (0, deadline_1.deadlineToString)(deadline));\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall,\n        };\n        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);\n        this.onCallStart();\n        call.addStatusWatcher(status => {\n            this.onCallEnd(status);\n        });\n        return call;\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n        }\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return (0, uri_parser_1.uriToString)(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n            this.lastActivityTimestamp = new Date();\n            this.maybeStartIdleTimer();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n                return;\n            }\n            timer = setTimeout(() => {\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error('Deadline passed without connectivity state change'));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer,\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.InternalChannel = InternalChannel;\n//# sourceMappingURL=internal-channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9pbnRlcm5hbC1jaGFubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QixtQkFBTyxDQUFDLDZHQUF1QjtBQUM3RCxrQ0FBa0MsbUJBQU8sQ0FBQyxxSEFBMkI7QUFDckUsMEJBQTBCLG1CQUFPLENBQUMscUdBQW1CO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLG1GQUFVO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLHVCQUF1QixtQkFBTyxDQUFDLCtGQUFnQjtBQUMvQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMscUZBQVc7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLDhCQUE4QixtQkFBTyxDQUFDLDZHQUF1QjtBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxtR0FBa0I7QUFDbkQsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0MsK0JBQStCLG1CQUFPLENBQUMsK0dBQXdCO0FBQy9ELHdCQUF3QixtQkFBTyxDQUFDLGlHQUFpQjtBQUNqRCwrQkFBK0IsbUJBQU8sQ0FBQywrR0FBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsT0FBTztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLE9BQU87QUFDdkY7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw4RkFBOEYsMkJBQTJCO0FBQ3JNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnRlcm5hbENoYW5uZWwgPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgcmVzb2x2aW5nX2xvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmluZy1sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9wb29sXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLXBvb2xcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZmlsdGVyX3N0YWNrXzEgPSByZXF1aXJlKFwiLi9maWx0ZXItc3RhY2tcIik7XG5jb25zdCBjb21wcmVzc2lvbl9maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWZpbHRlclwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgbG9hZF9iYWxhbmNpbmdfY2FsbF8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNpbmctY2FsbFwiKTtcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcbmNvbnN0IHJlc29sdmluZ19jYWxsXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctY2FsbFwiKTtcbmNvbnN0IGNhbGxfbnVtYmVyXzEgPSByZXF1aXJlKFwiLi9jYWxsLW51bWJlclwiKTtcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcbmNvbnN0IHJldHJ5aW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3JldHJ5aW5nLWNhbGxcIik7XG5jb25zdCBzdWJjaGFubmVsX2ludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1pbnRlcmZhY2VcIik7XG4vKipcbiAqIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL3RpbWVycy5odG1sI3RpbWVyc19zZXRpbnRlcnZhbF9jYWxsYmFja19kZWxheV9hcmdzXG4gKi9cbmNvbnN0IE1BWF9USU1FT1VUX1RJTUUgPSAyMTQ3NDgzNjQ3O1xuY29uc3QgTUlOX0lETEVfVElNRU9VVF9NUyA9IDEwMDA7XG4vLyAzMCBtaW51dGVzXG5jb25zdCBERUZBVUxUX0lETEVfVElNRU9VVF9NUyA9IDMwICogNjAgKiAxMDAwO1xuY29uc3QgUkVUUllfVEhST1RUTEVSX01BUCA9IG5ldyBNYXAoKTtcbmNvbnN0IERFRkFVTFRfUkVUUllfQlVGRkVSX1NJWkVfQllURVMgPSAxIDw8IDI0OyAvLyAxNiBNQlxuY29uc3QgREVGQVVMVF9QRVJfUlBDX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTID0gMSA8PCAyMDsgLy8gMSBNQlxuY2xhc3MgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyIGV4dGVuZHMgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgY2hhbm5lbCkge1xuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lciA9IChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSkgPT4ge1xuICAgICAgICAgICAgY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZShrZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2hpbGRTdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCArPSAxO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5yZW1vdmVXcmFwcGVkU3ViY2hhbm5lbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIEludGVybmFsQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxzIHF1ZXVlZCB1cCB0byBnZXQgYSBjYWxsIGNvbmZpZy4gU2hvdWxkIG9ubHkgYmUgcG9wdWxhdGVkIGJlZm9yZSB0aGVcbiAgICAgICAgICogZmlyc3QgdGltZSB0aGUgcmVzb2x2ZXIgcmV0dXJucyBhIHJlc3VsdCwgd2hpY2ggaW5jbHVkZXMgdGhlIENvbmZpZ1NlbGVjdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBlcnJvciBmcm9tIHRoZSBuYW1lIHJlc29sdmVyIGlmIGl0IGZhaWxlZCBtb3N0IHJlY2VudGx5LiBJdFxuICAgICAgICAgKiBpcyBvbmx5IHVzZWQgdG8gZW5kIGNhbGxzIHRoYXQgc3RhcnQgd2hpbGUgdGhlcmUgaXMgbm8gY29uZmlnIHNlbGVjdG9yXG4gICAgICAgICAqIGFuZCB0aGUgbmFtZSByZXNvbHZlciBpcyBpbiBiYWNrb2ZmLCBzbyBpdCBzaG91bGQgYmUgbnVsbGVkIGlmXG4gICAgICAgICAqIGNvbmZpZ1NlbGVjdG9yIGJlY29tZXMgc2V0IG9yIHRoZSBjaGFubmVsIHN0YXRlIGJlY29tZXMgYW55dGhpbmcgb3RoZXJcbiAgICAgICAgICogdGhhbiBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmNhbGxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcbiAgICAgICAgLy8gQ2hhbm5lbHogaW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIHRhcmdldCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoY3JlZGVudGlhbHMgaW5zdGFuY2VvZiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBjcmVkZW50aWFscyBtdXN0IGJlIGEgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnaW5hbFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUYXJnZXRVcmkgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKSh0YXJnZXQpO1xuICAgICAgICBpZiAob3JpZ2luYWxUYXJnZXRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHNjaGVtZSB0aGF0IGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGVcbiAgICAgICAgICogcmVzb2x2ZXIgKi9cbiAgICAgICAgY29uc3QgZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9ICgwLCByZXNvbHZlcl8xLm1hcFVyaURlZmF1bHRTY2hlbWUpKG9yaWdpbmFsVGFyZ2V0VXJpKTtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYSBkZWZhdWx0IHNjaGVtZSBmb3IgdGFyZ2V0IG5hbWUgXCIke3RhcmdldH1cImApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCBNQVhfVElNRU9VVF9USU1FKTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsUmVmVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNoYW5uZWx6UmVmID0gKDAsIGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwpKHRhcmdldCwgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDaGFubmVsIGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmRlZmF1bHRfYXV0aG9yaXR5J10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eSA9IHRoaXMub3B0aW9uc1snZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveHlNYXBSZXN1bHQgPSAoMCwgaHR0cF9wcm94eV8xLm1hcFByb3h5TmFtZSkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gcHJveHlNYXBSZXN1bHQudGFyZ2V0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHByb3h5TWFwUmVzdWx0LmV4dHJhT3B0aW9ucyk7XG4gICAgICAgIC8qIFRoZSBnbG9iYWwgYm9vbGVhbiBwYXJhbWV0ZXIgdG8gZ2V0U3ViY2hhbm5lbFBvb2wgaGFzIHRoZSBpbnZlcnNlIG1lYW5pbmcgdG8gd2hhdFxuICAgICAgICAgKiB0aGUgZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sIGNoYW5uZWwgb3B0aW9uIG1lYW5zLiAqL1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sID0gKDAsIHN1YmNoYW5uZWxfcG9vbF8xLmdldFN1YmNoYW5uZWxQb29sKSgoKF9jID0gb3B0aW9uc1snZ3JwYy51c2VfbG9jYWxfc3ViY2hhbm5lbF9wb29sJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDApID09PSAwKTtcbiAgICAgICAgdGhpcy5yZXRyeUJ1ZmZlclRyYWNrZXIgPSBuZXcgcmV0cnlpbmdfY2FsbF8xLk1lc3NhZ2VCdWZmZXJUcmFja2VyKChfZCA9IG9wdGlvbnNbJ2dycGMucmV0cnlfYnVmZmVyX3NpemUnXSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogREVGQVVMVF9SRVRSWV9CVUZGRVJfU0laRV9CWVRFUywgKF9lID0gb3B0aW9uc1snZ3JwYy5wZXJfcnBjX3JldHJ5X2J1ZmZlcl9zaXplJ10pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IERFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IChfZiA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogLTE7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXRNcyA9IE1hdGgubWF4KChfZyA9IG9wdGlvbnNbJ2dycGMuY2xpZW50X2lkbGVfdGltZW91dF9tcyddKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBERUZBVUxUX0lETEVfVElNRU9VVF9NUywgTUlOX0lETEVfVElNRU9VVF9NUyk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxDb250cm9sSGVscGVyID0ge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSB0aGlzLnN1YmNoYW5uZWxQb29sLmdldE9yQ3JlYXRlU3ViY2hhbm5lbCh0aGlzLnRhcmdldCwgc3ViY2hhbm5lbEFkZHJlc3MsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucywgc3ViY2hhbm5lbEFyZ3MpLCB0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKHRoaXMua2VlcGFsaXZlVGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDcmVhdGVkIHN1YmNoYW5uZWwgb3IgdXNlZCBleGlzdGluZyBzdWJjaGFubmVsJywgc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgPSBuZXcgQ2hhbm5lbFN1YmNoYW5uZWxXcmFwcGVyKHN1YmNoYW5uZWwsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzLmFkZCh3cmFwcGVkU3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRTdWJjaGFubmVsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZUNvcHkgPSB0aGlzLnBpY2tRdWV1ZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1F1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlQ29weS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHF1ZXVlQ29weSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmRvUGljaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb2x2aW5nIGxvYWQgYmFsYW5jZXIgc2hvdWxkIG5ldmVyIGNhbGwgcmVxdWVzdFJlcmVzb2x1dGlvbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlciA9IG5ldyByZXNvbHZpbmdfbG9hZF9iYWxhbmNlcl8xLlJlc29sdmluZ0xvYWRCYWxhbmNlcih0aGlzLnRhcmdldCwgY2hhbm5lbENvbnRyb2xIZWxwZXIsIG9wdGlvbnMsIChzZXJ2aWNlQ29uZmlnLCBjb25maWdTZWxlY3RvcikgPT4ge1xuICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWcucmV0cnlUaHJvdHRsaW5nKSB7XG4gICAgICAgICAgICAgICAgUkVUUllfVEhST1RUTEVSX01BUC5zZXQodGhpcy5nZXRUYXJnZXQoKSwgbmV3IHJldHJ5aW5nX2NhbGxfMS5SZXRyeVRocm90dGxlcihzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZy5tYXhUb2tlbnMsIHNlcnZpY2VDb25maWcucmV0cnlUaHJvdHRsaW5nLnRva2VuUmF0aW8sIFJFVFJZX1RIUk9UVExFUl9NQVAuZ2V0KHRoaXMuZ2V0VGFyZ2V0KCkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBSRVRSWV9USFJPVFRMRVJfTUFQLmRlbGV0ZSh0aGlzLmdldFRhcmdldCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdBZGRyZXNzIHJlc29sdXRpb24gc3VjY2VlZGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdG9yID0gY29uZmlnU2VsZWN0b3I7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgLyogV2UgcHJvY2VzcyB0aGUgcXVldWUgYXN5bmNocm9ub3VzbHkgdG8gZW5zdXJlIHRoYXQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAgICAgICAgICAqIGxvYWQgYmFsYW5jZXIgdXBkYXRlIGhhcyBjb21wbGV0ZWQuICovXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFF1ZXVlID0gdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBsb2NhbFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwuZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIHN0YXR1cyA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX1dBUk5JTkcnLCAnQWRkcmVzcyByZXNvbHV0aW9uIGZhaWxlZCB3aXRoIGNvZGUgJyArXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5jb2RlICtcbiAgICAgICAgICAgICAgICAgICAgJyBhbmQgZGV0YWlscyBcIicgK1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ05hbWUgcmVzb2x1dGlvbiBmYWlsZWQgd2l0aCBjYWxscyBxdWV1ZWQgZm9yIGNvbmZpZyBzZWxlY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscykpLCB7IG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFF1ZXVlID0gdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgICAgIGlmIChsb2NhbFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGNhbGwucmVwb3J0UmVzb2x2ZXJFcnJvcihzdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkgPSBuZXcgZmlsdGVyX3N0YWNrXzEuRmlsdGVyU3RhY2tGYWN0b3J5KFtcbiAgICAgICAgICAgIG5ldyBjb21wcmVzc2lvbl9maWx0ZXJfMS5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkodGhpcywgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMudHJhY2UoJ0NoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgdW5kZWZpbmVkLCAyKSk7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWxfc3RhY2t0cmFjZScsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgJ0NoYW5uZWwgY29uc3RydWN0ZWQgXFxuJyArXG4gICAgICAgICAgICAoKF9oID0gZXJyb3Iuc3RhY2spID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5zdWJzdHJpbmcoZXJyb3Iuc3RhY2suaW5kZXhPZignXFxuJykgKyAxKSkpO1xuICAgICAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGdldENoYW5uZWx6SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5vcmlnaW5hbFRhcmdldCxcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlLFxuICAgICAgICAgICAgdHJhY2U6IHRoaXMuY2hhbm5lbHpUcmFjZSxcbiAgICAgICAgICAgIGNhbGxUcmFja2VyOiB0aGlzLmNhbGxUcmFja2VyLFxuICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMuY2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCwgdmVyYm9zaXR5T3ZlcnJpZGUpIHtcbiAgICAgICAgKDAsIGxvZ2dpbmdfMS50cmFjZSkodmVyYm9zaXR5T3ZlcnJpZGUgIT09IG51bGwgJiYgdmVyYm9zaXR5T3ZlcnJpZGUgIT09IHZvaWQgMCA/IHZlcmJvc2l0eU92ZXJyaWRlIDogY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnY2hhbm5lbCcsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGNhbGxSZWZUaW1lclJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAvLyBJZiB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXG4gICAgICAgIGlmICghKChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS5oYXNSZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NhbGxSZWZUaW1lci5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYWxsUmVmVGltZXIpLnJlZikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxSZWZUaW1lclVucmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBJZiB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXG4gICAgICAgIGlmICghdGhpcy5jYWxsUmVmVGltZXIuaGFzUmVmIHx8IHRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZigpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIudW5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsUmVmVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyKHdhdGNoZXJPYmplY3QpIHtcbiAgICAgICAgY29uc3Qgd2F0Y2hlckluZGV4ID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLmZpbmRJbmRleCh2YWx1ZSA9PiB2YWx1ZSA9PT0gd2F0Y2hlck9iamVjdCk7XG4gICAgICAgIGlmICh3YXRjaGVySW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnNwbGljZSh3YXRjaGVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2Nvbm5lY3Rpdml0eV9zdGF0ZScsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZSB0byAnICsgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGNvbnN0IHdhdGNoZXJzQ29weSA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHdhdGNoZXJPYmplY3Qgb2Ygd2F0Y2hlcnNDb3B5KSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IHdhdGNoZXJPYmplY3QuY3VycmVudFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhdGNoZXJPYmplY3QudGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdhdGNoZXJPYmplY3QudGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB3YXRjaGVyT2JqZWN0LmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKSB7XG4gICAgICAgIGlmIChuZXdLZWVwYWxpdmVUaW1lID4gdGhpcy5rZWVwYWxpdmVUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgPSBuZXdLZWVwYWxpdmVUaW1lO1xuICAgICAgICAgICAgZm9yIChjb25zdCB3cmFwcGVkU3ViY2hhbm5lbCBvZiB0aGlzLndyYXBwZWRTdWJjaGFubmVscykge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRTdWJjaGFubmVsLnRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZVdyYXBwZWRTdWJjaGFubmVsKHdyYXBwZWRTdWJjaGFubmVsKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZFN1YmNoYW5uZWxzLmRlbGV0ZSh3cmFwcGVkU3ViY2hhbm5lbCk7XG4gICAgfVxuICAgIGRvUGljayhtZXRhZGF0YSwgZXh0cmFQaWNrSW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGlja2VyLnBpY2soe1xuICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgZXh0cmFQaWNrSW5mbzogZXh0cmFQaWNrSW5mbyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1ZXVlQ2FsbEZvclBpY2soY2FsbCkge1xuICAgICAgICB0aGlzLnBpY2tRdWV1ZS5wdXNoKGNhbGwpO1xuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xuICAgIH1cbiAgICBnZXRDb25maWcobWV0aG9kLCBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnU1VDQ0VTUycsXG4gICAgICAgICAgICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZ1NlbGVjdG9yKG1ldGhvZCwgbWV0YWRhdGEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRVJST1InLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTk9ORScsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZUNhbGxGb3JDb25maWcoY2FsbCkge1xuICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLnB1c2goY2FsbCk7XG4gICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyUmVmKCk7XG4gICAgfVxuICAgIGVudGVySWRsZSgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIpO1xuICAgICAgICBpZiAodGhpcy5pZGxlVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRJZGxlVGltZW91dCh0aW1lb3V0TXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGVyZSBpcyBjdXJyZW50bHkgYSBjYWxsLCB0aGUgY2hhbm5lbCB3aWxsIG5vdCBnbyBpZGxlIGZvciBhXG4gICAgICAgICAgICAgICAgICogcGVyaW9kIG9mIGF0IGxlYXN0IGlkbGVUaW1lb3V0TXMsIHNvIGNoZWNrIGFnYWluIGFmdGVyIHRoYXQgdGltZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SWRsZVRpbWVvdXQodGhpcy5pZGxlVGltZW91dE1zKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgdGltZVNpbmNlTGFzdEFjdGl2aXR5ID0gbm93LnZhbHVlT2YoKSAtIHRoaXMubGFzdEFjdGl2aXR5VGltZXN0YW1wLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIGlmICh0aW1lU2luY2VMYXN0QWN0aXZpdHkgPj0gdGhpcy5pZGxlVGltZW91dE1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnSWRsZSB0aW1lciB0cmlnZ2VyZWQgYWZ0ZXIgJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVvdXRNcyArXG4gICAgICAgICAgICAgICAgICAgICdtcyBvZiBpbmFjdGl2aXR5Jyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRlcklkbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIFdoZW5ldmVyIHRoZSB0aW1lciBmaXJlcyB3aXRoIHRoZSBsYXRlc3QgYWN0aXZpdHkgYmVpbmcgdG9vIHJlY2VudCxcbiAgICAgICAgICAgICAgICAgKiBzZXQgdGhlIHRpbWVyIGFnYWluIGZvciB0aGUgdGltZSB3aGVuIHRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgICogYWN0aXZpdHkgaXMgZXF1YWwgdG8gdGhlIHRpbWVvdXQuIFRoaXMgc2hvdWxkIHJlc3VsdCBpbiB0aGUgdGltZXJcbiAgICAgICAgICAgICAgICAgKiBmaXJpbmcgbm8gbW9yZSB0aGFuIG9uY2UgZXZlcnkgaWRsZVRpbWVvdXRNcy8yIG9uIGF2ZXJhZ2UuICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydElkbGVUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRNcyAtIHRpbWVTaW5jZUxhc3RBY3Rpdml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXRNcyk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuaWRsZVRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbiAgICBtYXliZVN0YXJ0SWRsZVRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04gJiYgIXRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SWRsZVRpbWVvdXQodGhpcy5pZGxlVGltZW91dE1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkNhbGxTdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsQ291bnQgKz0gMTtcbiAgICB9XG4gICAgb25DYWxsRW5kKHN0YXR1cykge1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxDb3VudCAtPSAxO1xuICAgICAgICB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMubWF5YmVTdGFydElkbGVUaW1lcigpO1xuICAgIH1cbiAgICBjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsIFsnICsgY2FsbE51bWJlciArICddIG1ldGhvZD1cIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuIG5ldyBsb2FkX2JhbGFuY2luZ19jYWxsXzEuTG9hZEJhbGFuY2luZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIpO1xuICAgIH1cbiAgICBjcmVhdGVSZXRyeWluZ0NhbGwoY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUpIHtcbiAgICAgICAgY29uc3QgY2FsbE51bWJlciA9ICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXRyeWluZ0NhbGwgWycgKyBjYWxsTnVtYmVyICsgJ10gbWV0aG9kPVwiJyArIG1ldGhvZCArICdcIicpO1xuICAgICAgICByZXR1cm4gbmV3IHJldHJ5aW5nX2NhbGxfMS5SZXRyeWluZ0NhbGwodGhpcywgY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIsIHRoaXMucmV0cnlCdWZmZXJUcmFja2VyLCBSRVRSWV9USFJPVFRMRVJfTUFQLmdldCh0aGlzLmdldFRhcmdldCgpKSk7XG4gICAgfVxuICAgIGNyZWF0ZUlubmVyQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBSZXRyeWluZ0NhbGwgaWYgcmV0cmllcyBhcmUgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9yZXRyaWVzJ10gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJldHJ5aW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUmVzb2x2aW5nQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBjb25zdCBjYWxsTnVtYmVyID0gKDAsIGNhbGxfbnVtYmVyXzEuZ2V0TmV4dENhbGxOdW1iZXIpKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZVJlc29sdmluZ0NhbGwgWycgK1xuICAgICAgICAgICAgY2FsbE51bWJlciArXG4gICAgICAgICAgICAnXSBtZXRob2Q9XCInICtcbiAgICAgICAgICAgIG1ldGhvZCArXG4gICAgICAgICAgICAnXCIsIGRlYWRsaW5lPScgK1xuICAgICAgICAgICAgKDAsIGRlYWRsaW5lXzEuZGVhZGxpbmVUb1N0cmluZykoZGVhZGxpbmUpKTtcbiAgICAgICAgY29uc3QgZmluYWxPcHRpb25zID0ge1xuICAgICAgICAgICAgZGVhZGxpbmU6IGRlYWRsaW5lLFxuICAgICAgICAgICAgZmxhZ3M6IHByb3BhZ2F0ZUZsYWdzICE9PSBudWxsICYmIHByb3BhZ2F0ZUZsYWdzICE9PSB2b2lkIDAgPyBwcm9wYWdhdGVGbGFncyA6IGNvbnN0YW50c18xLlByb3BhZ2F0ZS5ERUZBVUxUUyxcbiAgICAgICAgICAgIGhvc3Q6IGhvc3QgIT09IG51bGwgJiYgaG9zdCAhPT0gdm9pZCAwID8gaG9zdCA6IHRoaXMuZGVmYXVsdEF1dGhvcml0eSxcbiAgICAgICAgICAgIHBhcmVudENhbGw6IHBhcmVudENhbGwsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgcmVzb2x2aW5nX2NhbGxfMS5SZXNvbHZpbmdDYWxsKHRoaXMsIG1ldGhvZCwgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5jbG9uZSgpLCB0aGlzLmNyZWRlbnRpYWxzLl9nZXRDYWxsQ3JlZGVudGlhbHMoKSwgY2FsbE51bWJlcik7XG4gICAgICAgIHRoaXMub25DYWxsU3RhcnQoKTtcbiAgICAgICAgY2FsbC5hZGRTdGF0dXNXYXRjaGVyKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZChzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FsbFJlZlRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnlUb0Nvbm5lY3QpIHtcbiAgICAgICAgY29uc3QgY29ubmVjdGl2aXR5U3RhdGUgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICBpZiAodHJ5VG9Db25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SWRsZVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgIH1cbiAgICB3YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGlmIChkZWFkbGluZSAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlYWRsaW5lRGF0ZSA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lIDogbmV3IERhdGUoZGVhZGxpbmUpO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGlmIChkZWFkbGluZSA9PT0gLUluZmluaXR5IHx8IGRlYWRsaW5lRGF0ZSA8PSBub3cpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrLCBuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0RlYWRsaW5lIHBhc3NlZCB3aXRob3V0IGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UnKSk7XG4gICAgICAgICAgICB9LCBkZWFkbGluZURhdGUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2F0Y2hlck9iamVjdCA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgdGltZXIsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5wdXNoKHdhdGNoZXJPYmplY3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNoYW5uZWx6IHJlZmVyZW5jZSBvYmplY3QgZm9yIHRoaXMgY2hhbm5lbC4gVGhlIHJldHVybmVkIHZhbHVlIGlzXG4gICAgICogZ2FyYmFnZSBpZiBjaGFubmVseiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjaGFubmVsLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHR5cGVvZiBkZWFkbGluZSA9PT0gJ251bWJlcicgfHwgZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCNjcmVhdGVDYWxsOiBkZWFkbGluZSBtdXN0IGJlIGEgbnVtYmVyIG9yIERhdGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBoYXMgYmVlbiBzaHV0IGRvd24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXNvbHZpbmdDYWxsKG1ldGhvZCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudENhbGwsIHByb3BhZ2F0ZUZsYWdzKTtcbiAgICB9XG59XG5leHBvcnRzLkludGVybmFsQ2hhbm5lbCA9IEludGVybmFsQ2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLWNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = 'child_load_balancer_helper';\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.latestConfig = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent) {\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                }\n                else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {\n        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param addressList\n     * @param lbConfig\n     * @param attributes\n     */\n    updateAddressList(addressList, lbConfig, attributes) {\n        let childToUpdate;\n        if (this.currentChild === null ||\n            this.latestConfig === null ||\n            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            }\n            else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        }\n        else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            }\n            else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        this.latestConfig = lbConfig;\n        childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        /* Note: state updates are only propagated from the child balancer if that\n         * object is equal to this.currentChild or this.pendingChild. Since this\n         * function sets both of those to null, no further state updates will\n         * occur after this function returns. */\n        if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;\n//# sourceMappingURL=load-balancer-child-handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgVFlQRV9OQU1FID0gJ2NoaWxkX2xvYWRfYmFsYW5jZXJfaGVscGVyJztcbmNsYXNzIENoaWxkTG9hZEJhbGFuY2VySGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLkNoaWxkUG9saWN5SGVscGVyID0gY2xhc3Mge1xuICAgICAgICAgICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQgPSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNhbGxlZEJ5Q3VycmVudENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdENoaWxkID0gKF9hID0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGQgPT09IGxhdGVzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRDaGlsZChuZXdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZEJ5UGVuZGluZ0NoaWxkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkID09PSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWRCeUN1cnJlbnRDaGlsZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25maWdVcGRhdGVSZXF1aXJlc05ld1BvbGljeUluc3RhbmNlKG9sZENvbmZpZywgbmV3Q29uZmlnKSB7XG4gICAgICAgIHJldHVybiBvbGRDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpICE9PSBuZXdDb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVyZXF1aXNpdGVzOiBsYkNvbmZpZyAhPT0gbnVsbCBhbmQgbGJDb25maWcubmFtZSBpcyByZWdpc3RlcmVkXG4gICAgICogQHBhcmFtIGFkZHJlc3NMaXN0XG4gICAgICogQHBhcmFtIGxiQ29uZmlnXG4gICAgICogQHBhcmFtIGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgbGV0IGNoaWxkVG9VcGRhdGU7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnVXBkYXRlUmVxdWlyZXNOZXdQb2xpY3lJbnN0YW5jZSh0aGlzLmxhdGVzdENvbmZpZywgbGJDb25maWcpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdIZWxwZXIgPSBuZXcgdGhpcy5DaGlsZFBvbGljeUhlbHBlcih0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoaWxkID0gKDAsIGxvYWRfYmFsYW5jZXJfMS5jcmVhdGVMb2FkQmFsYW5jZXIpKGxiQ29uZmlnLCBuZXdIZWxwZXIpO1xuICAgICAgICAgICAgbmV3SGVscGVyLnNldENoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICAgICAgY2hpbGRUb1VwZGF0ZS51cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5leGl0SWRsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQucmVzZXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5yZXNldEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvKiBOb3RlOiBzdGF0ZSB1cGRhdGVzIGFyZSBvbmx5IHByb3BhZ2F0ZWQgZnJvbSB0aGUgY2hpbGQgYmFsYW5jZXIgaWYgdGhhdFxuICAgICAgICAgKiBvYmplY3QgaXMgZXF1YWwgdG8gdGhpcy5jdXJyZW50Q2hpbGQgb3IgdGhpcy5wZW5kaW5nQ2hpbGQuIFNpbmNlIHRoaXNcbiAgICAgICAgICogZnVuY3Rpb24gc2V0cyBib3RoIG9mIHRob3NlIHRvIG51bGwsIG5vIGZ1cnRoZXIgc3RhdGUgdXBkYXRlcyB3aWxsXG4gICAgICAgICAqIG9jY3VyIGFmdGVyIHRoaXMgZnVuY3Rpb24gcmV0dXJucy4gKi9cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIgPSBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'outlier_detection';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100,\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50,\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj) {\n        if (!(0, duration_1.isDuration)(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 &&\n            obj[fieldName].seconds <= 315576000000 &&\n            obj[fieldName].nanos >= 0 &&\n            obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, 'number', objectName);\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n        this.childPolicy = childPolicy;\n        if (childPolicy.length > 0 &&\n            childPolicy[0].getLoadBalancerName() === 'pick_first') {\n            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');\n        }\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection\n            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection\n            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            interval: (0, duration_1.msToDuration)(this.intervalMs),\n            base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\n            max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\n            max_ejection_percent: this.maxEjectionPercent,\n            success_rate_ejection: this.successRateEjection,\n            failure_percentage_ejection: this.failurePercentageEjection,\n            child_policy: this.childPolicy.map(policy => policy.toJsonObject()),\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    copyWithChildPolicy(childPolicy) {\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, 'interval');\n        validatePositiveDuration(obj, 'base_ejection_time');\n        validatePositiveDuration(obj, 'max_ejection_time');\n        validatePercentage(obj, 'max_ejection_percent');\n        if ('success_rate_ejection' in obj) {\n            if (typeof obj.success_rate_ejection !== 'object') {\n                throw new Error('outlier detection config success_rate_ejection must be an object');\n            }\n            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n        }\n        if ('failure_percentage_ejection' in obj) {\n            if (typeof obj.failure_percentage_ejection !== 'object') {\n                throw new Error('outlier detection config failure_percentage_ejection must be an object');\n            }\n            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry) {\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.stateListeners = [];\n        this.ejected = false;\n        this.refCount = 0;\n        this.childSubchannelState = childSubchannel.getConnectivityState();\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState, keepaliveTime) => {\n            this.childSubchannelState = newState;\n            if (!this.ejected) {\n                for (const listener of this.stateListeners) {\n                    listener(this, previousState, newState, keepaliveTime);\n                }\n            }\n        });\n    }\n    getConnectivityState() {\n        if (this.ejected) {\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n        }\n        else {\n            return this.childSubchannelState;\n        }\n    }\n    /**\n     * Add a listener function to be called whenever the wrapper's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.ejected = true;\n        for (const listener of this.stateListeners) {\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, -1);\n        }\n    }\n    uneject() {\n        this.ejected = false;\n        for (const listener of this.stateListeners) {\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState, -1);\n        }\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0,\n    };\n}\nclass CallCounter {\n    constructor() {\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls) {\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                let onCallEnded = wrappedPick.onCallEnded;\n                if (this.countCalls) {\n                    onCallEnded = statusCode => {\n                        var _a;\n                        if (statusCode === constants_1.Status.OK) {\n                            mapEntry.counter.addSuccess();\n                        }\n                        else {\n                            mapEntry.counter.addFailure();\n                        }\n                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);\n                    };\n                }\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });\n            }\n            else {\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });\n            }\n        }\n        else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper) {\n        this.addressMap = new Map();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.addressMap.get((0, subchannel_address_1.subchannelAddressToString)(subchannelAddress));\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker) => {\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n                }\n                else {\n                    channelControlHelper.updateState(connectivityState, picker);\n                }\n            },\n        }));\n        this.ejectionTimer = setInterval(() => { }, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return (this.latestConfig !== null &&\n            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||\n                this.latestConfig.getFailurePercentageEjectionConfig() !== null));\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.addressMap.values()) {\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return (ejectionCount * 100) / this.addressMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace('Running success rate check');\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const [address, mapEntry] of this.addressMap) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace('Stats for ' +\n                address +\n                ': successes=' +\n                successes +\n                ' failures=' +\n                failures +\n                ' targetRequestVolume=' +\n                targetRequestVolume);\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace('Found ' +\n            addresesWithTargetVolume +\n            ' success rate candidates; currentEjectionPercent=' +\n            this.getCurrentEjectionPercent() +\n            ' successRates=[' +\n            successRates +\n            ']');\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates) {\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean -\n            successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >=\n                this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace('Checking candidate ' + address + ' successRate=' + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' +\n                    address +\n                    ' randomNumber=' +\n                    randomNumber +\n                    ' enforcement_percentage=' +\n                    successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace('Running failure percentage check. threshold=' +\n            failurePercentageConfig.threshold +\n            ' request volume threshold=' +\n            failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.addressMap.values()) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >=\n                this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace('Candidate successes=' + successes + ' failures=' + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = (failures * 100) / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' +\n                    address +\n                    ' randomNumber=' +\n                    randomNumber +\n                    ' enforcement_percentage=' +\n                    failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.addressMap.values()) {\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        var _a, _b;\n        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace('Ejection timer running');\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            }\n            else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() +\n                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace('Unejecting ' + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(addressList, lbConfig, attributes) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        const subchannelAddresses = new Set();\n        for (const address of addressList) {\n            subchannelAddresses.add((0, subchannel_address_1.subchannelAddressToString)(address));\n        }\n        for (const address of subchannelAddresses) {\n            if (!this.addressMap.has(address)) {\n                trace('Adding map entry for ' + address);\n                this.addressMap.set(address, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: [],\n                });\n            }\n        }\n        for (const key of this.addressMap.keys()) {\n            if (!subchannelAddresses.has(key)) {\n                trace('Removing map entry for ' + key);\n                this.addressMap.delete(key);\n            }\n        }\n        const childPolicy = (0, load_balancer_1.getFirstUsableConfig)(lbConfig.getChildPolicy(), true);\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n        if (lbConfig.getSuccessRateEjectionConfig() ||\n            lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace('Previous timer existed. Replacing timer');\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() -\n                    (new Date().getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            }\n            else {\n                trace('Starting new timer');\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        }\n        else {\n            trace('Counting disabled. Cancelling timer.');\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.addressMap.values()) {\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-outlier-detection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsb0NBQW9DLEdBQUcsMkNBQTJDO0FBQ2xHLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQywrRkFBZ0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsaUdBQWlCO0FBQ2pELHNDQUFzQyxtQkFBTyxDQUFDLDZIQUErQjtBQUM3RSxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QsK0JBQStCLG1CQUFPLENBQUMsK0dBQXdCO0FBQy9ELGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsV0FBVyxHQUFHLFVBQVU7QUFDdEUsb0RBQW9ELGVBQWUsd0JBQXdCLGFBQWEsUUFBUSxzQkFBc0I7QUFDdEk7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVcsR0FBRyxVQUFVO0FBQ2xFO0FBQ0E7QUFDQSx3REFBd0QsZUFBZSxzQ0FBc0Msc0JBQXNCO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZUFBZTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXLEdBQUcsVUFBVTtBQUNsRTtBQUNBO0FBQ0Esb0RBQW9ELGVBQWU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQixnRkFBZ0Y7QUFDdko7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0Isc0RBQXNEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xudmFyIF9hO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IGV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZHVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL2R1cmF0aW9uXCIpO1xuY29uc3QgZXhwZXJpbWVudGFsXzEgPSByZXF1aXJlKFwiLi9leHBlcmltZW50YWxcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXJcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XG5jb25zdCBPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEID0gKChfYSA9IHByb2Nlc3MuZW52LkdSUENfRVhQRVJJTUVOVEFMX0VOQUJMRV9PVVRMSUVSX0RFVEVDVElPTikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RydWUnKSA9PT0gJ3RydWUnO1xuY29uc3QgZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcgPSB7XG4gICAgc3RkZXZfZmFjdG9yOiAxOTAwLFxuICAgIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U6IDEwMCxcbiAgICBtaW5pbXVtX2hvc3RzOiA1LFxuICAgIHJlcXVlc3Rfdm9sdW1lOiAxMDAsXG59O1xuY29uc3QgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcgPSB7XG4gICAgdGhyZXNob2xkOiA4NSxcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXG4gICAgbWluaW11bV9ob3N0czogNSxcbiAgICByZXF1ZXN0X3ZvbHVtZTogNTAsXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsIGV4cGVjdGVkVHlwZSwgb2JqZWN0TmFtZSkge1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqICYmIHR5cGVvZiBvYmpbZmllbGROYW1lXSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgJHtleHBlY3RlZFR5cGV9LCBnb3QgJHt0eXBlb2Ygb2JqW2ZpZWxkTmFtZV19YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgZmllbGROYW1lLCBvYmplY3ROYW1lKSB7XG4gICAgY29uc3QgZnVsbEZpZWxkTmFtZSA9IG9iamVjdE5hbWUgPyBgJHtvYmplY3ROYW1lfS4ke2ZpZWxkTmFtZX1gIDogZmllbGROYW1lO1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGlmICghKDAsIGR1cmF0aW9uXzEuaXNEdXJhdGlvbikob2JqW2ZpZWxkTmFtZV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiBleHBlY3RlZCBEdXJhdGlvbiwgZ290ICR7dHlwZW9mIG9ialtmaWVsZE5hbWVdfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPj0gMCAmJlxuICAgICAgICAgICAgb2JqW2ZpZWxkTmFtZV0uc2Vjb25kcyA8PSAzMTU1NzYwMDAwMDAgJiZcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLm5hbm9zID49IDAgJiZcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLm5hbm9zIDw9IDk5OTk5OTk5OSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IHZhbHVlcyBvdXQgb2YgcmFuZ2UgZm9yIG5vbi1uZWdhdGl2ZSBEdWFyYXRpb25gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUGVyY2VudGFnZShvYmosIGZpZWxkTmFtZSwgb2JqZWN0TmFtZSkge1xuICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcbiAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmosIGZpZWxkTmFtZSwgJ251bWJlcicsIG9iamVjdE5hbWUpO1xuICAgIGlmIChmaWVsZE5hbWUgaW4gb2JqICYmICEob2JqW2ZpZWxkTmFtZV0gPj0gMCAmJiBvYmpbZmllbGROYW1lXSA8PSAxMDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IHZhbHVlIG91dCBvZiByYW5nZSBmb3IgcGVyY2VudGFnZSAoMC0xMDApYCk7XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGludGVydmFsTXMsIGJhc2VFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uUGVyY2VudCwgc3VjY2Vzc1JhdGVFamVjdGlvbiwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiwgY2hpbGRQb2xpY3kpIHtcbiAgICAgICAgdGhpcy5jaGlsZFBvbGljeSA9IGNoaWxkUG9saWN5O1xuICAgICAgICBpZiAoY2hpbGRQb2xpY3kubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgY2hpbGRQb2xpY3lbMF0uZ2V0TG9hZEJhbGFuY2VyTmFtZSgpID09PSAncGlja19maXJzdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllcl9kZXRlY3Rpb24gTEIgcG9saWN5IGNhbm5vdCBoYXZlIGEgcGlja19maXJzdCBjaGlsZCBwb2xpY3knKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVydmFsTXMgPSBpbnRlcnZhbE1zICE9PSBudWxsICYmIGludGVydmFsTXMgIT09IHZvaWQgMCA/IGludGVydmFsTXMgOiAxMDAwMDtcbiAgICAgICAgdGhpcy5iYXNlRWplY3Rpb25UaW1lTXMgPSBiYXNlRWplY3Rpb25UaW1lTXMgIT09IG51bGwgJiYgYmFzZUVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBiYXNlRWplY3Rpb25UaW1lTXMgOiAzMDAwMDtcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblRpbWVNcyA9IG1heEVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIG1heEVqZWN0aW9uVGltZU1zICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblRpbWVNcyA6IDMwMDAwMDtcbiAgICAgICAgdGhpcy5tYXhFamVjdGlvblBlcmNlbnQgPSBtYXhFamVjdGlvblBlcmNlbnQgIT09IG51bGwgJiYgbWF4RWplY3Rpb25QZXJjZW50ICE9PSB2b2lkIDAgPyBtYXhFamVjdGlvblBlcmNlbnQgOiAxMDtcbiAgICAgICAgdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uID0gc3VjY2Vzc1JhdGVFamVjdGlvblxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKSwgc3VjY2Vzc1JhdGVFamVjdGlvbikgOiBudWxsO1xuICAgICAgICB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24gPSBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcpLCBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uKSA6IG51bGw7XG4gICAgfVxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVydmFsOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMuaW50ZXJ2YWxNcyksXG4gICAgICAgICAgICBiYXNlX2VqZWN0aW9uX3RpbWU6ICgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5iYXNlRWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgbWF4X2VqZWN0aW9uX3RpbWU6ICgwLCBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbikodGhpcy5tYXhFamVjdGlvblRpbWVNcyksXG4gICAgICAgICAgICBtYXhfZWplY3Rpb25fcGVyY2VudDogdGhpcy5tYXhFamVjdGlvblBlcmNlbnQsXG4gICAgICAgICAgICBzdWNjZXNzX3JhdGVfZWplY3Rpb246IHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbixcbiAgICAgICAgICAgIGZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbjogdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uLFxuICAgICAgICAgICAgY2hpbGRfcG9saWN5OiB0aGlzLmNoaWxkUG9saWN5Lm1hcChwb2xpY3kgPT4gcG9saWN5LnRvSnNvbk9iamVjdCgpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0SW50ZXJ2YWxNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJ2YWxNcztcbiAgICB9XG4gICAgZ2V0QmFzZUVqZWN0aW9uVGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlRWplY3Rpb25UaW1lTXM7XG4gICAgfVxuICAgIGdldE1heEVqZWN0aW9uVGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhFamVjdGlvblRpbWVNcztcbiAgICB9XG4gICAgZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhFamVjdGlvblBlcmNlbnQ7XG4gICAgfVxuICAgIGdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb247XG4gICAgfVxuICAgIGdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb247XG4gICAgfVxuICAgIGdldENoaWxkUG9saWN5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZFBvbGljeTtcbiAgICB9XG4gICAgY29weVdpdGhDaGlsZFBvbGljeShjaGlsZFBvbGljeSkge1xuICAgICAgICByZXR1cm4gbmV3IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKHRoaXMuaW50ZXJ2YWxNcywgdGhpcy5iYXNlRWplY3Rpb25UaW1lTXMsIHRoaXMubWF4RWplY3Rpb25UaW1lTXMsIHRoaXMubWF4RWplY3Rpb25QZXJjZW50LCB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb24sIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiwgY2hpbGRQb2xpY3kpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ2ludGVydmFsJyk7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdiYXNlX2VqZWN0aW9uX3RpbWUnKTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ21heF9lamVjdGlvbl90aW1lJyk7XG4gICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmosICdtYXhfZWplY3Rpb25fcGVyY2VudCcpO1xuICAgICAgICBpZiAoJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgc3VjY2Vzc19yYXRlX2VqZWN0aW9uIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnc3RkZXZfZmFjdG9yJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnZW5mb3JjZW1lbnRfcGVyY2VudGFnZScsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdtaW5pbXVtX2hvc3RzJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdyZXF1ZXN0X3ZvbHVtZScsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllciBkZXRlY3Rpb24gY29uZmlnIGZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICd0aHJlc2hvbGQnLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ2VuZm9yY2VtZW50X3BlcmNlbnRhZ2UnLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAnbWluaW11bV9ob3N0cycsICdudW1iZXInLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAncmVxdWVzdF92b2x1bWUnLCAnbnVtYmVyJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcob2JqLmludGVydmFsID8gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShvYmouaW50ZXJ2YWwpIDogbnVsbCwgb2JqLmJhc2VfZWplY3Rpb25fdGltZSA/ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9Ncykob2JqLmJhc2VfZWplY3Rpb25fdGltZSkgOiBudWxsLCBvYmoubWF4X2VqZWN0aW9uX3RpbWUgPyAoMCwgZHVyYXRpb25fMS5kdXJhdGlvblRvTXMpKG9iai5tYXhfZWplY3Rpb25fdGltZSkgOiBudWxsLCAoX2EgPSBvYmoubWF4X2VqZWN0aW9uX3BlcmNlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsIG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sIG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sIG9iai5jaGlsZF9wb2xpY3kubWFwKGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcpKTtcbiAgICB9XG59XG5leHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWc7XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIgZXh0ZW5kcyBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRTdWJjaGFubmVsLCBtYXBFbnRyeSkge1xuICAgICAgICBzdXBlcihjaGlsZFN1YmNoYW5uZWwpO1xuICAgICAgICB0aGlzLm1hcEVudHJ5ID0gbWFwRW50cnk7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5lamVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVmQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlID0gY2hpbGRTdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgIGNoaWxkU3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5lamVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHdyYXBwZXInc1xuICAgICAqIGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBBIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcGFzc2VkIHRvXG4gICAgICogICAgIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqL1xuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJJbmRleCA9IHRoaXMuc3RhdGVMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgIGlmIChsaXN0ZW5lckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCArPSAxO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgICAgICB0aGlzLnJlZkNvdW50IC09IDE7XG4gICAgICAgIGlmICh0aGlzLnJlZkNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5pbmRleE9mKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVqZWN0KCkge1xuICAgICAgICB0aGlzLmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5lamVjdCgpIHtcbiAgICAgICAgdGhpcy5lamVjdGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUsIC0xKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNYXBFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRW50cnk7XG4gICAgfVxuICAgIGdldFdyYXBwZWRTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUJ1Y2tldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiAwLFxuICAgICAgICBmYWlsdXJlOiAwLFxuICAgIH07XG59XG5jbGFzcyBDYWxsQ291bnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgfVxuICAgIGFkZFN1Y2Nlc3MoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LnN1Y2Nlc3MgKz0gMTtcbiAgICB9XG4gICAgYWRkRmFpbHVyZSgpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQuZmFpbHVyZSArPSAxO1xuICAgIH1cbiAgICBzd2l0Y2hCdWNrZXRzKCkge1xuICAgICAgICB0aGlzLmluYWN0aXZlQnVja2V0ID0gdGhpcy5hY3RpdmVCdWNrZXQ7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICB9XG4gICAgZ2V0TGFzdFN1Y2Nlc3NlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuc3VjY2VzcztcbiAgICB9XG4gICAgZ2V0TGFzdEZhaWx1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmFjdGl2ZUJ1Y2tldC5mYWlsdXJlO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHdyYXBwZWRQaWNrZXIsIGNvdW50Q2FsbHMpIHtcbiAgICAgICAgdGhpcy53cmFwcGVkUGlja2VyID0gd3JhcHBlZFBpY2tlcjtcbiAgICAgICAgdGhpcy5jb3VudENhbGxzID0gY291bnRDYWxscztcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCB3cmFwcGVkUGljayA9IHRoaXMud3JhcHBlZFBpY2tlci5waWNrKHBpY2tBcmdzKTtcbiAgICAgICAgaWYgKHdyYXBwZWRQaWNrLnBpY2tSZXN1bHRUeXBlID09PSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSB3cmFwcGVkUGljay5zdWJjaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgbWFwRW50cnkgPSBzdWJjaGFubmVsV3JhcHBlci5nZXRNYXBFbnRyeSgpO1xuICAgICAgICAgICAgaWYgKG1hcEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgbGV0IG9uQ2FsbEVuZGVkID0gd3JhcHBlZFBpY2sub25DYWxsRW5kZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRDYWxscykge1xuICAgICAgICAgICAgICAgICAgICBvbkNhbGxFbmRlZCA9IHN0YXR1c0NvZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuYWRkU3VjY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkuY291bnRlci5hZGRGYWlsdXJlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSB3cmFwcGVkUGljay5vbkNhbGxFbmRlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod3JhcHBlZFBpY2ssIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cmFwcGVkUGljayksIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbFdyYXBwZXIuZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSwgb25DYWxsRW5kZWQ6IG9uQ2FsbEVuZGVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlZFBpY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgICAgICB0aGlzLmFkZHJlc3NNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlciA9IG5ldyBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIoKDAsIGV4cGVyaW1lbnRhbF8xLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIpKGNoYW5uZWxDb250cm9sSGVscGVyLCB7XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdWJjaGFubmVsID0gY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcEVudHJ5ID0gdGhpcy5hZGRyZXNzTWFwLmdldCgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoc3ViY2hhbm5lbEFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsV3JhcHBlciA9IG5ldyBPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIob3JpZ2luYWxTdWJjaGFubmVsLCBtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKChtYXBFbnRyeSA9PT0gbnVsbCB8fCBtYXBFbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYWRkcmVzcyBpcyBlamVjdGVkLCBwcm9wYWdhdGUgdGhhdCB0byB0aGUgbmV3IHN1YmNoYW5uZWwgd3JhcHBlclxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci5lamVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBFbnRyeSA9PT0gbnVsbCB8fCBtYXBFbnRyeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzLnB1c2goc3ViY2hhbm5lbFdyYXBwZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWJjaGFubmVsV3JhcHBlcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZTogKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBuZXcgT3V0bGllckRldGVjdGlvblBpY2tlcihwaWNrZXIsIHRoaXMuaXNDb3VudGluZ0VuYWJsZWQoKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVqZWN0aW9uVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgfVxuICAgIGlzQ291bnRpbmdFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubGF0ZXN0Q29uZmlnICE9PSBudWxsICYmXG4gICAgICAgICAgICAodGhpcy5sYXRlc3RDb25maWcuZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpICE9PSBudWxsKSk7XG4gICAgfVxuICAgIGdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSB7XG4gICAgICAgIGxldCBlamVjdGlvbkNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlamVjdGlvbkNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChlamVjdGlvbkNvdW50ICogMTAwKSAvIHRoaXMuYWRkcmVzc01hcC5zaXplO1xuICAgIH1cbiAgICBydW5TdWNjZXNzUmF0ZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKTtcbiAgICAgICAgaWYgKCFzdWNjZXNzUmF0ZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIHN1Y2Nlc3MgcmF0ZSBjaGVjaycpO1xuICAgICAgICAvLyBTdGVwIDFcbiAgICAgICAgY29uc3QgdGFyZ2V0UmVxdWVzdFZvbHVtZSA9IHN1Y2Nlc3NSYXRlQ29uZmlnLnJlcXVlc3Rfdm9sdW1lO1xuICAgICAgICBsZXQgYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lID0gMDtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdFN1Y2Nlc3NlcygpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RGYWlsdXJlcygpO1xuICAgICAgICAgICAgdHJhY2UoJ1N0YXRzIGZvciAnICtcbiAgICAgICAgICAgICAgICBhZGRyZXNzICtcbiAgICAgICAgICAgICAgICAnOiBzdWNjZXNzZXM9JyArXG4gICAgICAgICAgICAgICAgc3VjY2Vzc2VzICtcbiAgICAgICAgICAgICAgICAnIGZhaWx1cmVzPScgK1xuICAgICAgICAgICAgICAgIGZhaWx1cmVzICtcbiAgICAgICAgICAgICAgICAnIHRhcmdldFJlcXVlc3RWb2x1bWU9JyArXG4gICAgICAgICAgICAgICAgdGFyZ2V0UmVxdWVzdFZvbHVtZSk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gdGFyZ2V0UmVxdWVzdFZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSArPSAxO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcy5wdXNoKHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdGb3VuZCAnICtcbiAgICAgICAgICAgIGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSArXG4gICAgICAgICAgICAnIHN1Y2Nlc3MgcmF0ZSBjYW5kaWRhdGVzOyBjdXJyZW50RWplY3Rpb25QZXJjZW50PScgK1xuICAgICAgICAgICAgdGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgK1xuICAgICAgICAgICAgJyBzdWNjZXNzUmF0ZXM9WycgK1xuICAgICAgICAgICAgc3VjY2Vzc1JhdGVzICtcbiAgICAgICAgICAgICddJyk7XG4gICAgICAgIGlmIChhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgPCBzdWNjZXNzUmF0ZUNvbmZpZy5taW5pbXVtX2hvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlTWVhbiA9IHN1Y2Nlc3NSYXRlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XG4gICAgICAgIGxldCBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcmF0ZSBvZiBzdWNjZXNzUmF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRldmlhdGlvbiA9IHJhdGUgLSBzdWNjZXNzUmF0ZU1lYW47XG4gICAgICAgICAgICBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSArPSBkZXZpYXRpb24gKiBkZXZpYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVWYXJpYW5jZSA9IHN1Y2Nlc3NSYXRlRGV2aWF0aW9uU3VtIC8gc3VjY2Vzc1JhdGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVTdGRldiA9IE1hdGguc3FydChzdWNjZXNzUmF0ZVZhcmlhbmNlKTtcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaHJlc2hvbGQgPSBzdWNjZXNzUmF0ZU1lYW4gLVxuICAgICAgICAgICAgc3VjY2Vzc1JhdGVTdGRldiAqIChzdWNjZXNzUmF0ZUNvbmZpZy5zdGRldl9mYWN0b3IgLyAxMDAwKTtcbiAgICAgICAgdHJhY2UoJ3N0ZGV2PScgKyBzdWNjZXNzUmF0ZVN0ZGV2ICsgJyBlamVjdGlvblRocmVzaG9sZD0nICsgZWplY3Rpb25UaHJlc2hvbGQpO1xuICAgICAgICAvLyBTdGVwIDNcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuYWRkcmVzc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMy5pXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgPj1cbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblBlcmNlbnQoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAzLmlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA8IHRhcmdldFJlcXVlc3RWb2x1bWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMy5paWlcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlID0gc3VjY2Vzc2VzIC8gKHN1Y2Nlc3NlcyArIGZhaWx1cmVzKTtcbiAgICAgICAgICAgIHRyYWNlKCdDaGVja2luZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MgKyAnIHN1Y2Nlc3NSYXRlPScgKyBzdWNjZXNzUmF0ZSk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc1JhdGUgPCBlamVjdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0NhbmRpZGF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyArXG4gICAgICAgICAgICAgICAgICAgICcgcmFuZG9tTnVtYmVyPScgK1xuICAgICAgICAgICAgICAgICAgICByYW5kb21OdW1iZXIgK1xuICAgICAgICAgICAgICAgICAgICAnIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NSYXRlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5kb21OdW1iZXIgPCBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdFamVjdGluZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bkZhaWx1cmVQZXJjZW50YWdlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpO1xuICAgICAgICBpZiAoIWZhaWx1cmVQZXJjZW50YWdlQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ1J1bm5pbmcgZmFpbHVyZSBwZXJjZW50YWdlIGNoZWNrLiB0aHJlc2hvbGQ9JyArXG4gICAgICAgICAgICBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy50aHJlc2hvbGQgK1xuICAgICAgICAgICAgJyByZXF1ZXN0IHZvbHVtZSB0aHJlc2hvbGQ9JyArXG4gICAgICAgICAgICBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSk7XG4gICAgICAgIC8vIFN0ZXAgMVxuICAgICAgICBsZXQgYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA+PSBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSA8IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLm1pbmltdW1faG9zdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDJcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuYWRkcmVzc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMi5pXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgPj1cbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblBlcmNlbnQoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAyLmlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgc3VjY2Vzc2VzPScgKyBzdWNjZXNzZXMgKyAnIGZhaWx1cmVzPScgKyBmYWlsdXJlcyk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAyLmlpaVxuICAgICAgICAgICAgY29uc3QgZmFpbHVyZVBlcmNlbnRhZ2UgPSAoZmFpbHVyZXMgKiAxMDApIC8gKGZhaWx1cmVzICsgc3VjY2Vzc2VzKTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlUGVyY2VudGFnZSA+IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0NhbmRpZGF0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyArXG4gICAgICAgICAgICAgICAgICAgICcgcmFuZG9tTnVtYmVyPScgK1xuICAgICAgICAgICAgICAgICAgICByYW5kb21OdW1iZXIgK1xuICAgICAgICAgICAgICAgICAgICAnIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5kb21OdW1iZXIgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdFamVjdGluZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyICs9IDE7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci5lamVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuZWplY3QobWFwRW50cnkpIHtcbiAgICAgICAgbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsV3JhcHBlciBvZiBtYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxXcmFwcGVyLnVuZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2hBbGxCdWNrZXRzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbWFwRW50cnkuY291bnRlci5zd2l0Y2hCdWNrZXRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRUaW1lcihkZWxheU1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuZWplY3Rpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5ydW5DaGVja3MoKSwgZGVsYXlNcyk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuZWplY3Rpb25UaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgcnVuQ2hlY2tzKCkge1xuICAgICAgICBjb25zdCBlamVjdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRyYWNlKCdFamVjdGlvbiB0aW1lciBydW5uaW5nJyk7XG4gICAgICAgIHRoaXMuc3dpdGNoQWxsQnVja2V0cygpO1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IGVqZWN0aW9uVGltZXN0YW1wO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZXIodGhpcy5sYXRlc3RDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcbiAgICAgICAgdGhpcy5ydW5TdWNjZXNzUmF0ZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKTtcbiAgICAgICAgdGhpcy5ydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKTtcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuYWRkcmVzc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEJhc2VFamVjdGlvblRpbWVNcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heEVqZWN0aW9uVGltZU1zID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25UaW1lTXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXR1cm5UaW1lID0gbmV3IERhdGUobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuVGltZS5zZXRNaWxsaXNlY29uZHMocmV0dXJuVGltZS5nZXRNaWxsaXNlY29uZHMoKSArXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGJhc2VFamVjdGlvblRpbWVNcyAqIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIsIE1hdGgubWF4KGJhc2VFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25UaW1lTXMpKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblRpbWUgPCBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdVbmVqZWN0aW5nICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmVqZWN0KG1hcEVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICghKGxiQ29uZmlnIGluc3RhbmNlb2YgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbEFkZHJlc3NlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIGFkZHJlc3NMaXN0KSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsQWRkcmVzc2VzLmFkZCgoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBzdWJjaGFubmVsQWRkcmVzc2VzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWRkcmVzc01hcC5oYXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnQWRkaW5nIG1hcCBlbnRyeSBmb3IgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkcmVzc01hcC5zZXQoYWRkcmVzcywge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyOiBuZXcgQ2FsbENvdW50ZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVqZWN0aW9uVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlamVjdGlvblRpbWVNdWx0aXBsaWVyOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlcnM6IFtdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuYWRkcmVzc01hcC5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmICghc3ViY2hhbm5lbEFkZHJlc3Nlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZW1vdmluZyBtYXAgZW50cnkgZm9yICcgKyBrZXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkcmVzc01hcC5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZFBvbGljeSA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWcpKGxiQ29uZmlnLmdldENoaWxkUG9saWN5KCksIHRydWUpO1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGNoaWxkUG9saWN5LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGxiQ29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSB8fFxuICAgICAgICAgICAgbGJDb25maWcuZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lclN0YXJ0VGltZSkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdQcmV2aW91cyB0aW1lciBleGlzdGVkLiBSZXBsYWNpbmcgdGltZXInKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdEZWxheSA9IGxiQ29uZmlnLmdldEludGVydmFsTXMoKSAtXG4gICAgICAgICAgICAgICAgICAgIChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMudGltZXJTdGFydFRpbWUuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIocmVtYWluaW5nRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1N0YXJ0aW5nIG5ldyB0aW1lcicpO1xuICAgICAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lcihsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3dpdGNoQWxsQnVja2V0cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhY2UoJ0NvdW50aW5nIGRpc2FibGVkLiBDYW5jZWxsaW5nIHRpbWVyLicpO1xuICAgICAgICAgICAgdGhpcy50aW1lclN0YXJ0VGltZSA9IG51bGw7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmVqZWN0KG1hcEVudHJ5KTtcbiAgICAgICAgICAgICAgICBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IGxiQ29uZmlnO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5lamVjdGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyID0gT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgIGlmIChPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEKSB7XG4gICAgICAgICgwLCBleHBlcmltZW50YWxfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciwgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    constructor(shuffleAddressList) {\n        this.shuffleAddressList = shuffleAddressList;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {\n                shuffleAddressList: this.shuffleAddressList,\n            },\n        };\n    }\n    getShuffleAddressList() {\n        return this.shuffleAddressList;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        if ('shuffleAddressList' in obj &&\n            !(typeof obj.shuffleAddressList === 'boolean')) {\n            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\n        }\n        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n    constructor(subchannel) {\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nfunction shuffled(list) {\n    const result = list.slice();\n    for (let i = result.length - 1; i > 1; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const temp = result[i];\n        result[i] = result[j];\n        result[j] = temp;\n    }\n    return result;\n}\nexports.shuffled = shuffled;\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */\n        this.children = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */\n        this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */\n        this.currentPick = null;\n        /**\n         * Listener callback attached to each subchannel in the `subchannels` list\n         * while establishing a connection.\n         */\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\n            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n        };\n        this.triedAllSubchannels = false;\n        /**\n         * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n         * subchannels have failed to connect at least once, and it stays in that\n         * mode until a connection attempt is successful. While in sticky TF mode,\n         * the LB policy continuously attempts to connect to all of its subchannels.\n         */\n        this.stickyTransientFailureMode = false;\n        /**\n         * Indicates whether we called channelControlHelper.requestReresolution since\n         * the last call to updateAddressList\n         */\n        this.requestedResolutionSinceLastUpdate = false;\n        /**\n         * The most recent error reported by any subchannel as it transitioned to\n         * TRANSIENT_FAILURE.\n         */\n        this.lastError = null;\n        this.latestAddressList = null;\n        this.connectionDelayTimeout = setTimeout(() => { }, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    allChildrenHaveReportedTF() {\n        return this.children.every(child => child.hasReportedTransientFailure);\n    }\n    calculateAndReportNewState() {\n        if (this.currentPick) {\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));\n        }\n        else if (this.children.length === 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n        else {\n            if (this.stickyTransientFailureMode) {\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({ details: `No connection established. Last error: ${this.lastError}` }));\n            }\n            else {\n                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n            }\n        }\n    }\n    requestReresolution() {\n        this.requestedResolutionSinceLastUpdate = true;\n        this.channelControlHelper.requestReresolution();\n    }\n    maybeEnterStickyTransientFailureMode() {\n        if (!this.allChildrenHaveReportedTF()) {\n            return;\n        }\n        if (!this.requestedResolutionSinceLastUpdate) {\n            /* Each time we get an update we reset each subchannel's\n             * hasReportedTransientFailure flag, so the next time we get to this\n             * point after that, each subchannel has reported TRANSIENT_FAILURE\n             * at least once since then. That is the trigger for requesting\n             * reresolution, whether or not the LB policy is already in sticky TF\n             * mode. */\n            this.requestReresolution();\n        }\n        if (this.stickyTransientFailureMode) {\n            return;\n        }\n        this.stickyTransientFailureMode = true;\n        for (const { subchannel } of this.children) {\n            subchannel.startConnecting();\n        }\n        this.calculateAndReportNewState();\n    }\n    removeCurrentPick() {\n        if (this.currentPick !== null) {\n            /* Unref can cause a state change, which can cause a change in the value\n             * of this.currentPick, so we hold a local reference to make sure that\n             * does not impact this function. */\n            const currentPick = this.currentPick;\n            this.currentPick = null;\n            currentPick.unref();\n            currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n        }\n    }\n    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n        var _a;\n        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.removeCurrentPick();\n                this.calculateAndReportNewState();\n                this.requestReresolution();\n            }\n            return;\n        }\n        for (const [index, child] of this.children.entries()) {\n            if (subchannel.realSubchannelEquals(child.subchannel)) {\n                if (newState === connectivity_state_1.ConnectivityState.READY) {\n                    this.pickSubchannel(child.subchannel);\n                }\n                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    child.hasReportedTransientFailure = true;\n                    if (errorMessage) {\n                        this.lastError = errorMessage;\n                    }\n                    this.maybeEnterStickyTransientFailureMode();\n                    if (index === this.currentSubchannelIndex) {\n                        this.startNextSubchannelConnecting(index + 1);\n                    }\n                }\n                child.subchannel.startConnecting();\n                return;\n            }\n        }\n    }\n    startNextSubchannelConnecting(startIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, child] of this.children.entries()) {\n            if (index >= startIndex) {\n                const subchannelState = child.subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n        this.maybeEnterStickyTransientFailureMode();\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */\n    startConnecting(subchannelIndex) {\n        var _a, _b;\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===\n            connectivity_state_1.ConnectivityState.IDLE) {\n            trace('Start connecting to subchannel with address ' +\n                this.children[subchannelIndex].subchannel.getAddress());\n            process.nextTick(() => {\n                var _a;\n                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = (_b = (_a = setTimeout(() => {\n            this.startNextSubchannelConnecting(subchannelIndex + 1);\n        }, CONNECTION_DELAY_INTERVAL_MS)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    pickSubchannel(subchannel) {\n        if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {\n            return;\n        }\n        trace('Pick subchannel with address ' + subchannel.getAddress());\n        this.stickyTransientFailureMode = false;\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n        this.calculateAndReportNewState();\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const child of this.children) {\n            if (!(this.currentPick && child.subchannel.realSubchannelEquals(this.currentPick))) {\n                /* The connectivity state listener is the same whether the subchannel\n                 * is in the list of children or it is the currentPick, so if it is in\n                 * both, removing it here would cause problems. In particular, that\n                 * always happens immediately after the subchannel is picked. */\n                child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            }\n            /* Refs are counted independently for the children list and the\n             * currentPick, so we call unref whether or not the child is the\n             * currentPick. Channelz child references are also refcounted, so\n             * removeChannelzChild can be handled the same way. */\n            child.subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.children = [];\n        this.triedAllSubchannels = false;\n        this.requestedResolutionSinceLastUpdate = false;\n    }\n    connectToAddressList(addressList) {\n        const newChildrenList = addressList.map(address => ({\n            subchannel: this.channelControlHelper.createSubchannel(address, {}),\n            hasReportedTransientFailure: false,\n        }));\n        /* Ref each subchannel before resetting the list, to ensure that\n         * subchannels shared between the list don't drop to 0 refs during the\n         * transition. */\n        for (const { subchannel } of newChildrenList) {\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        this.resetSubchannelList();\n        this.children = newChildrenList;\n        for (const { subchannel } of this.children) {\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n        }\n        for (const child of this.children) {\n            if (child.subchannel.getConnectivityState() ===\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                child.hasReportedTransientFailure = true;\n            }\n        }\n        this.startNextSubchannelConnecting(0);\n        this.calculateAndReportNewState();\n    }\n    updateAddressList(addressList, lbConfig) {\n        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n            return;\n        }\n        /* Previously, an update would be discarded if it was identical to the\n         * previous update, to minimize churn. Now the DNS resolver is\n         * rate-limited, so that is less of a concern. */\n        if (lbConfig.getShuffleAddressList()) {\n            addressList = shuffled(addressList);\n        }\n        this.latestAddressList = addressList;\n        this.connectToAddressList(addressList);\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\n            this.connectToAddressList(this.latestAddressList);\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n        this.removeCurrentPick();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-pick-first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsNkJBQTZCLEdBQUcsZ0JBQWdCLEdBQUcsb0NBQW9DO0FBQ3ZHLHdCQUF3QixtQkFBTyxDQUFDLGlHQUFpQjtBQUNqRCw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QsaUJBQWlCLG1CQUFPLENBQUMsbUZBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsbURBQW1ELGVBQWUsR0FBRztBQUNqTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBleHBvcnRzLnNodWZmbGVkID0gZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncGlja19maXJzdCc7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdwaWNrX2ZpcnN0Jztcbi8qKlxuICogRGVsYXkgYWZ0ZXIgc3RhcnRpbmcgYSBjb25uZWN0aW9uIG9uIGEgc3ViY2hhbm5lbCBiZWZvcmUgc3RhcnRpbmcgYVxuICogY29ubmVjdGlvbiBvbiB0aGUgbmV4dCBzdWJjaGFubmVsIGluIHRoZSBsaXN0LCBmb3IgSGFwcHkgRXllYmFsbHMgYWxnb3JpdGhtLlxuICovXG5jb25zdCBDT05ORUNUSU9OX0RFTEFZX0lOVEVSVkFMX01TID0gMjUwO1xuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgY29uc3RydWN0b3Ioc2h1ZmZsZUFkZHJlc3NMaXN0KSB7XG4gICAgICAgIHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0ID0gc2h1ZmZsZUFkZHJlc3NMaXN0O1xuICAgIH1cbiAgICBnZXRMb2FkQmFsYW5jZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge1xuICAgICAgICAgICAgICAgIHNodWZmbGVBZGRyZXNzTGlzdDogdGhpcy5zaHVmZmxlQWRkcmVzc0xpc3QsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTaHVmZmxlQWRkcmVzc0xpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdDtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzdGF0aWMgY3JlYXRlRnJvbUpzb24ob2JqKSB7XG4gICAgICAgIGlmICgnc2h1ZmZsZUFkZHJlc3NMaXN0JyBpbiBvYmogJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iai5zaHVmZmxlQWRkcmVzc0xpc3QgPT09ICdib29sZWFuJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGlja19maXJzdCBjb25maWcgZmllbGQgc2h1ZmZsZUFkZHJlc3NMaXN0IG11c3QgYmUgYSBib29sZWFuIGlmIHByb3ZpZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKG9iai5zaHVmZmxlQWRkcmVzc0xpc3QgPT09IHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyA9IFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWc7XG4vKipcbiAqIFBpY2tlciBmb3IgYSBgUGlja0ZpcnN0TG9hZEJhbGFuY2VyYCBpbiB0aGUgUkVBRFkgc3RhdGUuIEFsd2F5cyByZXR1cm5zIHRoZVxuICogcGlja2VkIHN1YmNoYW5uZWwuXG4gKi9cbmNsYXNzIFBpY2tGaXJzdFBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3ViY2hhbm5lbCkge1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWwgPSBzdWJjaGFubmVsO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiB0aGlzLnN1YmNoYW5uZWwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm4gYSBuZXcgYXJyYXkgd2l0aCB0aGUgZWxlbWVudHMgb2YgdGhlIGlucHV0IGFycmF5IGluIGEgcmFuZG9tIG9yZGVyXG4gKiBAcGFyYW0gbGlzdCBUaGUgaW5wdXQgYXJyYXlcbiAqIEByZXR1cm5zIEEgc2h1ZmZsZWQgYXJyYXkgb2YgdGhlIGVsZW1lbnRzIG9mIGxpc3RcbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZWQobGlzdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGxpc3Quc2xpY2UoKTtcbiAgICBmb3IgKGxldCBpID0gcmVzdWx0Lmxlbmd0aCAtIDE7IGkgPiAxOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBjb25zdCB0ZW1wID0gcmVzdWx0W2ldO1xuICAgICAgICByZXN1bHRbaV0gPSByZXN1bHRbal07XG4gICAgICAgIHJlc3VsdFtqXSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnNodWZmbGVkID0gc2h1ZmZsZWQ7XG5jbGFzcyBQaWNrRmlyc3RMb2FkQmFsYW5jZXIge1xuICAgIC8qKlxuICAgICAqIExvYWQgYmFsYW5jZXIgdGhhdCBhdHRlbXB0cyB0byBjb25uZWN0IHRvIGVhY2ggYmFja2VuZCBpbiB0aGUgYWRkcmVzcyBsaXN0XG4gICAgICogaW4gb3JkZXIsIGFuZCBwaWNrcyB0aGUgZmlyc3Qgb25lIHRoYXQgY29ubmVjdHMsIHVzaW5nIGl0IGZvciBldmVyeVxuICAgICAqIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIGNoYW5uZWxDb250cm9sSGVscGVyIGBDaGFubmVsQ29udHJvbEhlbHBlcmAgaW5zdGFuY2UgcHJvdmlkZWQgYnlcbiAgICAgKiAgICAgdGhpcyBsb2FkIGJhbGFuY2VyJ3Mgb3duZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxpc3Qgb2Ygc3ViY2hhbm5lbHMgdGhpcyBsb2FkIGJhbGFuY2VyIGlzIGN1cnJlbnRseSBhdHRlbXB0aW5nIHRvXG4gICAgICAgICAqIGNvbm5lY3QgdG8uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUgb2YgdGhlIGxvYWQgYmFsYW5jZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggd2l0aGluIHRoZSBgc3ViY2hhbm5lbHNgIGFycmF5IG9mIHRoZSBzdWJjaGFubmVsIHdpdGggdGhlIG1vc3RcbiAgICAgICAgICogcmVjZW50bHkgc3RhcnRlZCBjb25uZWN0aW9uIGF0dGVtcHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBwaWNrZWQgc3ViY2hhbm5lbCB1c2VkIGZvciBtYWtpbmcgY2FsbHMuIFBvcHVsYXRlZCBpZlxuICAgICAgICAgKiBhbmQgb25seSBpZiB0aGUgbG9hZCBiYWxhbmNlcidzIGN1cnJlbnQgc3RhdGUgaXMgUkVBRFkuIEluIHRoYXQgY2FzZSxcbiAgICAgICAgICogdGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IHN0YXRlIGlzIGFsc28gUkVBRFkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RlbmVyIGNhbGxiYWNrIGF0dGFjaGVkIHRvIGVhY2ggc3ViY2hhbm5lbCBpbiB0aGUgYHN1YmNoYW5uZWxzYCBsaXN0XG4gICAgICAgICAqIHdoaWxlIGVzdGFibGlzaGluZyBhIGNvbm5lY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25TdWJjaGFubmVsU3RhdGVVcGRhdGUoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJpZWRBbGxTdWJjaGFubmVscyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIExCIHBvbGljeSBlbnRlcnMgc3RpY2t5IFRSQU5TSUVOVF9GQUlMVVJFIG1vZGUgd2hlbiBhbGxcbiAgICAgICAgICogc3ViY2hhbm5lbHMgaGF2ZSBmYWlsZWQgdG8gY29ubmVjdCBhdCBsZWFzdCBvbmNlLCBhbmQgaXQgc3RheXMgaW4gdGhhdFxuICAgICAgICAgKiBtb2RlIHVudGlsIGEgY29ubmVjdGlvbiBhdHRlbXB0IGlzIHN1Y2Nlc3NmdWwuIFdoaWxlIGluIHN0aWNreSBURiBtb2RlLFxuICAgICAgICAgKiB0aGUgTEIgcG9saWN5IGNvbnRpbnVvdXNseSBhdHRlbXB0cyB0byBjb25uZWN0IHRvIGFsbCBvZiBpdHMgc3ViY2hhbm5lbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB3ZSBjYWxsZWQgY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbiBzaW5jZVxuICAgICAgICAgKiB0aGUgbGFzdCBjYWxsIHRvIHVwZGF0ZUFkZHJlc3NMaXN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVlc3RlZFJlc29sdXRpb25TaW5jZUxhc3RVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3N0IHJlY2VudCBlcnJvciByZXBvcnRlZCBieSBhbnkgc3ViY2hhbm5lbCBhcyBpdCB0cmFuc2l0aW9uZWQgdG9cbiAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgIH1cbiAgICBhbGxDaGlsZHJlbkhhdmVSZXBvcnRlZFRGKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5ldmVyeShjaGlsZCA9PiBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUpO1xuICAgIH1cbiAgICBjYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2spIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFksIG5ldyBQaWNrRmlyc3RQaWNrZXIodGhpcy5jdXJyZW50UGljaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7IGRldGFpbHM6IGBObyBjb25uZWN0aW9uIGVzdGFibGlzaGVkLiBMYXN0IGVycm9yOiAke3RoaXMubGFzdEVycm9yfWAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RSZXJlc29sdXRpb24oKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVkUmVzb2x1dGlvblNpbmNlTGFzdFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgIH1cbiAgICBtYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxDaGlsZHJlbkhhdmVSZXBvcnRlZFRGKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVxdWVzdGVkUmVzb2x1dGlvblNpbmNlTGFzdFVwZGF0ZSkge1xuICAgICAgICAgICAgLyogRWFjaCB0aW1lIHdlIGdldCBhbiB1cGRhdGUgd2UgcmVzZXQgZWFjaCBzdWJjaGFubmVsJ3NcbiAgICAgICAgICAgICAqIGhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSBmbGFnLCBzbyB0aGUgbmV4dCB0aW1lIHdlIGdldCB0byB0aGlzXG4gICAgICAgICAgICAgKiBwb2ludCBhZnRlciB0aGF0LCBlYWNoIHN1YmNoYW5uZWwgaGFzIHJlcG9ydGVkIFRSQU5TSUVOVF9GQUlMVVJFXG4gICAgICAgICAgICAgKiBhdCBsZWFzdCBvbmNlIHNpbmNlIHRoZW4uIFRoYXQgaXMgdGhlIHRyaWdnZXIgZm9yIHJlcXVlc3RpbmdcbiAgICAgICAgICAgICAqIHJlcmVzb2x1dGlvbiwgd2hldGhlciBvciBub3QgdGhlIExCIHBvbGljeSBpcyBhbHJlYWR5IGluIHN0aWNreSBURlxuICAgICAgICAgICAgICogbW9kZS4gKi9cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgeyBzdWJjaGFubmVsIH0gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XG4gICAgfVxuICAgIHJlbW92ZUN1cnJlbnRQaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyogVW5yZWYgY2FuIGNhdXNlIGEgc3RhdGUgY2hhbmdlLCB3aGljaCBjYW4gY2F1c2UgYSBjaGFuZ2UgaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAgKiBvZiB0aGlzLmN1cnJlbnRQaWNrLCBzbyB3ZSBob2xkIGEgbG9jYWwgcmVmZXJlbmNlIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAgICAgICAgKiBkb2VzIG5vdCBpbXBhY3QgdGhpcyBmdW5jdGlvbi4gKi9cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQaWNrID0gdGhpcy5jdXJyZW50UGljaztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xuICAgICAgICAgICAgY3VycmVudFBpY2sudW5yZWYoKTtcbiAgICAgICAgICAgIGN1cnJlbnRQaWNrLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoY3VycmVudFBpY2suZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25TdWJjaGFubmVsU3RhdGVVcGRhdGUoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLmN1cnJlbnRQaWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVhbFN1YmNoYW5uZWxFcXVhbHMoc3ViY2hhbm5lbCkpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUN1cnJlbnRQaWNrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZF0gb2YgdGhpcy5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsLnJlYWxTdWJjaGFubmVsRXF1YWxzKGNoaWxkLnN1YmNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpY2tTdWJjaGFubmVsKGNoaWxkLnN1YmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVFbnRlclN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKGluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hpbGQuc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3Rpbmcoc3RhcnRJbmRleCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICAgICAgaWYgKHRoaXMudHJpZWRBbGxTdWJjaGFubmVscykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBjaGlsZF0gb2YgdGhpcy5jaGlsZHJlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFN0YXRlID0gY2hpbGQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nKGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgPSB0cnVlO1xuICAgICAgICB0aGlzLm1heWJlRW50ZXJTdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYXZlIGEgc2luZ2xlIHN1YmNoYW5uZWwgaW4gdGhlIGBzdWJjaGFubmVsc2AgbGlzdCBzdGFydCBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsSW5kZXggVGhlIGluZGV4IGludG8gdGhlIGBzdWJjaGFubmVsc2AgbGlzdC5cbiAgICAgKi9cbiAgICBzdGFydENvbm5lY3Rpbmcoc3ViY2hhbm5lbEluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXggPSBzdWJjaGFubmVsSW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW3N1YmNoYW5uZWxJbmRleF0uc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PVxuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdHJhY2UoJ1N0YXJ0IGNvbm5lY3RpbmcgdG8gc3ViY2hhbm5lbCB3aXRoIGFkZHJlc3MgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdLnN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNoaWxkcmVuW3N1YmNoYW5uZWxJbmRleF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0ID0gKF9iID0gKF9hID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKHN1YmNoYW5uZWxJbmRleCArIDEpO1xuICAgICAgICB9LCBDT05ORUNUSU9OX0RFTEFZX0lOVEVSVkFMX01TKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgcGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljayAmJiBzdWJjaGFubmVsLnJlYWxTdWJjaGFubmVsRXF1YWxzKHRoaXMuY3VycmVudFBpY2spKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ1BpY2sgc3ViY2hhbm5lbCB3aXRoIGFkZHJlc3MgJyArIHN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgdGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljay51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHRoaXMuY3VycmVudFBpY2suZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IHN1YmNoYW5uZWw7XG4gICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcikge1xuICAgICAgICB0cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcik7XG4gICAgfVxuICAgIHJlc2V0U3ViY2hhbm5lbExpc3QoKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5jdXJyZW50UGljayAmJiBjaGlsZC5zdWJjaGFubmVsLnJlYWxTdWJjaGFubmVsRXF1YWxzKHRoaXMuY3VycmVudFBpY2spKSkge1xuICAgICAgICAgICAgICAgIC8qIFRoZSBjb25uZWN0aXZpdHkgc3RhdGUgbGlzdGVuZXIgaXMgdGhlIHNhbWUgd2hldGhlciB0aGUgc3ViY2hhbm5lbFxuICAgICAgICAgICAgICAgICAqIGlzIGluIHRoZSBsaXN0IG9mIGNoaWxkcmVuIG9yIGl0IGlzIHRoZSBjdXJyZW50UGljaywgc28gaWYgaXQgaXMgaW5cbiAgICAgICAgICAgICAgICAgKiBib3RoLCByZW1vdmluZyBpdCBoZXJlIHdvdWxkIGNhdXNlIHByb2JsZW1zLiBJbiBwYXJ0aWN1bGFyLCB0aGF0XG4gICAgICAgICAgICAgICAgICogYWx3YXlzIGhhcHBlbnMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHN1YmNoYW5uZWwgaXMgcGlja2VkLiAqL1xuICAgICAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcih0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFJlZnMgYXJlIGNvdW50ZWQgaW5kZXBlbmRlbnRseSBmb3IgdGhlIGNoaWxkcmVuIGxpc3QgYW5kIHRoZVxuICAgICAgICAgICAgICogY3VycmVudFBpY2ssIHNvIHdlIGNhbGwgdW5yZWYgd2hldGhlciBvciBub3QgdGhlIGNoaWxkIGlzIHRoZVxuICAgICAgICAgICAgICogY3VycmVudFBpY2suIENoYW5uZWx6IGNoaWxkIHJlZmVyZW5jZXMgYXJlIGFsc28gcmVmY291bnRlZCwgc29cbiAgICAgICAgICAgICAqIHJlbW92ZUNoYW5uZWx6Q2hpbGQgY2FuIGJlIGhhbmRsZWQgdGhlIHNhbWUgd2F5LiAqL1xuICAgICAgICAgICAgY2hpbGQuc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGNvbm5lY3RUb0FkZHJlc3NMaXN0KGFkZHJlc3NMaXN0KSB7XG4gICAgICAgIGNvbnN0IG5ld0NoaWxkcmVuTGlzdCA9IGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICh7XG4gICAgICAgICAgICBzdWJjaGFubmVsOiB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoYWRkcmVzcywge30pLFxuICAgICAgICAgICAgaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlOiBmYWxzZSxcbiAgICAgICAgfSkpO1xuICAgICAgICAvKiBSZWYgZWFjaCBzdWJjaGFubmVsIGJlZm9yZSByZXNldHRpbmcgdGhlIGxpc3QsIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgICAqIHN1YmNoYW5uZWxzIHNoYXJlZCBiZXR3ZWVuIHRoZSBsaXN0IGRvbid0IGRyb3AgdG8gMCByZWZzIGR1cmluZyB0aGVcbiAgICAgICAgICogdHJhbnNpdGlvbi4gKi9cbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiBuZXdDaGlsZHJlbkxpc3QpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuTGlzdDtcbiAgICAgICAgZm9yIChjb25zdCB7IHN1YmNoYW5uZWwgfSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cbiAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZygwKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgaWYgKCEobGJDb25maWcgaW5zdGFuY2VvZiBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFByZXZpb3VzbHksIGFuIHVwZGF0ZSB3b3VsZCBiZSBkaXNjYXJkZWQgaWYgaXQgd2FzIGlkZW50aWNhbCB0byB0aGVcbiAgICAgICAgICogcHJldmlvdXMgdXBkYXRlLCB0byBtaW5pbWl6ZSBjaHVybi4gTm93IHRoZSBETlMgcmVzb2x2ZXIgaXNcbiAgICAgICAgICogcmF0ZS1saW1pdGVkLCBzbyB0aGF0IGlzIGxlc3Mgb2YgYSBjb25jZXJuLiAqL1xuICAgICAgICBpZiAobGJDb25maWcuZ2V0U2h1ZmZsZUFkZHJlc3NMaXN0KCkpIHtcbiAgICAgICAgICAgIGFkZHJlc3NMaXN0ID0gc2h1ZmZsZWQoYWRkcmVzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBhZGRyZXNzTGlzdDtcbiAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdChhZGRyZXNzTGlzdCk7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgJiYgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VG9BZGRyZXNzTGlzdCh0aGlzLmxhdGVzdEFkZHJlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlQ3VycmVudFBpY2soKTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBQaWNrRmlyc3RMb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAoMCwgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FLCBQaWNrRmlyc3RMb2FkQmFsYW5jZXIsIFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcpO1xuICAgICgwLCBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItcGljay1maXJzdC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor() { }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {},\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0) {\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */\n    peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.lastError = null;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\n            this.calculateAndUpdateState();\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE ||\n                newState === connectivity_state_1.ConnectivityState.IDLE) {\n                if (errorMessage) {\n                    this.lastError = errorMessage;\n                }\n                this.channelControlHelper.requestReresolution();\n                subchannel.startConnecting();\n            }\n        };\n    }\n    countSubchannelsWithState(state) {\n        return this.subchannels.filter(subchannel => subchannel.getConnectivityState() === state).length;\n    }\n    calculateAndUpdateState() {\n        if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\n            const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        }\n        else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({ details: `No connection established. Last error: ${this.lastError}` }));\n        }\n        else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        }\n        else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels) {\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace('Connect to address list ' +\n            addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)));\n        this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels) {\n            subchannel.ref();\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels) {\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-round-robin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLDhCQUE4QjtBQUM5Qyx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELGlCQUFpQixtQkFBTyxDQUFDLG1GQUFVO0FBQ25DLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SEFBd0gsbURBQW1ELGVBQWUsR0FBRztBQUM3TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEc7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5Sb3VuZFJvYmluTG9hZEJhbGFuY2VyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XG5jbGFzcyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICByZXR1cm4gbmV3IFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKCk7XG4gICAgfVxufVxuY2xhc3MgUm91bmRSb2JpblBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3ViY2hhbm5lbExpc3QsIG5leHRJbmRleCA9IDApIHtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsTGlzdCA9IHN1YmNoYW5uZWxMaXN0O1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9IG5leHRJbmRleDtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCBwaWNrZWRTdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsTGlzdFt0aGlzLm5leHRJbmRleF07XG4gICAgICAgIHRoaXMubmV4dEluZGV4ID0gKHRoaXMubmV4dEluZGV4ICsgMSkgJSB0aGlzLnN1YmNoYW5uZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHBpY2tlZFN1YmNoYW5uZWwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoYXQgdGhlIG5leHQgc3ViY2hhbm5lbCByZXR1cm5lZCB3b3VsZCBiZS4gVXNlZCBieSB0aGUgbG9hZFxuICAgICAqIGJhbGFuY2VyIGltcGxlbWVudGF0aW9uIHRvIHByZXNlcnZlIHRoaXMgcGFydCBvZiB0aGUgcGlja2VyIHN0YXRlIGlmXG4gICAgICogcG9zc2libGUgd2hlbiBhIHN1YmNoYW5uZWwgY29ubmVjdHMgb3IgZGlzY29ubmVjdHMuXG4gICAgICovXG4gICAgcGVla05leHRTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVsTGlzdFt0aGlzLm5leHRJbmRleF07XG4gICAgfVxufVxuY2xhc3MgUm91bmRSb2JpbkxvYWRCYWxhbmNlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUsIGVycm9yTWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSB8fFxuICAgICAgICAgICAgICAgIG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY291bnRTdWJjaGFubmVsc1dpdGhTdGF0ZShzdGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVscy5maWx0ZXIoc3ViY2hhbm5lbCA9PiBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IHN0YXRlKS5sZW5ndGg7XG4gICAgfVxuICAgIGNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5jb3VudFN1YmNoYW5uZWxzV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWR5U3ViY2hhbm5lbHMgPSB0aGlzLnN1YmNoYW5uZWxzLmZpbHRlcihzdWJjaGFubmVsID0+IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gcmVhZHlTdWJjaGFubmVscy5pbmRleE9mKHRoaXMuY3VycmVudFJlYWR5UGlja2VyLnBlZWtOZXh0U3ViY2hhbm5lbCgpKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZLCBuZXcgUm91bmRSb2JpblBpY2tlcihyZWFkeVN1YmNoYW5uZWxzLCBpbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY291bnRTdWJjaGFubmVsc1dpdGhTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpID4gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKHsgZGV0YWlsczogYE5vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQuIExhc3QgZXJyb3I6ICR7dGhpcy5sYXN0RXJyb3J9YCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcikge1xuICAgICAgICB0cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gcGlja2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcik7XG4gICAgfVxuICAgIHJlc2V0U3ViY2hhbm5lbExpc3QoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gW107XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZykge1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgdHJhY2UoJ0Nvbm5lY3QgdG8gYWRkcmVzcyBsaXN0ICcgK1xuICAgICAgICAgICAgYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKSk7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbHMgPSBhZGRyZXNzTGlzdC5tYXAoYWRkcmVzcyA9PiB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoYWRkcmVzcywge30pKTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAoMCwgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSkoVFlQRV9OQU1FLCBSb3VuZFJvYmluTG9hZEJhbGFuY2VyLCBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyk7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */\nfunction createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent),\n    };\n}\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType,\n    };\n}\nexports.registerLoadBalancerType = registerLoadBalancerType;\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    }\n    else {\n        return null;\n    }\n}\nexports.createLoadBalancer = createLoadBalancer;\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nfunction getFirstUsableConfig(configs, fallbackTodefault = false) {\n    for (const config of configs) {\n        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\n            return config;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        }\n        else {\n            return null;\n        }\n    }\n    else {\n        return null;\n    }\n}\nexports.getFirstUsableConfig = getFirstUsableConfig;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validateLoadBalancingConfig(obj) {\n    if (!(obj !== null && typeof obj === 'object')) {\n        throw new Error('Load balancing config must be an object');\n    }\n    const keys = Object.keys(obj);\n    if (keys.length !== 1) {\n        throw new Error('Provided load balancing config has multiple conflicting entries');\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);\n    }\n    else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nexports.validateLoadBalancingConfig = validateLoadBalancingConfig;\n//# sourceMappingURL=load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsNEJBQTRCLEdBQUcsb0NBQW9DLEdBQUcsMEJBQTBCLEdBQUcsdUNBQXVDLEdBQUcsZ0NBQWdDLEdBQUcsdUNBQXVDO0FBQzdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLFNBQVM7QUFDNUU7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZXhwb3J0cy5pc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkID0gZXhwb3J0cy5jcmVhdGVMb2FkQmFsYW5jZXIgPSBleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IGV4cG9ydHMuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9IHZvaWQgMDtcbi8qKlxuICogQ3JlYXRlIGEgY2hpbGQgQ2hhbm5lbENvbnRyb2xIZWxwZXIgdGhhdCBvdmVycmlkZXMgc29tZSBtZXRob2RzIG9mIHRoZVxuICogcGFyZW50IHdoaWxlIGxldHRpbmcgb3RoZXJzIHBhc3MgdGhyb3VnaCB0byB0aGUgcGFyZW50IHVubW9kaWZpZWQuIFRoaXNcbiAqIGFsbG93cyBvdGhlciBjb2RlIHRvIGNyZWF0ZSB0aGVzZSBjaGlsZHJlbiB3aXRob3V0IG5lZWRpbmcgdG8ga25vdyBhYm91dFxuICogYWxsIG9mIHRoZSBtZXRob2RzIHRvIGJlIHBhc3NlZCB0aHJvdWdoLlxuICogQHBhcmFtIHBhcmVudFxuICogQHBhcmFtIG92ZXJyaWRlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKHBhcmVudCwgb3ZlcnJpZGVzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IChfYiA9IChfYSA9IG92ZXJyaWRlcy5jcmVhdGVTdWJjaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwYXJlbnQuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKHBhcmVudCksXG4gICAgICAgIHVwZGF0ZVN0YXRlOiAoX2QgPSAoX2MgPSBvdmVycmlkZXMudXBkYXRlU3RhdGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHBhcmVudC51cGRhdGVTdGF0ZS5iaW5kKHBhcmVudCksXG4gICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246IChfZiA9IChfZSA9IG92ZXJyaWRlcy5yZXF1ZXN0UmVyZXNvbHV0aW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBwYXJlbnQucmVxdWVzdFJlcmVzb2x1dGlvbi5iaW5kKHBhcmVudCksXG4gICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IChfaCA9IChfZyA9IG92ZXJyaWRlcy5hZGRDaGFubmVsekNoaWxkKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBwYXJlbnQuYWRkQ2hhbm5lbHpDaGlsZC5iaW5kKHBhcmVudCksXG4gICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IChfayA9IChfaiA9IG92ZXJyaWRlcy5yZW1vdmVDaGFubmVsekNoaWxkKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBwYXJlbnQucmVtb3ZlQ2hhbm5lbHpDaGlsZC5iaW5kKHBhcmVudCksXG4gICAgfTtcbn1cbmV4cG9ydHMuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9IGNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXI7XG5jb25zdCByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMgPSB7fTtcbmxldCBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IG51bGw7XG5mdW5jdGlvbiByZWdpc3RlckxvYWRCYWxhbmNlclR5cGUodHlwZU5hbWUsIGxvYWRCYWxhbmNlclR5cGUsIGxvYWRCYWxhbmNpbmdDb25maWdUeXBlKSB7XG4gICAgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXSA9IHtcbiAgICAgICAgTG9hZEJhbGFuY2VyOiBsb2FkQmFsYW5jZXJUeXBlLFxuICAgICAgICBMb2FkQmFsYW5jaW5nQ29uZmlnOiBsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSxcbiAgICB9O1xufVxuZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSByZWdpc3RlckxvYWRCYWxhbmNlclR5cGU7XG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKHR5cGVOYW1lKSB7XG4gICAgZGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSB0eXBlTmFtZTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGU7XG5mdW5jdGlvbiBjcmVhdGVMb2FkQmFsYW5jZXIoY29uZmlnLCBjaGFubmVsQ29udHJvbEhlbHBlcikge1xuICAgIGNvbnN0IHR5cGVOYW1lID0gY29uZmlnLmdldExvYWRCYWxhbmNlck5hbWUoKTtcbiAgICBpZiAodHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXS5Mb2FkQmFsYW5jZXIoY2hhbm5lbENvbnRyb2xIZWxwZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVMb2FkQmFsYW5jZXIgPSBjcmVhdGVMb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBpc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcztcbn1cbmV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQ7XG5mdW5jdGlvbiBnZXRGaXJzdFVzYWJsZUNvbmZpZyhjb25maWdzLCBmYWxsYmFja1RvZGVmYXVsdCA9IGZhbHNlKSB7XG4gICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICBpZiAoY29uZmlnLmdldExvYWRCYWxhbmNlck5hbWUoKSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZhbGxiYWNrVG9kZWZhdWx0KSB7XG4gICAgICAgIGlmIChkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbZGVmYXVsdExvYWRCYWxhbmNlclR5cGVdLkxvYWRCYWxhbmNpbmdDb25maWcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZ2V0Rmlyc3RVc2FibGVDb25maWc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKG9iaikge1xuICAgIGlmICghKG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkIGJhbGFuY2luZyBjb25maWcgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgbG9hZCBiYWxhbmNpbmcgY29uZmlnIGhhcyBtdWx0aXBsZSBjb25mbGljdGluZyBlbnRyaWVzJyk7XG4gICAgfVxuICAgIGNvbnN0IHR5cGVOYW1lID0ga2V5c1swXTtcbiAgICBpZiAodHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzKSB7XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdLkxvYWRCYWxhbmNpbmdDb25maWcuY3JlYXRlRnJvbUpzb24ob2JqW3R5cGVOYW1lXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBsb2FkIGJhbGFuY2luZyBjb25maWcgbmFtZSAke3R5cGVOYW1lfWApO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnID0gdmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst TRACER_NAME = 'load_balancing_call';\nclass LoadBalancingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {\n        var _a, _b;\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.metadata = null;\n        this.listener = null;\n        this.onCallEnded = null;\n        const splitPath = this.methodName.split('/');\n        let serviceName = '';\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */\n        if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    outputStatus(status, progress) {\n        var _a, _b;\n        if (!this.ended) {\n            this.ended = true;\n            this.trace('ended with status: code=' +\n                status.code +\n                ' details=\"' +\n                status.details +\n                '\"');\n            const finalStatus = Object.assign(Object.assign({}, status), { progress });\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\n        }\n    }\n    doPick() {\n        var _a, _b;\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata) {\n            throw new Error('doPick called before start');\n        }\n        this.trace('Pick called');\n        const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n        const subchannelString = pickResult.subchannel\n            ? '(' +\n                pickResult.subchannel.getChannelzRef().id +\n                ') ' +\n                pickResult.subchannel.getAddress()\n            : '' + pickResult.subchannel;\n        this.trace('Pick result: ' +\n            picker_1.PickResultType[pickResult.pickResultType] +\n            ' subchannel: ' +\n            subchannelString +\n            ' status: ' +\n            ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +\n            ' ' +\n            ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch (pickResult.pickResultType) {\n            case picker_1.PickResultType.COMPLETE:\n                this.credentials\n                    .generateMetadata({ service_url: this.serviceUrl })\n                    .then(credsMetadata => {\n                    var _a, _b, _c;\n                    /* If this call was cancelled (e.g. by the deadline) before\n                     * metadata generation finished, we shouldn't do anything with\n                     * it. */\n                    if (this.ended) {\n                        this.trace('Credentials metadata generation finished after call ended');\n                        return;\n                    }\n                    const finalMetadata = this.metadata.clone();\n                    finalMetadata.merge(credsMetadata);\n                    if (finalMetadata.get('authorization').length > 1) {\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: '\"authorization\" metadata cannot have multiple values',\n                            metadata: new metadata_1.Metadata(),\n                        }, 'PROCESSED');\n                    }\n                    if (pickResult.subchannel.getConnectivityState() !==\n                        connectivity_state_1.ConnectivityState.READY) {\n                        this.trace('Picked subchannel ' +\n                            subchannelString +\n                            ' has state ' +\n                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +\n                            ' after getting credentials metadata. Retrying pick');\n                        this.doPick();\n                        return;\n                    }\n                    if (this.deadline !== Infinity) {\n                        finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n                    }\n                    try {\n                        this.child = pickResult\n                            .subchannel.getRealSubchannel()\n                            .createCall(finalMetadata, this.host, this.methodName, {\n                            onReceiveMetadata: metadata => {\n                                this.trace('Received metadata');\n                                this.listener.onReceiveMetadata(metadata);\n                            },\n                            onReceiveMessage: message => {\n                                this.trace('Received message');\n                                this.listener.onReceiveMessage(message);\n                            },\n                            onReceiveStatus: status => {\n                                this.trace('Received status');\n                                if (status.rstCode ===\n                                    http2.constants.NGHTTP2_REFUSED_STREAM) {\n                                    this.outputStatus(status, 'REFUSED');\n                                }\n                                else {\n                                    this.outputStatus(status, 'PROCESSED');\n                                }\n                            },\n                        });\n                    }\n                    catch (error) {\n                        this.trace('Failed to start call on picked subchannel ' +\n                            subchannelString +\n                            ' with error ' +\n                            error.message);\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'Failed to start HTTP/2 stream with error ' +\n                                error.message,\n                            metadata: new metadata_1.Metadata(),\n                        }, 'NOT_STARTED');\n                        return;\n                    }\n                    (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                    this.onCallEnded = pickResult.onCallEnded;\n                    this.trace('Created child call [' + this.child.getCallNumber() + ']');\n                    if (this.readPending) {\n                        this.child.startRead();\n                    }\n                    if (this.pendingMessage) {\n                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n                    }\n                    if (this.pendingHalfClose) {\n                        this.child.halfClose();\n                    }\n                }, (error) => {\n                    // We assume the error code isn't 0 (Status.OK)\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    this.outputStatus({\n                        code: code,\n                        details: details,\n                        metadata: new metadata_1.Metadata(),\n                    }, 'PROCESSED');\n                });\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                setImmediate(() => {\n                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');\n                });\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (this.metadata.getOptions().waitForReady) {\n                    this.channel.queueCallForPick(this);\n                }\n                else {\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                    setImmediate(() => {\n                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.channel.queueCallForPick(this);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({ code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.listener = listener;\n        this.metadata = metadata;\n        this.doPick();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        if (this.child) {\n            this.child.sendMessageWithContext(context, message);\n        }\n        else {\n            this.pendingMessage = { context, message };\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        if (this.child) {\n            this.child.startRead();\n        }\n        else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        if (this.child) {\n            this.child.halfClose();\n        }\n        else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        throw new Error('Method not implemented.');\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.LoadBalancingCall = LoadBalancingCall;\n//# sourceMappingURL=load-balancing-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2luZy1jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQyxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQywrR0FBd0I7QUFDL0QsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxZQUFZLEVBQUUsV0FBVztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFNBQVMsR0FBRyxZQUFZO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWEsVUFBVTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw4QkFBOEI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNEJBQTRCLGdCQUFnQiwwTEFBMEwsY0FBYztBQUNwUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQSx3Q0FBd0MscURBQXFEO0FBQzdGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0EsNENBQTRDLHFEQUFxRDtBQUNqRyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUVBQXFFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2luZy1jYWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkxvYWRCYWxhbmNpbmdDYWxsID0gdm9pZCAwO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29udHJvbF9wbGFuZV9zdGF0dXNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyb2wtcGxhbmUtc3RhdHVzXCIpO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdsb2FkX2JhbGFuY2luZ19jYWxsJztcbmNsYXNzIExvYWRCYWxhbmNpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBjYWxsQ29uZmlnLCBtZXRob2ROYW1lLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5jYWxsQ29uZmlnID0gY2FsbENvbmZpZztcbiAgICAgICAgdGhpcy5tZXRob2ROYW1lID0gbWV0aG9kTmFtZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmRlYWRsaW5lID0gZGVhZGxpbmU7XG4gICAgICAgIHRoaXMuY2FsbE51bWJlciA9IGNhbGxOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMub25DYWxsRW5kZWQgPSBudWxsO1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSB0aGlzLm1ldGhvZE5hbWUuc3BsaXQoJy8nKTtcbiAgICAgICAgbGV0IHNlcnZpY2VOYW1lID0gJyc7XG4gICAgICAgIC8qIFRoZSBzdGFuZGFyZCBwYXRoIGZvcm1hdCBpcyBcIi97c2VydmljZU5hbWV9L3ttZXRob2ROYW1lfVwiLCBzbyBpZiB3ZSBzcGxpdFxuICAgICAgICAgKiBieSAnLycsIHRoZSBmaXJzdCBpdGVtIHNob3VsZCBiZSBlbXB0eSBhbmQgdGhlIHNlY29uZCBzaG91bGQgYmUgdGhlXG4gICAgICAgICAqIHNlcnZpY2UgbmFtZSAqL1xuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgICBzZXJ2aWNlTmFtZSA9IHNwbGl0UGF0aFsxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0bmFtZSA9IChfYiA9IChfYSA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGhpcy5ob3N0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdsb2NhbGhvc3QnO1xuICAgICAgICAvKiBDdXJyZW50bHksIGNhbGwgY3JlZGVudGlhbHMgYXJlIG9ubHkgYWxsb3dlZCBvbiBIVFRQUyBjb25uZWN0aW9ucywgc28gd2VcbiAgICAgICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSBzY2hlbWUgaXMgXCJodHRwc1wiICovXG4gICAgICAgIHRoaXMuc2VydmljZVVybCA9IGBodHRwczovLyR7aG9zdG5hbWV9LyR7c2VydmljZU5hbWV9YDtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgb3V0cHV0U3RhdHVzKHN0YXR1cywgcHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2VuZGVkIHdpdGggc3RhdHVzOiBjb2RlPScgK1xuICAgICAgICAgICAgICAgIHN0YXR1cy5jb2RlICtcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICBjb25zdCBmaW5hbFN0YXR1cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RhdHVzKSwgeyBwcm9ncmVzcyB9KTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblJlY2VpdmVTdGF0dXMoZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgKF9iID0gdGhpcy5vbkNhbGxFbmRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywgZmluYWxTdGF0dXMuY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9QaWNrKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb1BpY2sgY2FsbGVkIGJlZm9yZSBzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ1BpY2sgY2FsbGVkJyk7XG4gICAgICAgIGNvbnN0IHBpY2tSZXN1bHQgPSB0aGlzLmNoYW5uZWwuZG9QaWNrKHRoaXMubWV0YWRhdGEsIHRoaXMuY2FsbENvbmZpZy5waWNrSW5mb3JtYXRpb24pO1xuICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RyaW5nID0gcGlja1Jlc3VsdC5zdWJjaGFubmVsXG4gICAgICAgICAgICA/ICcoJyArXG4gICAgICAgICAgICAgICAgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkuaWQgK1xuICAgICAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRBZGRyZXNzKClcbiAgICAgICAgICAgIDogJycgKyBwaWNrUmVzdWx0LnN1YmNoYW5uZWw7XG4gICAgICAgIHRoaXMudHJhY2UoJ1BpY2sgcmVzdWx0OiAnICtcbiAgICAgICAgICAgIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlW3BpY2tSZXN1bHQucGlja1Jlc3VsdFR5cGVdICtcbiAgICAgICAgICAgICcgc3ViY2hhbm5lbDogJyArXG4gICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcbiAgICAgICAgICAgICcgc3RhdHVzOiAnICtcbiAgICAgICAgICAgICgoX2EgPSBwaWNrUmVzdWx0LnN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAoKF9iID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXRhaWxzKSk7XG4gICAgICAgIHN3aXRjaCAocGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURTpcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWRlbnRpYWxzXG4gICAgICAgICAgICAgICAgICAgIC5nZW5lcmF0ZU1ldGFkYXRhKHsgc2VydmljZV91cmw6IHRoaXMuc2VydmljZVVybCB9KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihjcmVkc01ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoaXMgY2FsbCB3YXMgY2FuY2VsbGVkIChlLmcuIGJ5IHRoZSBkZWFkbGluZSkgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAqIG1ldGFkYXRhIGdlbmVyYXRpb24gZmluaXNoZWQsIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZyB3aXRoXG4gICAgICAgICAgICAgICAgICAgICAqIGl0LiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlZGVudGlhbHMgbWV0YWRhdGEgZ2VuZXJhdGlvbiBmaW5pc2hlZCBhZnRlciBjYWxsIGVuZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxNZXRhZGF0YSA9IHRoaXMubWV0YWRhdGEuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxNZXRhZGF0YS5tZXJnZShjcmVkc01ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsTWV0YWRhdGEuZ2V0KCdhdXRob3JpemF0aW9uJykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnXCJhdXRob3JpemF0aW9uXCIgbWV0YWRhdGEgY2Fubm90IGhhdmUgbXVsdGlwbGUgdmFsdWVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUGlja2VkIHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBoYXMgc3RhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCldICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIGFmdGVyIGdldHRpbmcgY3JlZGVudGlhbHMgbWV0YWRhdGEuIFJldHJ5aW5nIHBpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmUgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbE1ldGFkYXRhLnNldCgnZ3JwYy10aW1lb3V0JywgKDAsIGRlYWRsaW5lXzEuZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nKSh0aGlzLmRlYWRsaW5lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBwaWNrUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN1YmNoYW5uZWwuZ2V0UmVhbFN1YmNoYW5uZWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jcmVhdGVDYWxsKGZpbmFsTWV0YWRhdGEsIHRoaXMuaG9zdCwgdGhpcy5tZXRob2ROYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHN0YXR1cycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnJzdENvZGUgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9SRUZVU0VEX1NUUkVBTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzLCAnUkVGVVNFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoc3RhdHVzLCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdGYWlsZWQgdG8gc3RhcnQgY2FsbCBvbiBwaWNrZWQgc3ViY2hhbm5lbCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdGYWlsZWQgdG8gc3RhcnQgSFRUUC8yIHN0cmVhbSB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgJ05PVF9TVEFSVEVEJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsQ29uZmlnKS5vbkNvbW1pdHRlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICAgICAgICAgICAgICAoX2MgPSBwaWNrUmVzdWx0Lm9uQ2FsbFN0YXJ0ZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHBpY2tSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2FsbEVuZGVkID0gcGlja1Jlc3VsdC5vbkNhbGxFbmRlZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCBjaGlsZCBjYWxsIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGUgZXJyb3IgY29kZSBpc24ndCAwIChTdGF0dXMuT0spXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKSh0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicgPyBlcnJvci5jb2RlIDogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sIGBHZXR0aW5nIG1ldGFkYXRhIGZyb20gcGx1Z2luIGZhaWxlZCB3aXRoIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuRFJPUDpcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlLCBkZXRhaWxzLCBtZXRhZGF0YTogcGlja1Jlc3VsdC5zdGF0dXMubWV0YWRhdGEgfSwgJ0RST1AnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yUGljayh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShwaWNrUmVzdWx0LnN0YXR1cy5jb2RlLCBwaWNrUmVzdWx0LnN0YXR1cy5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGE6IHBpY2tSZXN1bHQuc3RhdHVzLm1ldGFkYXRhIH0sICdQUk9DRVNTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5RVUVVRTpcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yUGljayh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICAoX2EgPSB0aGlzLmNoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7IGNvZGU6IHN0YXR1cywgZGV0YWlsczogZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSwgJ1BST0NFU1NFRCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5jaGFubmVsLmdldFRhcmdldCgpO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmRvUGljaygpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IHsgY29udGV4dCwgbWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnaGFsZkNsb3NlIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBnZXRDYWxsTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsTnVtYmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuTG9hZEJhbGFuY2luZ0NhbGwgPSBMb2FkQmFsYW5jaW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jaW5nLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst process_1 = __webpack_require__(/*! process */ \"process\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(action-browser)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams) => {\n        console.error('E ' + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams) => {\n        console.error('I ' + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams) => {\n        console.error('D ' + message, ...optionalParams);\n    },\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';\nswitch (verbosityString.toUpperCase()) {\n    case 'DEBUG':\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case 'INFO':\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case 'ERROR':\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case 'NONE':\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n    // Ignore any other values\n}\nconst getLogger = () => {\n    return _logger;\n};\nexports.getLogger = getLogger;\nconst setLogger = (logger) => {\n    _logger = logger;\n};\nexports.setLogger = setLogger;\nconst setLoggerVerbosity = (verbosity) => {\n    _logVerbosity = verbosity;\n};\nexports.setLoggerVerbosity = setLoggerVerbosity;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst log = (severity, ...args) => {\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch (severity) {\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */\n        if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nexports.log = log;\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(',')) {\n    if (tracerName.startsWith('-')) {\n        disabledTracers.add(tracerName.substring(1));\n    }\n    else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has('all');\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        (0, exports.log)(severity, new Date().toISOString() + ' | v' + clientVersion + ' ' + process_1.pid + ' | ' + tracer + ' | ' + text);\n    }\n}\nexports.trace = trace;\nfunction isTracerEnabled(tracer) {\n    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));\n}\nexports.isTracerEnabled = isTracerEnabled;\n//# sourceMappingURL=logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2dnaW5nLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLDBCQUEwQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQjtBQUMxSCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxrQkFBa0IsbUJBQU8sQ0FBQyx3QkFBUztBQUNuQyxzQkFBc0IscUhBQXFDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2dnaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG52YXIgX2EsIF9iLCBfYywgX2Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVHJhY2VyRW5hYmxlZCA9IGV4cG9ydHMudHJhY2UgPSBleHBvcnRzLmxvZyA9IGV4cG9ydHMuc2V0TG9nZ2VyVmVyYm9zaXR5ID0gZXhwb3J0cy5zZXRMb2dnZXIgPSBleHBvcnRzLmdldExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgcHJvY2Vzc18xID0gcmVxdWlyZShcInByb2Nlc3NcIik7XG5jb25zdCBjbGllbnRWZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmNvbnN0IERFRkFVTFRfTE9HR0VSID0ge1xuICAgIGVycm9yOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRSAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG4gICAgaW5mbzogKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0kgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICB9LFxuICAgIGRlYnVnOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRCAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG59O1xubGV0IF9sb2dnZXIgPSBERUZBVUxUX0xPR0dFUjtcbmxldCBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SO1xuY29uc3QgdmVyYm9zaXR5U3RyaW5nID0gKF9iID0gKF9hID0gcHJvY2Vzcy5lbnYuR1JQQ19OT0RFX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcHJvY2Vzcy5lbnYuR1JQQ19WRVJCT1NJVFkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuc3dpdGNoICh2ZXJib3NpdHlTdHJpbmcudG9VcHBlckNhc2UoKSkge1xuICAgIGNhc2UgJ0RFQlVHJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnSU5GTyc6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTztcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRVJST1InOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdOT05FJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5OT05FO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgIC8vIElnbm9yZSBhbnkgb3RoZXIgdmFsdWVzXG59XG5jb25zdCBnZXRMb2dnZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIF9sb2dnZXI7XG59O1xuZXhwb3J0cy5nZXRMb2dnZXIgPSBnZXRMb2dnZXI7XG5jb25zdCBzZXRMb2dnZXIgPSAobG9nZ2VyKSA9PiB7XG4gICAgX2xvZ2dlciA9IGxvZ2dlcjtcbn07XG5leHBvcnRzLnNldExvZ2dlciA9IHNldExvZ2dlcjtcbmNvbnN0IHNldExvZ2dlclZlcmJvc2l0eSA9ICh2ZXJib3NpdHkpID0+IHtcbiAgICBfbG9nVmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyVmVyYm9zaXR5ID0gc2V0TG9nZ2VyVmVyYm9zaXR5O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGxvZyA9IChzZXZlcml0eSwgLi4uYXJncykgPT4ge1xuICAgIGxldCBsb2dGdW5jdGlvbjtcbiAgICBpZiAoc2V2ZXJpdHkgPj0gX2xvZ1ZlcmJvc2l0eSkge1xuICAgICAgICBzd2l0Y2ggKHNldmVyaXR5KSB7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRzpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuZGVidWc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5pbmZvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I6XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmVycm9yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8qIEZhbGwgYmFjayB0byBfbG9nZ2VyLmVycm9yIHdoZW4gb3RoZXIgbWV0aG9kcyBhcmUgbm90IGF2YWlsYWJsZSBmb3JcbiAgICAgICAgICogY29tcGF0aWJsaXR5IHdpdGggb2xkZXIgYmVoYXZpb3IgdGhhdCBhbHdheXMgbG9nZ2VkIHRvIF9sb2dnZXIuZXJyb3IgKi9cbiAgICAgICAgaWYgKCFsb2dGdW5jdGlvbikge1xuICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dGdW5jdGlvbikge1xuICAgICAgICAgICAgbG9nRnVuY3Rpb24uYmluZChfbG9nZ2VyKSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnRzLmxvZyA9IGxvZztcbmNvbnN0IHRyYWNlcnNTdHJpbmcgPSAoX2QgPSAoX2MgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVFJBQ0UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHByb2Nlc3MuZW52LkdSUENfVFJBQ0UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnO1xuY29uc3QgZW5hYmxlZFRyYWNlcnMgPSBuZXcgU2V0KCk7XG5jb25zdCBkaXNhYmxlZFRyYWNlcnMgPSBuZXcgU2V0KCk7XG5mb3IgKGNvbnN0IHRyYWNlck5hbWUgb2YgdHJhY2Vyc1N0cmluZy5zcGxpdCgnLCcpKSB7XG4gICAgaWYgKHRyYWNlck5hbWUuc3RhcnRzV2l0aCgnLScpKSB7XG4gICAgICAgIGRpc2FibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZS5zdWJzdHJpbmcoMSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZW5hYmxlZFRyYWNlcnMuYWRkKHRyYWNlck5hbWUpO1xuICAgIH1cbn1cbmNvbnN0IGFsbEVuYWJsZWQgPSBlbmFibGVkVHJhY2Vycy5oYXMoJ2FsbCcpO1xuZnVuY3Rpb24gdHJhY2Uoc2V2ZXJpdHksIHRyYWNlciwgdGV4dCkge1xuICAgIGlmIChpc1RyYWNlckVuYWJsZWQodHJhY2VyKSkge1xuICAgICAgICAoMCwgZXhwb3J0cy5sb2cpKHNldmVyaXR5LCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnIHwgdicgKyBjbGllbnRWZXJzaW9uICsgJyAnICsgcHJvY2Vzc18xLnBpZCArICcgfCAnICsgdHJhY2VyICsgJyB8ICcgKyB0ZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLnRyYWNlID0gdHJhY2U7XG5mdW5jdGlvbiBpc1RyYWNlckVuYWJsZWQodHJhY2VyKSB7XG4gICAgcmV0dXJuICghZGlzYWJsZWRUcmFjZXJzLmhhcyh0cmFjZXIpICYmIChhbGxFbmFibGVkIHx8IGVuYWJsZWRUcmFjZXJzLmhhcyh0cmFjZXIpKSk7XG59XG5leHBvcnRzLmlzVHJhY2VyRW5hYmxlZCA9IGlzVHJhY2VyRW5hYmxlZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmcuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nconst requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest,\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */\nfunction isPrototypePolluted(key) {\n    return ['__proto__', 'prototype', 'constructor'].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach(name => {\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === 'string' && name.charAt(0) === '$') {\n            throw new Error('Method names cannot start with $');\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = 'bidi';\n            }\n            else {\n                methodType = 'client_stream';\n            }\n        }\n        else {\n            if (attrs.responseStream) {\n                methodType = 'server_stream';\n            }\n            else {\n                methodType = 'unary';\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] =\n                ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function (...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return 'format' in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\nfunction loadPackageDefinition(packageDef) {\n    const result = {};\n    for (const serviceFqn in packageDef) {\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split('.');\n            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)) {\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            }\n            else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition;\n//# sourceMappingURL=make-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tYWtlLWNsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDZCQUE2QjtBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtCQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ha2UtY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGV4cG9ydHMubWFrZUNsaWVudENvbnN0cnVjdG9yID0gdm9pZCAwO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG4vKipcbiAqIE1hcCB3aXRoIHNob3J0IG5hbWVzIGZvciBlYWNoIG9mIHRoZSByZXF1ZXN0ZXIgbWFrZXIgZnVuY3Rpb25zLiBVc2VkIGluXG4gKiBtYWtlQ2xpZW50Q29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHJlcXVlc3RlckZ1bmNzID0ge1xuICAgIHVuYXJ5OiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VVbmFyeVJlcXVlc3QsXG4gICAgc2VydmVyX3N0cmVhbTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlU2VydmVyU3RyZWFtUmVxdWVzdCxcbiAgICBjbGllbnRfc3RyZWFtOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VDbGllbnRTdHJlYW1SZXF1ZXN0LFxuICAgIGJpZGk6IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUJpZGlTdHJlYW1SZXF1ZXN0LFxufTtcbi8qKlxuICogUmV0dXJucyB0cnVlLCBpZiBnaXZlbiBrZXkgaXMgaW5jbHVkZWQgaW4gdGhlIGJsYWNrbGlzdGVkXG4gKiBrZXlzLlxuICogQHBhcmFtIGtleSBrZXkgZm9yIGNoZWNrLCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlUG9sbHV0ZWQoa2V5KSB7XG4gICAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluY2x1ZGVzKGtleSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBjb25zdHJ1Y3RvciBmb3IgYSBjbGllbnQgd2l0aCB0aGUgZ2l2ZW4gbWV0aG9kcywgYXMgc3BlY2lmaWVkIGluXG4gKiB0aGUgbWV0aG9kcyBhcmd1bWVudC4gVGhlIHJlc3VsdGluZyBjbGFzcyB3aWxsIGhhdmUgYW4gaW5zdGFuY2UgbWV0aG9kIGZvclxuICogZWFjaCBtZXRob2QgaW4gdGhlIHNlcnZpY2UsIHdoaWNoIGlzIGEgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBvbmUgb2YgdGhlXG4gKiBbQ2xpZW50XXtAbGluayBncnBjLkNsaWVudH0gcmVxdWVzdCBtZXRob2RzLCBkZXBlbmRpbmcgb24gYHJlcXVlc3RTZXJpYWxpemVgXG4gKiBhbmQgYHJlc3BvbnNlU2VyaWFsaXplYCwgd2l0aCB0aGUgYG1ldGhvZGAsIGBzZXJpYWxpemVgLCBhbmQgYGRlc2VyaWFsaXplYFxuICogYXJndW1lbnRzIHByZWRlZmluZWQuXG4gKiBAcGFyYW0gbWV0aG9kcyBBbiBvYmplY3QgbWFwcGluZyBtZXRob2QgbmFtZXMgdG9cbiAqICAgICBtZXRob2QgYXR0cmlidXRlc1xuICogQHBhcmFtIHNlcnZpY2VOYW1lIFRoZSBmdWxseSBxdWFsaWZpZWQgbmFtZSBvZiB0aGUgc2VydmljZVxuICogQHBhcmFtIGNsYXNzT3B0aW9ucyBBbiBvcHRpb25zIG9iamVjdC5cbiAqIEByZXR1cm4gTmV3IGNsaWVudCBjb25zdHJ1Y3Rvciwgd2hpY2ggaXMgYSBzdWJjbGFzcyBvZlxuICogICAgIHtAbGluayBncnBjLkNsaWVudH0sIGFuZCBoYXMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHRoYXQgY29uc3RydWN0b3IuXG4gKi9cbmZ1bmN0aW9uIG1ha2VDbGllbnRDb25zdHJ1Y3RvcihtZXRob2RzLCBzZXJ2aWNlTmFtZSwgY2xhc3NPcHRpb25zKSB7XG4gICAgaWYgKCFjbGFzc09wdGlvbnMpIHtcbiAgICAgICAgY2xhc3NPcHRpb25zID0ge307XG4gICAgfVxuICAgIGNsYXNzIFNlcnZpY2VDbGllbnRJbXBsIGV4dGVuZHMgY2xpZW50XzEuQ2xpZW50IHtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMobWV0aG9kcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGlzUHJvdG90eXBlUG9sbHV0ZWQobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRycyA9IG1ldGhvZHNbbmFtZV07XG4gICAgICAgIGxldCBtZXRob2RUeXBlO1xuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IFZlcmlmeSB0aGF0IHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycgJiYgbmFtZS5jaGFyQXQoMCkgPT09ICckJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgbmFtZXMgY2Fubm90IHN0YXJ0IHdpdGggJCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdHRycy5yZXF1ZXN0U3RyZWFtKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ2JpZGknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdjbGllbnRfc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdHRycy5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnc2VydmVyX3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3VuYXJ5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpYWxpemUgPSBhdHRycy5yZXF1ZXN0U2VyaWFsaXplO1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZSA9IGF0dHJzLnJlc3BvbnNlRGVzZXJpYWxpemU7XG4gICAgICAgIGNvbnN0IG1ldGhvZEZ1bmMgPSBwYXJ0aWFsKHJlcXVlc3RlckZ1bmNzW21ldGhvZFR5cGVdLCBhdHRycy5wYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplKTtcbiAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdID0gbWV0aG9kRnVuYztcbiAgICAgICAgLy8gQXNzb2NpYXRlIGFsbCBwcm92aWRlZCBhdHRyaWJ1dGVzIHdpdGggdGhlIG1ldGhvZFxuICAgICAgICBPYmplY3QuYXNzaWduKFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXSwgYXR0cnMpO1xuICAgICAgICBpZiAoYXR0cnMub3JpZ2luYWxOYW1lICYmICFpc1Byb3RvdHlwZVBvbGx1dGVkKGF0dHJzLm9yaWdpbmFsTmFtZSkpIHtcbiAgICAgICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVthdHRycy5vcmlnaW5hbE5hbWVdID1cbiAgICAgICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBTZXJ2aWNlQ2xpZW50SW1wbC5zZXJ2aWNlID0gbWV0aG9kcztcbiAgICBTZXJ2aWNlQ2xpZW50SW1wbC5zZXJ2aWNlTmFtZSA9IHNlcnZpY2VOYW1lO1xuICAgIHJldHVybiBTZXJ2aWNlQ2xpZW50SW1wbDtcbn1cbmV4cG9ydHMubWFrZUNsaWVudENvbnN0cnVjdG9yID0gbWFrZUNsaWVudENvbnN0cnVjdG9yO1xuZnVuY3Rpb24gcGFydGlhbChmbiwgcGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIHBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIC4uLmFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBpc1Byb3RvYnVmVHlwZURlZmluaXRpb24ob2JqKSB7XG4gICAgcmV0dXJuICdmb3JtYXQnIGluIG9iajtcbn1cbi8qKlxuICogTG9hZCBhIGdSUEMgcGFja2FnZSBkZWZpbml0aW9uIGFzIGEgZ1JQQyBvYmplY3QgaGllcmFyY2h5LlxuICogQHBhcmFtIHBhY2thZ2VEZWYgVGhlIHBhY2thZ2UgZGVmaW5pdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgZ1JQQyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGxvYWRQYWNrYWdlRGVmaW5pdGlvbihwYWNrYWdlRGVmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBzZXJ2aWNlRnFuIGluIHBhY2thZ2VEZWYpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYWNrYWdlRGVmLCBzZXJ2aWNlRnFuKSkge1xuICAgICAgICAgICAgY29uc3Qgc2VydmljZSA9IHBhY2thZ2VEZWZbc2VydmljZUZxbl07XG4gICAgICAgICAgICBjb25zdCBuYW1lQ29tcG9uZW50cyA9IHNlcnZpY2VGcW4uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmIChuYW1lQ29tcG9uZW50cy5zb21lKChjb21wKSA9PiBpc1Byb3RvdHlwZVBvbGx1dGVkKGNvbXApKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VydmljZU5hbWUgPSBuYW1lQ29tcG9uZW50c1tuYW1lQ29tcG9uZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50ID0gcmVzdWx0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWNrYWdlTmFtZSBvZiBuYW1lQ29tcG9uZW50cy5zbGljZSgwLCAtMSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRbcGFja2FnZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRbcGFja2FnZU5hbWVdID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhY2thZ2VOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1Byb3RvYnVmVHlwZURlZmluaXRpb24oc2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50W3NlcnZpY2VOYW1lXSA9IHNlcnZpY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50W3NlcnZpY2VOYW1lXSA9IG1ha2VDbGllbnRDb25zdHJ1Y3RvcihzZXJ2aWNlLCBzZXJ2aWNlTmFtZSwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGxvYWRQYWNrYWdlRGVmaW5pdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ha2UtY2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith('-bin');\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith('grpc-');\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        }\n        else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n    constructor(options = {}) {\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [value]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [value]);\n        }\n        else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */\n    remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */\n    get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */\n    getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */\n    clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr) {\n            const clonedValue = value.map(v => {\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                }\n                else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */\n    merge(other) {\n        for (const [key, values] of other.internalRepr) {\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */\n    toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */\n    toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */\n    static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)) {\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === ':') {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach(value => {\n                            result.add(key, Buffer.from(value, 'base64'));\n                        });\n                    }\n                    else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(',').forEach(v => {\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\n                            });\n                        }\n                        else {\n                            result.add(key, Buffer.from(values, 'base64'));\n                        }\n                    }\n                }\n                else {\n                    if (Array.isArray(values)) {\n                        values.forEach(value => {\n                            result.add(key, value);\n                        });\n                    }\n                    else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            }\n            catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val) => {\n    return Buffer.isBuffer(val) ? val.toString('base64') : val;\n};\n//# sourceMappingURL=metadata.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tZXRhZGF0YS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQjtBQUNoQixrQkFBa0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxJQUFJLElBQUksT0FBTyxJQUFJLG9DQUFvQztBQUN2SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ldGFkYXRhLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuY29uc3QgTEVHQUxfS0VZX1JFR0VYID0gL15bMC05YS16Xy4tXSskLztcbmNvbnN0IExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVggPSAvXlsgLX5dKiQvO1xuZnVuY3Rpb24gaXNMZWdhbEtleShrZXkpIHtcbiAgICByZXR1cm4gTEVHQUxfS0VZX1JFR0VYLnRlc3Qoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYLnRlc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNCaW5hcnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5lbmRzV2l0aCgnLWJpbicpO1xufVxuZnVuY3Rpb24gaXNDdXN0b21NZXRhZGF0YShrZXkpIHtcbiAgICByZXR1cm4gIWtleS5zdGFydHNXaXRoKCdncnBjLScpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplS2V5KGtleSkge1xuICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoIWlzTGVnYWxLZXkoa2V5KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIGtleSBcIicgKyBrZXkgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBCdWZmZXIgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJrZXlzIHRoYXQgZG9uJ3QgZW5kIHdpdGggJy1iaW4nIG11c3QgaGF2ZSBTdHJpbmcgdmFsdWVzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc0xlZ2FsTm9uQmluYXJ5VmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBzdHJpbmcgdmFsdWUgXCInICsgdmFsdWUgKyAnXCIgY29udGFpbnMgaWxsZWdhbCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgZm9yIHN0b3JpbmcgbWV0YWRhdGEuIEtleXMgYXJlIG5vcm1hbGl6ZWQgdG8gbG93ZXJjYXNlIEFTQ0lJLlxuICovXG5jbGFzcyBNZXRhZGF0YSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSByZXBsYWNpbmcgYW55IG90aGVyIHZhbHVlc1xuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgc2V0LlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIFt2YWx1ZV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBnaXZlbiB2YWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBieSBhcHBlbmRpbmcgdG8gYSBsaXN0IG9mIHByZXZpb3VzXG4gICAgICogdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGF0IGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBmb3Igd2hpY2ggYSBuZXcgdmFsdWUgc2hvdWxkIGJlIGFwcGVuZGVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLiBNdXN0IGJlIGEgYnVmZmVyIGlmIGFuZCBvbmx5XG4gICAgICogICBpZiB0aGUgbm9ybWFsaXplZCBrZXkgZW5kcyB3aXRoICctYmluJy5cbiAgICAgKi9cbiAgICBhZGQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGlzdGluZ1ZhbHVlLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGdpdmVuIGtleSBhbmQgYW55IGFzc29jaWF0ZWQgdmFsdWVzLiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlcyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICB0aGlzLmludGVybmFsUmVwci5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgYWxsIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB3aG9zZSB2YWx1ZSBzaG91bGQgYmUgcmV0cmlldmVkLlxuICAgICAqIEByZXR1cm4gQSBsaXN0IG9mIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGtleS5cbiAgICAgKi9cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICAvLyB2YWxpZGF0ZShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBwbGFpbiBvYmplY3QgbWFwcGluZyBlYWNoIGtleSB0byB0aGUgZmlyc3QgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAqIFRoaXMgcmVmbGVjdHMgdGhlIG1vc3QgY29tbW9uIHdheSB0aGF0IHBlb3BsZSB3aWxsIHdhbnQgdG8gc2VlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm4gQSBrZXkvdmFsdWUgbWFwcGluZyBvZiB0aGUgbWV0YWRhdGEuXG4gICAgICovXG4gICAgZ2V0TWFwKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gQnVmZmVyLmlzQnVmZmVyKHYpID8gQnVmZmVyLmZyb20odikgOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgbWV0YWRhdGEgb2JqZWN0LlxuICAgICAqIEByZXR1cm4gVGhlIG5ld2x5IGNsb25lZCBvYmplY3QuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IG5ld01ldGFkYXRhID0gbmV3IE1ldGFkYXRhKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG5ld0ludGVybmFsUmVwciA9IG5ld01ldGFkYXRhLmludGVybmFsUmVwcjtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZFZhbHVlID0gdmFsdWUubWFwKHYgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBuZXdJbnRlcm5hbFJlcHIuc2V0KGtleSwgY2xvbmVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdNZXRhZGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBrZXktdmFsdWUgcGFpcnMgZnJvbSBhIGdpdmVuIE1ldGFkYXRhIG9iamVjdCBpbnRvIHRoaXMgb25lLlxuICAgICAqIElmIGJvdGggdGhpcyBvYmplY3QgYW5kIHRoZSBnaXZlbiBvYmplY3QgaGF2ZSB2YWx1ZXMgaW4gdGhlIHNhbWUga2V5LFxuICAgICAqIHZhbHVlcyBmcm9tIHRoZSBvdGhlciBNZXRhZGF0YSBvYmplY3Qgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGlzIG9iamVjdCdzXG4gICAgICogdmFsdWVzLlxuICAgICAqIEBwYXJhbSBvdGhlciBBIE1ldGFkYXRhIG9iamVjdC5cbiAgICAgKi9cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2Ygb3RoZXIuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRWYWx1ZSA9ICh0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KSB8fCBbXSkuY29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBtZXJnZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gT3V0Z29pbmdIdHRwSGVhZGVycyBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBodHRwMiBBUEkuXG4gICAgICovXG4gICAgdG9IdHRwMkhlYWRlcnMoKSB7XG4gICAgICAgIC8vIE5PVEU6IE5vZGUgPDguOSBmb3JtYXRzIGh0dHAyIGhlYWRlcnMgaW5jb3JyZWN0bHkuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGlzIG9iamVjdCBpcyBsaW1pdGVkIHRvXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0cyBwdWJsaWMgQVBJIChpLmUuIGtleXMgYW5kIHZhbHVlcyBhcmUgYWxyZWFkeSB2YWxpZGF0ZWQpLlxuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXMubWFwKGJ1ZlRvU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZGlmaWVzIHRoZSBiZWhhdmlvciBvZiBKU09OLnN0cmluZ2lmeSB0byBzaG93IGFuIG9iamVjdFxuICAgICAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtZXRhZGF0YSBtYXAuXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IE1ldGFkYXRhIG9iamVjdCBiYXNlZCBmaWVsZHMgaW4gYSBnaXZlbiBJbmNvbWluZ0h0dHBIZWFkZXJzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBoZWFkZXJzIEFuIEluY29taW5nSHR0cEhlYWRlcnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1ldGFkYXRhKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAvLyBSZXNlcnZlZCBoZWFkZXJzIChiZWdpbm5pbmcgd2l0aCBgOmApIGFyZSBub3QgdmFsaWQga2V5cy5cbiAgICAgICAgICAgIGlmIChrZXkuY2hhckF0KDApID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IGhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmluYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXN0b21NZXRhZGF0YShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnNwbGl0KCcsJykuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHYudHJpbSgpLCAnYmFzZTY0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlcywgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2godmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYEZhaWxlZCB0byBhZGQgbWV0YWRhdGEgZW50cnkgJHtrZXl9OiAke3ZhbHVlc30uICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvcil9LiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL2lzc3Vlcy8xMTczYDtcbiAgICAgICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuTWV0YWRhdGEgPSBNZXRhZGF0YTtcbmNvbnN0IGJ1ZlRvU3RyaW5nID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsKSA/IHZhbC50b1N0cmluZygnYmFzZTY0JykgOiB2YWw7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YWRhdGEuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function (PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType || (exports.PickResultType = PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */\nclass UnavailablePicker {\n    constructor(status) {\n        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */\nclass QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer) {\n        this.loadBalancer = loadBalancer;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(() => {\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        return {\n            pickResultType: PickResultType.QUEUE,\n            subchannel: null,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n}\nexports.QueuePicker = QueuePicker;\n//# sourceMappingURL=picker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9waWNrZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDeEUsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQkFBcUIsc0JBQXNCLHNCQUFzQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsaUhBQWlIO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9waWNrZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBleHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IHZvaWQgMDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIFBpY2tSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChQaWNrUmVzdWx0VHlwZSkge1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiQ09NUExFVEVcIl0gPSAwXSA9IFwiQ09NUExFVEVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlFVRVVFXCJdID0gMV0gPSBcIlFVRVVFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJUUkFOU0lFTlRfRkFJTFVSRVwiXSA9IDJdID0gXCJUUkFOU0lFTlRfRkFJTFVSRVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiRFJPUFwiXSA9IDNdID0gXCJEUk9QXCI7XG59KShQaWNrUmVzdWx0VHlwZSB8fCAoZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IFBpY2tSZXN1bHRUeXBlID0ge30pKTtcbi8qKlxuICogQSBzdGFuZGFyZCBwaWNrZXIgcmVwcmVzZW50aW5nIGEgbG9hZCBiYWxhbmNlciBpbiB0aGUgVFJBTlNJRU5UX0ZBSUxVUkVcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYW4gVU5BVkFJTEFCTEUgc3RhdHVzLlxuICovXG5jbGFzcyBVbmF2YWlsYWJsZVBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gT2JqZWN0LmFzc2lnbih7IGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSwgZGV0YWlsczogJ05vIGNvbm5lY3Rpb24gZXN0YWJsaXNoZWQnLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9LCBzdGF0dXMpO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogUGlja1Jlc3VsdFR5cGUuVFJBTlNJRU5UX0ZBSUxVUkUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBudWxsLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gVW5hdmFpbGFibGVQaWNrZXI7XG4vKipcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIElETEUgb3IgQ09OTkVDVElOR1xuICogc3RhdGUuIEFsd2F5cyByZXNwb25kcyB0byBldmVyeSBwaWNrIHJlcXVlc3Qgd2l0aCBhIFFVRVVFIHBpY2sgcmVzdWx0XG4gKiBpbmRpY2F0aW5nIHRoYXQgdGhlIHBpY2sgc2hvdWxkIGJlIHRyaWVkIGFnYWluIHdpdGggdGhlIG5leHQgYFBpY2tlcmAuIEFsc29cbiAqIHJlcG9ydHMgYmFjayB0byB0aGUgbG9hZCBiYWxhbmNlciB0aGF0IGEgY29ubmVjdGlvbiBzaG91bGQgYmUgZXN0YWJsaXNoZWRcbiAqIG9uY2UgYW55IHBpY2sgaXMgYXR0ZW1wdGVkLlxuICovXG5jbGFzcyBRdWV1ZVBpY2tlciB7XG4gICAgLy8gQ29uc3RydWN0ZWQgd2l0aCBhIGxvYWQgYmFsYW5jZXIuIENhbGxzIGV4aXRJZGxlIG9uIGl0IHRoZSBmaXJzdCB0aW1lIHBpY2sgaXMgY2FsbGVkXG4gICAgY29uc3RydWN0b3IobG9hZEJhbGFuY2VyKSB7XG4gICAgICAgIHRoaXMubG9hZEJhbGFuY2VyID0gbG9hZEJhbGFuY2VyO1xuICAgICAgICB0aGlzLmNhbGxlZEV4aXRJZGxlID0gZmFsc2U7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxlZEV4aXRJZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNhbGxlZEV4aXRJZGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlFVRVVFLFxuICAgICAgICAgICAgc3ViY2hhbm5lbDogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxFbmRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlF1ZXVlUGlja2VyID0gUXVldWVQaWNrZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waWNrZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.DEFAULT_PORT = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nexports.DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays(...arrays) {\n    const result = [];\n    for (let i = 0; i <\n        Math.max.apply(null, arrays.map(array => array.length)); i++) {\n        for (const array of arrays) {\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n    constructor(target, listener, channelOptions) {\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        this.isServiceConfigEnabled = true;\n        this.returnedIpResult = false;\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\n        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        }\n        else {\n            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT,\n                    },\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            }\n            else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {\n            this.isServiceConfigEnabled = false;\n        }\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\n            metadata: new metadata_1.Metadata(),\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs =\n            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(() => { }, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */\n    startResolution() {\n        if (this.ipResult !== null) {\n            if (!this.returnedIpResult) {\n                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));\n                setImmediate(() => {\n                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n                });\n                this.returnedIpResult = true;\n            }\n            this.backoff.stop();\n            this.backoff.reset();\n            this.stopNextResolutionTimer();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));\n            setImmediate(() => {\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,\n                    metadata: new metadata_1.Metadata(),\n                });\n            });\n            this.stopNextResolutionTimer();\n        }\n        else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace('Looking up DNS hostname ' + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */\n            this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */\n            this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });\n            this.pendingLookupPromise.then(addressList => {\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                const ip4Addresses = addressList.filter(addr => addr.family === 4);\n                const ip6Addresses = addressList.filter(addr => addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map(addr => ({ host: addr.address, port: +this.port }));\n                const allAddressesString = '[' +\n                    this.latestLookupResult\n                        .map(addr => addr.host + ':' + addr.port)\n                        .join(',') +\n                    ']';\n                trace('Resolved addresses for target ' +\n                    (0, uri_parser_1.uriToString)(this.target) +\n                    ': ' +\n                    allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */\n                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, err => {\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                trace('Resolution error for target ' +\n                    (0, uri_parser_1.uriToString)(this.target) +\n                    ': ' +\n                    err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */\n            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */\n                this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then(txtRecord => {\n                    if (this.pendingTxtPromise === null) {\n                        return;\n                    }\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\n                    }\n                    catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: `Parsing service config failed with error ${err.message}`,\n                            metadata: new metadata_1.Metadata(),\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */\n                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, err => {\n                    /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */\n                });\n            }\n        }\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = (_b = (_a = setTimeout(() => {\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n            this.startResolution();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */\n        if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                if (this.isNextResolutionTimerRunning) {\n                    trace('resolution update delayed by \"min time between resolutions\" rate limit');\n                }\n                else {\n                    trace('resolution update delayed by backoff timer until ' + this.backoff.getEndTime().toISOString());\n                }\n                this.continueResolving = true;\n            }\n            else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    /**\n     * Reset the resolver to the same state it had when it was created. In-flight\n     * DNS requests cannot be cancelled, but they are discarded and their results\n     * will be ignored.\n     */\n    destroy() {\n        this.continueResolving = false;\n        this.backoff.reset();\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.returnedIpResult = false;\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n    static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n    (0, resolver_1.registerResolver)('dns', DnsResolver);\n    (0, resolver_1.registerDefaultScheme)('dns');\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-dns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci1kbnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLG9CQUFvQjtBQUNwQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMscUdBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwyQ0FBMkM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUYsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwyQ0FBMkM7QUFDdkc7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFdBQVc7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLHNDQUFzQztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0lBQStJO0FBQy9JLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsWUFBWTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLkRFRkFVTFRfUE9SVCA9IHZvaWQgMDtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGRucyA9IHJlcXVpcmUoXCJkbnNcIik7XG5jb25zdCB1dGlsID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBzZXJ2aWNlX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vc2VydmljZS1jb25maWdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgYmFja29mZl90aW1lb3V0XzEgPSByZXF1aXJlKFwiLi9iYWNrb2ZmLXRpbWVvdXRcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdkbnNfcmVzb2x2ZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRDUCBwb3J0IHRvIGNvbm5lY3QgdG8gaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSB0YXJnZXQuXG4gKi9cbmV4cG9ydHMuREVGQVVMVF9QT1JUID0gNDQzO1xuY29uc3QgREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TID0gMzAwMDA7XG5jb25zdCByZXNvbHZlVHh0UHJvbWlzZSA9IHV0aWwucHJvbWlzaWZ5KGRucy5yZXNvbHZlVHh0KTtcbmNvbnN0IGRuc0xvb2t1cFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMubG9va3VwKTtcbi8qKlxuICogTWVyZ2UgYW55IG51bWJlciBvZiBhcnJheXMgaW50byBhIHNpbmdsZSBhbHRlcm5hdGluZyBhcnJheVxuICogQHBhcmFtIGFycmF5c1xuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5cyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8XG4gICAgICAgIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5cy5tYXAoYXJyYXkgPT4gYXJyYXkubGVuZ3RoKSk7IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGFycmF5IG9mIGFycmF5cykge1xuICAgICAgICAgICAgaWYgKGkgPCBhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUmVzb2x2ZXIgaW1wbGVtZW50YXRpb24gdGhhdCBoYW5kbGVzIEROUyBuYW1lcyBhbmQgSVAgYWRkcmVzc2VzLlxuICovXG5jbGFzcyBEbnNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNTZXJ2aWNlQ29uZmlnRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0dXJuZWRJcFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSk7XG4gICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXQucGF0aCk7XG4gICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKDAsIG5ldF8xLmlzSVB2NCkoaG9zdFBvcnQuaG9zdCkgfHwgKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlwUmVzdWx0ID0gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0UG9ydC5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogKF9hID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXhwb3J0cy5ERUZBVUxUX1BPUlQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IGhvc3RQb3J0Lmhvc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gKF9iID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXhwb3J0cy5ERUZBVUxUX1BPUlQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJjZW50YWdlID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgICAgaWYgKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnX2Rpc2FibGVfcmVzb2x1dGlvbiddID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IgPSB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICBkZXRhaWxzOiBgTmFtZSByZXNvbHV0aW9uIGZhaWxlZCBmb3IgdGFyZ2V0ICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpfWAsXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlc29sdXRpb25XaXRoQmFja29mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZi51bnJlZigpO1xuICAgICAgICB0aGlzLm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcyA9XG4gICAgICAgICAgICAoX2MgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBERUZBVUxUX01JTl9USU1FX0JFVFdFRU5fUkVTT0xVVElPTlNfTVM7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaXMgYW4gSVAgYWRkcmVzcywganVzdCBwcm92aWRlIHRoYXQgYWRkcmVzcyBhcyBhIHJlc3VsdC5cbiAgICAgKiBPdGhlcndpc2UsIGluaXRpYXRlIEEsIEFBQUEsIGFuZCBUWFQgbG9va3Vwc1xuICAgICAqL1xuICAgIHN0YXJ0UmVzb2x1dGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXBSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXR1cm5lZElwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1JldHVybmluZyBJUCBhZGRyZXNzIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSk7XG4gICAgICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMuaXBSZXN1bHQsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybmVkSXBSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRuc0hvc3RuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgRE5TIGFkZHJlc3MgJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCl9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2UoJ0xvb2tpbmcgdXAgRE5TIGhvc3RuYW1lICcgKyB0aGlzLmRuc0hvc3RuYW1lKTtcbiAgICAgICAgICAgIC8qIFdlIGNsZWFyIG91dCBsYXRlc3RMb29rdXBSZXN1bHQgaGVyZSB0byBlbnN1cmUgdGhhdCBpdCBjb250YWlucyB0aGVcbiAgICAgICAgICAgICAqIGxhdGVzdCByZXN1bHQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzdGFydGVkIHJlc29sdmluZy4gVGhhdCB3YXksIHRoZVxuICAgICAgICAgICAgICogVFhUIHJlc29sdXRpb24gaGFuZGxlciBjYW4gdXNlIGl0LCBidXQgb25seSBpZiBpdCBmaW5pc2hlcyBzZWNvbmQuIFdlXG4gICAgICAgICAgICAgKiBkb24ndCBjbGVhciBvdXQgYW55IHByZXZpb3VzIHNlcnZpY2UgY29uZmlnIHJlc3VsdHMgYmVjYXVzZSBpdCdzXG4gICAgICAgICAgICAgKiBiZXR0ZXIgdG8gdXNlIGEgc2VydmljZSBjb25maWcgdGhhdCdzIHNsaWdodGx5IG91dCBvZiBkYXRlIHRoYW4gdG9cbiAgICAgICAgICAgICAqIHJldmVydCB0byBhbiBlZmZlY3RpdmVseSBibGFuayBvbmUuICovXG4gICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBob3N0bmFtZSA9IHRoaXMuZG5zSG9zdG5hbWU7XG4gICAgICAgICAgICAvKiBXZSBsb29rdXAgYm90aCBhZGRyZXNzIGZhbWlsaWVzIGhlcmUgYW5kIHRoZW4gc3BsaXQgdGhlbSB1cCBsYXRlclxuICAgICAgICAgICAgICogYmVjYXVzZSB3aGVuIGxvb2tpbmcgdXAgYSBzaW5nbGUgZmFtaWx5LCBkbnMubG9va3VwIG91dHB1dHMgYW4gZXJyb3JcbiAgICAgICAgICAgICAqIGlmIHRoZSBuYW1lIGV4aXN0cyBidXQgdGhlcmUgYXJlIG5vIHJlY29yZHMgZm9yIHRoYXQgZmFtaWx5LCBhbmQgdGhhdFxuICAgICAgICAgICAgICogZXJyb3IgaXMgaW5kaXN0aW5ndWlzaGFibGUgZnJvbSBvdGhlciBraW5kcyBvZiBlcnJvcnMgKi9cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBkbnNMb29rdXBQcm9taXNlKGhvc3RuYW1lLCB7IGFsbDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UudGhlbihhZGRyZXNzTGlzdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlwNEFkZHJlc3NlcyA9IGFkZHJlc3NMaXN0LmZpbHRlcihhZGRyID0+IGFkZHIuZmFtaWx5ID09PSA0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpcDZBZGRyZXNzZXMgPSBhZGRyZXNzTGlzdC5maWx0ZXIoYWRkciA9PiBhZGRyLmZhbWlseSA9PT0gNik7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBtZXJnZUFycmF5cyhpcDZBZGRyZXNzZXMsIGlwNEFkZHJlc3NlcykubWFwKGFkZHIgPT4gKHsgaG9zdDogYWRkci5hZGRyZXNzLCBwb3J0OiArdGhpcy5wb3J0IH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxBZGRyZXNzZXNTdHJpbmcgPSAnWycgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChhZGRyID0+IGFkZHIuaG9zdCArICc6JyArIGFkZHIucG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsJykgK1xuICAgICAgICAgICAgICAgICAgICAnXSc7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdmVkIGFkZHJlc3NlcyBmb3IgdGFyZ2V0ICcgK1xuICAgICAgICAgICAgICAgICAgICAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgYWxsQWRkcmVzc2VzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXRlc3RMb29rdXBSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBUWFQgbG9va3VwIGhhcyBub3QgeWV0IGZpbmlzaGVkLCBib3RoIG9mIHRoZSBsYXN0IHR3b1xuICAgICAgICAgICAgICAgICAqIGFyZ3VtZW50cyB3aWxsIGJlIG51bGwsIHdoaWNoIGlzIHRoZSBlcXVpdmFsZW50IG9mIGdldHRpbmcgYW5cbiAgICAgICAgICAgICAgICAgKiBlbXB0eSBUWFQgcmVzcG9uc2UuIFdoZW4gdGhlIFRYVCBsb29rdXAgZG9lcyBmaW5pc2gsIGl0cyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICogY2FuIHVwZGF0ZSB0aGUgc2VydmljZSBjb25maWcgYnkgdXNpbmcgdGhlIHNhbWUgYWRkcmVzcyBsaXN0ICovXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yLCBudWxsLCB7fSk7XG4gICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdXRpb24gZXJyb3IgZm9yIHRhcmdldCAnICtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qIElmIHRoZXJlIGFscmVhZHkgaXMgYSBzdGlsbC1wZW5kaW5nIFRYVCByZXNvbHV0aW9uLCB3ZSBjYW4ganVzdCB1c2VcbiAgICAgICAgICAgICAqIHRoYXQgcmVzdWx0IHdoZW4gaXQgY29tZXMgaW4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgJiYgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8qIFdlIGhhbmRsZSB0aGUgVFhUIHF1ZXJ5IHByb21pc2UgZGlmZmVyZW50bHkgdGhhbiB0aGUgb3RoZXJzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgKiB0aGUgbmFtZSByZXNvbHV0aW9uIGF0dGVtcHQgYXMgYSB3aG9sZSBpcyBhIHN1Y2Nlc3MgZXZlbiBpZiB0aGUgVFhUXG4gICAgICAgICAgICAgICAgICogbG9va3VwIGZhaWxzICovXG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9IHJlc29sdmVUeHRQcm9taXNlKGhvc3RuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlLnRoZW4odHh0UmVjb3JkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9ICgwLCBzZXJ2aWNlX2NvbmZpZ18xLmV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnKSh0eHRSZWNvcmQsIHRoaXMucGVyY2VudGFnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBQYXJzaW5nIHNlcnZpY2UgY29uZmlnIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBXZSByZWx5IGhlcmUgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICogaWRlbnRpY2FsIHBhcmFtZXRlcnMgd2lsbCBiZSBlc3NlbnRpYWx5IGlkZW1wb3RlbnQsIGFuZCBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB3aXRoIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCBhbmQgYSBkaWZmZXJlbnQgc2VydmljZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCByZXN1bHQgaW4gYSBmYXN0IGFuZCBzZWFtbGVzcyBzd2l0Y2hvdmVyLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yLCBudWxsLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiBUWFQgbG9va3VwIGZhaWxzIHdlIHNob3VsZCBkbyBub3RoaW5nLCB3aGljaCBtZWFucyB0aGF0IHdlXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnRpbnVlIHRvIHVzZSB0aGUgcmVzdWx0IG9mIHRoZSBtb3N0IHJlY2VudCBzdWNjZXNzZnVsIGxvb2t1cCxcbiAgICAgICAgICAgICAgICAgICAgICogb3IgdGhlIGRlZmF1bHQgbnVsbCBjb25maWcgb2JqZWN0IGlmIHRoZXJlIGhhcyBuZXZlciBiZWVuIGFcbiAgICAgICAgICAgICAgICAgICAgICogc3VjY2Vzc2Z1bCBsb29rdXAuIFdlIGRvIG5vdCBzZXQgdGhlIGxhdGVzdFNlcnZpY2VDb25maWdFcnJvclxuICAgICAgICAgICAgICAgICAgICAgKiBoZXJlIGJlY2F1c2UgdGhhdCBpcyBzcGVjaWZpY2FsbHkgdXNlZCBmb3IgcmVzcG9uc2UgdmFsaWRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiBlcnJvcnMuIFdlIHN0aWxsIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXJyb3Igc28gdGhhdCBpdCBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgKiBidWJibGUgdXAgYXMgYW4gdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uLiAqL1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0TmV4dFJlc29sdXRpb25UaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMubmV4dFJlc29sdXRpb25UaW1lciA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGludWVSZXNvbHZpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMubWluVGltZUJldHdlZW5SZXNvbHV0aW9uc01zKSkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucnVuT25jZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgLyogSWYgdGhlcmUgaXMgYSBwZW5kaW5nIGxvb2t1cCwganVzdCBsZXQgaXQgZmluaXNoLiBPdGhlcndpc2UsIGlmIHRoZVxuICAgICAgICAgKiBuZXh0UmVzb2x1dGlvblRpbWVyIG9yIGJhY2tvZmYgdGltZXIgaXMgcnVubmluZywgc2V0IHRoZVxuICAgICAgICAgKiBjb250aW51ZVJlc29sdmluZyBmbGFnIHRvIHJlc29sdmUgd2hlbiB3aGljaGV2ZXIgb2YgdGhvc2UgdGltZXJzXG4gICAgICAgICAqIGZpcmVzLiBPdGhlcndpc2UsIHN0YXJ0IHJlc29sdmluZyBpbW1lZGlhdGVseS4gKi9cbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgfHwgdGhpcy5iYWNrb2ZmLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZykge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVzb2x1dGlvbiB1cGRhdGUgZGVsYXllZCBieSBcIm1pbiB0aW1lIGJldHdlZW4gcmVzb2x1dGlvbnNcIiByYXRlIGxpbWl0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVzb2x1dGlvbiB1cGRhdGUgZGVsYXllZCBieSBiYWNrb2ZmIHRpbWVyIHVudGlsICcgKyB0aGlzLmJhY2tvZmYuZ2V0RW5kVGltZSgpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcmVzb2x2ZXIgdG8gdGhlIHNhbWUgc3RhdGUgaXQgaGFkIHdoZW4gaXQgd2FzIGNyZWF0ZWQuIEluLWZsaWdodFxuICAgICAqIEROUyByZXF1ZXN0cyBjYW5ub3QgYmUgY2FuY2VsbGVkLCBidXQgdGhleSBhcmUgZGlzY2FyZGVkIGFuZCB0aGVpciByZXN1bHRzXG4gICAgICogd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBnaXZlbiB0YXJnZXQuIEZvciBJUCB0YXJnZXRzLCB0aGF0IGlzXG4gICAgICogdGhlIElQIGFkZHJlc3MuIEZvciBETlMgdGFyZ2V0cywgaXQgaXMgdGhlIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSB0YXJnZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHVwIHRoZSBETlMgcmVzb2x2ZXIgY2xhc3MgYnkgcmVnaXN0ZXJpbmcgaXQgYXMgdGhlIGhhbmRsZXIgZm9yIHRoZVxuICogXCJkbnM6XCIgcHJlZml4IGFuZCBhcyB0aGUgZGVmYXVsdCByZXNvbHZlci5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoJ2RucycsIERuc1Jlc29sdmVyKTtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlckRlZmF1bHRTY2hlbWUpKCdkbnMnKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWRucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'ip_resolver';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = 'ipv4';\nconst IPV6_SCHEME = 'ipv6';\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions) {\n        var _a;\n        this.listener = listener;\n        this.addresses = [];\n        this.error = null;\n        this.hasReturnedResult = false;\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata(),\n            };\n            return;\n        }\n        const pathList = target.path.split(',');\n        for (const path of pathList) {\n            const hostPort = (0, uri_parser_1.splitHostPort)(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata(),\n                };\n                return;\n            }\n            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||\n                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata(),\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\n            });\n        }\n        this.addresses = addresses;\n        trace('Parsed ' + target.scheme + ' address list ' + this.addresses);\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(() => {\n                if (this.error) {\n                    this.listener.onError(this.error);\n                }\n                else {\n                    this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});\n                }\n            });\n        }\n    }\n    destroy() {\n        this.hasReturnedResult = false;\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(',')[0];\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);\n    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-ip.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci1pcC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLDJGQUFjO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxVQUFVLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlLFVBQVUsS0FBSztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkY7QUFDN0Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWlwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSB2b2lkIDA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2lwX3Jlc29sdmVyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgSVBWNF9TQ0hFTUUgPSAnaXB2NCc7XG5jb25zdCBJUFY2X1NDSEVNRSA9ICdpcHY2Jztcbi8qKlxuICogVGhlIGRlZmF1bHQgVENQIHBvcnQgdG8gY29ubmVjdCB0byBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlIHRhcmdldC5cbiAqL1xuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xuY2xhc3MgSXBSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gW107XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIHRyYWNlKCdSZXNvbHZlciBjb25zdHJ1Y3RlZCBmb3IgdGFyZ2V0ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpKTtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gW107XG4gICAgICAgIGlmICghKHRhcmdldC5zY2hlbWUgPT09IElQVjRfU0NIRU1FIHx8IHRhcmdldC5zY2hlbWUgPT09IElQVjZfU0NIRU1FKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFVucmVjb2duaXplZCBzY2hlbWUgJHt0YXJnZXQuc2NoZW1lfSBpbiBJUCByZXNvbHZlcmAsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGhMaXN0ID0gdGFyZ2V0LnBhdGguc3BsaXQoJywnKTtcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkocGF0aCk7XG4gICAgICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgJHt0YXJnZXQuc2NoZW1lfSBhZGRyZXNzICR7cGF0aH1gLFxuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNF9TQ0hFTUUgJiYgISgwLCBuZXRfMS5pc0lQdjQpKGhvc3RQb3J0Lmhvc3QpKSB8fFxuICAgICAgICAgICAgICAgICh0YXJnZXQuc2NoZW1lID09PSBJUFY2X1NDSEVNRSAmJiAhKDAsIG5ldF8xLmlzSVB2NikoaG9zdFBvcnQuaG9zdCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlICR7dGFyZ2V0LnNjaGVtZX0gYWRkcmVzcyAke3BhdGh9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRyZXNzZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaG9zdDogaG9zdFBvcnQuaG9zdCxcbiAgICAgICAgICAgICAgICBwb3J0OiAoX2EgPSBob3N0UG9ydC5wb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1BPUlQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IGFkZHJlc3NlcztcbiAgICAgICAgdHJhY2UoJ1BhcnNlZCAnICsgdGFyZ2V0LnNjaGVtZSArICcgYWRkcmVzcyBsaXN0ICcgKyB0aGlzLmFkZHJlc3Nlcyk7XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3IodGhpcy5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5hZGRyZXNzZXMsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnBhdGguc3BsaXQoJywnKVswXTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICAoMCwgcmVzb2x2ZXJfMS5yZWdpc3RlclJlc29sdmVyKShJUFY0X1NDSEVNRSwgSXBSZXNvbHZlcik7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoSVBWNl9TQ0hFTUUsIElwUmVzb2x2ZXIpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItaXAuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions) {\n        this.listener = listener;\n        this.addresses = [];\n        this.hasReturnedResult = false;\n        let path;\n        if (target.authority === '') {\n            path = '/' + target.path;\n        }\n        else {\n            path = target.path;\n        }\n        this.addresses = [{ path }];\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});\n        }\n    }\n    destroy() {\n        // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return 'localhost';\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)('unix', UdsResolver);\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-uds.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci11ZHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSB2b2lkIDA7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jbGFzcyBVZHNSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBsaXN0ZW5lciwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFtdO1xuICAgICAgICB0aGlzLmhhc1JldHVybmVkUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGxldCBwYXRoO1xuICAgICAgICBpZiAodGFyZ2V0LmF1dGhvcml0eSA9PT0gJycpIHtcbiAgICAgICAgICAgIHBhdGggPSAnLycgKyB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdGggPSB0YXJnZXQucGF0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFt7IHBhdGggfV07XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgdGhpcy5hZGRyZXNzZXMsIG51bGwsIG51bGwsIG51bGwsIHt9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBUaGlzIHJlc29sdmVyIG93bnMgbm8gcmVzb3VyY2VzLCBzbyB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gJ2xvY2FsaG9zdCc7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoJ3VuaXgnLCBVZHNSZXNvbHZlcik7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci11ZHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nfunction registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nfunction registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nfunction createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    }\n    else {\n        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nfunction getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    }\n    else {\n        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: (0, uri_parser_1.uriToString)(target),\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLDJCQUEyQixHQUFHLHNCQUFzQixHQUFHLDZCQUE2QixHQUFHLHdCQUF3QjtBQUM3SSxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLHNDQUFzQztBQUN6RztBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNDQUFzQztBQUNoRjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWFwVXJpRGVmYXVsdFNjaGVtZSA9IGV4cG9ydHMuZ2V0RGVmYXVsdEF1dGhvcml0eSA9IGV4cG9ydHMuY3JlYXRlUmVzb2x2ZXIgPSBleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IHZvaWQgMDtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCByZWdpc3RlcmVkUmVzb2x2ZXJzID0ge307XG5sZXQgZGVmYXVsdFNjaGVtZSA9IG51bGw7XG4vKipcbiAqIFJlZ2lzdGVyIGEgcmVzb2x2ZXIgY2xhc3MgdG8gaGFuZGxlIHRhcmdldCBuYW1lcyBwcmVmaXhlZCB3aXRoIHRoZSBgcHJlZml4YFxuICogc3RyaW5nLiBUaGlzIHByZWZpeCBzaG91bGQgY29ycmVzcG9uZCB0byBhIFVSSSBzY2hlbWUgbmFtZSBsaXN0ZWQgaW4gdGhlXG4gKiBbZ1JQQyBOYW1lIFJlc29sdXRpb24gZG9jdW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL25hbWluZy5tZClcbiAqIEBwYXJhbSBwcmVmaXhcbiAqIEBwYXJhbSByZXNvbHZlckNsYXNzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVzb2x2ZXIoc2NoZW1lLCByZXNvbHZlckNsYXNzKSB7XG4gICAgcmVnaXN0ZXJlZFJlc29sdmVyc1tzY2hlbWVdID0gcmVzb2x2ZXJDbGFzcztcbn1cbmV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IHJlZ2lzdGVyUmVzb2x2ZXI7XG4vKipcbiAqIFJlZ2lzdGVyIGEgZGVmYXVsdCByZXNvbHZlciB0byBoYW5kbGUgdGFyZ2V0IG5hbWVzIHRoYXQgZG8gbm90IHN0YXJ0IHdpdGhcbiAqIGFueSByZWdpc3RlcmVkIHByZWZpeC5cbiAqIEBwYXJhbSByZXNvbHZlckNsYXNzXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdFNjaGVtZShzY2hlbWUpIHtcbiAgICBkZWZhdWx0U2NoZW1lID0gc2NoZW1lO1xufVxuZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRTY2hlbWUgPSByZWdpc3RlckRlZmF1bHRTY2hlbWU7XG4vKipcbiAqIENyZWF0ZSBhIG5hbWUgcmVzb2x2ZXIgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LCBpZiBwb3NzaWJsZS4gVGhyb3dzIGFuXG4gKiBlcnJvciBpZiBubyBzdWNoIG5hbWUgcmVzb2x2ZXIgY2FuIGJlIGNyZWF0ZWQuXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKiBAcGFyYW0gbGlzdGVuZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIodGFyZ2V0LCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGlmICh0YXJnZXQuc2NoZW1lICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnNjaGVtZSBpbiByZWdpc3RlcmVkUmVzb2x2ZXJzKSB7XG4gICAgICAgIHJldHVybiBuZXcgcmVnaXN0ZXJlZFJlc29sdmVyc1t0YXJnZXQuc2NoZW1lXSh0YXJnZXQsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcmVzb2x2ZXIgY291bGQgYmUgY3JlYXRlZCBmb3IgdGFyZ2V0ICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KX1gKTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZVJlc29sdmVyID0gY3JlYXRlUmVzb2x2ZXI7XG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LCBpZiBwb3NzaWJsZS4gVGhyb3dzIGFuXG4gKiBlcnJvciBpZiBubyByZWdpc3RlcmVkIG5hbWUgcmVzb2x2ZXIgY2FuIHBhcnNlIHRoYXQgdGFyZ2V0IHN0cmluZy5cbiAqIEBwYXJhbSB0YXJnZXRcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFJlc29sdmVyc1t0YXJnZXQuc2NoZW1lXS5nZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFyZ2V0ICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KX1gKTtcbiAgICB9XG59XG5leHBvcnRzLmdldERlZmF1bHRBdXRob3JpdHkgPSBnZXREZWZhdWx0QXV0aG9yaXR5O1xuZnVuY3Rpb24gbWFwVXJpRGVmYXVsdFNjaGVtZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gdW5kZWZpbmVkIHx8ICEodGFyZ2V0LnNjaGVtZSBpbiByZWdpc3RlcmVkUmVzb2x2ZXJzKSkge1xuICAgICAgICBpZiAoZGVmYXVsdFNjaGVtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzY2hlbWU6IGRlZmF1bHRTY2hlbWUsXG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcGF0aDogKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0cy5tYXBVcmlEZWZhdWx0U2NoZW1lID0gbWFwVXJpRGVmYXVsdFNjaGVtZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-call.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResolvingCall = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst TRACER_NAME = 'resolving_call';\nclass ResolvingCall {\n    constructor(channel, method, options, filterStackFactory, credentials, callNumber) {\n        this.channel = channel;\n        this.method = method;\n        this.filterStackFactory = filterStackFactory;\n        this.credentials = credentials;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.readFilterPending = false;\n        this.writeFilterPending = false;\n        this.pendingChildStatus = null;\n        this.metadata = null;\n        this.listener = null;\n        this.statusWatchers = [];\n        this.deadlineTimer = setTimeout(() => { }, 0);\n        this.filterStack = null;\n        this.deadline = options.deadline;\n        this.host = options.host;\n        if (options.parentCall) {\n            if (options.flags & constants_1.Propagate.CANCELLATION) {\n                options.parentCall.on('cancelled', () => {\n                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n                });\n            }\n            if (options.flags & constants_1.Propagate.DEADLINE) {\n                this.trace('Propagating deadline from parent: ' +\n                    options.parentCall.getDeadline());\n                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\n            }\n        }\n        this.trace('Created');\n        this.runDeadlineTimer();\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    runDeadlineTimer() {\n        clearTimeout(this.deadlineTimer);\n        this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));\n        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\n        if (timeout !== Infinity) {\n            this.trace('Deadline will be reached in ' + timeout + 'ms');\n            const handleDeadline = () => {\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n            };\n            if (timeout <= 0) {\n                process.nextTick(handleDeadline);\n            }\n            else {\n                this.deadlineTimer = setTimeout(handleDeadline, timeout);\n            }\n        }\n    }\n    outputStatus(status) {\n        if (!this.ended) {\n            this.ended = true;\n            if (!this.filterStack) {\n                this.filterStack = this.filterStackFactory.createFilter();\n            }\n            clearTimeout(this.deadlineTimer);\n            const filteredStatus = this.filterStack.receiveTrailers(status);\n            this.trace('ended with status: code=' +\n                filteredStatus.code +\n                ' details=\"' +\n                filteredStatus.details +\n                '\"');\n            this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n            process.nextTick(() => {\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n        }\n    }\n    sendMessageOnChild(context, message) {\n        if (!this.child) {\n            throw new Error('sendMessageonChild called with child not populated');\n        }\n        const child = this.child;\n        this.writeFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {\n            this.writeFilterPending = false;\n            child.sendMessageWithContext(context, filteredMessage.message);\n            if (this.pendingHalfClose) {\n                child.halfClose();\n            }\n        }, (status) => {\n            this.cancelWithStatus(status.code, status.details);\n        });\n    }\n    getConfig() {\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata || !this.listener) {\n            throw new Error('getConfig called before start');\n        }\n        const configResult = this.channel.getConfig(this.method, this.metadata);\n        if (configResult.type === 'NONE') {\n            this.channel.queueCallForConfig(this);\n            return;\n        }\n        else if (configResult.type === 'ERROR') {\n            if (this.metadata.getOptions().waitForReady) {\n                this.channel.queueCallForConfig(this);\n            }\n            else {\n                this.outputStatus(configResult.error);\n            }\n            return;\n        }\n        // configResult.type === 'SUCCESS'\n        const config = configResult.config;\n        if (config.status !== constants_1.Status.OK) {\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);\n            this.outputStatus({\n                code: code,\n                details: details,\n                metadata: new metadata_1.Metadata(),\n            });\n            return;\n        }\n        if (config.methodConfig.timeout) {\n            const configDeadline = new Date();\n            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\n            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +\n                config.methodConfig.timeout.nanos / 1000000);\n            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\n            this.runDeadlineTimer();\n        }\n        this.filterStackFactory.push(config.dynamicFilterFactories);\n        this.filterStack = this.filterStackFactory.createFilter();\n        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {\n            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);\n            this.trace('Created child [' + this.child.getCallNumber() + ']');\n            this.child.start(filteredMetadata, {\n                onReceiveMetadata: metadata => {\n                    this.trace('Received metadata');\n                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\n                },\n                onReceiveMessage: message => {\n                    this.trace('Received message');\n                    this.readFilterPending = true;\n                    this.filterStack.receiveMessage(message).then(filteredMesssage => {\n                        this.trace('Finished filtering received message');\n                        this.readFilterPending = false;\n                        this.listener.onReceiveMessage(filteredMesssage);\n                        if (this.pendingChildStatus) {\n                            this.outputStatus(this.pendingChildStatus);\n                        }\n                    }, (status) => {\n                        this.cancelWithStatus(status.code, status.details);\n                    });\n                },\n                onReceiveStatus: status => {\n                    this.trace('Received status');\n                    if (this.readFilterPending) {\n                        this.pendingChildStatus = status;\n                    }\n                    else {\n                        this.outputStatus(status);\n                    }\n                },\n            });\n            if (this.readPending) {\n                this.child.startRead();\n            }\n            if (this.pendingMessage) {\n                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n            }\n            else if (this.pendingHalfClose) {\n                this.child.halfClose();\n            }\n        }, (status) => {\n            this.outputStatus(status);\n        });\n    }\n    reportResolverError(status) {\n        var _a;\n        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n            this.channel.queueCallForConfig(this);\n        }\n        else {\n            this.outputStatus(status);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata(),\n        });\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.metadata = metadata.clone();\n        this.listener = listener;\n        this.getConfig();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        if (this.child) {\n            this.sendMessageOnChild(context, message);\n        }\n        else {\n            this.pendingMessage = { context, message };\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        if (this.child) {\n            this.child.startRead();\n        }\n        else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        if (this.child && !this.writeFilterPending) {\n            this.child.halfClose();\n        }\n        else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        this.credentials = this.credentials.compose(credentials);\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.ResolvingCall = ResolvingCall;\n//# sourceMappingURL=resolving-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQixvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQywrQkFBK0IsbUJBQU8sQ0FBQywrR0FBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdDQUF3QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2aW5nQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZGVhZGxpbmVfMSA9IHJlcXVpcmUoXCIuL2RlYWRsaW5lXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyZXNvbHZpbmdfY2FsbCc7XG5jbGFzcyBSZXNvbHZpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBtZXRob2QsIG9wdGlvbnMsIGZpbHRlclN0YWNrRmFjdG9yeSwgY3JlZGVudGlhbHMsIGNhbGxOdW1iZXIpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gZmlsdGVyU3RhY2tGYWN0b3J5O1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuY2FsbE51bWJlciA9IGNhbGxOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBvcHRpb25zLmRlYWRsaW5lO1xuICAgICAgICB0aGlzLmhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgICAgIGlmIChvcHRpb25zLnBhcmVudENhbGwpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkNBTkNFTExBVElPTikge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyZW50Q2FsbC5vbignY2FuY2VsbGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBieSBwYXJlbnQgY2FsbCcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmxhZ3MgJiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuREVBRExJTkUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQcm9wYWdhdGluZyBkZWFkbGluZSBmcm9tIHBhcmVudDogJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGFyZW50Q2FsbC5nZXREZWFkbGluZSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gKDAsIGRlYWRsaW5lXzEubWluRGVhZGxpbmUpKHRoaXMuZGVhZGxpbmUsIG9wdGlvbnMucGFyZW50Q2FsbC5nZXREZWFkbGluZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkJyk7XG4gICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ1snICsgdGhpcy5jYWxsTnVtYmVyICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICBydW5EZWFkbGluZVRpbWVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWFkbGluZVRpbWVyKTtcbiAgICAgICAgdGhpcy50cmFjZSgnRGVhZGxpbmU6ICcgKyAoMCwgZGVhZGxpbmVfMS5kZWFkbGluZVRvU3RyaW5nKSh0aGlzLmRlYWRsaW5lKSk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoMCwgZGVhZGxpbmVfMS5nZXRSZWxhdGl2ZVRpbWVvdXQpKHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICBpZiAodGltZW91dCAhPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ0RlYWRsaW5lIHdpbGwgYmUgcmVhY2hlZCBpbiAnICsgdGltZW91dCArICdtcycpO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlRGVhZGxpbmUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soaGFuZGxlRGVhZGxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dChoYW5kbGVEZWFkbGluZSwgdGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0U3RhdHVzKHN0YXR1cykge1xuICAgICAgICBpZiAoIXRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZpbHRlclN0YWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJlZFN0YXR1cyA9IHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZVRyYWlsZXJzKHN0YXR1cyk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5jb2RlICtcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5kZXRhaWxzICtcbiAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMuZm9yRWFjaCh3YXRjaGVyID0+IHdhdGNoZXIoZmlsdGVyZWRTdGF0dXMpKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbHRlcmVkU3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlT25DaGlsZChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZW5kTWVzc2FnZW9uQ2hpbGQgY2FsbGVkIHdpdGggY2hpbGQgbm90IHBvcHVsYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGlsZDtcbiAgICAgICAgdGhpcy53cml0ZUZpbHRlclBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnNlbmRNZXNzYWdlKFByb21pc2UucmVzb2x2ZSh7IG1lc3NhZ2U6IG1lc3NhZ2UsIGZsYWdzOiBjb250ZXh0LmZsYWdzIH0pKS50aGVuKGZpbHRlcmVkTWVzc2FnZSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBmaWx0ZXJlZE1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29uZmlnKCkge1xuICAgICAgICBpZiAodGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tZXRhZGF0YSB8fCAhdGhpcy5saXN0ZW5lcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRDb25maWcgY2FsbGVkIGJlZm9yZSBzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IHRoaXMuY2hhbm5lbC5nZXRDb25maWcodGhpcy5tZXRob2QsIHRoaXMubWV0YWRhdGEpO1xuICAgICAgICBpZiAoY29uZmlnUmVzdWx0LnR5cGUgPT09ICdOT05FJykge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWdSZXN1bHQudHlwZSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JDb25maWcodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhjb25maWdSZXN1bHQuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbmZpZ1Jlc3VsdC50eXBlID09PSAnU1VDQ0VTUydcbiAgICAgICAgY29uc3QgY29uZmlnID0gY29uZmlnUmVzdWx0LmNvbmZpZztcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0dXMgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKGNvbmZpZy5zdGF0dXMsICdGYWlsZWQgdG8gcm91dGUgY2FsbCB0byBtZXRob2QgJyArIHRoaXMubWV0aG9kKTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0KSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWdEZWFkbGluZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25maWdEZWFkbGluZS5zZXRTZWNvbmRzKGNvbmZpZ0RlYWRsaW5lLmdldFNlY29uZHMoKSArIGNvbmZpZy5tZXRob2RDb25maWcudGltZW91dC5zZWNvbmRzKTtcbiAgICAgICAgICAgIGNvbmZpZ0RlYWRsaW5lLnNldE1pbGxpc2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRNaWxsaXNlY29uZHMoKSArXG4gICAgICAgICAgICAgICAgY29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0Lm5hbm9zIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gKDAsIGRlYWRsaW5lXzEubWluRGVhZGxpbmUpKHRoaXMuZGVhZGxpbmUsIGNvbmZpZ0RlYWRsaW5lKTtcbiAgICAgICAgICAgIHRoaXMucnVuRGVhZGxpbmVUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LnB1c2goY29uZmlnLmR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMpO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2suc2VuZE1ldGFkYXRhKFByb21pc2UucmVzb2x2ZSh0aGlzLm1ldGFkYXRhKSkudGhlbihmaWx0ZXJlZE1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQgPSB0aGlzLmNoYW5uZWwuY3JlYXRlSW5uZXJDYWxsKGNvbmZpZywgdGhpcy5tZXRob2QsIHRoaXMuaG9zdCwgdGhpcy5jcmVkZW50aWFscywgdGhpcy5kZWFkbGluZSk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIFsnICsgdGhpcy5jaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydChmaWx0ZXJlZE1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSh0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkRmlsdGVyUGVuZGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkudGhlbihmaWx0ZXJlZE1lc3NzYWdlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZpbmlzaGVkIGZpbHRlcmluZyByZWNlaXZlZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UoZmlsdGVyZWRNZXNzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc3RhdHVzJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRGaWx0ZXJQZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkUGVuZGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VPbkNoaWxkKHRoaXMucGVuZGluZ01lc3NhZ2UuY29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIChzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXBvcnRSZXNvbHZlckVycm9yKHN0YXR1cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvckNvbmZpZyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgY29kZTogc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGEuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmdldENvbmZpZygpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kTWVzc2FnZU9uQ2hpbGQoY29udGV4dCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0geyBjb250ZXh0LCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydFJlYWQgY2FsbGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkICYmICF0aGlzLndyaXRlRmlsdGVyUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IHRoaXMuY3JlZGVudGlhbHMuY29tcG9zZShjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIGFkZFN0YXR1c1dhdGNoZXIod2F0Y2hlcikge1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLnB1c2god2F0Y2hlcik7XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxOdW1iZXI7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZpbmdDYWxsID0gUmVzb2x2aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmluZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * Name match levels in order from most to least specific. This is the order in\n * which searches will be performed.\n */\nconst NAME_MATCH_LEVEL_ORDER = [\n    'SERVICE_AND_METHOD',\n    'SERVICE',\n    'EMPTY',\n];\nfunction hasMatchingName(service, method, methodConfig, matchLevel) {\n    for (const name of methodConfig.name) {\n        switch (matchLevel) {\n            case 'EMPTY':\n                if (!name.service && !name.method) {\n                    return true;\n                }\n                break;\n            case 'SERVICE':\n                if (name.service === service && !name.method) {\n                    return true;\n                }\n                break;\n            case 'SERVICE_AND_METHOD':\n                if (name.service === service && name.method === method) {\n                    return true;\n                }\n        }\n    }\n    return false;\n}\nfunction findMatchingConfig(service, method, methodConfigs, matchLevel) {\n    for (const config of methodConfigs) {\n        if (hasMatchingName(service, method, config, matchLevel)) {\n            return config;\n        }\n    }\n    return null;\n}\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split('/').filter(x => x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n        if (serviceConfig && serviceConfig.methodConfig) {\n            /* Check for the following in order, and return the first method\n             * config that matches:\n             * 1. A name that exactly matches the service and method\n             * 2. A name with no method set that matches the service\n             * 3. An empty name\n             */\n            for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {\n                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);\n                if (matchingConfig) {\n                    return {\n                        methodConfig: matchingConfig,\n                        pickInformation: {},\n                        status: constants_1.Status.OK,\n                        dynamicFilterFactories: [],\n                    };\n                }\n            }\n        }\n        return {\n            methodConfig: { name: [] },\n            pickInformation: {},\n            status: constants_1.Status.OK,\n            dynamicFilterFactories: [],\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */\n    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */\n        this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */\n        this.continueResolving = false;\n        if (channelOptions['grpc.service_config']) {\n            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));\n        }\n        else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: [],\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: () => {\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */\n                if (this.backoffTimeout.isRunning()) {\n                    trace('requestReresolution delayed by backoff timer until ' + this.backoffTimeout.getEndTime().toISOString());\n                    this.continueResolving = true;\n                }\n                else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker) => {\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),\n        });\n        this.innerResolver = (0, resolver_1.createResolver)(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n                var _a;\n                this.backoffTimeout.stop();\n                this.backoffTimeout.reset();\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */\n                if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    }\n                    else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        }\n                        else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                }\n                else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = (0, load_balancer_1.getFirstUsableConfig)(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: 'All load balancer options in service config are not compatible',\n                        metadata: new metadata_1.Metadata(),\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error) => {\n                this.handleResolutionFailure(error);\n            },\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            }\n            else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker) {\n        trace((0, uri_parser_1.uriToString)(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||\n            this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.backoffTimeout.reset();\n        this.backoffTimeout.stop();\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.previousServiceConfig = null;\n        this.continueResolving = false;\n    }\n    getTypeName() {\n        return 'resolving_load_balancer';\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\n//# sourceMappingURL=resolving-load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZpbmctbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qix3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQseUJBQXlCLG1CQUFPLENBQUMsbUdBQWtCO0FBQ25ELDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxtRkFBVTtBQUNuQywwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBbUI7QUFDckQsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsdUZBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0Msc0NBQXNDLG1CQUFPLENBQUMsNkhBQStCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZpbmctbG9hZC1iYWxhbmNlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3Qgc2VydmljZV9jb25maWdfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2UtY29uZmlnXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG4vKipcbiAqIE5hbWUgbWF0Y2ggbGV2ZWxzIGluIG9yZGVyIGZyb20gbW9zdCB0byBsZWFzdCBzcGVjaWZpYy4gVGhpcyBpcyB0aGUgb3JkZXIgaW5cbiAqIHdoaWNoIHNlYXJjaGVzIHdpbGwgYmUgcGVyZm9ybWVkLlxuICovXG5jb25zdCBOQU1FX01BVENIX0xFVkVMX09SREVSID0gW1xuICAgICdTRVJWSUNFX0FORF9NRVRIT0QnLFxuICAgICdTRVJWSUNFJyxcbiAgICAnRU1QVFknLFxuXTtcbmZ1bmN0aW9uIGhhc01hdGNoaW5nTmFtZShzZXJ2aWNlLCBtZXRob2QsIG1ldGhvZENvbmZpZywgbWF0Y2hMZXZlbCkge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xuICAgICAgICBzd2l0Y2ggKG1hdGNoTGV2ZWwpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VNUFRZJzpcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUuc2VydmljZSAmJiAhbmFtZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU0VSVklDRSc6XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc2VydmljZSA9PT0gc2VydmljZSAmJiAhbmFtZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnU0VSVklDRV9BTkRfTUVUSE9EJzpcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZXJ2aWNlICYmIG5hbWUubWV0aG9kID09PSBtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIG1ldGhvZENvbmZpZ3MsIG1hdGNoTGV2ZWwpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBtZXRob2RDb25maWdzKSB7XG4gICAgICAgIGlmIChoYXNNYXRjaGluZ05hbWUoc2VydmljZSwgbWV0aG9kLCBjb25maWcsIG1hdGNoTGV2ZWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yKHNlcnZpY2VDb25maWcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVmYXVsdENvbmZpZ1NlbGVjdG9yKG1ldGhvZE5hbWUsIG1ldGFkYXRhKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHNwbGl0TmFtZSA9IG1ldGhvZE5hbWUuc3BsaXQoJy8nKS5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDApO1xuICAgICAgICBjb25zdCBzZXJ2aWNlID0gKF9hID0gc3BsaXROYW1lWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKF9iID0gc3BsaXROYW1lWzFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgJiYgc2VydmljZUNvbmZpZy5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgIC8qIENoZWNrIGZvciB0aGUgZm9sbG93aW5nIGluIG9yZGVyLCBhbmQgcmV0dXJuIHRoZSBmaXJzdCBtZXRob2RcbiAgICAgICAgICAgICAqIGNvbmZpZyB0aGF0IG1hdGNoZXM6XG4gICAgICAgICAgICAgKiAxLiBBIG5hbWUgdGhhdCBleGFjdGx5IG1hdGNoZXMgdGhlIHNlcnZpY2UgYW5kIG1ldGhvZFxuICAgICAgICAgICAgICogMi4gQSBuYW1lIHdpdGggbm8gbWV0aG9kIHNldCB0aGF0IG1hdGNoZXMgdGhlIHNlcnZpY2VcbiAgICAgICAgICAgICAqIDMuIEFuIGVtcHR5IG5hbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZm9yIChjb25zdCBtYXRjaExldmVsIG9mIE5BTUVfTUFUQ0hfTEVWRUxfT1JERVIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGluZ0NvbmZpZyA9IGZpbmRNYXRjaGluZ0NvbmZpZyhzZXJ2aWNlLCBtZXRob2QsIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnLCBtYXRjaExldmVsKTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hpbmdDb25maWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogbWF0Y2hpbmdDb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwaWNrSW5mb3JtYXRpb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICAgICAgICAgICAgICBkeW5hbWljRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZENvbmZpZzogeyBuYW1lOiBbXSB9LFxuICAgICAgICAgICAgcGlja0luZm9ybWF0aW9uOiB7fSxcbiAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgIH07XG4gICAgfTtcbn1cbmNsYXNzIFJlc29sdmluZ0xvYWRCYWxhbmNlciB7XG4gICAgLyoqXG4gICAgICogV3JhcHBlciBjbGFzcyB0aGF0IGJlaGF2ZXMgbGlrZSBhIGBMb2FkQmFsYW5jZXJgIGFuZCBhbHNvIGhhbmRsZXMgbmFtZVxuICAgICAqIHJlc29sdXRpb24gaW50ZXJuYWxseS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBhZGRyZXNzIG9mIHRoZSBiYWNrZW5kIHRvIGNvbm5lY3QgdG8uXG4gICAgICogQHBhcmFtIGNoYW5uZWxDb250cm9sSGVscGVyIGBDaGFubmVsQ29udHJvbEhlbHBlcmAgaW5zdGFuY2UgcHJvdmlkZWQgYnlcbiAgICAgKiAgICAgdGhpcyBsb2FkIGJhbGFuY2VyJ3Mgb3duZXIuXG4gICAgICogQHBhcmFtIGRlZmF1bHRTZXJ2aWNlQ29uZmlnIFRoZSBkZWZhdWx0IHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byBiZSB1c2VkXG4gICAgICogICAgIGlmIG5vbmUgaXMgcHJvdmlkZWQgYnkgdGhlIG5hbWUgcmVzb2x2ZXIuIEEgYG51bGxgIHZhbHVlIGluZGljYXRlc1xuICAgICAqICAgICB0aGF0IHRoZSBkZWZhdWx0IGJlaGF2aW9yIHNob3VsZCBiZSB0aGUgZGVmYXVsdCB1bmNvbmZpZ3VyZWQgYmVoYXZpb3IuXG4gICAgICogICAgIEluIHByYWN0aWNlLCB0aGF0IG1lYW5zIHVzaW5nIHRoZSBcInBpY2sgZmlyc3RcIiBsb2FkIGJhbGFuY2VyXG4gICAgICogICAgIGltcGxtZW50YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBjaGFubmVsT3B0aW9ucywgb25TdWNjZXNzZnVsUmVzb2x1dGlvbiwgb25GYWlsZWRSZXNvbHV0aW9uKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyID0gY2hhbm5lbENvbnRyb2xIZWxwZXI7XG4gICAgICAgIHRoaXMub25TdWNjZXNzZnVsUmVzb2x1dGlvbiA9IG9uU3VjY2Vzc2Z1bFJlc29sdXRpb247XG4gICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uID0gb25GYWlsZWRSZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLmxhdGVzdENoaWxkUGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyByZXNvbHZpbmcgbG9hZCBiYWxhbmNlcidzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlcnZpY2UgY29uZmlnIG9iamVjdCBmcm9tIHRoZSBsYXN0IHN1Y2Nlc3NmdWwgcmVzb2x1dGlvbiwgaWZcbiAgICAgICAgICogYXZhaWxhYmxlLiBBIHZhbHVlIG9mIG51bGwgaW5kaWNhdGVzIHRoYXQgd2UgaGF2ZSBub3QgeWV0IHJlY2VpdmVkIGEgdmFsaWRcbiAgICAgICAgICogc2VydmljZSBjb25maWcgZnJvbSB0aGUgcmVzb2x2ZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB3ZSBzaG91bGQgYXR0ZW1wdCB0byByZXNvbHZlIGFnYWluIGFmdGVyIHRoZSBiYWNrb2ZmXG4gICAgICAgICAqIHRpbWVyIHJ1bnMgb3V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWcnXSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZyA9ICgwLCBzZXJ2aWNlX2NvbmZpZ18xLnZhbGlkYXRlU2VydmljZUNvbmZpZykoSlNPTi5wYXJzZShjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZyddKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlciA9IG5ldyBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXIoe1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZlRpbWVvdXQgaXMgcnVubmluZywgd2UncmUgc3RpbGwgYmFja2luZyBvZmYgZnJvbVxuICAgICAgICAgICAgICAgICAqIG1ha2luZyByZXNvbHZlIHJlcXVlc3RzLCBzbyB3ZSBzaG91bGRuJ3QgbWFrZSBhbm90aGVyIG9uZSBoZXJlLlxuICAgICAgICAgICAgICAgICAqIEluIHRoYXQgY2FzZSwgdGhlIGJhY2tvZmYgdGltZXIgY2FsbGJhY2sgd2lsbCBjYWxsXG4gICAgICAgICAgICAgICAgICogdXBkYXRlUmVzb2x1dGlvbiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdyZXF1ZXN0UmVyZXNvbHV0aW9uIGRlbGF5ZWQgYnkgYmFja29mZiB0aW1lciB1bnRpbCAnICsgdGhpcy5iYWNrb2ZmVGltZW91dC5nZXRFbmRUaW1lKCkudG9JU09TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlOiAobmV3U3RhdGUsIHBpY2tlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZDogY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlciA9ICgwLCByZXNvbHZlcl8xLmNyZWF0ZVJlc29sdmVyKSh0YXJnZXQsIHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yLCBjb25maWdTZWxlY3RvciwgYXR0cmlidXRlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgbGV0IHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvKiBUaGlzIGZpcnN0IGdyb3VwIG9mIGNvbmRpdGlvbmFscyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkXG4gICAgICAgICAgICAgICAgICogaW4gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTIxLXNlcnZpY2UtY29uZmlnLWVycm9yLWhhbmRsaW5nLm1kXG4gICAgICAgICAgICAgICAgICogaW4gdGhlIHNlY3Rpb24gY2FsbGVkIFwiQmVoYXZpb3Igb24gcmVjZWl2aW5nIGEgbmV3IGdSUEMgQ29uZmlnXCIuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0IGFuZCA1XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaWlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKHNlcnZpY2VDb25maWdFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDQuaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgM1xuICAgICAgICAgICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gc2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgd29ya2luZ0NvbmZpZ0xpc3QgPSAoX2EgPSB3b3JraW5nU2VydmljZUNvbmZpZyA9PT0gbnVsbCB8fCB3b3JraW5nU2VydmljZUNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd29ya2luZ1NlcnZpY2VDb25maWcubG9hZEJhbGFuY2luZ0NvbmZpZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZEJhbGFuY2luZ0NvbmZpZyA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWcpKHdvcmtpbmdDb25maWdMaXN0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAobG9hZEJhbGFuY2luZ0NvbmZpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSB3ZXJlIGxvYWQgYmFsYW5jaW5nIGNvbmZpZ3MgYnV0IG5vbmUgYXJlIHN1cHBvcnRlZC4gVGhpcyBjb3VudHMgYXMgYSByZXNvbHV0aW9uIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQWxsIGxvYWQgYmFsYW5jZXIgb3B0aW9ucyBpbiBzZXJ2aWNlIGNvbmZpZyBhcmUgbm90IGNvbXBhdGlibGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxvYWRCYWxhbmNpbmdDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsU2VydmljZUNvbmZpZyA9IHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSBudWxsICYmIHdvcmtpbmdTZXJ2aWNlQ29uZmlnICE9PSB2b2lkIDAgPyB3b3JraW5nU2VydmljZUNvbmZpZyA6IHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKGZpbmFsU2VydmljZUNvbmZpZywgY29uZmlnU2VsZWN0b3IgIT09IG51bGwgJiYgY29uZmlnU2VsZWN0b3IgIT09IHZvaWQgMCA/IGNvbmZpZ1NlbGVjdG9yIDogZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yKGZpbmFsU2VydmljZUNvbmZpZykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICAgICAgbWF4RGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLmxhdGVzdENoaWxkU3RhdGUsIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQudW5yZWYoKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW2Nvbm5lY3Rpdml0eVN0YXRlXSk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoaXMuZXhpdElkbGUoKSBpcyBjYWxsZWQgYnkgdGhlIHBpY2tlclxuICAgICAgICBpZiAoY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICBoYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShlcnJvcikge1xuICAgICAgICBpZiAodGhpcy5sYXRlc3RDaGlsZFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoZXJyb3IpKTtcbiAgICAgICAgICAgIHRoaXMub25GYWlsZWRSZXNvbHV0aW9uKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VwZGF0ZUFkZHJlc3NMaXN0IG5vdCBzdXBwb3J0ZWQgb24gUmVzb2x2aW5nTG9hZEJhbGFuY2VyJyk7XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnN0b3AoKTtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gUmVzb2x2aW5nTG9hZEJhbGFuY2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/retrying-call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'retrying_call';\nclass RetryThrottler {\n    constructor(maxTokens, tokenRatio, previousRetryThrottler) {\n        this.maxTokens = maxTokens;\n        this.tokenRatio = tokenRatio;\n        if (previousRetryThrottler) {\n            /* When carrying over tokens from a previous config, rescale them to the\n             * new max value */\n            this.tokens =\n                previousRetryThrottler.tokens *\n                    (maxTokens / previousRetryThrottler.maxTokens);\n        }\n        else {\n            this.tokens = maxTokens;\n        }\n    }\n    addCallSucceeded() {\n        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n    }\n    addCallFailed() {\n        this.tokens = Math.min(this.tokens - 1, 0);\n    }\n    canRetryCall() {\n        return this.tokens > this.maxTokens / 2;\n    }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n    constructor(totalLimit, limitPerCall) {\n        this.totalLimit = totalLimit;\n        this.limitPerCall = limitPerCall;\n        this.totalAllocated = 0;\n        this.allocatedPerCall = new Map();\n    }\n    allocate(size, callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.limitPerCall - currentPerCall < size ||\n            this.totalLimit - this.totalAllocated < size) {\n            return false;\n        }\n        this.allocatedPerCall.set(callId, currentPerCall + size);\n        this.totalAllocated += size;\n        return true;\n    }\n    free(size, callId) {\n        var _a;\n        if (this.totalAllocated < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= size;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (currentPerCall < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n        }\n        this.allocatedPerCall.set(callId, currentPerCall - size);\n    }\n    freeAll(callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.totalAllocated < currentPerCall) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= currentPerCall;\n        this.allocatedPerCall.delete(callId);\n    }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\nclass RetryingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.bufferTracker = bufferTracker;\n        this.retryThrottler = retryThrottler;\n        this.listener = null;\n        this.initialMetadata = null;\n        this.underlyingCalls = [];\n        this.writeBuffer = [];\n        /**\n         * The offset of message indices in the writeBuffer. For example, if\n         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n         * is in writeBuffer[5].\n         */\n        this.writeBufferOffset = 0;\n        /**\n         * Tracks whether a read has been started, so that we know whether to start\n         * reads on new child calls. This only matters for the first read, because\n         * once a message comes in the child call becomes committed and there will\n         * be no new child calls.\n         */\n        this.readStarted = false;\n        this.transparentRetryUsed = false;\n        /**\n         * Number of attempts so far\n         */\n        this.attempts = 0;\n        this.hedgingTimer = null;\n        this.committedCallIndex = null;\n        this.initialRetryBackoffSec = 0;\n        this.nextRetryBackoffSec = 0;\n        if (callConfig.methodConfig.retryPolicy) {\n            this.state = 'RETRY';\n            const retryPolicy = callConfig.methodConfig.retryPolicy;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n        }\n        else if (callConfig.methodConfig.hedgingPolicy) {\n            this.state = 'HEDGING';\n        }\n        else {\n            this.state = 'TRANSPARENT_ONLY';\n        }\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    reportStatus(statusObject) {\n        this.trace('ended with status: code=' +\n            statusObject.code +\n            ' details=\"' +\n            statusObject.details +\n            '\"');\n        this.bufferTracker.freeAll(this.callNumber);\n        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n        this.writeBuffer = [];\n        process.nextTick(() => {\n            var _a;\n            // Explicitly construct status object to remove progress field\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n                code: statusObject.code,\n                details: statusObject.details,\n                metadata: statusObject.metadata,\n            });\n        });\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });\n        for (const { call } of this.underlyingCalls) {\n            call.cancelWithStatus(status, details);\n        }\n    }\n    getPeer() {\n        if (this.committedCallIndex !== null) {\n            return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getBufferEntry(messageIndex) {\n        var _a;\n        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n            entryType: 'FREED',\n            allocated: false,\n        });\n    }\n    getNextBufferIndex() {\n        return this.writeBufferOffset + this.writeBuffer.length;\n    }\n    clearSentMessages() {\n        if (this.state !== 'COMMITTED') {\n            return;\n        }\n        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\n            const bufferEntry = this.getBufferEntry(messageIndex);\n            if (bufferEntry.allocated) {\n                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n            }\n        }\n        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n        this.writeBufferOffset = earliestNeededMessageIndex;\n    }\n    commitCall(index) {\n        if (this.state === 'COMMITTED') {\n            return;\n        }\n        if (this.underlyingCalls[index].state === 'COMPLETED') {\n            return;\n        }\n        this.trace('Committing call [' +\n            this.underlyingCalls[index].call.getCallNumber() +\n            '] at index ' +\n            index);\n        this.state = 'COMMITTED';\n        this.committedCallIndex = index;\n        for (let i = 0; i < this.underlyingCalls.length; i++) {\n            if (i === index) {\n                continue;\n            }\n            if (this.underlyingCalls[i].state === 'COMPLETED') {\n                continue;\n            }\n            this.underlyingCalls[i].state = 'COMPLETED';\n            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n        }\n        this.clearSentMessages();\n    }\n    commitCallWithMostMessages() {\n        if (this.state === 'COMMITTED') {\n            return;\n        }\n        let mostMessages = -1;\n        let callWithMostMessages = -1;\n        for (const [index, childCall] of this.underlyingCalls.entries()) {\n            if (childCall.state === 'ACTIVE' &&\n                childCall.nextMessageToSend > mostMessages) {\n                mostMessages = childCall.nextMessageToSend;\n                callWithMostMessages = index;\n            }\n        }\n        if (callWithMostMessages === -1) {\n            /* There are no active calls, disable retries to force the next call that\n             * is started to be committed. */\n            this.state = 'TRANSPARENT_ONLY';\n        }\n        else {\n            this.commitCall(callWithMostMessages);\n        }\n    }\n    isStatusCodeInList(list, code) {\n        return list.some(value => value === code ||\n            value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());\n    }\n    getNextRetryBackoffMs() {\n        var _a;\n        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n        if (!retryPolicy) {\n            return 0;\n        }\n        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n        return nextBackoffMs;\n    }\n    maybeRetryCall(pushback, callback) {\n        if (this.state !== 'RETRY') {\n            callback(false);\n            return;\n        }\n        const retryPolicy = this.callConfig.methodConfig.retryPolicy;\n        if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n            callback(false);\n            return;\n        }\n        let retryDelayMs;\n        if (pushback === null) {\n            retryDelayMs = this.getNextRetryBackoffMs();\n        }\n        else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            callback(false);\n            return;\n        }\n        else {\n            retryDelayMs = pushback;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n        }\n        setTimeout(() => {\n            var _a, _b;\n            if (this.state !== 'RETRY') {\n                callback(false);\n                return;\n            }\n            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n                callback(true);\n                this.attempts += 1;\n                this.startNewAttempt();\n            }\n        }, retryDelayMs);\n    }\n    countActiveCalls() {\n        let count = 0;\n        for (const call of this.underlyingCalls) {\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    handleProcessedStatus(status, callIndex, pushback) {\n        var _a, _b, _c;\n        switch (this.state) {\n            case 'COMMITTED':\n            case 'TRANSPARENT_ONLY':\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case 'HEDGING':\n                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n                    let delayMs;\n                    if (pushback === null) {\n                        delayMs = 0;\n                    }\n                    else if (pushback < 0) {\n                        this.state = 'TRANSPARENT_ONLY';\n                        this.commitCall(callIndex);\n                        this.reportStatus(status);\n                        return;\n                    }\n                    else {\n                        delayMs = pushback;\n                    }\n                    setTimeout(() => {\n                        this.maybeStartHedgingAttempt();\n                        // If after trying to start a call there are no active calls, this was the last one\n                        if (this.countActiveCalls() === 0) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    }, delayMs);\n                }\n                else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n            case 'RETRY':\n                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n                    this.maybeRetryCall(pushback, retried => {\n                        if (!retried) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    });\n                }\n                else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n        }\n    }\n    getPushback(metadata) {\n        const mdValue = metadata.get('grpc-retry-pushback-ms');\n        if (mdValue.length === 0) {\n            return null;\n        }\n        try {\n            return parseInt(mdValue[0]);\n        }\n        catch (e) {\n            return -1;\n        }\n    }\n    handleChildStatus(status, callIndex) {\n        var _a;\n        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n            return;\n        }\n        this.trace('state=' +\n            this.state +\n            ' handling status with progress ' +\n            status.progress +\n            ' from child [' +\n            this.underlyingCalls[callIndex].call.getCallNumber() +\n            '] in state ' +\n            this.underlyingCalls[callIndex].state);\n        this.underlyingCalls[callIndex].state = 'COMPLETED';\n        if (status.code === constants_1.Status.OK) {\n            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n        }\n        if (this.state === 'COMMITTED') {\n            this.reportStatus(status);\n            return;\n        }\n        const pushback = this.getPushback(status.metadata);\n        switch (status.progress) {\n            case 'NOT_STARTED':\n                // RPC never leaves the client, always safe to retry\n                this.startNewAttempt();\n                break;\n            case 'REFUSED':\n                // RPC reaches the server library, but not the server application logic\n                if (this.transparentRetryUsed) {\n                    this.handleProcessedStatus(status, callIndex, pushback);\n                }\n                else {\n                    this.transparentRetryUsed = true;\n                    this.startNewAttempt();\n                }\n                break;\n            case 'DROP':\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case 'PROCESSED':\n                this.handleProcessedStatus(status, callIndex, pushback);\n                break;\n        }\n    }\n    maybeStartHedgingAttempt() {\n        if (this.state !== 'HEDGING') {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n            return;\n        }\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    maybeStartHedgingTimer() {\n        var _a, _b, _c;\n        if (this.hedgingTimer) {\n            clearTimeout(this.hedgingTimer);\n        }\n        if (this.state !== 'HEDGING') {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n            return;\n        }\n        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\n        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n        this.hedgingTimer = setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n        }, hedgingDelaySec * 1000);\n        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n    startNewAttempt() {\n        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n        this.trace('Created child call [' +\n            child.getCallNumber() +\n            '] for attempt ' +\n            this.attempts);\n        const index = this.underlyingCalls.length;\n        this.underlyingCalls.push({\n            state: 'ACTIVE',\n            call: child,\n            nextMessageToSend: 0,\n        });\n        const previousAttempts = this.attempts - 1;\n        const initialMetadata = this.initialMetadata.clone();\n        if (previousAttempts > 0) {\n            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        let receivedMetadata = false;\n        child.start(initialMetadata, {\n            onReceiveMetadata: metadata => {\n                this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n                this.commitCall(index);\n                receivedMetadata = true;\n                if (previousAttempts > 0) {\n                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\n                    this.listener.onReceiveMetadata(metadata);\n                }\n            },\n            onReceiveMessage: message => {\n                this.trace('Received message from child [' + child.getCallNumber() + ']');\n                this.commitCall(index);\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\n                    this.listener.onReceiveMessage(message);\n                }\n            },\n            onReceiveStatus: status => {\n                this.trace('Received status from child [' + child.getCallNumber() + ']');\n                if (!receivedMetadata && previousAttempts > 0) {\n                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                this.handleChildStatus(status, index);\n            },\n        });\n        this.sendNextChildMessage(index);\n        if (this.readStarted) {\n            child.startRead();\n        }\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.listener = listener;\n        this.initialMetadata = metadata;\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    handleChildWriteCompleted(childIndex) {\n        var _a, _b;\n        const childCall = this.underlyingCalls[childIndex];\n        const messageIndex = childCall.nextMessageToSend;\n        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.clearSentMessages();\n        childCall.nextMessageToSend += 1;\n        this.sendNextChildMessage(childIndex);\n    }\n    sendNextChildMessage(childIndex) {\n        const childCall = this.underlyingCalls[childIndex];\n        if (childCall.state === 'COMPLETED') {\n            return;\n        }\n        if (this.getBufferEntry(childCall.nextMessageToSend)) {\n            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n            switch (bufferEntry.entryType) {\n                case 'MESSAGE':\n                    childCall.call.sendMessageWithContext({\n                        callback: error => {\n                            // Ignore error\n                            this.handleChildWriteCompleted(childIndex);\n                        },\n                    }, bufferEntry.message.message);\n                    break;\n                case 'HALF_CLOSE':\n                    childCall.nextMessageToSend += 1;\n                    childCall.call.halfClose();\n                    break;\n                case 'FREED':\n                    // Should not be possible\n                    break;\n            }\n        }\n    }\n    sendMessageWithContext(context, message) {\n        var _a;\n        this.trace('write() called with message of length ' + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags,\n        };\n        const messageIndex = this.getNextBufferIndex();\n        const bufferEntry = {\n            entryType: 'MESSAGE',\n            message: writeObj,\n            allocated: this.bufferTracker.allocate(message.length, this.callNumber),\n        };\n        this.writeBuffer.push(bufferEntry);\n        if (bufferEntry.allocated) {\n            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            for (const [callIndex, call] of this.underlyingCalls.entries()) {\n                if (call.state === 'ACTIVE' &&\n                    call.nextMessageToSend === messageIndex) {\n                    call.call.sendMessageWithContext({\n                        callback: error => {\n                            // Ignore error\n                            this.handleChildWriteCompleted(callIndex);\n                        },\n                    }, message);\n                }\n            }\n        }\n        else {\n            this.commitCallWithMostMessages();\n            // commitCallWithMostMessages can fail if we are between ping attempts\n            if (this.committedCallIndex === null) {\n                return;\n            }\n            const call = this.underlyingCalls[this.committedCallIndex];\n            bufferEntry.callback = context.callback;\n            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n                call.call.sendMessageWithContext({\n                    callback: error => {\n                        // Ignore error\n                        this.handleChildWriteCompleted(this.committedCallIndex);\n                    },\n                }, message);\n            }\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        this.readStarted = true;\n        for (const underlyingCall of this.underlyingCalls) {\n            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\n                underlyingCall.call.startRead();\n            }\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        const halfCloseIndex = this.getNextBufferIndex();\n        this.writeBuffer.push({\n            entryType: 'HALF_CLOSE',\n            allocated: false,\n        });\n        for (const call of this.underlyingCalls) {\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' &&\n                call.nextMessageToSend === halfCloseIndex) {\n                call.nextMessageToSend += 1;\n                call.call.halfClose();\n            }\n        }\n    }\n    setCredentials(newCredentials) {\n        throw new Error('Method not implemented.');\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.host;\n    }\n}\nexports.RetryingCall = RetryingCall;\n//# sourceMappingURL=retrying-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXRyeWluZy1jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCO0FBQzVFLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsUUFBUSxNQUFNLG9CQUFvQixvQkFBb0I7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUSxRQUFRLE1BQU0sdUJBQXVCLGVBQWU7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsUUFBUSxZQUFZLGdCQUFnQixvQkFBb0Isb0JBQW9CO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNERBQTREO0FBQ3hGLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwyQ0FBMkM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGlCQUFpQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGlCQUFpQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlCQUFpQjtBQUNoRztBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3JldHJ5aW5nLWNhbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmV0cnlpbmdDYWxsID0gZXhwb3J0cy5NZXNzYWdlQnVmZmVyVHJhY2tlciA9IGV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmV0cnlpbmdfY2FsbCc7XG5jbGFzcyBSZXRyeVRocm90dGxlciB7XG4gICAgY29uc3RydWN0b3IobWF4VG9rZW5zLCB0b2tlblJhdGlvLCBwcmV2aW91c1JldHJ5VGhyb3R0bGVyKSB7XG4gICAgICAgIHRoaXMubWF4VG9rZW5zID0gbWF4VG9rZW5zO1xuICAgICAgICB0aGlzLnRva2VuUmF0aW8gPSB0b2tlblJhdGlvO1xuICAgICAgICBpZiAocHJldmlvdXNSZXRyeVRocm90dGxlcikge1xuICAgICAgICAgICAgLyogV2hlbiBjYXJyeWluZyBvdmVyIHRva2VucyBmcm9tIGEgcHJldmlvdXMgY29uZmlnLCByZXNjYWxlIHRoZW0gdG8gdGhlXG4gICAgICAgICAgICAgKiBuZXcgbWF4IHZhbHVlICovXG4gICAgICAgICAgICB0aGlzLnRva2VucyA9XG4gICAgICAgICAgICAgICAgcHJldmlvdXNSZXRyeVRocm90dGxlci50b2tlbnMgKlxuICAgICAgICAgICAgICAgICAgICAobWF4VG9rZW5zIC8gcHJldmlvdXNSZXRyeVRocm90dGxlci5tYXhUb2tlbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b2tlbnMgPSBtYXhUb2tlbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2FsbFN1Y2NlZWRlZCgpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBNYXRoLm1heCh0aGlzLnRva2VucyArIHRoaXMudG9rZW5SYXRpbywgdGhpcy5tYXhUb2tlbnMpO1xuICAgIH1cbiAgICBhZGRDYWxsRmFpbGVkKCkge1xuICAgICAgICB0aGlzLnRva2VucyA9IE1hdGgubWluKHRoaXMudG9rZW5zIC0gMSwgMCk7XG4gICAgfVxuICAgIGNhblJldHJ5Q2FsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5zID4gdGhpcy5tYXhUb2tlbnMgLyAyO1xuICAgIH1cbn1cbmV4cG9ydHMuUmV0cnlUaHJvdHRsZXIgPSBSZXRyeVRocm90dGxlcjtcbmNsYXNzIE1lc3NhZ2VCdWZmZXJUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3RhbExpbWl0LCBsaW1pdFBlckNhbGwpIHtcbiAgICAgICAgdGhpcy50b3RhbExpbWl0ID0gdG90YWxMaW1pdDtcbiAgICAgICAgdGhpcy5saW1pdFBlckNhbGwgPSBsaW1pdFBlckNhbGw7XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgPSAwO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFsbG9jYXRlKHNpemUsIGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAodGhpcy5saW1pdFBlckNhbGwgLSBjdXJyZW50UGVyQ2FsbCA8IHNpemUgfHxcbiAgICAgICAgICAgIHRoaXMudG90YWxMaW1pdCAtIHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLnNldChjYWxsSWQsIGN1cnJlbnRQZXJDYWxsICsgc2l6ZSk7XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgKz0gc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZyZWUoc2l6ZSwgY2FsbElkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMudG90YWxBbGxvY2F0ZWQgPCBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyIGFsbG9jYXRpb24gc3RhdGU6IGNhbGwgJHtjYWxsSWR9IGZyZWVkICR7c2l6ZX0gPiB0b3RhbCBhbGxvY2F0ZWQgJHt0aGlzLnRvdGFsQWxsb2NhdGVkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgLT0gc2l6ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFBlckNhbGwgPSAoX2EgPSB0aGlzLmFsbG9jYXRlZFBlckNhbGwuZ2V0KGNhbGxJZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgIGlmIChjdXJyZW50UGVyQ2FsbCA8IHNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidWZmZXIgYWxsb2NhdGlvbiBzdGF0ZTogY2FsbCAke2NhbGxJZH0gZnJlZWQgJHtzaXplfSA+IGFsbG9jYXRlZCBmb3IgY2FsbCAke2N1cnJlbnRQZXJDYWxsfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5zZXQoY2FsbElkLCBjdXJyZW50UGVyQ2FsbCAtIHNpemUpO1xuICAgIH1cbiAgICBmcmVlQWxsKGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAodGhpcy50b3RhbEFsbG9jYXRlZCA8IGN1cnJlbnRQZXJDYWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyIGFsbG9jYXRpb24gc3RhdGU6IGNhbGwgJHtjYWxsSWR9IGFsbG9jYXRlZCAke2N1cnJlbnRQZXJDYWxsfSA+IHRvdGFsIGFsbG9jYXRlZCAke3RoaXMudG90YWxBbGxvY2F0ZWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRlZCAtPSBjdXJyZW50UGVyQ2FsbDtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmRlbGV0ZShjYWxsSWQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZUJ1ZmZlclRyYWNrZXIgPSBNZXNzYWdlQnVmZmVyVHJhY2tlcjtcbmNvbnN0IFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVkgPSAnZ3JwYy1wcmV2aW91cy1ycGMtYXR0ZW1wdHMnO1xuY2xhc3MgUmV0cnlpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBjYWxsQ29uZmlnLCBtZXRob2ROYW1lLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUsIGNhbGxOdW1iZXIsIGJ1ZmZlclRyYWNrZXIsIHJldHJ5VGhyb3R0bGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IGRlYWRsaW5lO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIgPSBidWZmZXJUcmFja2VyO1xuICAgICAgICB0aGlzLnJldHJ5VGhyb3R0bGVyID0gcmV0cnlUaHJvdHRsZXI7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxNZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzID0gW107XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvZmZzZXQgb2YgbWVzc2FnZSBpbmRpY2VzIGluIHRoZSB3cml0ZUJ1ZmZlci4gRm9yIGV4YW1wbGUsIGlmXG4gICAgICAgICAqIHdyaXRlQnVmZmVyT2Zmc2V0IGlzIDEwLCBtZXNzYWdlIDEwIGlzIGluIHdyaXRlQnVmZmVyWzBdIGFuZCBtZXNzYWdlIDE1XG4gICAgICAgICAqIGlzIGluIHdyaXRlQnVmZmVyWzVdLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlck9mZnNldCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3Mgd2hldGhlciBhIHJlYWQgaGFzIGJlZW4gc3RhcnRlZCwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgdG8gc3RhcnRcbiAgICAgICAgICogcmVhZHMgb24gbmV3IGNoaWxkIGNhbGxzLiBUaGlzIG9ubHkgbWF0dGVycyBmb3IgdGhlIGZpcnN0IHJlYWQsIGJlY2F1c2VcbiAgICAgICAgICogb25jZSBhIG1lc3NhZ2UgY29tZXMgaW4gdGhlIGNoaWxkIGNhbGwgYmVjb21lcyBjb21taXR0ZWQgYW5kIHRoZXJlIHdpbGxcbiAgICAgICAgICogYmUgbm8gbmV3IGNoaWxkIGNhbGxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50UmV0cnlVc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgc28gZmFyXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5oZWRnaW5nVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYyA9IDA7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IDA7XG4gICAgICAgIGlmIChjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdSRVRSWSc7XG4gICAgICAgICAgICBjb25zdCByZXRyeVBvbGljeSA9IGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5O1xuICAgICAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gdGhpcy5pbml0aWFsUmV0cnlCYWNrb2ZmU2VjID0gTnVtYmVyKHJldHJ5UG9saWN5LmluaXRpYWxCYWNrb2ZmLnN1YnN0cmluZygwLCByZXRyeVBvbGljeS5pbml0aWFsQmFja29mZi5sZW5ndGggLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdIRURHSU5HJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnVFJBTlNQQVJFTlRfT05MWSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcmVwb3J0U3RhdHVzKHN0YXR1c09iamVjdCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgIHN0YXR1c09iamVjdC5jb2RlICtcbiAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgc3RhdHVzT2JqZWN0LmRldGFpbHMgK1xuICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgIHRoaXMuYnVmZmVyVHJhY2tlci5mcmVlQWxsKHRoaXMuY2FsbE51bWJlcik7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBFeHBsaWNpdGx5IGNvbnN0cnVjdCBzdGF0dXMgb2JqZWN0IHRvIHJlbW92ZSBwcm9ncmVzcyBmaWVsZFxuICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogc3RhdHVzT2JqZWN0LmNvZGUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogc3RhdHVzT2JqZWN0LmRldGFpbHMsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXR1c09iamVjdC5tZXRhZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XG4gICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHsgY29kZTogc3RhdHVzLCBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9KTtcbiAgICAgICAgZm9yIChjb25zdCB7IGNhbGwgfSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdLmNhbGwuZ2V0UGVlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMud3JpdGVCdWZmZXJbbWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0ZSRUVEJyxcbiAgICAgICAgICAgIGFsbG9jYXRlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0QnVmZmVySW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ICsgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyU2VudE1lc3NhZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XS5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgZm9yIChsZXQgbWVzc2FnZUluZGV4ID0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldDsgbWVzc2FnZUluZGV4IDwgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXg7IG1lc3NhZ2VJbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHRoaXMuZ2V0QnVmZmVyRW50cnkobWVzc2FnZUluZGV4KTtcbiAgICAgICAgICAgIGlmIChidWZmZXJFbnRyeS5hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIuZnJlZShidWZmZXJFbnRyeS5tZXNzYWdlLm1lc3NhZ2UubGVuZ3RoLCB0aGlzLmNhbGxOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSB0aGlzLndyaXRlQnVmZmVyLnNsaWNlKGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4IC0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSBlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleDtcbiAgICB9XG4gICAgY29tbWl0Q2FsbChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ0NvbW1pdHRpbmcgY2FsbCBbJyArXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uY2FsbC5nZXRDYWxsTnVtYmVyKCkgK1xuICAgICAgICAgICAgJ10gYXQgaW5kZXggJyArXG4gICAgICAgICAgICBpbmRleCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSAnQ09NTUlUVEVEJztcbiAgICAgICAgdGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPSBpbmRleDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnVuZGVybHlpbmdDYWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uc3RhdGUgPT09ICdDT01QTEVURUQnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tpXS5zdGF0ZSA9ICdDT01QTEVURUQnO1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdEaXNjYXJkZWQgaW4gZmF2b3Igb2Ygb3RoZXIgaGVkZ2VkIGF0dGVtcHQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyU2VudE1lc3NhZ2VzKCk7XG4gICAgfVxuICAgIGNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ0NPTU1JVFRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbW9zdE1lc3NhZ2VzID0gLTE7XG4gICAgICAgIGxldCBjYWxsV2l0aE1vc3RNZXNzYWdlcyA9IC0xO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRDYWxsXSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZENhbGwuc3RhdGUgPT09ICdBQ1RJVkUnICYmXG4gICAgICAgICAgICAgICAgY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kID4gbW9zdE1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgbW9zdE1lc3NhZ2VzID0gY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kO1xuICAgICAgICAgICAgICAgIGNhbGxXaXRoTW9zdE1lc3NhZ2VzID0gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxXaXRoTW9zdE1lc3NhZ2VzID09PSAtMSkge1xuICAgICAgICAgICAgLyogVGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgZGlzYWJsZSByZXRyaWVzIHRvIGZvcmNlIHRoZSBuZXh0IGNhbGwgdGhhdFxuICAgICAgICAgICAgICogaXMgc3RhcnRlZCB0byBiZSBjb21taXR0ZWQuICovXG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxXaXRoTW9zdE1lc3NhZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1N0YXR1c0NvZGVJbkxpc3QobGlzdCwgY29kZSkge1xuICAgICAgICByZXR1cm4gbGlzdC5zb21lKHZhbHVlID0+IHZhbHVlID09PSBjb2RlIHx8XG4gICAgICAgICAgICB2YWx1ZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkgPT09IGNvbnN0YW50c18xLlN0YXR1c1tjb2RlXS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG4gICAgZ2V0TmV4dFJldHJ5QmFja29mZk1zKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gKF9hID0gdGhpcy5jYWxsQ29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWV0aG9kQ29uZmlnLnJldHJ5UG9saWN5O1xuICAgICAgICBpZiAoIXJldHJ5UG9saWN5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0QmFja29mZk1zID0gTWF0aC5yYW5kb20oKSAqIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIDEwMDA7XG4gICAgICAgIGNvbnN0IG1heEJhY2tvZmZTZWMgPSBOdW1iZXIocmV0cnlQb2xpY3kubWF4QmFja29mZi5zdWJzdHJpbmcoMCwgcmV0cnlQb2xpY3kubWF4QmFja29mZi5sZW5ndGggLSAxKSk7XG4gICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IE1hdGgubWluKHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyAqIHJldHJ5UG9saWN5LmJhY2tvZmZNdWx0aXBsaWVyLCBtYXhCYWNrb2ZmU2VjKTtcbiAgICAgICAgcmV0dXJuIG5leHRCYWNrb2ZmTXM7XG4gICAgfVxuICAgIG1heWJlUmV0cnlDYWxsKHB1c2hiYWNrLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ1JFVFJZJykge1xuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5UG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdHMgPj0gTWF0aC5taW4ocmV0cnlQb2xpY3kubWF4QXR0ZW1wdHMsIDUpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHJ5RGVsYXlNcztcbiAgICAgICAgaWYgKHB1c2hiYWNrID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXRyeURlbGF5TXMgPSB0aGlzLmdldE5leHRSZXRyeUJhY2tvZmZNcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1c2hiYWNrIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXlNcyA9IHB1c2hiYWNrO1xuICAgICAgICAgICAgdGhpcy5uZXh0UmV0cnlCYWNrb2ZmU2VjID0gdGhpcy5pbml0aWFsUmV0cnlCYWNrb2ZmU2VjO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnUkVUUlknKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoX2IgPSAoX2EgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUmV0cnlDYWxsKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmV0cnlEZWxheU1zKTtcbiAgICB9XG4gICAgY291bnRBY3RpdmVDYWxscygpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzKSB7XG4gICAgICAgICAgICBpZiAoKGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5zdGF0ZSkgPT09ICdBQ1RJVkUnKSB7XG4gICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIGhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnQ09NTUlUVEVEJzpcbiAgICAgICAgICAgIGNhc2UgJ1RSQU5TUEFSRU5UX09OTFknOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdIRURHSU5HJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXR1c0NvZGVJbkxpc3QoKF9hID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5Lm5vbkZhdGFsU3RhdHVzQ29kZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCBzdGF0dXMuY29kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZXRyeVRocm90dGxlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGF5TXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwdXNoYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHVzaGJhY2sgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXlNcyA9IHB1c2hiYWNrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGFmdGVyIHRyeWluZyB0byBzdGFydCBhIGNhbGwgdGhlcmUgYXJlIG5vIGFjdGl2ZSBjYWxscywgdGhpcyB3YXMgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudEFjdGl2ZUNhbGxzKCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBkZWxheU1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JFVFJZJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N0YXR1c0NvZGVJbkxpc3QodGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeS5yZXRyeWFibGVTdGF0dXNDb2Rlcywgc3RhdHVzLmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZXRyeUNhbGwocHVzaGJhY2ssIHJldHJpZWQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXRyaWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UHVzaGJhY2sobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgbWRWYWx1ZSA9IG1ldGFkYXRhLmdldCgnZ3JwYy1yZXRyeS1wdXNoYmFjay1tcycpO1xuICAgICAgICBpZiAobWRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQobWRWYWx1ZVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDaGlsZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXRlPScgK1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSArXG4gICAgICAgICAgICAnIGhhbmRsaW5nIHN0YXR1cyB3aXRoIHByb2dyZXNzICcgK1xuICAgICAgICAgICAgc3RhdHVzLnByb2dyZXNzICtcbiAgICAgICAgICAgICcgZnJvbSBjaGlsZCBbJyArXG4gICAgICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLmNhbGwuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGluIHN0YXRlICcgK1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSk7XG4gICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUgPSAnQ09NUExFVEVEJztcbiAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIChfYSA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB1c2hiYWNrID0gdGhpcy5nZXRQdXNoYmFjayhzdGF0dXMubWV0YWRhdGEpO1xuICAgICAgICBzd2l0Y2ggKHN0YXR1cy5wcm9ncmVzcykge1xuICAgICAgICAgICAgY2FzZSAnTk9UX1NUQVJURUQnOlxuICAgICAgICAgICAgICAgIC8vIFJQQyBuZXZlciBsZWF2ZXMgdGhlIGNsaWVudCwgYWx3YXlzIHNhZmUgdG8gcmV0cnlcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUkVGVVNFRCc6XG4gICAgICAgICAgICAgICAgLy8gUlBDIHJlYWNoZXMgdGhlIHNlcnZlciBsaWJyYXJ5LCBidXQgbm90IHRoZSBzZXJ2ZXIgYXBwbGljYXRpb24gbG9naWNcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVByb2Nlc3NlZFN0YXR1cyhzdGF0dXMsIGNhbGxJbmRleCwgcHVzaGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRFJPUCc6XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BST0NFU1NFRCc6XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnSEVER0lORycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlZGdpbmdQb2xpY3kgPSB0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3k7XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IE1hdGgubWluKGhlZGdpbmdQb2xpY3kubWF4QXR0ZW1wdHMsIDUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xuICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICB0aGlzLm1heWJlU3RhcnRIZWRnaW5nVGltZXIoKTtcbiAgICB9XG4gICAgbWF5YmVTdGFydEhlZGdpbmdUaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLmhlZGdpbmdUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaGVkZ2luZ1RpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0hFREdJTkcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWRnaW5nUG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5O1xuICAgICAgICBpZiAodGhpcy5hdHRlbXB0cyA+PSBNYXRoLm1pbihoZWRnaW5nUG9saWN5Lm1heEF0dGVtcHRzLCA1KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhlZGdpbmdEZWxheVN0cmluZyA9IChfYSA9IGhlZGdpbmdQb2xpY3kuaGVkZ2luZ0RlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnMHMnO1xuICAgICAgICBjb25zdCBoZWRnaW5nRGVsYXlTZWMgPSBOdW1iZXIoaGVkZ2luZ0RlbGF5U3RyaW5nLnN1YnN0cmluZygwLCBoZWRnaW5nRGVsYXlTdHJpbmcubGVuZ3RoIC0gMSkpO1xuICAgICAgICB0aGlzLmhlZGdpbmdUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ0F0dGVtcHQoKTtcbiAgICAgICAgfSwgaGVkZ2luZ0RlbGF5U2VjICogMTAwMCk7XG4gICAgICAgIChfYyA9IChfYiA9IHRoaXMuaGVkZ2luZ1RpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpO1xuICAgIH1cbiAgICBzdGFydE5ld0F0dGVtcHQoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZUxvYWRCYWxhbmNpbmdDYWxsKHRoaXMuY2FsbENvbmZpZywgdGhpcy5tZXRob2ROYW1lLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICB0aGlzLnRyYWNlKCdDcmVhdGVkIGNoaWxkIGNhbGwgWycgK1xuICAgICAgICAgICAgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGZvciBhdHRlbXB0ICcgK1xuICAgICAgICAgICAgdGhpcy5hdHRlbXB0cyk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscy5wdXNoKHtcbiAgICAgICAgICAgIHN0YXRlOiAnQUNUSVZFJyxcbiAgICAgICAgICAgIGNhbGw6IGNoaWxkLFxuICAgICAgICAgICAgbmV4dE1lc3NhZ2VUb1NlbmQ6IDAsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcmV2aW91c0F0dGVtcHRzID0gdGhpcy5hdHRlbXB0cyAtIDE7XG4gICAgICAgIGNvbnN0IGluaXRpYWxNZXRhZGF0YSA9IHRoaXMuaW5pdGlhbE1ldGFkYXRhLmNsb25lKCk7XG4gICAgICAgIGlmIChwcmV2aW91c0F0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgaW5pdGlhbE1ldGFkYXRhLnNldChQUkVWSU9OU19SUENfQVRURU1QVFNfTUVUQURBVEFfS0VZLCBgJHtwcmV2aW91c0F0dGVtcHRzfWApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNlaXZlZE1ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIGNoaWxkLnN0YXJ0KGluaXRpYWxNZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXRhZGF0YSBmcm9tIGNoaWxkIFsnICsgY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0F0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5zdGF0ZSA9PT0gJ0FDVElWRScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLnN0YXRlID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZE1ldGFkYXRhICYmIHByZXZpb3VzQXR0ZW1wdHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFN0YXR1cyhzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmROZXh0Q2hpbGRNZXNzYWdlKGluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMucmVhZFN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0UmVhZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydCBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmluaXRpYWxNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmF0dGVtcHRzICs9IDE7XG4gICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdUaW1lcigpO1xuICAgIH1cbiAgICBoYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKGNoaWxkSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hpbGRDYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2hpbGRJbmRleF07XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJbmRleCA9IGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy5nZXRCdWZmZXJFbnRyeShtZXNzYWdlSW5kZXgpKS5jYWxsYmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLmNsZWFyU2VudE1lc3NhZ2VzKCk7XG4gICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xuICAgICAgICB0aGlzLnNlbmROZXh0Q2hpbGRNZXNzYWdlKGNoaWxkSW5kZXgpO1xuICAgIH1cbiAgICBzZW5kTmV4dENoaWxkTWVzc2FnZShjaGlsZEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkQ2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW2NoaWxkSW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGRDYWxsLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdldEJ1ZmZlckVudHJ5KGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckVudHJ5ID0gdGhpcy5nZXRCdWZmZXJFbnRyeShjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQpO1xuICAgICAgICAgICAgc3dpdGNoIChidWZmZXJFbnRyeS5lbnRyeVR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdNRVNTQUdFJzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZChjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIGJ1ZmZlckVudHJ5Lm1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0hBTEZfQ0xPU0UnOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0ZSRUVEJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIG5vdCBiZSBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCd3cml0ZSgpIGNhbGxlZCB3aXRoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHdyaXRlT2JqID0ge1xuICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIGZsYWdzOiBjb250ZXh0LmZsYWdzLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSB0aGlzLmdldE5leHRCdWZmZXJJbmRleCgpO1xuICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ01FU1NBR0UnLFxuICAgICAgICAgICAgbWVzc2FnZTogd3JpdGVPYmosXG4gICAgICAgICAgICBhbGxvY2F0ZWQ6IHRoaXMuYnVmZmVyVHJhY2tlci5hbGxvY2F0ZShtZXNzYWdlLmxlbmd0aCwgdGhpcy5jYWxsTnVtYmVyKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKGJ1ZmZlckVudHJ5KTtcbiAgICAgICAgaWYgKGJ1ZmZlckVudHJ5LmFsbG9jYXRlZCkge1xuICAgICAgICAgICAgKF9hID0gY29udGV4dC5jYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY29udGV4dCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtjYWxsSW5kZXgsIGNhbGxdIG9mIHRoaXMudW5kZXJseWluZ0NhbGxzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJlxuICAgICAgICAgICAgICAgICAgICBjYWxsLm5leHRNZXNzYWdlVG9TZW5kID09PSBtZXNzYWdlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbFdpdGhNb3N0TWVzc2FnZXMoKTtcbiAgICAgICAgICAgIC8vIGNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzIGNhbiBmYWlsIGlmIHdlIGFyZSBiZXR3ZWVuIHBpbmcgYXR0ZW1wdHNcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1pdHRlZENhbGxJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF07XG4gICAgICAgICAgICBidWZmZXJFbnRyeS5jYWxsYmFjayA9IGNvbnRleHQuY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoY2FsbC5zdGF0ZSA9PT0gJ0FDVElWRScgJiYgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA9PT0gbWVzc2FnZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQodGhpcy5jb21taXR0ZWRDYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xuICAgICAgICB0aGlzLnJlYWRTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCB1bmRlcmx5aW5nQ2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgaWYgKCh1bmRlcmx5aW5nQ2FsbCA9PT0gbnVsbCB8fCB1bmRlcmx5aW5nQ2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdW5kZXJseWluZ0NhbGwuc3RhdGUpID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgIHVuZGVybHlpbmdDYWxsLmNhbGwuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdoYWxmQ2xvc2UgY2FsbGVkJyk7XG4gICAgICAgIGNvbnN0IGhhbGZDbG9zZUluZGV4ID0gdGhpcy5nZXROZXh0QnVmZmVySW5kZXgoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgIGVudHJ5VHlwZTogJ0hBTEZfQ0xPU0UnLFxuICAgICAgICAgICAgYWxsb2NhdGVkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgaWYgKChjYWxsID09PSBudWxsIHx8IGNhbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGwuc3RhdGUpID09PSAnQUNUSVZFJyAmJlxuICAgICAgICAgICAgICAgIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IGhhbGZDbG9zZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCArPSAxO1xuICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDcmVkZW50aWFscyhuZXdDcmVkZW50aWFscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGhvZCBub3QgaW1wbGVtZW50ZWQuJyk7XG4gICAgfVxuICAgIGdldE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kTmFtZTtcbiAgICB9XG4gICAgZ2V0SG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdDtcbiAgICB9XG59XG5leHBvcnRzLlJldHJ5aW5nQ2FsbCA9IFJldHJ5aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJldHJ5aW5nLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst TRACER_NAME = 'server_call';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001,\n};\nconst defaultCompressionHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n    [GRPC_ENCODING_HEADER]: 'identity',\n};\nconst defaultResponseHeaders = {\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true,\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request) {\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize, encoding) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on('error', err => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    _write(chunk, encoding, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once('drain', callback);\n                return;\n            }\n        }\n        catch (err) {\n            this.emit('error', {\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL,\n            });\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: 'OK',\n            metadata: this.trailingMetadata,\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize, encoding) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n        this.on('error', err => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read =\n    ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n    ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n    ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options) {\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.cancelled = false;\n        this.deadlineTimer = null;\n        this.statusSent = false;\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once('error', (err) => {\n            /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */\n        });\n        this.stream.once('close', () => {\n            var _a;\n            trace('Request to method ' +\n                ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n                ' stream closed with rstCode ' +\n                this.stream.rstCode);\n            if (!this.statusSent) {\n                this.cancelled = true;\n                this.emit('cancelled', 'cancelled');\n                this.emit('streamEnd', false);\n                this.sendStatus({\n                    code: constants_1.Status.CANCELLED,\n                    details: 'Cancelled by client',\n                    metadata: null,\n                });\n                if (this.deadlineTimer)\n                    clearTimeout(this.deadlineTimer);\n            }\n        });\n        this.stream.on('drain', () => {\n            this.emit('drain');\n        });\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */\n        if (this.stream.destroyed || this.stream.closed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    getDecompressedMessage(message, encoding) {\n        const messageContents = message.subarray(5);\n        if (encoding === 'identity') {\n            return messageContents;\n        }\n        else if (encoding === 'deflate' || encoding === 'gzip') {\n            let decompresser;\n            if (encoding === 'deflate') {\n                decompresser = zlib.createInflate();\n            }\n            else {\n                decompresser = zlib.createGunzip();\n            }\n            return new Promise((resolve, reject) => {\n                let totalLength = 0;\n                const messageParts = [];\n                decompresser.on('data', (chunk) => {\n                    messageParts.push(chunk);\n                    totalLength += chunk.byteLength;\n                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\n                        decompresser.destroy();\n                        reject({\n                            code: constants_1.Status.RESOURCE_EXHAUSTED,\n                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\n                        });\n                    }\n                });\n                decompresser.on('end', () => {\n                    resolve(Buffer.concat(messageParts));\n                });\n                decompresser.write(messageContents);\n                decompresser.end();\n            });\n        }\n        else {\n            return Promise.reject({\n                code: constants_1.Status.UNIMPLEMENTED,\n                details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n            });\n        }\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace('Request to ' +\n                this.handler.path +\n                ' received headers ' +\n                JSON.stringify(metadata.toJSON()));\n        }\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error('Invalid deadline');\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return metadata;\n            }\n            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    receiveUnaryMessage(encoding) {\n        return new Promise((resolve, reject) => {\n            const { stream } = this;\n            let receivedLength = 0;\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const call = this;\n            const body = [];\n            const limit = this.maxReceiveMessageSize;\n            this.stream.on('data', onData);\n            this.stream.on('end', onEnd);\n            this.stream.on('error', onEnd);\n            function onData(chunk) {\n                receivedLength += chunk.byteLength;\n                if (limit !== -1 && receivedLength > limit) {\n                    stream.removeListener('data', onData);\n                    stream.removeListener('end', onEnd);\n                    stream.removeListener('error', onEnd);\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${receivedLength} vs. ${limit})`,\n                    });\n                    return;\n                }\n                body.push(chunk);\n            }\n            function onEnd(err) {\n                stream.removeListener('data', onData);\n                stream.removeListener('end', onEnd);\n                stream.removeListener('error', onEnd);\n                if (err !== undefined) {\n                    reject({ code: constants_1.Status.INTERNAL, details: err.message });\n                    return;\n                }\n                if (receivedLength === 0) {\n                    reject({\n                        code: constants_1.Status.INTERNAL,\n                        details: 'received empty unary message',\n                    });\n                    return;\n                }\n                call.emit('receiveMessage');\n                const requestBytes = Buffer.concat(body, receivedLength);\n                const compressed = requestBytes.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : 'identity';\n                const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n                if (Buffer.isBuffer(decompressedMessage)) {\n                    resolve(call.deserializeMessageWithInternalError(decompressedMessage));\n                    return;\n                }\n                decompressedMessage.then(decompressed => resolve(call.deserializeMessageWithInternalError(decompressed)), (err) => reject(err.code\n                    ? err\n                    : {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n                    }));\n            }\n        });\n    }\n    async deserializeMessageWithInternalError(buffer) {\n        try {\n            return this.deserializeMessage(buffer);\n        }\n        catch (err) {\n            throw {\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL,\n            };\n        }\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        return this.handler.deserialize(bytes);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (metadata === undefined) {\n            metadata = null;\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({ code: constants_1.Status.OK, details: 'OK', metadata });\n        }\n        catch (err) {\n            this.sendError({\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL,\n            });\n        }\n    }\n    sendStatus(statusObj) {\n        var _a, _b;\n        this.emit('callEnd', statusObj.code);\n        this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace('Request to method ' +\n            ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n            ' ended with status code: ' +\n            constants_1.Status[statusObj.code] +\n            ' details: ' +\n            statusObj.details);\n        if (this.deadlineTimer)\n            clearTimeout(this.deadlineTimer);\n        if (this.stream.headersSent) {\n            if (!this.wantTrailers) {\n                this.wantTrailers = true;\n                this.stream.once('wantTrailers', () => {\n                    var _a;\n                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                    this.stream.sendTrailers(trailersToSend);\n                    this.statusSent = true;\n                });\n                this.stream.end();\n            }\n        }\n        else {\n            // Trailers-only response\n            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, defaultResponseHeaders), (_b = statusObj.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\n            this.stream.respond(trailersToSend, { endStream: true });\n            this.statusSent = true;\n        }\n    }\n    sendError(error) {\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: 'message' in error ? error.message : 'Unknown Error',\n            metadata: 'metadata' in error && error.metadata !== undefined\n                ? error.metadata\n                : null,\n        };\n        if ('code' in error &&\n            typeof error.code === 'number' &&\n            Number.isInteger(error.code)) {\n            status.code = error.code;\n            if ('details' in error && typeof error.details === 'string') {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 &&\n            chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n            });\n            return;\n        }\n        this.sendMetadata();\n        this.emit('sendMessage');\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once('cancelled', reason => {\n            call.cancelled = true;\n            call.emit('cancelled', reason);\n        });\n        this.once('callEnd', status => call.emit('callEnd', status));\n    }\n    setupReadable(readable, encoding) {\n        const decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);\n        let readsDone = false;\n        let pendingMessageProcessing = false;\n        let pushedEnd = false;\n        const maybePushEnd = async () => {\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n                pushedEnd = true;\n                await this.pushOrBufferMessage(readable, null);\n            }\n        };\n        this.stream.on('data', async (data) => {\n            let messages;\n            try {\n                messages = decoder.write(data);\n            }\n            catch (e) {\n                this.sendError({\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: e.message\n                });\n                return;\n            }\n            pendingMessageProcessing = true;\n            this.stream.pause();\n            for (const message of messages) {\n                this.emit('receiveMessage');\n                const compressed = message.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : 'identity';\n                let decompressedMessage;\n                try {\n                    decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n                }\n                catch (e) {\n                    this.sendError(e);\n                    return;\n                }\n                // Encountered an error with decompression; it'll already have been propogated back\n                // Just return early\n                if (!decompressedMessage)\n                    return;\n                await this.pushOrBufferMessage(readable, decompressedMessage);\n            }\n            pendingMessageProcessing = false;\n            this.stream.resume();\n            await maybePushEnd();\n        });\n        this.stream.once('end', async () => {\n            readsDone = true;\n            await maybePushEnd();\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while (this.messagesToPush.length > 0) {\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    async pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        }\n        else {\n            await this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            trace('Received end of stream');\n            if (this.canPush) {\n                readable.push(null);\n            }\n            else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        trace('Received message of length ' + messageBytes.length);\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            }\n            else {\n                this.messagesToPush.push(deserialized);\n            }\n        }\n        catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            let code = (0, error_1.getErrorCode)(error);\n            if (code === null || code < constants_1.Status.OK || code > constants_1.Status.UNAUTHENTICATED) {\n                code = constants_1.Status.INTERNAL;\n            }\n            readable.emit('error', {\n                details: (0, error_1.getErrorMessage)(error),\n                code: code,\n            });\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            await this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        var _a;\n        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\n        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            }\n            else {\n                return socket.remoteAddress;\n            }\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getPath() {\n        return this.handler.path;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error('Deadline exceeded');\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit('cancelled', 'deadline');\n}\n//# sourceMappingURL=server-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QixHQUFHLDhCQUE4QixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQjtBQUNsSyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxpRkFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsMkJBQTJCO0FBQzVILHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsU0FBUztBQUM1RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxnQkFBZ0IsTUFBTSxNQUFNO0FBQ2xHLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQXlEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsU0FBUyxRQUFRLFVBQVU7QUFDaEcscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzREFBc0Q7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCwyRkFBMkY7QUFDdEo7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDJGQUEyRjtBQUM1SixrREFBa0QsaUJBQWlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsY0FBYyxNQUFNLHdCQUF3QjtBQUN0RyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQixHQUFHLGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY2FsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMlNlcnZlckNhbGxTdHJlYW0gPSBleHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJVbmFyeUNhbGxJbXBsID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBzdHJlYW1fMSA9IHJlcXVpcmUoXCJzdHJlYW1cIik7XG5jb25zdCB6bGliID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IHN0cmVhbV9kZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9zdHJlYW0tZGVjb2RlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc2VydmVyX2NhbGwnO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBHUlBDX0FDQ0VQVF9FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnO1xuY29uc3QgR1JQQ19FTkNPRElOR19IRUFERVIgPSAnZ3JwYy1lbmNvZGluZyc7XG5jb25zdCBHUlBDX01FU1NBR0VfSEVBREVSID0gJ2dycGMtbWVzc2FnZSc7XG5jb25zdCBHUlBDX1NUQVRVU19IRUFERVIgPSAnZ3JwYy1zdGF0dXMnO1xuY29uc3QgR1JQQ19USU1FT1VUX0hFQURFUiA9ICdncnBjLXRpbWVvdXQnO1xuY29uc3QgREVBRExJTkVfUkVHRVggPSAvKFxcZHsxLDh9KVxccyooW0hNU211bl0pLztcbmNvbnN0IGRlYWRsaW5lVW5pdHNUb01zID0ge1xuICAgIEg6IDM2MDAwMDAsXG4gICAgTTogNjAwMDAsXG4gICAgUzogMTAwMCxcbiAgICBtOiAxLFxuICAgIHU6IDAuMDAxLFxuICAgIG46IDAuMDAwMDAxLFxufTtcbmNvbnN0IGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMgPSB7XG4gICAgLy8gVE9ETyhjamlocmlnKTogUmVtb3ZlIHRoZXNlIGVuY29kaW5nIGhlYWRlcnMgZnJvbSB0aGUgZGVmYXVsdCByZXNwb25zZVxuICAgIC8vIG9uY2UgY29tcHJlc3Npb24gaXMgaW50ZWdyYXRlZC5cbiAgICBbR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcsXG4gICAgW0dSUENfRU5DT0RJTkdfSEVBREVSXTogJ2lkZW50aXR5Jyxcbn07XG5jb25zdCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzID0ge1xuICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1NUQVRVU106IGh0dHAyLmNvbnN0YW50cy5IVFRQX1NUQVRVU19PSyxcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdOiAnYXBwbGljYXRpb24vZ3JwYytwcm90bycsXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyA9IHtcbiAgICB3YWl0Rm9yVHJhaWxlcnM6IHRydWUsXG59O1xuY2xhc3MgU2VydmVyVW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IFNlcnZlclVuYXJ5Q2FsbEltcGw7XG5jbGFzcyBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIGRlc2VyaWFsaXplLCBlbmNvZGluZykge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xuICAgIH1cbiAgICBfcmVhZChzaXplKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsLmNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsLnJlc3VtZSgpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQYXRoKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwgPSBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHNlcmlhbGl6ZSwgcmVxdWVzdCkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFN1cmZhY2VDYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuY2FsbC5zZXJpYWxpemVNZXNzYWdlKGNodW5rKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYWxsLndyaXRlKHJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5vbmNlKCdkcmFpbicsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVyciksXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy50cmFpbGluZ01ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZW5kKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsID0gU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgU2VydmVyRHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGVuY29kaW5nKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVuZChtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckR1cGxleFN0cmVhbUltcGwgPSBTZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX3JlYWQgPVxuICAgIFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX3JlYWQ7XG5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsLnByb3RvdHlwZS5fd3JpdGUgPVxuICAgIFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX3dyaXRlO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX2ZpbmFsID1cbiAgICBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl9maW5hbDtcbi8vIEludGVybmFsIGNsYXNzIHRoYXQgd3JhcHMgdGhlIEhUVFAyIHJlcXVlc3QuXG5jbGFzcyBIdHRwMlNlcnZlckNhbGxTdHJlYW0gZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1RvUHVzaCA9IFtdO1xuICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgdG8gYXZvaWQgdW5jYXVnaHQgZXJyb3IgZXZlbnQgZXhjZXB0aW9ucywgYnV0XG4gICAgICAgICAgICAgKiB0aGVyZSBpcyBub3RoaW5nIHdlIGNhbiByZWFzb25hYmx5IGRvIGhlcmUuIEFueSBlcnJvciBldmVudCBzaG91bGRcbiAgICAgICAgICAgICAqIGhhdmUgYSBjb3JyZXNwb25kaW5nIGNsb3NlIGV2ZW50LCB3aGljaCBoYW5kbGVzIGVtaXR0aW5nIHRoZSBjYW5jZWxsZWRcbiAgICAgICAgICAgICAqIGV2ZW50LiBBbmQgdGhlIHN0cmVhbSBpcyBub3cgaW4gYSBiYWQgc3RhdGUsIHNvIHdlIGNhbid0IHJlYXNvbmFibHlcbiAgICAgICAgICAgICAqIGV4cGVjdCB0byBiZSBhYmxlIHRvIHNlbmQgYW4gZXJyb3Igb3ZlciBpdC4gKi9cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gbWV0aG9kICcgK1xuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXG4gICAgICAgICAgICAgICAgJyBzdHJlYW0gY2xvc2VkIHdpdGggcnN0Q29kZSAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5yc3RDb2RlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNTZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2FuY2VsbGVkJywgJ2NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RyZWFtRW5kJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDYW5jZWxsZWQgYnkgY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmVUaW1lcilcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbignZHJhaW4nLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDYW5jZWxsZWQoKSB7XG4gICAgICAgIC8qIEluIHNvbWUgY2FzZXMgdGhlIHN0cmVhbSBjYW4gYmVjb21lIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNsb3NlIGV2ZW50XG4gICAgICAgICAqIGZpcmVzLiBUaGF0IGNyZWF0ZXMgYSByYWNlIGNvbmRpdGlvbiB0aGF0IHRoaXMgY2hlY2sgd29ya3MgYXJvdW5kICovXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbS5kZXN0cm95ZWQgfHwgdGhpcy5zdHJlYW0uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXREZWNvbXByZXNzZWRNZXNzYWdlKG1lc3NhZ2UsIGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50cyA9IG1lc3NhZ2Uuc3ViYXJyYXkoNSk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2VDb250ZW50cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZyA9PT0gJ2RlZmxhdGUnIHx8IGVuY29kaW5nID09PSAnZ3ppcCcpIHtcbiAgICAgICAgICAgIGxldCBkZWNvbXByZXNzZXI7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdkZWZsYXRlJykge1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlSW5mbGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyID0gemxpYi5jcmVhdGVHdW56aXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlUGFydHMgPSBbXTtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVBhcnRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgIT09IC0xICYmIHRvdGFsTGVuZ3RoID4gdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgdGhhdCBkZWNvbXByZXNzZXMgdG8gYSBzaXplIGxhcmdlciB0aGFuICR7dGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KG1lc3NhZ2VQYXJ0cykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci53cml0ZShtZXNzYWdlQ29udGVudHMpO1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3Nlci5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBjb21wcmVzc2VkIHdpdGggdW5zdXBwb3J0ZWQgZW5jb2RpbmcgXCIke2VuY29kaW5nfVwiYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShjdXN0b21NZXRhZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGFTZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXRhZGF0YVNlbnQgPSB0cnVlO1xuICAgICAgICBjb25zdCBjdXN0b20gPSBjdXN0b21NZXRhZGF0YSA/IGN1c3RvbU1ldGFkYXRhLnRvSHR0cDJIZWFkZXJzKCkgOiBudWxsO1xuICAgICAgICAvLyBUT0RPKGNqaWhyaWcpOiBJbmNsdWRlIGNvbXByZXNzaW9uIGhlYWRlcnMuXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyksIGRlZmF1bHRDb21wcmVzc2lvbkhlYWRlcnMpLCBjdXN0b20pO1xuICAgICAgICB0aGlzLnN0cmVhbS5yZXNwb25kKGhlYWRlcnMsIGRlZmF1bHRSZXNwb25zZU9wdGlvbnMpO1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEoaGVhZGVycykge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgaWYgKGxvZ2dpbmcuaXNUcmFjZXJFbmFibGVkKFRSQUNFUl9OQU1FKSkge1xuICAgICAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gJyArXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVyLnBhdGggK1xuICAgICAgICAgICAgICAgICcgcmVjZWl2ZWQgaGVhZGVycyAnICtcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShtZXRhZGF0YS50b0pTT04oKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oY2ppaHJpZyk6IFJlY2VpdmUgY29tcHJlc3Npb24gbWV0YWRhdGEuXG4gICAgICAgIGNvbnN0IHRpbWVvdXRIZWFkZXIgPSBtZXRhZGF0YS5nZXQoR1JQQ19USU1FT1VUX0hFQURFUik7XG4gICAgICAgIGlmICh0aW1lb3V0SGVhZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGltZW91dEhlYWRlclswXS50b1N0cmluZygpLm1hdGNoKERFQURMSU5FX1JFR0VYKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSW52YWxpZCBkZWFkbGluZScpO1xuICAgICAgICAgICAgICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLk9VVF9PRl9SQU5HRTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoK21hdGNoWzFdICogZGVhZGxpbmVVbml0c1RvTXNbbWF0Y2hbMl1dKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9IG5vdy5zZXRNaWxsaXNlY29uZHMobm93LmdldE1pbGxpc2Vjb25kcygpICsgdGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBzZXRUaW1lb3V0KGhhbmRsZUV4cGlyZWREZWFkbGluZSwgdGltZW91dCwgdGhpcyk7XG4gICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoR1JQQ19USU1FT1VUX0hFQURFUik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHNldmVyYWwgaGVhZGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJvcGFnYXRlZCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQUNDRVBUX0VOQ09ESU5HKTtcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfVEUpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtYWNjZXB0LWVuY29kaW5nJyk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZVVuYXJ5TWVzc2FnZShlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzdHJlYW0gfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgcmVjZWl2ZWRMZW5ndGggPSAwO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBjYWxsID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemU7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5vbignZGF0YScsIG9uRGF0YSk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5vbignZW5kJywgb25FbmQpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgb25FbmQpO1xuICAgICAgICAgICAgZnVuY3Rpb24gb25EYXRhKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGltaXQgIT09IC0xICYmIHJlY2VpdmVkTGVuZ3RoID4gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke3JlY2VpdmVkTGVuZ3RofSB2cy4gJHtsaW1pdH0pYCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYm9keS5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uRW5kKGVycikge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHsgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBkZXRhaWxzOiBlcnIubWVzc2FnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdyZWNlaXZlZCBlbXB0eSB1bmFyeSBtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbC5lbWl0KCdyZWNlaXZlTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RCeXRlcyA9IEJ1ZmZlci5jb25jYXQoYm9keSwgcmVjZWl2ZWRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSByZXF1ZXN0Qnl0ZXMucmVhZFVJbnQ4KDApID09PSAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcgPSBjb21wcmVzc2VkID8gZW5jb2RpbmcgOiAnaWRlbnRpdHknO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZE1lc3NhZ2UgPSBjYWxsLmdldERlY29tcHJlc3NlZE1lc3NhZ2UocmVxdWVzdEJ5dGVzLCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRlY29tcHJlc3NlZE1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY2FsbC5kZXNlcmlhbGl6ZU1lc3NhZ2VXaXRoSW50ZXJuYWxFcnJvcihkZWNvbXByZXNzZWRNZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VkTWVzc2FnZS50aGVuKGRlY29tcHJlc3NlZCA9PiByZXNvbHZlKGNhbGwuZGVzZXJpYWxpemVNZXNzYWdlV2l0aEludGVybmFsRXJyb3IoZGVjb21wcmVzc2VkKSksIChlcnIpID0+IHJlamVjdChlcnIuY29kZVxuICAgICAgICAgICAgICAgICAgICA/IGVyclxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBcImdycGMtZW5jb2RpbmdcIiBoZWFkZXIgXCIke2VuY29kaW5nfVwiIGJ1dCAke2VuY29kaW5nfSBkZWNvbXByZXNzaW9uIGZhaWxlZGAsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGRlc2VyaWFsaXplTWVzc2FnZVdpdGhJbnRlcm5hbEVycm9yKGJ1ZmZlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVNZXNzYWdlKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgICAgIGRldGFpbHM6ICgwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZXJyKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlcmlhbGl6ZU1lc3NhZ2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUJ1ZmZlciA9IHRoaXMuaGFuZGxlci5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgICAvLyBUT0RPKGNqaWhyaWcpOiBDYWxsIGNvbXByZXNzaW9uIGF3YXJlIHNlcmlhbGl6ZU1lc3NhZ2UoKS5cbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IG1lc3NhZ2VCdWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJ5dGVMZW5ndGggKyA1KTtcbiAgICAgICAgb3V0cHV0LndyaXRlVUludDgoMCwgMCk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQzMkJFKGJ5dGVMZW5ndGgsIDEpO1xuICAgICAgICBtZXNzYWdlQnVmZmVyLmNvcHkob3V0cHV0LCA1KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZGVzZXJpYWxpemVNZXNzYWdlKGJ5dGVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIuZGVzZXJpYWxpemUoYnl0ZXMpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVW5hcnlNZXNzYWdlKGVyciwgdmFsdWUsIG1ldGFkYXRhLCBmbGFncykge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIsICdtZXRhZGF0YScpICYmIG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgZXJyLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMuc2VyaWFsaXplTWVzc2FnZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLndyaXRlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7IGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSywgZGV0YWlsczogJ09LJywgbWV0YWRhdGEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGRldGFpbHM6ICgwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZXJyKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kU3RhdHVzKHN0YXR1c09iaikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVtaXQoJ2NhbGxFbmQnLCBzdGF0dXNPYmouY29kZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RyZWFtRW5kJywgc3RhdHVzT2JqLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSyk7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byBtZXRob2QgJyArXG4gICAgICAgICAgICAoKF9hID0gdGhpcy5oYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgK1xuICAgICAgICAgICAgJyBlbmRlZCB3aXRoIHN0YXR1cyBjb2RlOiAnICtcbiAgICAgICAgICAgIGNvbnN0YW50c18xLlN0YXR1c1tzdGF0dXNPYmouY29kZV0gK1xuICAgICAgICAgICAgJyBkZXRhaWxzOiAnICtcbiAgICAgICAgICAgIHN0YXR1c09iai5kZXRhaWxzKTtcbiAgICAgICAgaWYgKHRoaXMuZGVhZGxpbmVUaW1lcilcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0uaGVhZGVyc1NlbnQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy53YW50VHJhaWxlcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbnRUcmFpbGVycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnd2FudFRyYWlsZXJzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJzVG9TZW5kID0gT2JqZWN0LmFzc2lnbih7IFtHUlBDX1NUQVRVU19IRUFERVJdOiBzdGF0dXNPYmouY29kZSwgW0dSUENfTUVTU0FHRV9IRUFERVJdOiBlbmNvZGVVUkkoc3RhdHVzT2JqLmRldGFpbHMpIH0sIChfYSA9IHN0YXR1c09iai5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvSHR0cDJIZWFkZXJzKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5zZW5kVHJhaWxlcnModHJhaWxlcnNUb1NlbmQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c1NlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLmVuZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJhaWxlcnMtb25seSByZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgdHJhaWxlcnNUb1NlbmQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBbR1JQQ19TVEFUVVNfSEVBREVSXTogc3RhdHVzT2JqLmNvZGUsIFtHUlBDX01FU1NBR0VfSEVBREVSXTogZW5jb2RlVVJJKHN0YXR1c09iai5kZXRhaWxzKSB9LCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzKSwgKF9iID0gc3RhdHVzT2JqLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9IdHRwMkhlYWRlcnMoKSk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5yZXNwb25kKHRyYWlsZXJzVG9TZW5kLCB7IGVuZFN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzU2VudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZEVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgZGV0YWlsczogJ21lc3NhZ2UnIGluIGVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIEVycm9yJyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiAnbWV0YWRhdGEnIGluIGVycm9yICYmIGVycm9yLm1ldGFkYXRhICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IGVycm9yLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoJ2NvZGUnIGluIGVycm9yICYmXG4gICAgICAgICAgICB0eXBlb2YgZXJyb3IuY29kZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIE51bWJlci5pc0ludGVnZXIoZXJyb3IuY29kZSkpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb2RlID0gZXJyb3IuY29kZTtcbiAgICAgICAgICAgIGlmICgnZGV0YWlscycgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLmRldGFpbHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgPSBlcnJvci5kZXRhaWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZFN0YXR1cyhzdGF0dXMpO1xuICAgIH1cbiAgICB3cml0ZShjaHVuaykge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplICE9PSAtMSAmJlxuICAgICAgICAgICAgY2h1bmsubGVuZ3RoID4gdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBTZW50IG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke2NodW5rLmxlbmd0aH0gdnMuICR7dGhpcy5tYXhTZW5kTWVzc2FnZVNpemV9KWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRNZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmVtaXQoJ3NlbmRNZXNzYWdlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS53cml0ZShjaHVuayk7XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgdGhpcy5zdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICAgIHNldHVwU3VyZmFjZUNhbGwoY2FsbCkge1xuICAgICAgICB0aGlzLm9uY2UoJ2NhbmNlbGxlZCcsIHJlYXNvbiA9PiB7XG4gICAgICAgICAgICBjYWxsLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBjYWxsLmVtaXQoJ2NhbmNlbGxlZCcsIHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uY2UoJ2NhbGxFbmQnLCBzdGF0dXMgPT4gY2FsbC5lbWl0KCdjYWxsRW5kJywgc3RhdHVzKSk7XG4gICAgfVxuICAgIHNldHVwUmVhZGFibGUocmVhZGFibGUsIGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgc3RyZWFtX2RlY29kZXJfMS5TdHJlYW1EZWNvZGVyKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKTtcbiAgICAgICAgbGV0IHJlYWRzRG9uZSA9IGZhbHNlO1xuICAgICAgICBsZXQgcGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCBwdXNoZWRFbmQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbWF5YmVQdXNoRW5kID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwdXNoZWRFbmQgJiYgcmVhZHNEb25lICYmICFwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBwdXNoZWRFbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uKCdkYXRhJywgYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXMgPSBkZWNvZGVyLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGUubWVzc2FnZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWNlaXZlTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBtZXNzYWdlLnJlYWRVSW50OCgwKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nID0gY29tcHJlc3NlZCA/IGVuY29kaW5nIDogJ2lkZW50aXR5JztcbiAgICAgICAgICAgICAgICBsZXQgZGVjb21wcmVzc2VkTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZWRNZXNzYWdlID0gYXdhaXQgdGhpcy5nZXREZWNvbXByZXNzZWRNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbmNvdW50ZXJlZCBhbiBlcnJvciB3aXRoIGRlY29tcHJlc3Npb247IGl0J2xsIGFscmVhZHkgaGF2ZSBiZWVuIHByb3BvZ2F0ZWQgYmFja1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIGVhcmx5XG4gICAgICAgICAgICAgICAgaWYgKCFkZWNvbXByZXNzZWRNZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoT3JCdWZmZXJNZXNzYWdlKHJlYWRhYmxlLCBkZWNvbXByZXNzZWRNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgICAgICBhd2FpdCBtYXliZVB1c2hFbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJlYWRzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICBhd2FpdCBtYXliZVB1c2hFbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN1bWVVbnB1c2hlZE1lc3NhZ2VzKHJlYWRhYmxlKSB7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XG4gICAgICAgIHdoaWxlICh0aGlzLm1lc3NhZ2VzVG9QdXNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRNZXNzYWdlID0gdGhpcy5tZXNzYWdlc1RvUHVzaC5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3QgY2FuUHVzaCA9IHJlYWRhYmxlLnB1c2gobmV4dE1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKG5leHRNZXNzYWdlID09PSBudWxsIHx8IGNhblB1c2ggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuUHVzaDtcbiAgICB9XG4gICAgYXN5bmMgcHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUHVzaFBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1c2hNZXNzYWdlKHJlYWRhYmxlLCBtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHB1c2hNZXNzYWdlKHJlYWRhYmxlLCBtZXNzYWdlQnl0ZXMpIHtcbiAgICAgICAgaWYgKG1lc3NhZ2VCeXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhY2UoJ1JlY2VpdmVkIGVuZCBvZiBzdHJlYW0nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgICAgICByZWFkYWJsZS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1RvUHVzaC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSZWNlaXZlZCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZUJ5dGVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWQgPSBhd2FpdCB0aGlzLmRlc2VyaWFsaXplTWVzc2FnZShtZXNzYWdlQnl0ZXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVhZGFibGUucHVzaChkZXNlcmlhbGl6ZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2gucHVzaChkZXNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gSWdub3JlIGFueSByZW1haW5pbmcgbWVzc2FnZXMgd2hlbiBlcnJvcnMgb2NjdXIuXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGxldCBjb2RlID0gKDAsIGVycm9yXzEuZ2V0RXJyb3JDb2RlKShlcnJvcik7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gbnVsbCB8fCBjb2RlIDwgY29uc3RhbnRzXzEuU3RhdHVzLk9LIHx8IGNvZGUgPiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRhYmxlLmVtaXQoJ2Vycm9yJywge1xuICAgICAgICAgICAgICAgIGRldGFpbHM6ICgwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnB1c2hNZXNzYWdlKHJlYWRhYmxlLCB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSAoX2EgPSB0aGlzLnN0cmVhbS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc29ja2V0O1xuICAgICAgICBpZiAoc29ja2V0ID09PSBudWxsIHx8IHNvY2tldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc29ja2V0LnJlbW90ZUFkZHJlc3MpIHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQucmVtb3RlUG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzb2NrZXQucmVtb3RlQWRkcmVzc306JHtzb2NrZXQucmVtb3RlUG9ydH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVhZGxpbmU7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLkh0dHAyU2VydmVyQ2FsbFN0cmVhbSA9IEh0dHAyU2VydmVyQ2FsbFN0cmVhbTtcbmZ1bmN0aW9uIGhhbmRsZUV4cGlyZWREZWFkbGluZShjYWxsKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdEZWFkbGluZSBleGNlZWRlZCcpO1xuICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLkRFQURMSU5FX0VYQ0VFREVEO1xuICAgIGNhbGwuc2VuZEVycm9yKGVycik7XG4gICAgY2FsbC5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGNhbGwuZW1pdCgnY2FuY2VsbGVkJywgJ2RlYWRsaW5lJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerCredentials = void 0;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError('rootCerts must be null or a Buffer');\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError('keyCertPairs must be an array');\n        }\n        if (typeof checkClientCertificate !== 'boolean') {\n            throw new TypeError('checkClientCertificate must be a boolean');\n        }\n        const cert = [];\n        const key = [];\n        for (let i = 0; i < keyCertPairs.length; i++) {\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== 'object') {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            ca: rootCerts || (0, tls_helpers_1.getDefaultRootsData)() || undefined,\n            cert,\n            key,\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES,\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    _isSecure() {\n        return false;\n    }\n    _getSettings() {\n        return null;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(options) {\n        super();\n        this.options = options;\n    }\n    _isSecure() {\n        return true;\n    }\n    _getSettings() {\n        return this.options;\n    }\n}\n//# sourceMappingURL=server-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY3JlZGVudGlhbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekIsc0JBQXNCLG1CQUFPLENBQUMsNkZBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXItY3JlZGVudGlhbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCB0bHNfaGVscGVyc18xID0gcmVxdWlyZShcIi4vdGxzLWhlbHBlcnNcIik7XG5jbGFzcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgc3RhdGljIGNyZWF0ZUluc2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVNzbChyb290Q2VydHMsIGtleUNlcnRQYWlycywgY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChyb290Q2VydHMgIT09IG51bGwgJiYgIUJ1ZmZlci5pc0J1ZmZlcihyb290Q2VydHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyb290Q2VydHMgbXVzdCBiZSBudWxsIG9yIGEgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGtleUNlcnRQYWlycykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2tleUNlcnRQYWlycyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja0NsaWVudENlcnRpZmljYXRlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NoZWNrQ2xpZW50Q2VydGlmaWNhdGUgbXVzdCBiZSBhIGJvb2xlYW4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZXJ0ID0gW107XG4gICAgICAgIGNvbnN0IGtleSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUNlcnRQYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IGtleUNlcnRQYWlyc1tpXTtcbiAgICAgICAgICAgIGlmIChwYWlyID09PSBudWxsIHx8IHR5cGVvZiBwYWlyICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dIG11c3QgYmUgYW4gb2JqZWN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYWlyLnByaXZhdGVfa2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGtleUNlcnRQYWlyWyR7aX1dLnByaXZhdGVfa2V5IG11c3QgYmUgYSBCdWZmZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHBhaXIuY2VydF9jaGFpbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBrZXlDZXJ0UGFpclske2l9XS5jZXJ0X2NoYWluIG11c3QgYmUgYSBCdWZmZXJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNlcnQucHVzaChwYWlyLmNlcnRfY2hhaW4pO1xuICAgICAgICAgICAga2V5LnB1c2gocGFpci5wcml2YXRlX2tleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyh7XG4gICAgICAgICAgICBjYTogcm9vdENlcnRzIHx8ICgwLCB0bHNfaGVscGVyc18xLmdldERlZmF1bHRSb290c0RhdGEpKCkgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VydCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHJlcXVlc3RDZXJ0OiBjaGVja0NsaWVudENlcnRpZmljYXRlLFxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlckNyZWRlbnRpYWxzID0gU2VydmVyQ3JlZGVudGlhbHM7XG5jbGFzcyBJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIGV4dGVuZHMgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNsYXNzIFNlY3VyZVNlcnZlckNyZWRlbnRpYWxzIGV4dGVuZHMgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2dldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZlci1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = 'server';\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch(handlerType){\n        case 'unary':\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'clientStream':\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'serverStream':\n            return (call)=>{\n                call.emit('error', unimplementedStatusResponse);\n            };\n        case 'bidi':\n            return (call)=>{\n                call.emit('error', unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options){\n        var _a, _b, _c, _d;\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.shutdown = false;\n        this.serverAddressString = 'null';\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzServer)(()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Server created');\n        }\n        this.maxConnectionAgeMs = (_a = this.options['grpc.max_connection_age_ms']) !== null && _a !== void 0 ? _a : UNLIMITED_CONNECTION_AGE_MS;\n        this.maxConnectionAgeGraceMs = (_b = this.options['grpc.max_connection_age_grace_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n        this.keepaliveTimeMs = (_c = this.options['grpc.keepalive_time_ms']) !== null && _c !== void 0 ? _c : KEEPALIVE_MAX_TIME_MS;\n        this.keepaliveTimeoutMs = (_d = this.options['grpc.keepalive_timeout_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_TIMEOUT_MS;\n        this.trace('Server constructed');\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return ()=>{\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n                    remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n                };\n            } else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n    }\n    addProtoService() {\n        throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n        if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n            throw new Error('addService() requires two objects as arguments');\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error('Cannot add an empty service to a server');\n        }\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = 'bidi';\n                } else {\n                    methodType = 'clientStream';\n                }\n            } else {\n                if (attrs.responseStream) {\n                    methodType = 'serverStream';\n                } else {\n                    methodType = 'unary';\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === 'string') {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            } else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== 'object') {\n            throw new Error('removeService() requires object as argument');\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (this.shutdown) {\n            throw new Error('bindAsync called after shutdown');\n        }\n        if (typeof port !== 'string') {\n            throw new TypeError('port must be a string');\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError('creds must be a ServerCredentials object');\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError('callback must be a function');\n        }\n        const initialPortUri = (0, uri_parser_1.parseUri)(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n        };\n        if ('grpc-node.max_session_memory' in this.options) {\n            serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */ serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if ('grpc.max_concurrent_streams' in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n            };\n        }\n        const deferredCallback = (error, port)=>{\n            process.nextTick(()=>callback(error, port));\n        };\n        const setupServer = ()=>{\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                secureServerOptions.enableTrace = this.options['grpc-node.tls_enable_trace'] === 1;\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on('secureConnection', (socket)=>{\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                     * according to https://github.com/nodejs/node/issues/35824 */ socket.on('error', (e)=>{\n                        this.trace('An incoming TLS connection closed with error: ' + e.message);\n                    });\n                });\n            } else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: portNum,\n                    count: previousCount\n                });\n            }\n            return Promise.all(addressList.map((address)=>{\n                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n                let addr;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum\n                    };\n                } else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject)=>{\n                    const onError = (err)=>{\n                        this.trace('Failed to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address) + ' with error ' + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once('error', onError);\n                    http2Server.listen(addr, ()=>{\n                        if (this.shutdown) {\n                            http2Server.close();\n                            resolve(new Error('bindAsync failed because server is shutdown'));\n                            return;\n                        }\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === 'string') {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        } else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({\n                            server: http2Server,\n                            channelzRef: channelzRef\n                        });\n                        this.trace('Successfully bound ' + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                        resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener('error', onError);\n                    });\n                });\n            })).then((results)=>{\n                let count = 0;\n                for (const result of results){\n                    if (typeof result === 'number') {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error('Invalid state: multiple port numbers added from single address');\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount\n                };\n            });\n        };\n        const bindWildcardPort = (addressList)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: 0,\n                    count: 0\n                });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject)=>{\n                const onError = (err)=>{\n                    this.trace('Failed to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address) + ' with error ' + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once('error', onError);\n                http2Server.listen(address, ()=>{\n                    if (this.shutdown) {\n                        http2Server.close();\n                        resolve({\n                            port: 0,\n                            count: 0\n                        });\n                        return;\n                    }\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({\n                        server: http2Server,\n                        channelzRef: channelzRef\n                    });\n                    this.trace('Successfully bound ' + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener('error', onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError)=>{\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = ()=>{};\n                if (this.shutdown) {\n                    deferredCallback(new Error(`bindAsync failed because server is shutdown`), 0);\n                }\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    } else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                } else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult)=>{\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    } else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error)=>{\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error)=>{\n                deferredCallback(new Error(error.details), 0);\n            }\n        };\n        const resolver = (0, resolver_1.createResolver)(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        this.shutdown = true;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session)=>{\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server })=>http2Server.listening !== true)) {\n            throw new Error('server must be bound in order to start');\n        }\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Starting');\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error)=>{\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        this.shutdown = true;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session)=>{\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error('Not yet implemented');\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n            }, {\n                endStream: true\n            });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(path) {\n        this.trace('Received call to method ' + path + ' at address ' + this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n            return null;\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once('callEnd', (code)=>{\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once('streamEnd', (success)=>{\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                } else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on('sendMessage', ()=>{\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on('receiveMessage', ()=>{\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';\n        metadata.remove('grpc-encoding');\n        const { type } = handler;\n        if (type === 'unary') {\n            handleUnary(call, handler, metadata, encoding);\n        } else if (type === 'clientStream') {\n            handleClientStreaming(call, handler, metadata, encoding);\n        } else if (type === 'serverStream') {\n            handleServerStreaming(call, handler, metadata, encoding);\n        } else if (type === 'bidi') {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        } else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = 'null';\n        if (serverAddress) {\n            if (typeof serverAddress === 'string') {\n                serverAddressString = serverAddress;\n            } else {\n                serverAddressString = serverAddress.address + ':' + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n        http2Server.on('stream', handler.bind(this));\n        http2Server.on('session', (session)=>{\n            var _a, _b, _c, _d, _e;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            const channelzRef = (0, channelz_1.registerChannelzSocket)((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            let connectionAgeTimer = null;\n            let connectionAgeGraceTimer = null;\n            let sessionClosedByServer = false;\n            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                // Apply a random jitter within a +/-10% range\n                const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                connectionAgeTimer = (_c = (_b = setTimeout(()=>{\n                    var _a, _b;\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\n                    }\n                    try {\n                        session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), Buffer.from('max_age'));\n                    } catch (e) {\n                        // The goaway can't be sent because the session is already closed\n                        session.destroy();\n                        return;\n                    }\n                    session.close();\n                    /* Allow a grace period after sending the GOAWAY before forcibly\n                     * closing the connection. */ if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                        connectionAgeGraceTimer = (_b = (_a = setTimeout(()=>{\n                            session.destroy();\n                        }, this.maxConnectionAgeGraceMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                }, this.maxConnectionAgeMs + jitter)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n            }\n            const keeapliveTimeTimer = (_e = (_d = setInterval(()=>{\n                var _a, _b;\n                const timeoutTImer = (_b = (_a = setTimeout(()=>{\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\n                    }\n                    session.close();\n                }, this.keepaliveTimeoutMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                try {\n                    session.ping((err, duration, payload)=>{\n                        clearTimeout(timeoutTImer);\n                    });\n                } catch (e) {\n                    // The ping can't be sent because the session is already closed\n                    session.destroy();\n                }\n            }, this.keepaliveTimeMs)).unref) === null || _e === void 0 ? void 0 : _e.call(_d);\n            session.on('close', ()=>{\n                if (this.channelzEnabled) {\n                    if (!sessionClosedByServer) {\n                        this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n                    }\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    (0, channelz_1.unregisterChannelzRef)(channelzRef);\n                }\n                if (connectionAgeTimer) {\n                    clearTimeout(connectionAgeTimer);\n                }\n                if (connectionAgeGraceTimer) {\n                    clearTimeout(connectionAgeGraceTimer);\n                }\n                if (keeapliveTimeTimer) {\n                    clearTimeout(keeapliveTimeTimer);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nasync function handleUnary(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags)=>{\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on('error', respond);\n    handler.func(stream, respond);\n}\nasync function handleServerStreaming(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n} //# sourceMappingURL=server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRzs7OztBQUVILHdEQUErQjtBQUkvQixtSUFBbUQ7QUFHbkQseUlBb0J1QjtBQUN2Qiw4SkFBeUQ7QUFFekQsZ0lBSW9CO0FBQ3BCLDJIQUFxQztBQUNyQyw4SkFNOEI7QUFDOUIsc0lBQXdDO0FBQ3hDLGdJQVlvQjtBQUdwQixNQUFNLDJCQUEyQixHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRSxDQUFDO0FBQzlDLE1BQU0scUJBQXFCLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFFLENBQUM7QUFDeEMsTUFBTSxvQkFBb0IsR0FBRyxLQUFLLENBQUM7QUFFbkMsTUFBTSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQztBQUU5QyxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUM7QUFPN0IsU0FBUyxJQUFJLElBQVUsQ0FBQztBQUV4QixTQUFTLDhCQUE4QixDQUNyQyxVQUFrQjtJQUVsQixPQUFPO1FBQ0wsSUFBSSxFQUFFLGtCQUFNLENBQUMsYUFBYTtRQUMxQixPQUFPLEVBQUUsNENBQTRDLFVBQVUsRUFBRTtLQUNsRSxDQUFDO0FBQ0osQ0FBQztBQWFELFNBQVMsaUJBQWlCLENBQUMsV0FBd0IsRUFBRSxVQUFrQjtJQUNyRSxNQUFNLDJCQUEyQixHQUMvQiw4QkFBOEIsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUM3QyxPQUFRLFdBQVcsRUFBRTtRQUNuQixLQUFLLE9BQU87WUFDVixPQUFPLENBQ0wsSUFBK0IsRUFDL0IsUUFBNEIsRUFDNUIsRUFBRTtnQkFDRixRQUFRLENBQUMsMkJBQTJDLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDOUQsQ0FBQyxDQUFDO1FBQ0osS0FBSyxjQUFjO1lBQ2pCLE9BQU8sQ0FDTCxJQUFvQyxFQUNwQyxRQUE0QixFQUM1QixFQUFFO2dCQUNGLFFBQVEsQ0FBQywyQkFBMkMsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM5RCxDQUFDLENBQUM7UUFDSixLQUFLLGNBQWM7WUFDakIsT0FBTyxDQUFDLElBQW9DLEVBQUUsRUFBRTtnQkFDOUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsMkJBQTJCLENBQUMsQ0FBQztZQUNsRCxDQUFDLENBQUM7UUFDSixLQUFLLE1BQU07WUFDVCxPQUFPLENBQUMsSUFBa0MsRUFBRSxFQUFFO2dCQUM1QyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSwyQkFBMkIsQ0FBQyxDQUFDO1lBQ2xELENBQUMsQ0FBQztRQUNKO1lBQ0UsTUFBTSxJQUFJLEtBQUssQ0FBQyx1QkFBdUIsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUMxRCxDQUFDO0FBQ0gsQ0FBQztBQVdELE1BQWEsTUFBTTtJQThCakIsWUFBWSxPQUF3Qjs7UUE3QjVCLG9CQUFlLEdBR2pCLEVBQUUsQ0FBQztRQUVELGFBQVEsR0FBZ0MsSUFBSSxHQUFHLEVBR3BELENBQUM7UUFDSSxhQUFRLEdBQUcsSUFBSSxHQUFHLEVBQWlELENBQUM7UUFDcEUsWUFBTyxHQUFHLEtBQUssQ0FBQztRQUNoQixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRWpCLHdCQUFtQixHQUFHLE1BQU0sQ0FBQztRQUVyQyxnQkFBZ0I7UUFDQyxvQkFBZSxHQUFZLElBQUksQ0FBQztRQUV6QyxrQkFBYSxHQUFHLElBQUksd0JBQWEsRUFBRSxDQUFDO1FBQ3BDLGdCQUFXLEdBQUcsSUFBSSw4QkFBbUIsRUFBRSxDQUFDO1FBQ3hDLDRCQUF1QixHQUFHLElBQUksa0NBQXVCLEVBQUUsQ0FBQztRQUN4RCwyQkFBc0IsR0FBRyxJQUFJLGtDQUF1QixFQUFFLENBQUM7UUFTN0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPLGFBQVAsT0FBTyxjQUFQLE9BQU8sR0FBSSxFQUFFLENBQUM7UUFDN0IsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLHNCQUFzQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDL0MsSUFBSSxDQUFDLGVBQWUsR0FBRyxLQUFLLENBQUM7UUFDL0IsQ0FBQztRQUNELElBQUksQ0FBQyxXQUFXLEdBQUcsdUNBQ2pCLEdBQUcsQ0FBRyxDQUFELEdBQUssQ0FBQyxlQUFlLEVBQUUsRUFDNUIsSUFBSSxDQUFDLGVBQWUsQ0FDckIsQ0FBQztRQUNGLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzNELENBQUM7UUFDRCxJQUFJLENBQUMsa0JBQWtCLEdBQ3JCLFVBQUksQ0FBQyxPQUFPLENBQUMsNkJBQTRCLE1BQUMsNkJBQUksMkJBQTJCLENBQUM7UUFDNUUsSUFBSSxDQUFDLHVCQUF1QixHQUMxQixVQUFJLENBQUMsT0FBTyxDQUFDLG1DQUFrQyxNQUFDLDZCQUNoRCwyQkFBMkIsQ0FBQztRQUM5QixJQUFJLENBQUMsZUFBZSxHQUNsQixVQUFJLENBQUMsT0FBTyxDQUFDLHlCQUF3QixNQUFDLDZCQUFJLHFCQUFxQixDQUFDO1FBQ2xFLElBQUksQ0FBQyxrQkFBa0IsR0FDckIsVUFBSSxDQUFDLE9BQU8sQ0FBQyw0QkFBMkIsTUFBQyw2QkFBSSxvQkFBb0IsQ0FBQztRQUNwRSxJQUFJLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVPLGVBQWU7UUFDckIsT0FBTztZQUNMLEtBQUssRUFBRSxJQUFJLENBQUMsYUFBYTtZQUN6QixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsZ0JBQWdCLEVBQUUsSUFBSSxDQUFDLHVCQUF1QixDQUFDLGFBQWEsRUFBRTtZQUM5RCxlQUFlLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLGFBQWEsRUFBRTtTQUM3RCxDQUFDO0lBQ0osQ0FBQztJQUVPLDRCQUE0QixDQUNsQyxPQUFpQztRQUVqQyxPQUFPLEdBQUcsRUFBRTs7WUFDVixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUUsQ0FBQztZQUNoRCxNQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDO1lBQ3JDLE1BQU0sYUFBYSxHQUFHLGFBQWEsQ0FBQyxhQUFhLEdBQzdDLG9EQUNFLGFBQWEsQ0FBQyxhQUFhLEVBQzNCLGFBQWEsQ0FBQyxVQUFVLENBQ3pCLEdBQ0QsSUFBSSxDQUFDO1lBQ1QsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLFlBQVksR0FDM0Msb0RBQ0UsYUFBYSxDQUFDLFlBQWEsRUFDM0IsYUFBYSxDQUFDLFNBQVMsQ0FDeEIsR0FDRCxJQUFJLENBQUM7WUFDVCxJQUFJLE9BQXVCLENBQUM7WUFDNUIsSUFBSSxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ3RCLE1BQU0sU0FBUyxHQUFjLGFBQTBCLENBQUM7Z0JBQ3hELE1BQU0sVUFBVSxHQUNkLFNBQVMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDeEIsTUFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLGNBQWMsRUFBRSxDQUFDO2dCQUMvQyxNQUFNLGVBQWUsR0FBRyxTQUFTLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztnQkFDdkQsT0FBTyxHQUFHO29CQUNSLHVCQUF1QixFQUFFLGdCQUFVLENBQUMsa0JBQVksNkJBQUksSUFBSTtvQkFDeEQsb0JBQW9CLEVBQUUsVUFBVSxDQUFDLFlBQVksR0FDekMsSUFBSSxHQUNKLFVBQVUsQ0FBQyxJQUFJO29CQUNuQixnQkFBZ0IsRUFDZCxXQUFXLElBQUksS0FBSyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSTtvQkFDOUQsaUJBQWlCLEVBQ2YsZUFBZSxJQUFJLEtBQUssSUFBSSxlQUFlLEdBQ3ZDLGVBQWUsQ0FBQyxHQUFHLEdBQ25CLElBQUk7aUJBQ1gsQ0FBQztZQUNKLENBQUMsTUFBTSxDQUFDO2dCQUNOLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDakIsQ0FBQztZQUNELE1BQU0sVUFBVSxHQUFlO2dCQUM3QixhQUFhLEVBQUUsYUFBYTtnQkFDNUIsWUFBWSxFQUFFLFlBQVk7Z0JBQzFCLFFBQVEsRUFBRSxPQUFPO2dCQUNqQixVQUFVLEVBQUUsSUFBSTtnQkFDaEIsY0FBYyxFQUFFLFdBQVcsQ0FBQyxhQUFhLENBQUMsWUFBWTtnQkFDdEQsZ0JBQWdCLEVBQUUsV0FBVyxDQUFDLGFBQWEsQ0FBQyxjQUFjO2dCQUMxRCxhQUFhLEVBQUUsV0FBVyxDQUFDLGFBQWEsQ0FBQyxXQUFXO2dCQUNwRCxZQUFZLEVBQUUsV0FBVyxDQUFDLFlBQVk7Z0JBQ3RDLGdCQUFnQixFQUFFLFdBQVcsQ0FBQyxnQkFBZ0I7Z0JBQzlDLGNBQWMsRUFBRSxDQUFDO2dCQUNqQiwrQkFBK0IsRUFBRSxJQUFJO2dCQUNyQyxnQ0FBZ0MsRUFDOUIsV0FBVyxDQUFDLGFBQWEsQ0FBQyx3QkFBd0I7Z0JBQ3BELHdCQUF3QixFQUFFLFdBQVcsQ0FBQyx3QkFBd0I7Z0JBQzlELDRCQUE0QixFQUFFLFdBQVcsQ0FBQyw0QkFBNEI7Z0JBQ3RFLHNCQUFzQixFQUFFLGFBQU8sQ0FBQyxLQUFLLENBQUMscUJBQWUsNkJBQUksSUFBSTtnQkFDN0QsdUJBQXVCLEVBQUUsYUFBTyxDQUFDLEtBQUssQ0FBQyxzQkFBZ0IsNkJBQUksSUFBSTthQUNoRSxDQUFDO1lBQ0YsT0FBTyxVQUFVLENBQUM7UUFDcEIsQ0FBQyxDQUFDO0lBQ0osQ0FBQztJQUVPLEtBQUssQ0FBQyxJQUFZO1FBQ3hCLE9BQU8sQ0FBQyxLQUFLLENBQ1gsd0JBQVksQ0FBQyxLQUFLLEVBQ2xCLFdBQVcsRUFDWCxHQUFHLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FDeEMsQ0FBQztJQUNKLENBQUM7SUFFRCxlQUFlO1FBQ2IsTUFBTSxJQUFJLEtBQUssQ0FBQywyQ0FBMkMsQ0FBQyxDQUFDO0lBQy9ELENBQUM7SUFFRCxVQUFVLENBQ1IsT0FBMEIsRUFDMUIsY0FBNEM7UUFFNUMsSUFDRSxPQUFPLEtBQUssSUFBSSxJQUNoQixPQUFPLE9BQU8sS0FBSyxRQUFRLElBQzNCLGNBQWMsS0FBSyxJQUFJLElBQ3ZCLE9BQU8sY0FBYyxLQUFLLFFBQVEsRUFDbEMsQ0FBQztZQUNELE1BQU0sSUFBSSxLQUFLLENBQUMsZ0RBQWdELENBQUMsQ0FBQztRQUNwRSxDQUFDO1FBRUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV6QyxJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDN0IsTUFBTSxJQUFJLEtBQUssQ0FBQyx5Q0FBeUMsQ0FBQyxDQUFDO1FBQzdELENBQUM7UUFFRCxXQUFXLENBQUMsT0FBTyxFQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3pCLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1QixJQUFJLFVBQXVCLENBQUM7WUFFNUIsSUFBSSxLQUFLLENBQUMsYUFBYSxFQUFFLENBQUM7Z0JBQ3hCLElBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO29CQUN6QixVQUFVLEdBQUcsTUFBTSxDQUFDO2dCQUN0QixDQUFDLE1BQU0sQ0FBQztvQkFDTixVQUFVLEdBQUcsY0FBYyxDQUFDO2dCQUM5QixDQUFDO1lBQ0gsQ0FBQyxNQUFNLENBQUM7Z0JBQ04sSUFBSSxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7b0JBQ3pCLFVBQVUsR0FBRyxjQUFjLENBQUM7Z0JBQzlCLENBQUMsTUFBTSxDQUFDO29CQUNOLFVBQVUsR0FBRyxPQUFPLENBQUM7Z0JBQ3ZCLENBQUM7WUFDSCxDQUFDO1lBRUQsSUFBSSxNQUFNLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2xDLElBQUksSUFBSSxDQUFDO1lBRVQsSUFBSSxNQUFNLEtBQUssU0FBUyxJQUFJLE9BQU8sS0FBSyxDQUFDLFlBQVksS0FBSyxRQUFRLEVBQUUsQ0FBQztnQkFDbkUsTUFBTSxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDOUMsQ0FBQztZQUVELElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRSxDQUFDO2dCQUN6QixJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNyQyxDQUFDLE1BQU0sQ0FBQztnQkFDTixJQUFJLEdBQUcsaUJBQWlCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzdDLENBQUM7WUFFRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUMzQixLQUFLLENBQUMsSUFBSSxFQUNWLElBQXlCLEVBQ3pCLEtBQUssQ0FBQyxpQkFBaUIsRUFDdkIsS0FBSyxDQUFDLGtCQUFrQixFQUN4QixVQUFVLENBQ1gsQ0FBQztZQUVGLElBQUksT0FBTyxLQUFLLEtBQUssRUFBRSxDQUFDO2dCQUN0QixNQUFNLElBQUksS0FBSyxDQUFDLHNCQUFzQixLQUFLLENBQUMsSUFBSSxvQkFBb0IsQ0FBQyxDQUFDO1lBQ3hFLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxhQUFhLENBQUMsT0FBMEI7UUFDdEMsSUFBSSxPQUFPLEtBQUssSUFBSSxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsRUFBRSxDQUFDO1lBQ3BELE1BQU0sSUFBSSxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztRQUNqRSxDQUFDO1FBRUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN6QyxXQUFXLENBQUMsT0FBTyxFQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3pCLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM1QixJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM5QixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxJQUFJLENBQUMsSUFBWSxFQUFFLEtBQXdCO1FBQ3pDLE1BQU0sSUFBSSxLQUFLLENBQUMsMENBQTBDLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBRUQsU0FBUyxDQUNQLElBQVksRUFDWixLQUF3QixFQUN4QixRQUFxRDtRQUVyRCxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNsQixNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7UUFDckQsQ0FBQztRQUVELElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFLENBQUM7WUFDN0IsTUFBTSxJQUFJLFNBQVMsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFFRCxJQUFJLEtBQUssS0FBSyxJQUFJLElBQUksQ0FBQyxDQUFDLEtBQUssWUFBWSx1Q0FBa0IsRUFBRSxDQUFDO1lBQzVELE1BQU0sSUFBSSxTQUFTLENBQUMsMENBQTBDLENBQUMsQ0FBQztRQUNsRSxDQUFDO1FBRUQsSUFBSSxPQUFPLFFBQVEsS0FBSyxVQUFVLEVBQUUsQ0FBQztZQUNuQyxNQUFNLElBQUksU0FBUyxDQUFDLDZCQUE2QixDQUFDLENBQUM7UUFDckQsQ0FBQztRQUVELE1BQU0sY0FBYyxHQUFHLDJCQUFTLElBQUksQ0FBQyxDQUFDO1FBQ3RDLElBQUksY0FBYyxLQUFLLElBQUksRUFBRSxDQUFDO1lBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLElBQUksR0FBRyxDQUFDLENBQUM7UUFDcEQsQ0FBQztRQUNELE1BQU0sT0FBTyxHQUFHLG9DQUFvQixjQUFjLENBQUMsQ0FBQztRQUNwRCxJQUFJLE9BQU8sS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUNyQixNQUFNLElBQUksS0FBSyxDQUFDLDRDQUE0QyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ3ZFLENBQUM7UUFFRCxNQUFNLGFBQWEsR0FBd0I7WUFDekMsd0JBQXdCLEVBQUUsTUFBTSxDQUFDLGdCQUFnQjtTQUNsRCxDQUFDO1FBQ0YsSUFBSSw4QkFBOEIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbkQsYUFBYSxDQUFDLGdCQUFnQixHQUM1QixJQUFJLENBQUMsT0FBTyxDQUFDLDhCQUE4QixDQUFDLENBQUM7UUFDakQsQ0FBQyxNQUFNLENBQUM7WUFDTjs7O2tEQUdzQyxDQUN0QyxhQUFhLENBQUMsZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDO1FBQzNELENBQUM7UUFDRCxJQUFJLDZCQUE2QixJQUFJLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNsRCxhQUFhLENBQUMsUUFBUSxHQUFHO2dCQUN2QixvQkFBb0IsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLDZCQUE2QixDQUFDO2FBQ2xFLENBQUM7UUFDSixDQUFDO1FBRUQsTUFBTSxnQkFBZ0IsR0FBRyxDQUFDLEtBQW1CLEVBQUUsSUFBWSxFQUFFLEVBQUU7WUFDN0QsT0FBTyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUcsQ0FBRCxPQUFTLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDaEQsQ0FBQyxDQUFDO1FBRUYsTUFBTSxXQUFXLEdBQUcsR0FBZ0QsRUFBRTtZQUNwRSxJQUFJLFdBQXdELENBQUM7WUFDN0QsSUFBSSxLQUFLLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQztnQkFDdEIsTUFBTSxtQkFBbUIsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUN2QyxhQUFhLEVBQ2IsS0FBSyxDQUFDLFlBQVksRUFBRyxDQUN0QixDQUFDO2dCQUNGLG1CQUFtQixDQUFDLFdBQVcsR0FDN0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyw0QkFBNEIsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDbkQsV0FBVyxHQUFHLEtBQUssQ0FBQyxrQkFBa0IsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO2dCQUM1RCxXQUFXLENBQUMsRUFBRSxDQUFDLGtCQUFrQixFQUFFLENBQUMsTUFBaUIsRUFBRSxFQUFFO29CQUN2RDtrRkFDOEQsQ0FDOUQsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFRLEVBQUUsRUFBRTt3QkFDOUIsSUFBSSxDQUFDLEtBQUssQ0FDUixnREFBZ0QsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUM3RCxDQUFDO29CQUNKLENBQUMsQ0FBQyxDQUFDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxNQUFNLENBQUM7Z0JBQ04sV0FBVyxHQUFHLEtBQUssQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDbEQsQ0FBQztZQUVELFdBQVcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2hDLElBQUksQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDakMsT0FBTyxXQUFXLENBQUM7UUFDckIsQ0FBQyxDQUFDO1FBRUYsTUFBTSxnQkFBZ0IsR0FBRyxDQUN2QixXQUFnQyxFQUNoQyxPQUFlLEVBQ2YsYUFBcUIsRUFDQSxFQUFFO1lBQ3ZCLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDN0IsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDO29CQUFFLElBQUksRUFBRSxPQUFPO29CQUFFLEtBQUssRUFBRSxhQUFhO2dCQUFBLENBQUUsQ0FBQyxDQUFDO1lBQ2xFLENBQUM7WUFDRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQ2hCLFdBQVcsQ0FBQyxHQUFHLEVBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ3hCLElBQUksQ0FBQyxLQUFLLENBQ1IscUJBQXFCLEdBQUcsb0RBQTBCLE9BQU8sQ0FBQyxDQUMzRCxDQUFDO2dCQUNGLElBQUksSUFBdUIsQ0FBQztnQkFDNUIsSUFBSSxpREFBdUIsT0FBTyxDQUFDLEVBQUUsQ0FBQztvQkFDcEMsSUFBSSxHQUFHO3dCQUNMLElBQUksRUFBRyxPQUFnQyxDQUFDLElBQUk7d0JBQzVDLElBQUksRUFBRSxPQUFPO3FCQUNkLENBQUM7Z0JBQ0osQ0FBQyxNQUFNLENBQUM7b0JBQ04sSUFBSSxHQUFHLE9BQU8sQ0FBQztnQkFDakIsQ0FBQztnQkFFRCxNQUFNLFdBQVcsR0FBRyxXQUFXLEVBQUUsQ0FBQztnQkFDbEMsT0FBTyxJQUFJLE9BQU8sQ0FBaUIsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7b0JBQ3JELE1BQU0sT0FBTyxHQUFHLENBQUMsR0FBVSxFQUFFLEVBQUU7d0JBQzdCLElBQUksQ0FBQyxLQUFLLENBQ1IsaUJBQWlCLEdBQ2Ysb0RBQTBCLE9BQU8sQ0FBQyxHQUNsQyxjQUFjLEdBQ2QsR0FBRyxDQUFDLE9BQU8sQ0FDZCxDQUFDO3dCQUNGLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDZixDQUFDLENBQUM7b0JBRUYsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7b0JBRW5DLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRTt3QkFDNUIsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7NEJBQ2xCLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQzs0QkFDcEIsT0FBTyxDQUFDLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUMsQ0FBQzs0QkFDbEUsT0FBTzt3QkFDVCxDQUFDO3dCQUNELE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxPQUFPLEVBQUcsQ0FBQzt3QkFDNUMsSUFBSSxzQkFBeUMsQ0FBQzt3QkFDOUMsSUFBSSxPQUFPLFlBQVksS0FBSyxRQUFRLEVBQUUsQ0FBQzs0QkFDckMsc0JBQXNCLEdBQUc7Z0NBQ3ZCLElBQUksRUFBRSxZQUFZOzZCQUNuQixDQUFDO3dCQUNKLENBQUMsTUFBTSxDQUFDOzRCQUNOLHNCQUFzQixHQUFHO2dDQUN2QixJQUFJLEVBQUUsWUFBWSxDQUFDLE9BQU87Z0NBQzFCLElBQUksRUFBRSxZQUFZLENBQUMsSUFBSTs2QkFDeEIsQ0FBQzt3QkFDSixDQUFDO3dCQUVELE1BQU0sV0FBVyxHQUFHLHVDQUNsQixrREFBeUIsRUFBQyxzQkFBc0IsQ0FBQyxFQUNqRCxHQUFHLEVBQUU7NEJBQ0gsT0FBTztnQ0FDTCxZQUFZLEVBQUUsc0JBQXNCO2dDQUNwQyxhQUFhLEVBQUUsSUFBSTtnQ0FDbkIsUUFBUSxFQUFFLElBQUk7Z0NBQ2QsVUFBVSxFQUFFLElBQUk7Z0NBQ2hCLGNBQWMsRUFBRSxDQUFDO2dDQUNqQixnQkFBZ0IsRUFBRSxDQUFDO2dDQUNuQixhQUFhLEVBQUUsQ0FBQztnQ0FDaEIsWUFBWSxFQUFFLENBQUM7Z0NBQ2YsZ0JBQWdCLEVBQUUsQ0FBQztnQ0FDbkIsY0FBYyxFQUFFLENBQUM7Z0NBQ2pCLCtCQUErQixFQUFFLElBQUk7Z0NBQ3JDLGdDQUFnQyxFQUFFLElBQUk7Z0NBQ3RDLHdCQUF3QixFQUFFLElBQUk7Z0NBQzlCLDRCQUE0QixFQUFFLElBQUk7Z0NBQ2xDLHNCQUFzQixFQUFFLElBQUk7Z0NBQzVCLHVCQUF1QixFQUFFLElBQUk7NkJBQzlCLENBQUM7d0JBQ0osQ0FBQyxFQUNELElBQUksQ0FBQyxlQUFlLENBQ3JCLENBQUM7d0JBQ0YsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7NEJBQ3pCLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUM7d0JBQ3JELENBQUM7d0JBQ0QsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUM7NEJBQ3hCLE1BQU0sRUFBRSxXQUFXOzRCQUNuQixXQUFXLEVBQUUsV0FBVzt5QkFDekIsQ0FBQyxDQUFDO3dCQUNILElBQUksQ0FBQyxLQUFLLENBQ1IscUJBQXFCLEdBQ25CLG9EQUEwQixzQkFBc0IsQ0FBQyxDQUNwRCxDQUFDO3dCQUNGLE9BQU8sQ0FDTCxNQUFNLElBQUksc0JBQXNCLEdBQzVCLHNCQUFzQixDQUFDLElBQUksR0FDM0IsT0FBTyxDQUNaLENBQUM7d0JBQ0YsV0FBVyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7b0JBQy9DLENBQUMsQ0FBQyxDQUFDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQ0gsQ0FBQyxJQUFJLEVBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ2YsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO2dCQUNkLEtBQUssTUFBTSxNQUFNLElBQUksT0FBTyxDQUFFLENBQUM7b0JBQzdCLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFLENBQUM7d0JBQy9CLEtBQUssSUFBSSxDQUFDLENBQUM7d0JBQ1gsSUFBSSxNQUFNLEtBQUssT0FBTyxFQUFFLENBQUM7NEJBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQ2IsZ0VBQWdFLENBQ2pFLENBQUM7d0JBQ0osQ0FBQztvQkFDSCxDQUFDO2dCQUNILENBQUM7Z0JBQ0QsT0FBTztvQkFDTCxJQUFJLEVBQUUsT0FBTztvQkFDYixLQUFLLEVBQUUsS0FBSyxHQUFHLGFBQWE7aUJBQzdCLENBQUM7WUFDSixDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQztRQUVGLE1BQU0sZ0JBQWdCLEdBQUcsQ0FDdkIsV0FBZ0MsRUFDWCxFQUFFO1lBQ3ZCLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDN0IsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFhO29CQUFFLElBQUksRUFBRSxDQUFDO29CQUFFLEtBQUssRUFBRSxDQUFDO2dCQUFBLENBQUUsQ0FBQyxDQUFDO1lBQzVELENBQUM7WUFDRCxNQUFNLE9BQU8sR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0IsTUFBTSxXQUFXLEdBQUcsV0FBVyxFQUFFLENBQUM7WUFDbEMsT0FBTyxJQUFJLE9BQU8sQ0FBYSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRTtnQkFDakQsTUFBTSxPQUFPLEdBQUcsQ0FBQyxHQUFVLEVBQUUsRUFBRTtvQkFDN0IsSUFBSSxDQUFDLEtBQUssQ0FDUixpQkFBaUIsR0FDZixvREFBMEIsT0FBTyxDQUFDLEdBQ2xDLGNBQWMsR0FDZCxHQUFHLENBQUMsT0FBTyxDQUNkLENBQUM7b0JBQ0YsT0FBTyxDQUFDLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNsRCxDQUFDLENBQUM7Z0JBRUYsV0FBVyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBRW5DLFdBQVcsQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtvQkFDL0IsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7d0JBQ2xCLFdBQVcsQ0FBQyxLQUFLLEVBQUUsQ0FBQzt3QkFDcEIsT0FBTyxDQUFDOzRCQUFDLElBQUksRUFBRSxDQUFDOzRCQUFFLEtBQUssRUFBRSxDQUFDO3dCQUFBLENBQUMsQ0FBQyxDQUFDO3dCQUM3QixPQUFPO29CQUNULENBQUM7b0JBQ0QsTUFBTSxZQUFZLEdBQUcsV0FBVyxDQUFDLE9BQU8sRUFBaUIsQ0FBQztvQkFDMUQsTUFBTSxzQkFBc0IsR0FBc0I7d0JBQ2hELElBQUksRUFBRSxZQUFZLENBQUMsT0FBTzt3QkFDMUIsSUFBSSxFQUFFLFlBQVksQ0FBQyxJQUFJO3FCQUN4QixDQUFDO29CQUNGLE1BQU0sV0FBVyxHQUFHLHVDQUNsQixvREFBMEIsc0JBQXNCLENBQUMsRUFDakQsR0FBRyxFQUFFO3dCQUNILE9BQU87NEJBQ0wsWUFBWSxFQUFFLHNCQUFzQjs0QkFDcEMsYUFBYSxFQUFFLElBQUk7NEJBQ25CLFFBQVEsRUFBRSxJQUFJOzRCQUNkLFVBQVUsRUFBRSxJQUFJOzRCQUNoQixjQUFjLEVBQUUsQ0FBQzs0QkFDakIsZ0JBQWdCLEVBQUUsQ0FBQzs0QkFDbkIsYUFBYSxFQUFFLENBQUM7NEJBQ2hCLFlBQVksRUFBRSxDQUFDOzRCQUNmLGdCQUFnQixFQUFFLENBQUM7NEJBQ25CLGNBQWMsRUFBRSxDQUFDOzRCQUNqQiwrQkFBK0IsRUFBRSxJQUFJOzRCQUNyQyxnQ0FBZ0MsRUFBRSxJQUFJOzRCQUN0Qyx3QkFBd0IsRUFBRSxJQUFJOzRCQUM5Qiw0QkFBNEIsRUFBRSxJQUFJOzRCQUNsQyxzQkFBc0IsRUFBRSxJQUFJOzRCQUM1Qix1QkFBdUIsRUFBRSxJQUFJO3lCQUM5QixDQUFDO29CQUNKLENBQUMsRUFDRCxJQUFJLENBQUMsZUFBZSxDQUNyQixDQUFDO29CQUNGLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO3dCQUN6QixJQUFJLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUNyRCxDQUFDO29CQUNELElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDO3dCQUN4QixNQUFNLEVBQUUsV0FBVzt3QkFDbkIsV0FBVyxFQUFFLFdBQVc7cUJBQ3pCLENBQUMsQ0FBQztvQkFDSCxJQUFJLENBQUMsS0FBSyxDQUNSLHFCQUFxQixHQUNuQixrREFBeUIsRUFBQyxzQkFBc0IsQ0FBQyxDQUNwRCxDQUFDO29CQUNGLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDdEUsV0FBVyxDQUFDLGNBQWMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7Z0JBQy9DLENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUM7UUFFRixNQUFNLGdCQUFnQixHQUFxQjtZQUN6QyxzQkFBc0IsRUFBRSxDQUN0QixXQUFXLEVBQ1gsYUFBYSxFQUNiLGtCQUFrQixFQUNsQixFQUFFO2dCQUNGLGlFQUFpRTtnQkFDakUsZ0JBQWdCLENBQUMsc0JBQXNCLEdBQUcsR0FBRyxFQUFFLENBQUcsQ0FBQztnQkFDbkQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7b0JBQ2xCLGdCQUFnQixDQUNkLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLEVBQ3hELENBQUMsQ0FDRixDQUFDO2dCQUNKLENBQUM7Z0JBQ0QsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO29CQUM3QixnQkFBZ0IsQ0FDZCxJQUFJLEtBQUssQ0FBQyxrQ0FBa0MsSUFBSSxFQUFFLENBQUMsRUFDbkQsQ0FBQyxDQUNGLENBQUM7b0JBQ0YsT0FBTztnQkFDVCxDQUFDO2dCQUNELElBQUksaUJBQXNDLENBQUM7Z0JBQzNDLElBQUksaURBQXVCLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7b0JBQzNDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQzt3QkFDOUIsaUJBQWlCLEdBQUcsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ3BELENBQUMsTUFBTSxDQUFDO3dCQUNOLGlCQUFpQixHQUFHLGdCQUFnQixDQUNsQyxXQUFXLEVBQ1gsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFDbkIsQ0FBQyxDQUNGLENBQUM7b0JBQ0osQ0FBQztnQkFDSCxDQUFDLE1BQU0sQ0FBQztvQkFDTix1REFBdUQ7b0JBQ3ZELGlCQUFpQixHQUFHLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQzFELENBQUM7Z0JBQ0QsaUJBQWlCLENBQUMsSUFBSSxDQUNwQixVQUFVLENBQUMsRUFBRTtvQkFDWCxJQUFJLFVBQVUsQ0FBQyxLQUFLLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBQzNCLE1BQU0sV0FBVyxHQUFHLGlDQUFpQyxXQUFXLENBQUMsTUFBTSxXQUFXLENBQUM7d0JBQ25GLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQVksQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7d0JBQzdDLGdCQUFnQixDQUFDLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUM5QyxDQUFDLE1BQU0sQ0FBQzt3QkFDTixJQUFJLFVBQVUsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDOzRCQUMxQyxPQUFPLENBQUMsR0FBRyxDQUNULHdCQUFZLENBQUMsSUFBSSxFQUNqQixnQkFBZ0IsVUFBVSxDQUFDLEtBQUssaUNBQWlDLFdBQVcsQ0FBQyxNQUFNLFdBQVcsQ0FDL0YsQ0FBQzt3QkFDSixDQUFDO3dCQUNELGdCQUFnQixDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQzFDLENBQUM7Z0JBQ0gsQ0FBQyxHQUNELEtBQUssQ0FBQyxFQUFFO29CQUNOLE1BQU0sV0FBVyxHQUFHLGlDQUFpQyxXQUFXLENBQUMsTUFBTSxXQUFXLENBQUM7b0JBQ25GLE9BQU8sQ0FBQyxHQUFHLENBQUMsd0JBQVksQ0FBQyxLQUFLLEVBQUUsV0FBVyxDQUFDLENBQUM7b0JBQzdDLGdCQUFnQixDQUFDLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUM5QyxDQUFDLENBQ0YsQ0FBQztZQUNKLENBQUM7WUFDRCxPQUFPLEdBQUUsS0FBSyxDQUFDLEVBQUU7Z0JBQ2YsZ0JBQWdCLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2hELENBQUM7U0FDRixDQUFDO1FBRUYsTUFBTSxRQUFRLEdBQUcsK0JBQWUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN6RSxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQsYUFBYTtRQUNYLDJDQUEyQztRQUUzQyxLQUFLLE1BQU0sRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsSUFBSSxJQUFJLENBQ3pELGVBQWUsQ0FBRSxDQUFDO1lBQ25CLElBQUksV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUMxQixXQUFXLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRTtvQkFDckIsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7d0JBQ3pCLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQzdDLHNDQUFzQixHQUFHLENBQUMsQ0FBQztvQkFDN0IsQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUM7UUFDSCxDQUFDO1FBRUQsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFFckIsd0VBQXdFO1FBQ3hFLHFFQUFxRTtRQUNyRSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsRUFBRTtZQUM5QyxnRUFBZ0U7WUFDaEUsZ0RBQWdEO1lBQ2hELDhEQUE4RDtZQUM5RCxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsY0FBcUIsQ0FBQyxDQUFDO1FBQ3pELENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUN0QixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN6QixzQ0FBc0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzFDLENBQUM7SUFDSCxDQUFDO0lBRUQsUUFBUSxDQUNOLElBQVksRUFDWixPQUE4QyxFQUM5QyxTQUFrQyxFQUNsQyxXQUFxQyxFQUNyQyxJQUFZO1FBRVosSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQzVCLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRTtZQUN0QixJQUFJLEVBQUUsT0FBTztZQUNiLFNBQVM7WUFDVCxXQUFXO1lBQ1gsSUFBSTtZQUNKLElBQUksRUFBRSxJQUFJO1NBQ08sQ0FBQyxDQUFDO1FBQ3JCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELFVBQVUsQ0FBQyxJQUFZO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELEtBQUs7UUFDSCxJQUNFLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxLQUFLLENBQUMsSUFDakMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQ3hCLENBQUMsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLEVBQUUsQ0FBRyxDQUFELFVBQVksQ0FBQyxTQUFTLEtBQUssSUFBSSxDQUM1RCxFQUNELENBQUM7WUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLHdDQUF3QyxDQUFDLENBQUM7UUFDNUQsQ0FBQztRQUVELElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUMxQixNQUFNLElBQUksS0FBSyxDQUFDLDJCQUEyQixDQUFDLENBQUM7UUFDL0MsQ0FBQztRQUNELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNyRCxDQUFDO1FBQ0QsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7SUFDdEIsQ0FBQztJQUVELFdBQVcsQ0FBQyxRQUFpQztRQUMzQyxNQUFNLGVBQWUsR0FBRyxDQUFDLEtBQWEsRUFBRSxFQUFFO1lBQ3hDLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUN6QixzQ0FBc0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQzFDLENBQUM7WUFDRCxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDbEIsQ0FBQyxDQUFDO1FBQ0YsSUFBSSxhQUFhLEdBQUcsQ0FBQyxDQUFDO1FBRXRCLFNBQVMsYUFBYTtZQUNwQixhQUFhLEVBQUUsQ0FBQztZQUVoQixJQUFJLGFBQWEsS0FBSyxDQUFDLEVBQUUsQ0FBQztnQkFDeEIsZUFBZSxFQUFFLENBQUM7WUFDcEIsQ0FBQztRQUNILENBQUM7UUFFRCxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7UUFDckIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFFckIsS0FBSyxNQUFNLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLElBQUksSUFBSSxDQUN6RCxlQUFlLENBQUUsQ0FBQztZQUNuQixJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDMUIsYUFBYSxFQUFFLENBQUM7Z0JBQ2hCLFdBQVcsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFO29CQUNyQixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQzt3QkFDekIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDN0Msc0NBQXNCLEdBQUcsQ0FBQyxDQUFDO29CQUM3QixDQUFDO29CQUNELGFBQWEsRUFBRSxDQUFDO2dCQUNsQixDQUFDLENBQUMsQ0FBQztZQUNMLENBQUM7UUFDSCxDQUFDO1FBRUQsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLEVBQUU7WUFDOUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDcEIsYUFBYSxJQUFJLENBQUMsQ0FBQztnQkFDbkIsT0FBTyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUMvQixDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFDSCxJQUFJLGFBQWEsS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUN4QixlQUFlLEVBQUUsQ0FBQztRQUNwQixDQUFDO0lBQ0gsQ0FBQztJQUVELFlBQVk7UUFDVixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFDekMsQ0FBQztJQUVEOzs7O09BSUcsQ0FDSCxjQUFjO1FBQ1osT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzFCLENBQUM7SUFFTyxrQkFBa0IsQ0FDeEIsTUFBK0IsRUFDL0IsT0FBa0M7UUFFbEMsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMseUJBQXlCLENBQUMsQ0FBQztRQUV2RSxJQUNFLE9BQU8sV0FBVyxLQUFLLFFBQVEsSUFDL0IsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLGtCQUFrQixDQUFDLEVBQzNDLENBQUM7WUFDRCxNQUFNLENBQUMsT0FBTyxDQUNaO2dCQUNFLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxtQkFBbUIsQ0FBQyxFQUNuQyxLQUFLLENBQUMsU0FBUyxDQUFDLGtDQUFrQzthQUNyRCxFQUNEO2dCQUFFLFNBQVMsRUFBRSxJQUFJO1lBQUEsQ0FBRSxDQUNwQixDQUFDO1lBQ0YsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU8sZ0JBQWdCLENBQUMsSUFBWTtRQUNuQyxJQUFJLENBQUMsS0FBSyxDQUNSLDBCQUEwQixHQUN4QixJQUFJLEdBQ0osY0FBYyxHQUNkLElBQUksQ0FBQyxtQkFBbUIsQ0FDM0IsQ0FBQztRQUVGLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXhDLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzFCLElBQUksQ0FBQyxLQUFLLENBQ1IsbUNBQW1DLEdBQ2pDLElBQUksR0FDSixpQ0FBaUMsQ0FDcEMsQ0FBQztZQUNGLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFTyxpQkFBaUIsQ0FDdkIsR0FBTSxFQUNOLE1BQStCLEVBQy9CLHNCQUFrRCxJQUFJO1FBRXRELE1BQU0sSUFBSSxHQUFHLElBQUksbUNBQXFCLENBQUMsTUFBTSxFQUFFLElBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFcEUsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzNCLEdBQUcsQ0FBQyxJQUFJLEdBQUcsa0JBQU0sQ0FBQyxRQUFRLENBQUM7UUFDN0IsQ0FBQztRQUVELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3pCLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDakMsbUJBQW1CLGFBQW5CLG1CQUFtQix1QkFBbkIsbUJBQW1CLENBQUUsYUFBYSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3JELENBQUM7UUFFRCxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3RCLENBQUM7SUFFTyxnQkFBZ0IsQ0FDdEIsTUFBK0IsRUFDL0IsT0FBa0M7UUFFbEMsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FDM0MsTUFBTSxDQUFDLE9BQW1DLENBQzNDLENBQUM7UUFFRixJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ2xDLG1CQUFtQixhQUFuQixtQkFBbUIsdUJBQW5CLG1CQUFtQixDQUFFLGFBQWEsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUVwRCxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQzlDLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDakMsbUJBQW1CLGFBQW5CLG1CQUFtQix1QkFBbkIsbUJBQW1CLENBQUUsYUFBYSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ25ELE9BQU87UUFDVCxDQUFDO1FBRUQsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFXLENBQUM7UUFFbEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxpQkFBaUIsQ0FDcEIsOEJBQThCLENBQUMsSUFBSSxDQUFDLEVBQ3BDLE1BQU0sRUFDTixtQkFBbUIsQ0FDcEIsQ0FBQztZQUNGLE9BQU87UUFDVCxDQUFDO1FBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxtQ0FBcUIsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV0RSxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDLElBQVksRUFBRSxFQUFFO1lBQ3BDLElBQUksSUFBSSxLQUFLLGtCQUFNLENBQUMsRUFBRSxFQUFFLENBQUM7Z0JBQ3ZCLElBQUksQ0FBQyxXQUFXLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztZQUN0QyxDQUFDLE1BQU0sQ0FBQztnQkFDTixJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ25DLENBQUM7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksbUJBQW1CLEVBQUUsQ0FBQztZQUN4QixJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLE9BQWdCLEVBQUUsRUFBRTtnQkFDMUMsSUFBSSxPQUFPLEVBQUUsQ0FBQztvQkFDWixtQkFBbUIsQ0FBQyxhQUFhLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztnQkFDdkQsQ0FBQyxNQUFNLENBQUM7b0JBQ04sbUJBQW1CLENBQUMsYUFBYSxDQUFDLGFBQWEsRUFBRSxDQUFDO2dCQUNwRCxDQUFDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsRUFBRSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUU7Z0JBQzFCLG1CQUFtQixDQUFDLFlBQVksSUFBSSxDQUFDLENBQUM7Z0JBQ3RDLG1CQUFtQixDQUFDLHdCQUF3QixHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7WUFDNUQsQ0FBQyxDQUFDLENBQUM7WUFDSCxJQUFJLENBQUMsRUFBRSxDQUFDLGdCQUFnQixFQUFFLEdBQUcsRUFBRTtnQkFDN0IsbUJBQW1CLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFDO2dCQUMxQyxtQkFBbUIsQ0FBQyw0QkFBNEIsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ2hFLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ3JELElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDakMsbUJBQW1CLGFBQW5CLG1CQUFtQix1QkFBbkIsbUJBQW1CLENBQUUsYUFBYSxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBRW5ELElBQUksQ0FBQyxTQUFTLENBQUM7Z0JBQ2IsSUFBSSxFQUFFLGtCQUFNLENBQUMsUUFBUTtnQkFDckIsT0FBTyxFQUFFLHlCQUF5QixPQUFPLENBQUMsSUFBSSxFQUFFO2FBQ2pELENBQUMsQ0FBQztRQUNMLENBQUM7SUFDSCxDQUFDO0lBRU8sY0FBYyxDQUNwQixNQUErQixFQUMvQixPQUFrQztRQUVsQyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDdEQsT0FBTztRQUNULENBQUM7UUFFRCxNQUFNLElBQUksR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQVcsQ0FBQztRQUVsRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLGlCQUFpQixDQUNwQiw4QkFBOEIsQ0FBQyxJQUFJLENBQUMsRUFDcEMsTUFBTSxFQUNOLElBQUksQ0FDTCxDQUFDO1lBQ0YsT0FBTztRQUNULENBQUM7UUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLG1DQUFxQixDQUFDLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3RFLElBQUksQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDO1lBQ3JELElBQUksQ0FBQyxTQUFTLENBQUM7Z0JBQ2IsSUFBSSxFQUFFLGtCQUFNLENBQUMsUUFBUTtnQkFDckIsT0FBTyxFQUFFLHlCQUF5QixPQUFPLENBQUMsSUFBSSxFQUFFO2FBQ2pELENBQUMsQ0FBQztRQUNMLENBQUM7SUFDSCxDQUFDO0lBRU8sa0JBQWtCLENBQ3hCLElBQXFDLEVBQ3JDLE9BQTBCLEVBQzFCLE9BQWtDOztRQUVsQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQy9DLE1BQU0sUUFBUSxHQUNaLE1BQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFDLE1BQXdCLDZCQUFJLFVBQVUsQ0FBQztRQUN6RSxRQUFRLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBRWpDLE1BQU0sRUFBRSxJQUFJLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDekIsSUFBSSxJQUFJLEtBQUssT0FBTyxFQUFFLENBQUM7WUFDckIsV0FBVyxDQUFDLElBQUksRUFBRSxPQUE4QixFQUFFLFFBQVEsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN4RSxDQUFDLE1BQU0sSUFBSSxJQUFJLEtBQUssY0FBYyxFQUFFLENBQUM7WUFDbkMscUJBQXFCLENBQ25CLElBQUksRUFDSixPQUF3QyxFQUN4QyxRQUFRLEVBQ1IsUUFBUSxDQUNULENBQUM7UUFDSixDQUFDLE1BQU0sSUFBSSxJQUFJLEtBQUssY0FBYyxFQUFFLENBQUM7WUFDbkMscUJBQXFCLENBQ25CLElBQUksRUFDSixPQUF3QyxFQUN4QyxRQUFRLEVBQ1IsUUFBUSxDQUNULENBQUM7UUFDSixDQUFDLE1BQU0sSUFBSSxJQUFJLEtBQUssTUFBTSxFQUFFLENBQUM7WUFDM0IsbUJBQW1CLENBQ2pCLElBQUksRUFDSixPQUFzQyxFQUN0QyxRQUFRLEVBQ1IsUUFBUSxDQUNULENBQUM7UUFDSixDQUFDLE1BQU0sQ0FBQztZQUNOLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVPLGNBQWMsQ0FDcEIsV0FBd0Q7UUFFeEQsSUFBSSxXQUFXLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDekIsT0FBTztRQUNULENBQUM7UUFFRCxNQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsT0FBTyxFQUFFLENBQUM7UUFDNUMsSUFBSSxtQkFBbUIsR0FBRyxNQUFNLENBQUM7UUFDakMsSUFBSSxhQUFhLEVBQUUsQ0FBQztZQUNsQixJQUFJLE9BQU8sYUFBYSxLQUFLLFFBQVEsRUFBRSxDQUFDO2dCQUN0QyxtQkFBbUIsR0FBRyxhQUFhLENBQUM7WUFDdEMsQ0FBQyxNQUFNLENBQUM7Z0JBQ04sbUJBQW1CLEdBQUcsYUFBYSxDQUFDLE9BQU8sR0FBRyxHQUFHLEdBQUcsYUFBYSxDQUFDLElBQUksQ0FBQztZQUN6RSxDQUFDO1FBQ0gsQ0FBQztRQUNELElBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztRQUUvQyxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxHQUNoQyxJQUFJLENBQUMsZ0JBQWdCLEdBQ3JCLElBQUksQ0FBQyxjQUFjLENBQUM7UUFFeEIsV0FBVyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzdDLFdBQVcsQ0FBQyxFQUFFLENBQUMsU0FBUyxHQUFFLE9BQU8sQ0FBQyxFQUFFOztZQUNsQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNsQixPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ2xCLE9BQU87WUFDVCxDQUFDO1lBRUQsTUFBTSxXQUFXLEdBQUcsdUNBQ2xCLGFBQU8sQ0FBQyxNQUFNLENBQUMsYUFBYSxtQ0FBSSxTQUFTLEVBQ3pDLElBQUksQ0FBQyw0QkFBNEIsQ0FBQyxPQUFPLENBQUMsRUFDMUMsSUFBSSxDQUFDLGVBQWUsQ0FDckIsQ0FBQztZQUVGLE1BQU0sbUJBQW1CLEdBQXdCO2dCQUMvQyxHQUFHLEVBQUUsV0FBVztnQkFDaEIsYUFBYSxFQUFFLElBQUksOEJBQW1CLEVBQUU7Z0JBQ3hDLFlBQVksRUFBRSxDQUFDO2dCQUNmLGdCQUFnQixFQUFFLENBQUM7Z0JBQ25CLHdCQUF3QixFQUFFLElBQUk7Z0JBQzlCLDRCQUE0QixFQUFFLElBQUk7YUFDbkMsQ0FBQztZQUVGLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1lBQ2hELE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDO1lBQ25ELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO2dCQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FDekIsU0FBUyxFQUNULG1DQUFtQyxHQUFHLGFBQWEsQ0FDcEQsQ0FBQztnQkFDRixJQUFJLENBQUMsc0JBQXNCLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3BELENBQUM7WUFDRCxJQUFJLGtCQUFrQixHQUEwQixJQUFJLENBQUM7WUFDckQsSUFBSSx1QkFBdUIsR0FBMEIsSUFBSSxDQUFDO1lBQzFELElBQUkscUJBQXFCLEdBQUcsS0FBSyxDQUFDO1lBQ2xDLElBQUksSUFBSSxDQUFDLGtCQUFrQixLQUFLLDJCQUEyQixFQUFFLENBQUM7Z0JBQzVELDhDQUE4QztnQkFDOUMsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixHQUFHLEVBQUUsQ0FBQztnQkFDckQsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLGVBQWUsR0FBRyxDQUFDLEdBQUcsZUFBZSxDQUFDO2dCQUNyRSxrQkFBa0IsR0FBRyxzQkFBVSxDQUFDLEdBQUcsRUFBRTs7b0JBQ25DLHFCQUFxQixHQUFHLElBQUksQ0FBQztvQkFDN0IsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7d0JBQ3pCLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUN6QixTQUFTLEVBQ1QsZ0RBQWdELEdBQUcsYUFBYSxDQUNqRSxDQUFDO29CQUNKLENBQUM7b0JBQ0QsSUFBSSxDQUFDO3dCQUNILE9BQU8sQ0FBQyxNQUFNLENBQ1osS0FBSyxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFDaEMsQ0FBQyxDQUFDLENBQUMsSUFBSSxHQUFFLENBQUMsQ0FDVixNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUN2QixDQUFDO29CQUNKLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO3dCQUNYLGlFQUFpRTt3QkFDakUsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO3dCQUNsQixPQUFPO29CQUNULENBQUM7b0JBQ0QsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUNoQjtpREFDNkIsQ0FDN0IsSUFBSSxJQUFJLENBQUMsdUJBQXVCLEtBQUssMkJBQTJCLEVBQUUsQ0FBQzt3QkFDakUsdUJBQXVCLEdBQUcsc0JBQVUsQ0FBQyxHQUFHLEVBQUU7NEJBQ3hDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQzt3QkFDcEIsQ0FBQyxFQUFFLElBQUksQ0FBQyx3QkFBdUIsQ0FBQyxDQUFDLFdBQUssNENBQUksQ0FBQztvQkFDN0MsQ0FBQztnQkFDSCxDQUFDLEVBQUUsSUFBSSxDQUFDLGtCQUFrQixHQUFHLE9BQU0sQ0FBQyxDQUFDLFdBQUssNENBQUksQ0FBQztZQUNqRCxDQUFDO1lBQ0QsTUFBTSxrQkFBa0IsR0FBMEIsdUJBQVcsQ0FBQyxHQUFHLEVBQUU7O2dCQUNqRSxNQUFNLFlBQVksR0FBRyxzQkFBVSxDQUFDLEdBQUcsRUFBRTtvQkFDbkMscUJBQXFCLEdBQUcsSUFBSSxDQUFDO29CQUM3QixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQzt3QkFDekIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQ3pCLFNBQVMsRUFDVCwrQ0FBK0MsR0FBRyxhQUFhLENBQ2hFLENBQUM7b0JBQ0osQ0FBQztvQkFDRCxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUM7Z0JBQ2xCLENBQUMsRUFBRSxJQUFJLENBQUMsbUJBQWtCLENBQUMsQ0FBQyxXQUFLLDRDQUFJLENBQUM7Z0JBQ3RDLElBQUksQ0FBQztvQkFDSCxPQUFPLENBQUMsSUFBSSxDQUNWLENBQUMsR0FBaUIsRUFBRSxRQUFnQixFQUFFLE9BQWUsRUFBRSxFQUFFO3dCQUN2RCxZQUFZLENBQUMsWUFBWSxDQUFDLENBQUM7b0JBQzdCLENBQUMsQ0FDRixDQUFDO2dCQUNKLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO29CQUNYLCtEQUErRDtvQkFDL0QsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNwQixDQUFDO1lBQ0gsQ0FBQyxFQUFFLElBQUksQ0FBQyxnQkFBZSxDQUFDLENBQUMsV0FBSyw0Q0FBSSxDQUFDO1lBQ25DLE9BQU8sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRTtnQkFDdkIsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7b0JBQ3pCLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxDQUFDO3dCQUMzQixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FDekIsU0FBUyxFQUNULCtCQUErQixHQUFHLGFBQWEsQ0FDaEQsQ0FBQztvQkFDSixDQUFDO29CQUNELElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUM7b0JBQ3BELHNDQUFzQixXQUFXLENBQUMsQ0FBQztnQkFDckMsQ0FBQztnQkFDRCxJQUFJLGtCQUFrQixFQUFFLENBQUM7b0JBQ3ZCLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO2dCQUNuQyxDQUFDO2dCQUNELElBQUksdUJBQXVCLEVBQUUsQ0FBQztvQkFDNUIsWUFBWSxDQUFDLHVCQUF1QixDQUFDLENBQUM7Z0JBQ3hDLENBQUM7Z0JBQ0QsSUFBSSxrQkFBa0IsRUFBRSxDQUFDO29CQUN2QixZQUFZLENBQUMsa0JBQWtCLENBQUMsQ0FBQztnQkFDbkMsQ0FBQztnQkFDRCxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNoQyxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztDQUNGO0FBM2dDRCx3QkEyZ0NDO0FBRUQsS0FBSyxVQUFVLFdBQVcsQ0FDeEIsSUFBc0QsRUFDdEQsT0FBZ0QsRUFDaEQsUUFBa0IsRUFDbEIsUUFBZ0I7SUFFaEIsSUFBSSxDQUFDO1FBQ0gsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFekQsSUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUM1QyxPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sT0FBTyxHQUFHLElBQUksaUNBQW1CLENBQ3JDLElBQUksRUFDSixRQUFRLEVBQ1IsT0FBTyxDQUNSLENBQUM7UUFFRixPQUFPLENBQUMsSUFBSSxDQUNWLE9BQU8sRUFDUCxDQUNFLEdBQXNELEVBQ3RELEtBQTJCLEVBQzNCLE9BQWtCLEVBQ2xCLEtBQWMsRUFDZCxFQUFFO1lBQ0YsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3BELENBQUMsQ0FDRixDQUFDO0lBQ0osQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQTBCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMscUJBQXFCLENBQzVCLElBQXNELEVBQ3RELE9BQTBELEVBQzFELFFBQWtCLEVBQ2xCLFFBQWdCO0lBRWhCLE1BQU0sTUFBTSxHQUFHLElBQUksc0NBQXdCLENBQ3pDLElBQUksRUFDSixRQUFRLEVBQ1IsT0FBTyxDQUFDLFdBQVcsRUFDbkIsUUFBUSxDQUNULENBQUM7SUFFRixTQUFTLE9BQU8sQ0FDZCxHQUFzRCxFQUN0RCxLQUEyQixFQUMzQixPQUFrQixFQUNsQixLQUFjO1FBRWQsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDbkIsT0FBTztJQUNULENBQUM7SUFFRCxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztJQUM1QixPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQztBQUNoQyxDQUFDO0FBRUQsS0FBSyxVQUFVLHFCQUFxQixDQUNsQyxJQUFzRCxFQUN0RCxPQUEwRCxFQUMxRCxRQUFrQixFQUNsQixRQUFnQjtJQUVoQixJQUFJLENBQUM7UUFDSCxNQUFNLE9BQU8sR0FBRyxNQUFNLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUV6RCxJQUFJLE9BQU8sS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQzVDLE9BQU87UUFDVCxDQUFDO1FBRUQsTUFBTSxNQUFNLEdBQUcsSUFBSSxzQ0FBd0IsQ0FDekMsSUFBSSxFQUNKLFFBQVEsRUFDUixPQUFPLENBQUMsU0FBUyxFQUNqQixPQUFPLENBQ1IsQ0FBQztRQUVGLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDdkIsQ0FBQyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQTBCLENBQUMsQ0FBQztJQUM3QyxDQUFDO0FBQ0gsQ0FBQztBQUVELFNBQVMsbUJBQW1CLENBQzFCLElBQXNELEVBQ3RELE9BQXdELEVBQ3hELFFBQWtCLEVBQ2xCLFFBQWdCO0lBRWhCLE1BQU0sTUFBTSxHQUFHLElBQUksb0NBQXNCLENBQ3ZDLElBQUksRUFDSixRQUFRLEVBQ1IsT0FBTyxDQUFDLFNBQVMsRUFDakIsT0FBTyxDQUFDLFdBQVcsRUFDbkIsUUFBUSxDQUNULENBQUM7SUFFRixJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNuQixPQUFPO0lBQ1QsQ0FBQztJQUVELE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdkIsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3NyYy9zZXJ2ZXIudHMiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = exports.validateRetryThrottling = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\nfunction validateName(obj) {\n    // In this context, and unset field and '' are considered the same\n    if ('service' in obj && obj.service !== '') {\n        if (typeof obj.service !== 'string') {\n            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\n        }\n        if ('method' in obj && obj.method !== '') {\n            if (typeof obj.method !== 'string') {\n                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\n            }\n            return {\n                service: obj.service,\n                method: obj.method,\n            };\n        }\n        else {\n            return {\n                service: obj.service,\n            };\n        }\n    }\n    else {\n        if ('method' in obj && obj.method !== undefined) {\n            throw new Error(`Invalid method config name: method set with empty or unset service`);\n        }\n        return {};\n    }\n}\nfunction validateRetryPolicy(obj) {\n    if (!('maxAttempts' in obj) ||\n        !Number.isInteger(obj.maxAttempts) ||\n        obj.maxAttempts < 2) {\n        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');\n    }\n    if (!('initialBackoff' in obj) ||\n        typeof obj.initialBackoff !== 'string' ||\n        !DURATION_REGEX.test(obj.initialBackoff)) {\n        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s');\n    }\n    if (!('maxBackoff' in obj) ||\n        typeof obj.maxBackoff !== 'string' ||\n        !DURATION_REGEX.test(obj.maxBackoff)) {\n        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s');\n    }\n    if (!('backoffMultiplier' in obj) ||\n        typeof obj.backoffMultiplier !== 'number' ||\n        obj.backoffMultiplier <= 0) {\n        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');\n    }\n    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');\n    }\n    if (obj.retryableStatusCodes.length === 0) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');\n    }\n    for (const value of obj.retryableStatusCodes) {\n        if (typeof value === 'number') {\n            if (!Object.values(constants_1.Status).includes(value)) {\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');\n            }\n        }\n        else if (typeof value === 'string') {\n            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');\n            }\n        }\n        else {\n            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');\n        }\n    }\n    return {\n        maxAttempts: obj.maxAttempts,\n        initialBackoff: obj.initialBackoff,\n        maxBackoff: obj.maxBackoff,\n        backoffMultiplier: obj.backoffMultiplier,\n        retryableStatusCodes: obj.retryableStatusCodes,\n    };\n}\nfunction validateHedgingPolicy(obj) {\n    if (!('maxAttempts' in obj) ||\n        !Number.isInteger(obj.maxAttempts) ||\n        obj.maxAttempts < 2) {\n        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');\n    }\n    if ('hedgingDelay' in obj &&\n        (typeof obj.hedgingDelay !== 'string' ||\n            !DURATION_REGEX.test(obj.hedgingDelay))) {\n        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');\n    }\n    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n        for (const value of obj.nonFatalStatusCodes) {\n            if (typeof value === 'number') {\n                if (!Object.values(constants_1.Status).includes(value)) {\n                    throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not in status code range');\n                }\n            }\n            else if (typeof value === 'string') {\n                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                    throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not a status code name');\n                }\n            }\n            else {\n                throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number');\n            }\n        }\n    }\n    const result = {\n        maxAttempts: obj.maxAttempts,\n    };\n    if (obj.hedgingDelay) {\n        result.hedgingDelay = obj.hedgingDelay;\n    }\n    if (obj.nonFatalStatusCodes) {\n        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: [],\n    };\n    if (!('name' in obj) || !Array.isArray(obj.name)) {\n        throw new Error('Invalid method config: invalid name array');\n    }\n    for (const name of obj.name) {\n        result.name.push(validateName(name));\n    }\n    if ('waitForReady' in obj) {\n        if (typeof obj.waitForReady !== 'boolean') {\n            throw new Error('Invalid method config: invalid waitForReady');\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if ('timeout' in obj) {\n        if (typeof obj.timeout === 'object') {\n            if (!('seconds' in obj.timeout) ||\n                !(typeof obj.timeout.seconds === 'number')) {\n                throw new Error('Invalid method config: invalid timeout.seconds');\n            }\n            if (!('nanos' in obj.timeout) ||\n                !(typeof obj.timeout.nanos === 'number')) {\n                throw new Error('Invalid method config: invalid timeout.nanos');\n            }\n            result.timeout = obj.timeout;\n        }\n        else if (typeof obj.timeout === 'string' &&\n            DURATION_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout\n                .substring(0, obj.timeout.length - 1)\n                .split('.');\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,\n            };\n        }\n        else {\n            throw new Error('Invalid method config: invalid timeout');\n        }\n    }\n    if ('maxRequestBytes' in obj) {\n        if (typeof obj.maxRequestBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if ('maxResponseBytes' in obj) {\n        if (typeof obj.maxResponseBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    if ('retryPolicy' in obj) {\n        if ('hedgingPolicy' in obj) {\n            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');\n        }\n        else {\n            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n        }\n    }\n    else if ('hedgingPolicy' in obj) {\n        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n    }\n    return result;\n}\nfunction validateRetryThrottling(obj) {\n    if (!('maxTokens' in obj) ||\n        typeof obj.maxTokens !== 'number' ||\n        obj.maxTokens <= 0 ||\n        obj.maxTokens > 1000) {\n        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');\n    }\n    if (!('tokenRatio' in obj) ||\n        typeof obj.tokenRatio !== 'number' ||\n        obj.tokenRatio <= 0) {\n        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');\n    }\n    return {\n        maxTokens: +obj.maxTokens.toFixed(3),\n        tokenRatio: +obj.tokenRatio.toFixed(3),\n    };\n}\nexports.validateRetryThrottling = validateRetryThrottling;\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: [],\n    };\n    if ('loadBalancingPolicy' in obj) {\n        if (typeof obj.loadBalancingPolicy === 'string') {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingPolicy');\n        }\n    }\n    if ('loadBalancingConfig' in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig) {\n                result.loadBalancingConfig.push((0, load_balancer_1.validateLoadBalancingConfig)(config));\n            }\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingConfig');\n        }\n    }\n    if ('methodConfig' in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig) {\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    if ('retryThrottling' in obj) {\n        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig) {\n        for (const name of methodConfig.name) {\n            for (const seenName of seenMethodNames) {\n                if (name.service === seenName.service &&\n                    name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n    if (!('serviceConfig' in obj)) {\n        throw new Error('Invalid service config choice: missing service config');\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig),\n    };\n    if ('clientLanguage' in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage) {\n                if (typeof lang === 'string') {\n                    result.clientLanguage.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientLanguage');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n    }\n    if ('clientHostname' in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname) {\n                if (typeof lang === 'string') {\n                    result.clientHostname.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientHostname');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n    }\n    if ('percentage' in obj) {\n        if (typeof obj.percentage === 'number' &&\n            0 <= obj.percentage &&\n            obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid percentage');\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        'clientLanguage',\n        'percentage',\n        'clientHostname',\n        'serviceConfig',\n    ];\n    for (const field in obj) {\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error('Invalid service config list');\n    }\n    for (const config of obj) {\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */\n        if (typeof validatedConfig.percentage === 'number' &&\n            percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname) {\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage) {\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord) {\n        if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n            const recordString = record.join('').substring('grpc_config='.length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;\n//# sourceMappingURL=service-config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zZXJ2aWNlLWNvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFDQUFxQyxHQUFHLDZCQUE2QixHQUFHLCtCQUErQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6Qyx3QkFBd0IsbUJBQU8sQ0FBQyxpR0FBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsSUFBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csbUJBQW1CO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLHlHQUF5RyxtQkFBbUI7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsYUFBYSxHQUFHLFlBQVk7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsTUFBTTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IGV4cG9ydHMudmFsaWRhdGVSZXRyeVRocm90dGxpbmcgPSB2b2lkIDA7XG4vKiBUaGlzIGZpbGUgaW1wbGVtZW50cyBnUkZDIEEyIGFuZCB0aGUgc2VydmljZSBjb25maWcgc3BlYzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EyLXNlcnZpY2UtY29uZmlncy1pbi1kbnMubWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMvYmxvYi9tYXN0ZXIvZG9jL3NlcnZpY2VfY29uZmlnLm1kLiBFYWNoXG4gKiBmdW5jdGlvbiBoZXJlIHRha2VzIGFuIG9iamVjdCB3aXRoIHVua25vd24gc3RydWN0dXJlIGFuZCByZXR1cm5zIGl0c1xuICogc3BlY2lmaWMgb2JqZWN0IHR5cGUgaWYgdGhlIGlucHV0IGhhcyB0aGUgcmlnaHQgc3RydWN0dXJlLCBhbmQgdGhyb3dzIGFuXG4gKiBlcnJvciBvdGhlcndpc2UuICovXG4vKiBUaGUgYW55IHR5cGUgaXMgcHVycG9zZWx5IHVzZWQgaGVyZS4gQWxsIGZ1bmN0aW9ucyB2YWxpZGF0ZSB0aGVpciBpbnB1dCBhdFxuICogcnVudGltZSAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG4vKipcbiAqIFJlY29nbml6ZXMgYSBudW1iZXIgd2l0aCB1cCB0byA5IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgZm9sbG93ZWQgYnlcbiAqIGFuIFwic1wiLCByZXByZXNlbnRpbmcgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqL1xuY29uc3QgRFVSQVRJT05fUkVHRVggPSAvXlxcZCsoXFwuXFxkezEsOX0pP3MkLztcbi8qKlxuICogQ2xpZW50IGxhbmd1YWdlIG5hbWUgdXNlZCBmb3IgZGV0ZXJtaW5pbmcgd2hldGhlciB0aGlzIGNsaWVudCBtYXRjaGVzIGFcbiAqIGBTZXJ2aWNlQ29uZmlnQ2FuYXJ5Q29uZmlnYCdzIGBjbGllbnRMYW5ndWFnZWAgbGlzdC5cbiAqL1xuY29uc3QgQ0xJRU5UX0xBTkdVQUdFX1NUUklORyA9ICdub2RlJztcbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShvYmopIHtcbiAgICAvLyBJbiB0aGlzIGNvbnRleHQsIGFuZCB1bnNldCBmaWVsZCBhbmQgJycgYXJlIGNvbnNpZGVyZWQgdGhlIHNhbWVcbiAgICBpZiAoJ3NlcnZpY2UnIGluIG9iaiAmJiBvYmouc2VydmljZSAhPT0gJycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmouc2VydmljZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IGludmFsaWQgc2VydmljZTogZXhwZWN0ZWQgdHlwZSBzdHJpbmcsIGdvdCAke3R5cGVvZiBvYmouc2VydmljZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ21ldGhvZCcgaW4gb2JqICYmIG9iai5tZXRob2QgIT09ICcnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5tZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBtZXRob2Q6IGV4cGVjdGVkIHR5cGUgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygb2JqLnNlcnZpY2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogb2JqLm1ldGhvZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IG9iai5zZXJ2aWNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCdtZXRob2QnIGluIG9iaiAmJiBvYmoubWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IG1ldGhvZCBzZXQgd2l0aCBlbXB0eSBvciB1bnNldCBzZXJ2aWNlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmV0cnlQb2xpY3kob2JqKSB7XG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9iai5tYXhBdHRlbXB0cykgfHxcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IG1heEF0dGVtcHRzIG11c3QgYmUgYW4gaW50ZWdlciBhdCBsZWFzdCAyJyk7XG4gICAgfVxuICAgIGlmICghKCdpbml0aWFsQmFja29mZicgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLmluaXRpYWxCYWNrb2ZmICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmouaW5pdGlhbEJhY2tvZmYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogaW5pdGlhbEJhY2tvZmYgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieSBzJyk7XG4gICAgfVxuICAgIGlmICghKCdtYXhCYWNrb2ZmJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmoubWF4QmFja29mZiAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLm1heEJhY2tvZmYpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogbWF4QmFja29mZiBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5IHMnKTtcbiAgICB9XG4gICAgaWYgKCEoJ2JhY2tvZmZNdWx0aXBsaWVyJyBpbiBvYmopIHx8XG4gICAgICAgIHR5cGVvZiBvYmouYmFja29mZk11bHRpcGxpZXIgIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai5iYWNrb2ZmTXVsdGlwbGllciA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogYmFja29mZk11bHRpcGxpZXIgbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cbiAgICBpZiAoISgncmV0cnlhYmxlU3RhdHVzQ29kZXMnIGluIG9iaiAmJiBBcnJheS5pc0FycmF5KG9iai5yZXRyeWFibGVTdGF0dXNDb2RlcykpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyBtdXN0IGJlIG5vbi1lbXB0eScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iai5yZXRyeWFibGVTdGF0dXNDb2Rlcykge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZS50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgdmFsdWUgbm90IGEgc3RhdHVzIGNvZGUgbmFtZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiByZXRyeWFibGVTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heEF0dGVtcHRzOiBvYmoubWF4QXR0ZW1wdHMsXG4gICAgICAgIGluaXRpYWxCYWNrb2ZmOiBvYmouaW5pdGlhbEJhY2tvZmYsXG4gICAgICAgIG1heEJhY2tvZmY6IG9iai5tYXhCYWNrb2ZmLFxuICAgICAgICBiYWNrb2ZmTXVsdGlwbGllcjogb2JqLmJhY2tvZmZNdWx0aXBsaWVyLFxuICAgICAgICByZXRyeWFibGVTdGF0dXNDb2Rlczogb2JqLnJldHJ5YWJsZVN0YXR1c0NvZGVzLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqKSB7XG4gICAgaWYgKCEoJ21heEF0dGVtcHRzJyBpbiBvYmopIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKG9iai5tYXhBdHRlbXB0cykgfHxcbiAgICAgICAgb2JqLm1heEF0dGVtcHRzIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbWF4QXR0ZW1wdHMgbXVzdCBiZSBhbiBpbnRlZ2VyIGF0IGxlYXN0IDInKTtcbiAgICB9XG4gICAgaWYgKCdoZWRnaW5nRGVsYXknIGluIG9iaiAmJlxuICAgICAgICAodHlwZW9mIG9iai5oZWRnaW5nRGVsYXkgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAhRFVSQVRJT05fUkVHRVgudGVzdChvYmouaGVkZ2luZ0RlbGF5KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IGhlZGdpbmdEZWxheSBtdXN0IGJlIGEgc3RyaW5nIGNvbnNpc3Rpbmcgb2YgYSBwb3NpdGl2ZSBpbnRlZ2VyIGZvbGxvd2VkIGJ5IHMnKTtcbiAgICB9XG4gICAgaWYgKCdub25GYXRhbFN0YXR1c0NvZGVzJyBpbiBvYmogJiYgQXJyYXkuaXNBcnJheShvYmoubm9uRmF0YWxTdGF0dXNDb2RlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmoubm9uRmF0YWxTdGF0dXNDb2Rlcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC52YWx1ZXMoY29uc3RhbnRzXzEuU3RhdHVzKS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBub3QgaW4gc3RhdHVzIGNvZGUgcmFuZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBub3QgYSBzdGF0dXMgY29kZSBuYW1lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZsaWQgbWV0aG9kIGNvbmZpZyBoZWRnaW5nIHBvbGljeTogbm9uRmF0YWxTdGF0dXNDb2RlcyB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbWF4QXR0ZW1wdHM6IG9iai5tYXhBdHRlbXB0cyxcbiAgICB9O1xuICAgIGlmIChvYmouaGVkZ2luZ0RlbGF5KSB7XG4gICAgICAgIHJlc3VsdC5oZWRnaW5nRGVsYXkgPSBvYmouaGVkZ2luZ0RlbGF5O1xuICAgIH1cbiAgICBpZiAob2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpIHtcbiAgICAgICAgcmVzdWx0Lm5vbkZhdGFsU3RhdHVzQ29kZXMgPSBvYmoubm9uRmF0YWxTdGF0dXNDb2RlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kQ29uZmlnKG9iaikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IFtdLFxuICAgIH07XG4gICAgaWYgKCEoJ25hbWUnIGluIG9iaikgfHwgIUFycmF5LmlzQXJyYXkob2JqLm5hbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG5hbWUgYXJyYXknKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIG9iai5uYW1lKSB7XG4gICAgICAgIHJlc3VsdC5uYW1lLnB1c2godmFsaWRhdGVOYW1lKG5hbWUpKTtcbiAgICB9XG4gICAgaWYgKCd3YWl0Rm9yUmVhZHknIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai53YWl0Rm9yUmVhZHkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgd2FpdEZvclJlYWR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LndhaXRGb3JSZWFkeSA9IG9iai53YWl0Rm9yUmVhZHk7XG4gICAgfVxuICAgIGlmICgndGltZW91dCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnRpbWVvdXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoISgnc2Vjb25kcycgaW4gb2JqLnRpbWVvdXQpIHx8XG4gICAgICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnRpbWVvdXQuc2Vjb25kcyA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dC5zZWNvbmRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgnbmFub3MnIGluIG9iai50aW1lb3V0KSB8fFxuICAgICAgICAgICAgICAgICEodHlwZW9mIG9iai50aW1lb3V0Lm5hbm9zID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Lm5hbm9zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IG9iai50aW1lb3V0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvYmoudGltZW91dCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIERVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLnRpbWVvdXQpKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0UGFydHMgPSBvYmoudGltZW91dFxuICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgb2JqLnRpbWVvdXQubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIHJlc3VsdC50aW1lb3V0ID0ge1xuICAgICAgICAgICAgICAgIHNlY29uZHM6IHRpbWVvdXRQYXJ0c1swXSB8IDAsXG4gICAgICAgICAgICAgICAgbmFub3M6ICgoX2EgPSB0aW1lb3V0UGFydHNbMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIHwgMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtYXhSZXF1ZXN0Qnl0ZXMnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5tYXhSZXF1ZXN0Qnl0ZXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubWF4UmVxdWVzdEJ5dGVzID0gb2JqLm1heFJlcXVlc3RCeXRlcztcbiAgICB9XG4gICAgaWYgKCdtYXhSZXNwb25zZUJ5dGVzJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubWF4UmVzcG9uc2VCeXRlcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIG1heFJlcXVlc3RCeXRlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5tYXhSZXNwb25zZUJ5dGVzID0gb2JqLm1heFJlc3BvbnNlQnl0ZXM7XG4gICAgfVxuICAgIGlmICgncmV0cnlQb2xpY3knIGluIG9iaikge1xuICAgICAgICBpZiAoJ2hlZGdpbmdQb2xpY3knIGluIG9iaikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IHJldHJ5UG9saWN5IGFuZCBoZWRnaW5nUG9saWN5IGNhbm5vdCBib3RoIGJlIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnJldHJ5UG9saWN5ID0gdmFsaWRhdGVSZXRyeVBvbGljeShvYmoucmV0cnlQb2xpY3kpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCdoZWRnaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgcmVzdWx0LmhlZGdpbmdQb2xpY3kgPSB2YWxpZGF0ZUhlZGdpbmdQb2xpY3kob2JqLmhlZGdpbmdQb2xpY3kpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVSZXRyeVRocm90dGxpbmcob2JqKSB7XG4gICAgaWYgKCEoJ21heFRva2VucycgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLm1heFRva2VucyAhPT0gJ251bWJlcicgfHxcbiAgICAgICAgb2JqLm1heFRva2VucyA8PSAwIHx8XG4gICAgICAgIG9iai5tYXhUb2tlbnMgPiAxMDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXRyeVRocm90dGxpbmc6IG1heFRva2VucyBtdXN0IGJlIGEgbnVtYmVyIGluICgwLCAxMDAwXScpO1xuICAgIH1cbiAgICBpZiAoISgndG9rZW5SYXRpbycgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLnRva2VuUmF0aW8gIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai50b2tlblJhdGlvIDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJldHJ5VGhyb3R0bGluZzogdG9rZW5SYXRpbyBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG1heFRva2VuczogK29iai5tYXhUb2tlbnMudG9GaXhlZCgzKSxcbiAgICAgICAgdG9rZW5SYXRpbzogK29iai50b2tlblJhdGlvLnRvRml4ZWQoMyksXG4gICAgfTtcbn1cbmV4cG9ydHMudmFsaWRhdGVSZXRyeVRocm90dGxpbmcgPSB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZztcbmZ1bmN0aW9uIHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmopIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGxvYWRCYWxhbmNpbmdDb25maWc6IFtdLFxuICAgICAgICBtZXRob2RDb25maWc6IFtdLFxuICAgIH07XG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubG9hZEJhbGFuY2luZ1BvbGljeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5sb2FkQmFsYW5jaW5nUG9saWN5ID0gb2JqLmxvYWRCYWxhbmNpbmdQb2xpY3k7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ1BvbGljeScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbG9hZEJhbGFuY2luZ0NvbmZpZycgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5sb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2Ygb2JqLmxvYWRCYWxhbmNpbmdDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubG9hZEJhbGFuY2luZ0NvbmZpZy5wdXNoKCgwLCBsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKShjb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtZXRob2RDb25maWcnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubWV0aG9kQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXRob2RDb25maWcgb2Ygb2JqLm1ldGhvZENvbmZpZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tZXRob2RDb25maWcucHVzaCh2YWxpZGF0ZU1ldGhvZENvbmZpZyhtZXRob2RDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3JldHJ5VGhyb3R0bGluZycgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdC5yZXRyeVRocm90dGxpbmcgPSB2YWxpZGF0ZVJldHJ5VGhyb3R0bGluZyhvYmoucmV0cnlUaHJvdHRsaW5nKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgbWV0aG9kIG5hbWUgdW5pcXVlbmVzc1xuICAgIGNvbnN0IHNlZW5NZXRob2ROYW1lcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIHJlc3VsdC5tZXRob2RDb25maWcpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlZW5OYW1lIG9mIHNlZW5NZXRob2ROYW1lcykge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlZW5OYW1lLnNlcnZpY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgbmFtZS5tZXRob2QgPT09IHNlZW5OYW1lLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VydmljZSBjb25maWc6IGR1cGxpY2F0ZSBuYW1lICR7bmFtZS5zZXJ2aWNlfS8ke25hbWUubWV0aG9kfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlZW5NZXRob2ROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IHZhbGlkYXRlU2VydmljZUNvbmZpZztcbmZ1bmN0aW9uIHZhbGlkYXRlQ2FuYXJ5Q29uZmlnKG9iaikge1xuICAgIGlmICghKCdzZXJ2aWNlQ29uZmlnJyBpbiBvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IG1pc3Npbmcgc2VydmljZSBjb25maWcnKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBzZXJ2aWNlQ29uZmlnOiB2YWxpZGF0ZVNlcnZpY2VDb25maWcob2JqLnNlcnZpY2VDb25maWcpLFxuICAgIH07XG4gICAgaWYgKCdjbGllbnRMYW5ndWFnZScgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jbGllbnRMYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jbGllbnRMYW5ndWFnZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRMYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNsaWVudExhbmd1YWdlLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRMYW5ndWFnZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnY2xpZW50SG9zdG5hbWUnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY2xpZW50SG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY2xpZW50SG9zdG5hbWUgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBvYmouY2xpZW50SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZS5wdXNoKGxhbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50SG9zdG5hbWUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ3BlcmNlbnRhZ2UnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgMCA8PSBvYmoucGVyY2VudGFnZSAmJlxuICAgICAgICAgICAgb2JqLnBlcmNlbnRhZ2UgPD0gMTAwKSB7XG4gICAgICAgICAgICByZXN1bHQucGVyY2VudGFnZSA9IG9iai5wZXJjZW50YWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBwZXJjZW50YWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgdGhhdCBubyB1bmV4cGVjdGVkIGZpZWxkcyBhcmUgcHJlc2VudFxuICAgIGNvbnN0IGFsbG93ZWRGaWVsZHMgPSBbXG4gICAgICAgICdjbGllbnRMYW5ndWFnZScsXG4gICAgICAgICdwZXJjZW50YWdlJyxcbiAgICAgICAgJ2NsaWVudEhvc3RuYW1lJyxcbiAgICAgICAgJ3NlcnZpY2VDb25maWcnLFxuICAgIF07XG4gICAgZm9yIChjb25zdCBmaWVsZCBpbiBvYmopIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkRmllbGRzLmluY2x1ZGVzKGZpZWxkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogdW5leHBlY3RlZCBmaWVsZCAke2ZpZWxkfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUFuZFNlbGVjdENhbmFyeUNvbmZpZyhvYmosIHBlcmNlbnRhZ2UpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgbGlzdCcpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmopIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkQ29uZmlnID0gdmFsaWRhdGVDYW5hcnlDb25maWcoY29uZmlnKTtcbiAgICAgICAgLyogRm9yIGVhY2ggZmllbGQsIHdlIGNoZWNrIGlmIGl0IGlzIHByZXNlbnQsIHRoZW4gb25seSBkaXNjYXJkIHRoZVxuICAgICAgICAgKiBjb25maWcgaWYgdGhlIGZpZWxkIHZhbHVlIGRvZXMgbm90IG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudCAqL1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkYXRlZENvbmZpZy5wZXJjZW50YWdlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgcGVyY2VudGFnZSA+IHZhbGlkYXRlZENvbmZpZy5wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50SG9zdG5hbWUpKSB7XG4gICAgICAgICAgICBsZXQgaG9zdG5hbWVNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhvc3RuYW1lIG9mIHZhbGlkYXRlZENvbmZpZy5jbGllbnRIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChob3N0bmFtZSA9PT0gb3MuaG9zdG5hbWUoKSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0bmFtZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaG9zdG5hbWVNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGVkQ29uZmlnLmNsaWVudExhbmd1YWdlKSkge1xuICAgICAgICAgICAgbGV0IGxhbmd1YWdlTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5ndWFnZSBvZiB2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UgPT09IENMSUVOVF9MQU5HVUFHRV9TVFJJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRDb25maWcuc2VydmljZUNvbmZpZztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtYXRjaGluZyBzZXJ2aWNlIGNvbmZpZyBmb3VuZCcpO1xufVxuLyoqXG4gKiBGaW5kIHRoZSBcImdycGNfY29uZmlnXCIgcmVjb3JkIGFtb25nIHRoZSBUWFQgcmVjb3JkcywgcGFyc2UgaXRzIHZhbHVlIGFzIEpTT04sIHZhbGlkYXRlIGl0cyBjb250ZW50cyxcbiAqIGFuZCBzZWxlY3QgYSBzZXJ2aWNlIGNvbmZpZyB3aXRoIHNlbGVjdGlvbiBmaWVsZHMgdGhhdCBhbGwgbWF0Y2ggdGhpcyBjbGllbnQuIE1vc3Qgb2YgdGhlc2Ugc3RlcHNcbiAqIGNhbiBmYWlsIHdpdGggYW4gZXJyb3I7IHRoZSBjYWxsZXIgbXVzdCBoYW5kbGUgYW55IGVycm9ycyB0aHJvd24gdGhpcyB3YXkuXG4gKiBAcGFyYW0gdHh0UmVjb3JkIFRoZSBUWFQgcmVjb3JkIGFycmF5IHRoYXQgaXMgb3V0cHV0IGZyb20gYSBzdWNjZXNzZnVsIGNhbGwgdG8gZG5zLnJlc29sdmVUeHRcbiAqIEBwYXJhbSBwZXJjZW50YWdlIEEgbnVtYmVyIGNob3NlbiBmcm9tIHRoZSByYW5nZSBbMCwgMTAwKSB0aGF0IGlzIHVzZWQgdG8gc2VsZWN0IHdoaWNoIGNvbmZpZyB0byB1c2VcbiAqIEByZXR1cm4gVGhlIHNlcnZpY2UgY29uZmlndXJhdGlvbiB0byB1c2UsIGdpdmVuIHRoZSBwZXJjZW50YWdlIHZhbHVlLCBvciBudWxsIGlmIHRoZSBzZXJ2aWNlIGNvbmZpZ1xuICogICAgIGRhdGEgaGFzIGEgdmFsaWQgZm9ybWF0IGJ1dCBub25lIG9mIHRoZSBvcHRpb25zIG1hdGNoIHRoZSBjdXJyZW50IGNsaWVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcodHh0UmVjb3JkLCBwZXJjZW50YWdlKSB7XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgdHh0UmVjb3JkKSB7XG4gICAgICAgIGlmIChyZWNvcmQubGVuZ3RoID4gMCAmJiByZWNvcmRbMF0uc3RhcnRzV2l0aCgnZ3JwY19jb25maWc9JykpIHtcbiAgICAgICAgICAgIC8qIFRyZWF0IHRoZSBsaXN0IG9mIHN0cmluZ3MgaW4gdGhpcyByZWNvcmQgYXMgYSBzaW5nbGUgc3RyaW5nIGFuZCByZW1vdmVcbiAgICAgICAgICAgICAqIFwiZ3JwY19jb25maWc9XCIgZnJvbSB0aGUgYmVnaW5uaW5nLiBUaGUgcmVzdCBzaG91bGQgYmUgYSBKU09OIHN0cmluZyAqL1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkU3RyaW5nID0gcmVjb3JkLmpvaW4oJycpLnN1YnN0cmluZygnZ3JwY19jb25maWc9Jy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkSnNvbiA9IEpTT04ucGFyc2UocmVjb3JkU3RyaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB2YWxpZGF0ZUFuZFNlbGVjdENhbmFyeUNvbmZpZyhyZWNvcmRKc29uLCBwZXJjZW50YWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcnZpY2UtY29uZmlnLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */\nclass StatusBuilder {\n    constructor() {\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */\n    withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */\n    withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */\n    withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */\n    build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder;\n//# sourceMappingURL=status-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdGF0dXMtYnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdGF0dXMtYnVpbGRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gdm9pZCAwO1xuLyoqXG4gKiBBIGJ1aWxkZXIgZm9yIGdSUEMgc3RhdHVzIG9iamVjdHMuXG4gKi9cbmNsYXNzIFN0YXR1c0J1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0YXR1cyBjb2RlIHRvIHRoZSBidWlsZGVyLlxuICAgICAqL1xuICAgIHdpdGhDb2RlKGNvZGUpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZGV0YWlscyB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoRGV0YWlscyhkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG1ldGFkYXRhIHRvIHRoZSBidWlsZGVyLlxuICAgICAqL1xuICAgIHdpdGhNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZHMgdGhlIHN0YXR1cyBvYmplY3QuXG4gICAgICovXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5jb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29kZSA9IHRoaXMuY29kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kZXRhaWxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0dXMuZGV0YWlscyA9IHRoaXMuZGV0YWlscztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLm1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IFN0YXR1c0J1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0dXMtYnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor(maxReadMessageLength) {\n        this.maxReadMessageLength = maxReadMessageLength;\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while (readHead < data.length) {\n            switch (this.readState) {\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\n                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\n                        }\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        }\n                        else {\n                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize,\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error('Unexpected read state');\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder;\n//# sourceMappingURL=stream-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdHJlYW0tZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHNCQUFzQixLQUFLLDBCQUEwQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N0cmVhbS1kZWNvZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSB2b2lkIDA7XG52YXIgUmVhZFN0YXRlO1xuKGZ1bmN0aW9uIChSZWFkU3RhdGUpIHtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiTk9fREFUQVwiXSA9IDBdID0gXCJOT19EQVRBXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIlJFQURJTkdfU0laRVwiXSA9IDFdID0gXCJSRUFESU5HX1NJWkVcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19NRVNTQUdFXCJdID0gMl0gPSBcIlJFQURJTkdfTUVTU0FHRVwiO1xufSkoUmVhZFN0YXRlIHx8IChSZWFkU3RhdGUgPSB7fSkpO1xuY2xhc3MgU3RyZWFtRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IobWF4UmVhZE1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aCA9IG1heFJlYWRNZXNzYWdlTGVuZ3RoO1xuICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xuICAgICAgICB0aGlzLnJlYWRDb21wcmVzc0ZsYWcgPSBCdWZmZXIuYWxsb2MoMSk7XG4gICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nID0gNDtcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSAwO1xuICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSA9IFtdO1xuICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gMDtcbiAgICB9XG4gICAgd3JpdGUoZGF0YSkge1xuICAgICAgICBsZXQgcmVhZEhlYWQgPSAwO1xuICAgICAgICBsZXQgdG9SZWFkO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHJlYWRIZWFkIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5yZWFkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5OT19EQVRBOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDb21wcmVzc0ZsYWcgPSBkYXRhLnNsaWNlKHJlYWRIZWFkLCByZWFkSGVhZCArIDEpO1xuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5SRUFESU5HX1NJWkU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplLmZpbGwoMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFNpemVSZW1haW5pbmcgPSA0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlU2l6ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5SRUFESU5HX1NJWkU6XG4gICAgICAgICAgICAgICAgICAgIHRvUmVhZCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gcmVhZEhlYWQsIHRoaXMucmVhZFNpemVSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmNvcHkodGhpcy5yZWFkUGFydGlhbFNpemUsIDQgLSB0aGlzLnJlYWRTaXplUmVtYWluaW5nLCByZWFkSGVhZCwgcmVhZEhlYWQgKyB0b1JlYWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nIC09IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkU2l6ZVJlbWFpbmluZyA+PTAgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5yZWFkVUludDMyQkUoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aCAhPT0gLTEgJiYgdGhpcy5yZWFkTWVzc2FnZVNpemUgPiB0aGlzLm1heFJlYWRNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNlaXZlZCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHt0aGlzLnJlYWRNZXNzYWdlU2l6ZX0gdnMgJHt0aGlzLm1heFJlYWRNZXNzYWdlTGVuZ3RofSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPSB0aGlzLnJlYWRNZXNzYWdlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLlJFQURJTkdfTUVTU0FHRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KFt0aGlzLnJlYWRDb21wcmVzc0ZsYWcsIHRoaXMucmVhZFBhcnRpYWxTaXplXSwgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFJlYWRTdGF0ZS5SRUFESU5HX01FU1NBR0U6XG4gICAgICAgICAgICAgICAgICAgIHRvUmVhZCA9IE1hdGgubWluKGRhdGEubGVuZ3RoIC0gcmVhZEhlYWQsIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZS5wdXNoKGRhdGEuc2xpY2UocmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgLT0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICByZWFkSGVhZCArPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRNZXNzYWdlUmVtYWluaW5nID49MCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHJlYWQgYSBmdWxsIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2VCdWZmZXJzID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZENvbXByZXNzRmxhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0uY29uY2F0KHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lZE1lc3NhZ2UgPSBCdWZmZXIuY29uY2F0KGZyYW1lZE1lc3NhZ2VCdWZmZXJzLCB0aGlzLnJlYWRNZXNzYWdlU2l6ZSArIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZWFkIHN0YXRlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLlN0cmVhbURlY29kZXIgPSBTdHJlYW1EZWNvZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyZWFtLWRlY29kZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return 'port' in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n    if (!address1 && !address2) {\n        return true;\n    }\n    if (!address1 || !address2) {\n        return false;\n    }\n    if (isTcpSubchannelAddress(address1)) {\n        return (isTcpSubchannelAddress(address2) &&\n            address1.host === address2.host &&\n            address1.port === address2.port);\n    }\n    else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        return address.host + ':' + address.port;\n    }\n    else {\n        return address.path;\n    }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if ((0, net_1.isIP)(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT,\n        };\n    }\n    else {\n        return {\n            path: addressString,\n        };\n    }\n}\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\n//# sourceMappingURL=subchannel-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsR0FBRyxpQ0FBaUMsR0FBRyw4QkFBOEIsR0FBRyw4QkFBOEI7QUFDdkksY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtYWRkcmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc0VxdWFsID0gZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuZnVuY3Rpb24gaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuICdwb3J0JyBpbiBhZGRyZXNzO1xufVxuZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gaXNUY3BTdWJjaGFubmVsQWRkcmVzcztcbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoYWRkcmVzczEsIGFkZHJlc3MyKSB7XG4gICAgaWYgKCFhZGRyZXNzMSAmJiAhYWRkcmVzczIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYWRkcmVzczEgfHwgIWFkZHJlc3MyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczEpKSB7XG4gICAgICAgIHJldHVybiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiZcbiAgICAgICAgICAgIGFkZHJlc3MxLmhvc3QgPT09IGFkZHJlc3MyLmhvc3QgJiZcbiAgICAgICAgICAgIGFkZHJlc3MxLnBvcnQgPT09IGFkZHJlc3MyLnBvcnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MyKSAmJiBhZGRyZXNzMS5wYXRoID09PSBhZGRyZXNzMi5wYXRoO1xuICAgIH1cbn1cbmV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbCA9IHN1YmNoYW5uZWxBZGRyZXNzRXF1YWw7XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5ob3N0ICsgJzonICsgYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcgPSBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nO1xuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xuZnVuY3Rpb24gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzU3RyaW5nLCBwb3J0KSB7XG4gICAgaWYgKCgwLCBuZXRfMS5pc0lQKShhZGRyZXNzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaG9zdDogYWRkcmVzc1N0cmluZyxcbiAgICAgICAgICAgIHBvcnQ6IHBvcnQgIT09IG51bGwgJiYgcG9ydCAhPT0gdm9pZCAwID8gcG9ydCA6IERFRkFVTFRfUE9SVCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBhZGRyZXNzU3RyaW5nLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyA9IHN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-call.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2SubchannelCall = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'subchannel_call';\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)) {\n        if (num === errno) {\n            return name;\n        }\n    }\n    return 'Unknown system error ' + errno;\n}\nclass Http2SubchannelCall {\n    constructor(http2Stream, callEventTracker, listener, transport, callId) {\n        var _a;\n        this.http2Stream = http2Stream;\n        this.callEventTracker = callEventTracker;\n        this.listener = listener;\n        this.transport = transport;\n        this.callId = callId;\n        this.isReadFilterPending = false;\n        this.isPushPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */\n        this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.internalError = null;\n        const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);\n        http2Stream.on('response', (headers, flags) => {\n            let headersString = '';\n            for (const header of Object.keys(headers)) {\n                headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n            }\n            this.trace('Received server headers:\\n' + headersString);\n            switch (headers[':status']) {\n                // TODO(murgatroid99): handle 100 and 101\n                case 400:\n                    this.mappedStatusCode = constants_1.Status.INTERNAL;\n                    break;\n                case 401:\n                    this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                    break;\n                case 403:\n                    this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                    break;\n                case 404:\n                    this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                    break;\n                case 429:\n                case 502:\n                case 503:\n                case 504:\n                    this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                    break;\n                default:\n                    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n            }\n            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                this.handleTrailers(headers);\n            }\n            else {\n                let metadata;\n                try {\n                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                }\n                catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNKNOWN,\n                        details: error.message,\n                        metadata: new metadata_1.Metadata(),\n                    });\n                    return;\n                }\n                this.listener.onReceiveMetadata(metadata);\n            }\n        });\n        http2Stream.on('trailers', (headers) => {\n            this.handleTrailers(headers);\n        });\n        http2Stream.on('data', (data) => {\n            /* If the status has already been output, allow the http2 stream to\n             * drain without processing the data. */\n            if (this.statusOutput) {\n                return;\n            }\n            this.trace('receive HTTP/2 data frame of length ' + data.length);\n            let messages;\n            try {\n                messages = this.decoder.write(data);\n            }\n            catch (e) {\n                this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);\n                return;\n            }\n            for (const message of messages) {\n                this.trace('parsed message of length ' + message.length);\n                this.callEventTracker.addMessageReceived();\n                this.tryPush(message);\n            }\n        });\n        http2Stream.on('end', () => {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n        });\n        http2Stream.on('close', () => {\n            /* Use process.next tick to ensure that this code happens after any\n             * \"error\" event that may be emitted at about the same time, so that\n             * we can bubble up the error message from that event. */\n            process.nextTick(() => {\n                var _a;\n                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n                /* If we have a final status with an OK status code, that means that\n                 * we have received all of the messages and we have processed the\n                 * trailers and the call completed successfully, so it doesn't matter\n                 * how the stream ends after that */\n                if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                    return;\n                }\n                let code;\n                let details = '';\n                switch (http2Stream.rstCode) {\n                    case http2.constants.NGHTTP2_NO_ERROR:\n                        /* If we get a NO_ERROR code and we already have a status, the\n                         * stream completed properly and we just haven't fully processed\n                         * it yet */\n                        if (this.finalStatus !== null) {\n                            return;\n                        }\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                        break;\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\n                        code = constants_1.Status.UNAVAILABLE;\n                        details = 'Stream refused by server';\n                        break;\n                    case http2.constants.NGHTTP2_CANCEL:\n                        code = constants_1.Status.CANCELLED;\n                        details = 'Call cancelled';\n                        break;\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\n                        details = 'Bandwidth exhausted or memory limit exceeded';\n                        break;\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                        code = constants_1.Status.PERMISSION_DENIED;\n                        details = 'Protocol not secure enough';\n                        break;\n                    case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                        code = constants_1.Status.INTERNAL;\n                        if (this.internalError === null) {\n                            /* This error code was previously handled in the default case, and\n                             * there are several instances of it online, so I wanted to\n                             * preserve the original error message so that people find existing\n                             * information in searches, but also include the more recognizable\n                             * \"Internal server error\" message. */\n                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n                        }\n                        else {\n                            if (this.internalError.code === 'ECONNRESET' ||\n                                this.internalError.code === 'ETIMEDOUT') {\n                                code = constants_1.Status.UNAVAILABLE;\n                                details = this.internalError.message;\n                            }\n                            else {\n                                /* The \"Received RST_STREAM with code ...\" error is preserved\n                                 * here for continuity with errors reported online, but the\n                                 * error message at the end will probably be more relevant in\n                                 * most cases. */\n                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                            }\n                        }\n                        break;\n                    default:\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                }\n                // This is a no-op if trailers were received at all.\n                // This is OK, because status codes emitted here correspond to more\n                // catastrophic issues that prevent us from receiving trailers in the\n                // first place.\n                this.endCall({\n                    code,\n                    details,\n                    metadata: new metadata_1.Metadata(),\n                    rstCode: http2Stream.rstCode,\n                });\n            });\n        });\n        http2Stream.on('error', (err) => {\n            /* We need an error handler here to stop \"Uncaught Error\" exceptions\n             * from bubbling up. However, errors here should all correspond to\n             * \"close\" events, where we will handle the error more granularly */\n            /* Specifically looking for stream errors that were *not* constructed\n             * from a RST_STREAM response here:\n             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n             */\n            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n                this.trace('Node error event: message=' +\n                    err.message +\n                    ' code=' +\n                    err.code +\n                    ' errno=' +\n                    getSystemErrorName(err.errno) +\n                    ' syscall=' +\n                    err.syscall);\n                this.internalError = err;\n            }\n            this.callEventTracker.onStreamEnd(false);\n        });\n    }\n    onDisconnect() {\n        this.endCall({\n            code: constants_1.Status.UNAVAILABLE,\n            details: 'Connection dropped',\n            metadata: new metadata_1.Metadata(),\n        });\n    }\n    outputStatus() {\n        /* Precondition: this.finalStatus !== null */\n        if (!this.statusOutput) {\n            this.statusOutput = true;\n            this.trace('ended with status: code=' +\n                this.finalStatus.code +\n                ' details=\"' +\n                this.finalStatus.details +\n                '\"');\n            this.callEventTracker.onCallEnd(this.finalStatus);\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */\n            process.nextTick(() => {\n                this.listener.onReceiveStatus(this.finalStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */\n            this.http2Stream.resume();\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n    endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */\n        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */\n            if (this.finalStatus.code !== constants_1.Status.OK ||\n                (this.readsClosed &&\n                    this.unpushedReadMessages.length === 0 &&\n                    !this.isReadFilterPending &&\n                    !this.isPushPending)) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace('pushing to reader message of length ' +\n            (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        this.isPushPending = true;\n        process.nextTick(() => {\n            this.isPushPending = false;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */\n            if (this.statusOutput) {\n                return;\n            }\n            this.listener.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    tryPush(messageBytes) {\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(messageBytes);\n        }\n        else {\n            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\n            this.unpushedReadMessages.push(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.callEventTracker.onStreamEnd(true);\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        this.trace('Received server trailers:\\n' + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        }\n        catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN &&\n            typeof metadataMap['grpc-status'] === 'string') {\n            const receivedStatus = Number(metadataMap['grpc-status']);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace('received status code ' + receivedStatus + ' from server');\n            }\n            metadata.remove('grpc-status');\n        }\n        let details = '';\n        if (typeof metadataMap['grpc-message'] === 'string') {\n            try {\n                details = decodeURI(metadataMap['grpc-message']);\n            }\n            catch (e) {\n                details = metadataMap['grpc-message'];\n            }\n            metadata.remove('grpc-message');\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = { code, details, metadata };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (!this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */\n            let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            }\n            else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace('close http2 stream with code ' + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        return this.transport.getPeerName();\n    }\n    getCallNumber() {\n        return this.callId;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.unpushedReadMessages.length > 0) {\n            const nextMessage = this.unpushedReadMessages.shift();\n            this.push(nextMessage);\n            return;\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit */\n        this.http2Stream.resume();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        const cb = (error) => {\n            /* nextTick here ensures that no stream action can be taken in the call\n             * stack of the write callback, in order to hopefully work around\n             * https://github.com/nodejs/node/issues/49147 */\n            process.nextTick(() => {\n                var _a;\n                let code = constants_1.Status.UNAVAILABLE;\n                if ((error === null || error === void 0 ? void 0 : error.code) ===\n                    'ERR_STREAM_WRITE_AFTER_END') {\n                    code = constants_1.Status.INTERNAL;\n                }\n                if (error) {\n                    this.cancelWithStatus(code, `Write error: ${error.message}`);\n                }\n                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            });\n        };\n        this.trace('sending data chunk of length ' + message.length);\n        this.callEventTracker.addMessageSent();\n        try {\n            this.http2Stream.write(message, cb);\n        }\n        catch (error) {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Write failed with error ${error.message}`,\n                metadata: new metadata_1.Metadata(),\n            });\n        }\n    }\n    halfClose() {\n        this.trace('end() called');\n        this.trace('calling end() on HTTP/2 stream');\n        this.http2Stream.end();\n    }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall;\n//# sourceMappingURL=subchannel-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkI7QUFDM0IsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLG9CQUFvQixtQkFBTyxDQUFDLHlGQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLG1HQUFrQjtBQUNuRCxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG9CQUFvQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxxQkFBcUI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQixzQ0FBc0MsMkJBQTJCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsb0JBQW9CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUE0RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsY0FBYztBQUM5RTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtY2FsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3Qgc3RyZWFtX2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS1kZWNvZGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3N1YmNoYW5uZWxfY2FsbCc7XG4vKipcbiAqIFNob3VsZCBkbyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHRoaW5nIGFzIHV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lIGJ1dCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwZXMgZG9uJ3QgaGF2ZSB0aGF0IGZ1bmN0aW9uIGZvciBzb21lIHJlYXNvbiBzbyBJIGp1c3QgbWFkZSBteVxuICogb3duLlxuICogQHBhcmFtIGVycm5vXG4gKi9cbmZ1bmN0aW9uIGdldFN5c3RlbUVycm9yTmFtZShlcnJubykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIG51bV0gb2YgT2JqZWN0LmVudHJpZXMob3MuY29uc3RhbnRzLmVycm5vKSkge1xuICAgICAgICBpZiAobnVtID09PSBlcnJubykge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duIHN5c3RlbSBlcnJvciAnICsgZXJybm87XG59XG5jbGFzcyBIdHRwMlN1YmNoYW5uZWxDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihodHRwMlN0cmVhbSwgY2FsbEV2ZW50VHJhY2tlciwgbGlzdGVuZXIsIHRyYW5zcG9ydCwgY2FsbElkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5odHRwMlN0cmVhbSA9IGh0dHAyU3RyZWFtO1xuICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIgPSBjYWxsRXZlbnRUcmFja2VyO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICB0aGlzLmNhbGxJZCA9IGNhbGxJZDtcbiAgICAgICAgdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGFuICdlbmQnIGV2ZW50IGhhcyBjb21lIGZyb20gdGhlIGh0dHAyIHN0cmVhbSwgc28gdGhlcmVcbiAgICAgICAgICogd2lsbCBiZSBubyBtb3JlIGRhdGEgZXZlbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzID0gW107XG4gICAgICAgIC8vIFN0YXR1cyBjb2RlIG1hcHBlZCBmcm9tIDpzdGF0dXMuIFRvIGJlIHVzZWQgaWYgZ3JwYy1zdGF0dXMgaXMgbm90IHJlY2VpdmVkXG4gICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xuICAgICAgICAvLyBUaGlzIGlzIHBvcHVsYXRlZCAobm9uLW51bGwpIGlmIGFuZCBvbmx5IGlmIHRoZSBjYWxsIGhhcyBlbmRlZFxuICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gbnVsbDtcbiAgICAgICAgY29uc3QgbWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGggPSAoX2EgPSB0cmFuc3BvcnQuZ2V0T3B0aW9ucygpWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzdHJlYW1fZGVjb2Rlcl8xLlN0cmVhbURlY29kZXIobWF4UmVjZWl2ZU1lc3NhZ2VMZW5ndGgpO1xuICAgICAgICBodHRwMlN0cmVhbS5vbigncmVzcG9uc2UnLCAoaGVhZGVycywgZmxhZ3MpID0+IHtcbiAgICAgICAgICAgIGxldCBoZWFkZXJzU3RyaW5nID0gJyc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzZXJ2ZXIgaGVhZGVyczpcXG4nICsgaGVhZGVyc1N0cmluZyk7XG4gICAgICAgICAgICBzd2l0Y2ggKGhlYWRlcnNbJzpzdGF0dXMnXSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogaGFuZGxlIDEwMCBhbmQgMTAxXG4gICAgICAgICAgICAgICAgY2FzZSA0MDA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFVVEhFTlRJQ0FURUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDAzOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0Mjk6XG4gICAgICAgICAgICAgICAgY2FzZSA1MDI6XG4gICAgICAgICAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgICAgICAgICAgY2FzZSA1MDQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV047XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmxhZ3MgJiBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9GTEFHX0VORF9TVFJFQU0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCd0cmFpbGVycycsIChoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgLyogSWYgdGhlIHN0YXR1cyBoYXMgYWxyZWFkeSBiZWVuIG91dHB1dCwgYWxsb3cgdGhlIGh0dHAyIHN0cmVhbSB0b1xuICAgICAgICAgICAgICogZHJhaW4gd2l0aG91dCBwcm9jZXNzaW5nIHRoZSBkYXRhLiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZSBIVFRQLzIgZGF0YSBmcmFtZSBvZiBsZW5ndGggJyArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXMgPSB0aGlzLmRlY29kZXIud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3BhcnNlZCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAvKiBVc2UgcHJvY2Vzcy5uZXh0IHRpY2sgdG8gZW5zdXJlIHRoYXQgdGhpcyBjb2RlIGhhcHBlbnMgYWZ0ZXIgYW55XG4gICAgICAgICAgICAgKiBcImVycm9yXCIgZXZlbnQgdGhhdCBtYXkgYmUgZW1pdHRlZCBhdCBhYm91dCB0aGUgc2FtZSB0aW1lLCBzbyB0aGF0XG4gICAgICAgICAgICAgKiB3ZSBjYW4gYnViYmxlIHVwIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdIVFRQLzIgc3RyZWFtIGNsb3NlZCB3aXRoIGNvZGUgJyArIGh0dHAyU3RyZWFtLnJzdENvZGUpO1xuICAgICAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYSBmaW5hbCBzdGF0dXMgd2l0aCBhbiBPSyBzdGF0dXMgY29kZSwgdGhhdCBtZWFucyB0aGF0XG4gICAgICAgICAgICAgICAgICogd2UgaGF2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIG1lc3NhZ2VzIGFuZCB3ZSBoYXZlIHByb2Nlc3NlZCB0aGVcbiAgICAgICAgICAgICAgICAgKiB0cmFpbGVycyBhbmQgdGhlIGNhbGwgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgc28gaXQgZG9lc24ndCBtYXR0ZXJcbiAgICAgICAgICAgICAgICAgKiBob3cgdGhlIHN0cmVhbSBlbmRzIGFmdGVyIHRoYXQgKi9cbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICAgICAgICAgbGV0IGRldGFpbHMgPSAnJztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGh0dHAyU3RyZWFtLnJzdENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIGdldCBhIE5PX0VSUk9SIGNvZGUgYW5kIHdlIGFscmVhZHkgaGF2ZSBhIHN0YXR1cywgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzdHJlYW0gY29tcGxldGVkIHByb3Blcmx5IGFuZCB3ZSBqdXN0IGhhdmVuJ3QgZnVsbHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB5ZXQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9SRUZVU0VEX1NUUkVBTTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1N0cmVhbSByZWZ1c2VkIGJ5IHNlcnZlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUw6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQ2FsbCBjYW5jZWxsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE06XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQmFuZHdpZHRoIGV4aGF1c3RlZCBvciBtZW1vcnkgbGltaXQgZXhjZWVkZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfSU5BREVRVUFURV9TRUNVUklUWTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuUEVSTUlTU0lPTl9ERU5JRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ1Byb3RvY29sIG5vdCBzZWN1cmUgZW5vdWdoJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGVycm9yIGNvZGUgd2FzIHByZXZpb3VzbHkgaGFuZGxlZCBpbiB0aGUgZGVmYXVsdCBjYXNlLCBhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGVyZSBhcmUgc2V2ZXJhbCBpbnN0YW5jZXMgb2YgaXQgb25saW5lLCBzbyBJIHdhbnRlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIHNvIHRoYXQgcGVvcGxlIGZpbmQgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBpbmZvcm1hdGlvbiBpbiBzZWFyY2hlcywgYnV0IGFsc28gaW5jbHVkZSB0aGUgbW9yZSByZWNvZ25pemFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBcIkludGVybmFsIHNlcnZlciBlcnJvclwiIG1lc3NhZ2UuICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9IChJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IpYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvci5jb2RlID09PSAnRVRJTUVET1VUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gdGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgXCJSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAuLi5cIiBlcnJvciBpcyBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaGVyZSBmb3IgY29udGludWl0eSB3aXRoIGVycm9ycyByZXBvcnRlZCBvbmxpbmUsIGJ1dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogZXJyb3IgbWVzc2FnZSBhdCB0aGUgZW5kIHdpbGwgcHJvYmFibHkgYmUgbW9yZSByZWxldmFudCBpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBtb3N0IGNhc2VzLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX0gdHJpZ2dlcmVkIGJ5IGludGVybmFsIGNsaWVudCBlcnJvcjogJHt0aGlzLmludGVybmFsRXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0cmFpbGVycyB3ZXJlIHJlY2VpdmVkIGF0IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIE9LLCBiZWNhdXNlIHN0YXR1cyBjb2RlcyBlbWl0dGVkIGhlcmUgY29ycmVzcG9uZCB0byBtb3JlXG4gICAgICAgICAgICAgICAgLy8gY2F0YXN0cm9waGljIGlzc3VlcyB0aGF0IHByZXZlbnQgdXMgZnJvbSByZWNlaXZpbmcgdHJhaWxlcnMgaW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgcGxhY2UuXG4gICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIHJzdENvZGU6IGh0dHAyU3RyZWFtLnJzdENvZGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIC8qIFdlIG5lZWQgYW4gZXJyb3IgaGFuZGxlciBoZXJlIHRvIHN0b3AgXCJVbmNhdWdodCBFcnJvclwiIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgICAqIGZyb20gYnViYmxpbmcgdXAuIEhvd2V2ZXIsIGVycm9ycyBoZXJlIHNob3VsZCBhbGwgY29ycmVzcG9uZCB0b1xuICAgICAgICAgICAgICogXCJjbG9zZVwiIGV2ZW50cywgd2hlcmUgd2Ugd2lsbCBoYW5kbGUgdGhlIGVycm9yIG1vcmUgZ3JhbnVsYXJseSAqL1xuICAgICAgICAgICAgLyogU3BlY2lmaWNhbGx5IGxvb2tpbmcgZm9yIHN0cmVhbSBlcnJvcnMgdGhhdCB3ZXJlICpub3QqIGNvbnN0cnVjdGVkXG4gICAgICAgICAgICAgKiBmcm9tIGEgUlNUX1NUUkVBTSByZXNwb25zZSBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvOGI4NjIwZDU4MDMxNDA1MDE3NTk4MzQwMmRmZGRmMjY3NGU4ZTIyYS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMjI2N1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFUlJfSFRUUDJfU1RSRUFNX0VSUk9SJykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ05vZGUgZXJyb3IgZXZlbnQ6IG1lc3NhZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgJyBjb2RlPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSArXG4gICAgICAgICAgICAgICAgICAgICcgZXJybm89JyArXG4gICAgICAgICAgICAgICAgICAgIGdldFN5c3RlbUVycm9yTmFtZShlcnIuZXJybm8pICtcbiAgICAgICAgICAgICAgICAgICAgJyBzeXNjYWxsPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIuc3lzY2FsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgIGRldGFpbHM6ICdDb25uZWN0aW9uIGRyb3BwZWQnLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIC8qIFByZWNvbmRpdGlvbjogdGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAqL1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c091dHB1dCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgK1xuICAgICAgICAgICAgICAgICcgZGV0YWlscz1cIicgK1xuICAgICAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIub25DYWxsRW5kKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgLyogV2UgZGVsYXkgdGhlIGFjdHVhbCBhY3Rpb24gb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cyB0byBpbnN1bGF0ZSB0aGVcbiAgICAgICAgICAgICAqIGNsZWFudXAgY29kZSBpbiB0aGlzIGNsYXNzIGZyb20gYW55IGVycm9ycyB0aGF0IG1heSBiZSB0aHJvd24gaW4gdGhlXG4gICAgICAgICAgICAgKiB1cHBlciBsYXllcnMgYXMgYSByZXN1bHQgb2YgYnViYmxpbmcgdXAgdGhlIHN0YXR1cy4gSW4gcGFydGljdWxhcixcbiAgICAgICAgICAgICAqIGlmIHRoZSBzdGF0dXMgaXMgbm90IE9LLCB0aGUgXCJlcnJvclwiIGV2ZW50IG1heSBiZSBlbWl0dGVkXG4gICAgICAgICAgICAgKiBzeW5jaHJvbm91c2x5IGF0IHRoZSB0b3AgbGV2ZWwsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgdGhyb3duIGVycm9yIGlmXG4gICAgICAgICAgICAgKiB0aGUgdXNlciBkb2VzIG5vdCBoYW5kbGUgdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHRoaXMuZmluYWxTdGF0dXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBMZWF2ZSB0aGUgaHR0cDIgc3RyZWFtIGluIGZsb3dpbmcgc3RhdGUgdG8gZHJhaW4gaW5jb21pbmcgbWVzc2FnZXMsIHRvXG4gICAgICAgICAgICAgKiBlbnN1cmUgdGhhdCB0aGUgc3RyZWFtIGNsb3N1cmUgY29tcGxldGVzLiBUaGUgY2FsbCBzdHJlYW0gYWxyZWFkeSBkb2VzXG4gICAgICAgICAgICAgKiBub3QgcHVzaCBtb3JlIG1lc3NhZ2VzIGFmdGVyIHRoZSBzdGF0dXMgaXMgb3V0cHV0LCBzbyB0aGUgbWVzc2FnZXMgZ29cbiAgICAgICAgICAgICAqIG5vd2hlcmUgZWl0aGVyIHdheS4gKi9cbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbElkICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBmaXJzdCBjYWxsLCBlbWl0cyBhICdzdGF0dXMnIGV2ZW50IHdpdGggdGhlIGdpdmVuIFN0YXR1c09iamVjdC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIGFyZSBuby1vcHMuXG4gICAgICogQHBhcmFtIHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBjYWxsLlxuICAgICAqL1xuICAgIGVuZENhbGwoc3RhdHVzKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaXMgT0sgYW5kIGEgbmV3IHN0YXR1cyBjb21lcyBpbiAoZS5nLiBmcm9tIGFcbiAgICAgICAgICogZGVzZXJpYWxpemF0aW9uIGZhaWx1cmUpLCB0aGF0IG5ldyBzdGF0dXMgdGFrZXMgcHJpb3JpdHkgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgPT09IG51bGwgfHwgdGhpcy5maW5hbFN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95SHR0cDJTdHJlYW0oKTtcbiAgICB9XG4gICAgbWF5YmVPdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBUaGUgY29tYmluYXRpb24gY2hlY2sgb2YgcmVhZHNDbG9zZWQgYW5kIHRoYXQgdGhlIHR3byBtZXNzYWdlIGJ1ZmZlclxuICAgICAgICAgICAgICogYXJyYXlzIGFyZSBlbXB0eSBjaGVja3MgdGhhdCB0aGVyZSBhbGwgaW5jb21pbmcgZGF0YSBoYXMgYmVlbiBmdWxseVxuICAgICAgICAgICAgICogcHJvY2Vzc2VkICovXG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0sgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5yZWFkc0Nsb3NlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUHVzaFBlbmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgncHVzaGluZyB0byByZWFkZXIgbWVzc2FnZSBvZiBsZW5ndGggJyArXG4gICAgICAgICAgICAobWVzc2FnZSBpbnN0YW5jZW9mIEJ1ZmZlciA/IG1lc3NhZ2UubGVuZ3RoIDogbnVsbCkpO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qIElmIHdlIGhhdmUgYWxyZWFkeSBvdXRwdXQgdGhlIHN0YXR1cyBhbnkgbGF0ZXIgbWVzc2FnZXMgc2hvdWxkIGJlXG4gICAgICAgICAgICAgKiBpZ25vcmVkLCBhbmQgY2FuIGNhdXNlIG91dC1vZi1vcmRlciBvcGVyYXRpb24gZXJyb3JzIGhpZ2hlciB1cCBpbiB0aGVcbiAgICAgICAgICAgICAqIHN0YWNrLiBDaGVja2luZyBhcyBsYXRlIGFzIHBvc3NpYmxlIGhlcmUgdG8gYXZvaWQgYW55IHJhY2UgY29uZGl0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHJ5UHVzaChtZXNzYWdlQnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCd1bnB1c2hlZFJlYWRNZXNzYWdlcy5wdXNoIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlQnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uU3RyZWFtRW5kKHRydWUpO1xuICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzZXJ2ZXIgdHJhaWxlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhTWFwID0gbWV0YWRhdGEuZ2V0TWFwKCk7XG4gICAgICAgIGxldCBjb2RlID0gdGhpcy5tYXBwZWRTdGF0dXNDb2RlO1xuICAgICAgICBpZiAoY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04gJiZcbiAgICAgICAgICAgIHR5cGVvZiBtZXRhZGF0YU1hcFsnZ3JwYy1zdGF0dXMnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkU3RhdHVzID0gTnVtYmVyKG1ldGFkYXRhTWFwWydncnBjLXN0YXR1cyddKTtcbiAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cyBpbiBjb25zdGFudHNfMS5TdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gcmVjZWl2ZWRTdGF0dXM7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGNvZGUgJyArIHJlY2VpdmVkU3RhdHVzICsgJyBmcm9tIHNlcnZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLXN0YXR1cycpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZXRhaWxzID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gZGVjb2RlVVJJKG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMgPSBtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtbWVzc2FnZScpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgncmVjZWl2ZWQgc3RhdHVzIGRldGFpbHMgc3RyaW5nIFwiJyArIGRldGFpbHMgKyAnXCIgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSB7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhIH07XG4gICAgICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiB0aGUgY2FsbCB3YXMgYWxyZWFkeSBlbmRlZCB3aGVuIGhhbmRsaW5nIGhlYWRlcnMuXG4gICAgICAgIHRoaXMuZW5kQ2FsbChzdGF0dXMpO1xuICAgIH1cbiAgICBkZXN0cm95SHR0cDJTdHJlYW0oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gVGhlIGh0dHAyIHN0cmVhbSBjb3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBkZXN0cm95ZWQgaWYgY2FuY2VsV2l0aFN0YXR1c1xuICAgICAgICAvLyBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJuYWwgaHR0cDIgZXJyb3IuXG4gICAgICAgIGlmICghdGhpcy5odHRwMlN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBjYWxsIGhhcyBlbmRlZCB3aXRoIGFuIE9LIHN0YXR1cywgY29tbXVuaWNhdGUgdGhhdCB3aGVuIGNsb3NpbmdcbiAgICAgICAgICAgICAqIHRoZSBzdHJlYW0sIHBhcnRseSB0byBhdm9pZCBhIHNpdHVhdGlvbiBpbiB3aGljaCB3ZSBkZXRlY3QgYW4gZXJyb3JcbiAgICAgICAgICAgICAqIFJTVF9TVFJFQU0gYXMgYSByZXN1bHQgYWZ0ZXIgd2UgaGF2ZSB0aGUgc3RhdHVzICovXG4gICAgICAgICAgICBsZXQgY29kZTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5maW5hbFN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2xvc2UgaHR0cDIgc3RyZWFtIHdpdGggY29kZSAnICsgY29kZSk7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmNsb3NlKGNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICB0aGlzLmVuZENhbGwoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0pO1xuICAgIH1cbiAgICBnZXRTdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsU3RhdHVzO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuZ2V0UGVlck5hbWUoKTtcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbElkO1xuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdHJlYW0gaGFzIGVuZGVkIHdpdGggYW4gZXJyb3IsIHdlIHNob3VsZCBub3QgZW1pdCBhbnkgbW9yZVxuICAgICAgICAgKiBtZXNzYWdlcyBhbmQgd2Ugc2hvdWxkIGNvbW11bmljYXRlIHRoYXQgdGhlIHN0cmVhbSBoYXMgZW5kZWQgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgJiYgdGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRNZXNzYWdlID0gdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoKG5leHRNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBPbmx5IHJlc3VtZSByZWFkaW5nIGZyb20gdGhlIGh0dHAyU3RyZWFtIGlmIHdlIGRvbid0IGhhdmUgYW55IHBlbmRpbmdcbiAgICAgICAgICogbWVzc2FnZXMgdG8gZW1pdCAqL1xuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCBjYiA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLyogbmV4dFRpY2sgaGVyZSBlbnN1cmVzIHRoYXQgbm8gc3RyZWFtIGFjdGlvbiBjYW4gYmUgdGFrZW4gaW4gdGhlIGNhbGxcbiAgICAgICAgICAgICAqIHN0YWNrIG9mIHRoZSB3cml0ZSBjYWxsYmFjaywgaW4gb3JkZXIgdG8gaG9wZWZ1bGx5IHdvcmsgYXJvdW5kXG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MTQ3ICovXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgaWYgKChlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY29kZSkgPT09XG4gICAgICAgICAgICAgICAgICAgICdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBgV3JpdGUgZXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gY29udGV4dC5jYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFjZSgnc2VuZGluZyBkYXRhIGNodW5rIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIuYWRkTWVzc2FnZVNlbnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ud3JpdGUobWVzc2FnZSwgY2IpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFdyaXRlIGZhaWxlZCB3aXRoIGVycm9yICR7ZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnRyYWNlKCdlbmQoKSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FsbGluZyBlbmQoKSBvbiBIVFRQLzIgc3RyZWFtJyk7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0uZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDYWxsID0gSHR0cDJTdWJjaGFubmVsQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child) {\n        this.child = child;\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        this.child.throttleKeepalive(newKeepaliveTime);\n    }\n    ref() {\n        this.child.ref();\n    }\n    unref() {\n        this.child.unref();\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n    realSubchannelEquals(other) {\n        return this.getRealSubchannel() === other.getRealSubchannel();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper;\n//# sourceMappingURL=subchannel-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWludGVyZmFjZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWludGVyZmFjZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSB2b2lkIDA7XG5jbGFzcyBCYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkKSB7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBjaGlsZDtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgfVxuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNoaWxkLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldEFkZHJlc3MoKTtcbiAgICB9XG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xuICAgICAgICB0aGlzLmNoaWxkLnRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnVucmVmKCk7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDaGFubmVselJlZigpO1xuICAgIH1cbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcbiAgICB9XG4gICAgcmVhbFN1YmNoYW5uZWxFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVhbFN1YmNoYW5uZWwoKSA9PT0gb3RoZXIuZ2V0UmVhbFN1YmNoYW5uZWwoKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IEJhc2VTdWJjaGFubmVsV3JhcHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtaW50ZXJmYWNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/transport.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */\n    constructor() {\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */\n        this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */\n    unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */\n        // eslint-disable-disable-next-line:forin\n        for (const channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */\n            this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */\n        // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */\n    ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(() => {\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */\n    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray) {\n                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&\n                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&\n                    channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel,\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    }\n    else {\n        return new SubchannelPool();\n    }\n}\nexports.getSubchannelPool = getSubchannelPool;\n//# sourceMappingURL=subchannel-pool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDbEQsMEJBQTBCLG1CQUFPLENBQUMscUdBQW1CO0FBQ3JELHFCQUFxQixtQkFBTyxDQUFDLDJGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N1YmNoYW5uZWwtcG9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRTdWJjaGFubmVsUG9vbCA9IGV4cG9ydHMuU3ViY2hhbm5lbFBvb2wgPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsX29wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtb3B0aW9uc1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWxcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydFwiKTtcbi8vIDEwIHNlY29uZHMgaW4gbWlsbGlzZWNvbmRzLiBUaGlzIHZhbHVlIGlzIGFyYml0cmFyeS5cbi8qKlxuICogVGhlIGFtb3VudCBvZiB0aW1lIGluIGJldHdlZW4gY2hlY2tzIGZvciBkcm9wcGluZyBzdWJjaGFubmVscyB0aGF0IGhhdmUgbm9cbiAqIG90aGVyIHJlZmVyZW5jZXNcbiAqL1xuY29uc3QgUkVGX0NIRUNLX0lOVEVSVkFMID0gMTAwMDA7XG5jbGFzcyBTdWJjaGFubmVsUG9vbCB7XG4gICAgLyoqXG4gICAgICogQSBwb29sIG9mIHN1YmNoYW5uZWxzIHVzZSBmb3IgbWFraW5nIGNvbm5lY3Rpb25zLiBTdWJjaGFubmVscyB3aXRoIHRoZVxuICAgICAqIGV4YWN0IHNhbWUgcGFyYW1ldGVycyB3aWxsIGJlIHJldXNlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wb29sID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdGltZXIgb2YgYSB0YXNrIHBlcmZvcm1pbmcgYSBwZXJpb2RpYyBzdWJjaGFubmVsIGNsZWFudXAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFudXBUaW1lciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVmcyBhbGwgdW51c2VkIHN1YmNoYW5uZWxzIGFuZCBjYW5jZWxzIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsXG4gICAgICogc3ViY2hhbm5lbHMgaGF2ZSBiZWVuIHVucmVmZWQuXG4gICAgICovXG4gICAgdW5yZWZVbnVzZWRTdWJjaGFubmVscygpIHtcbiAgICAgICAgbGV0IGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IHRydWU7XG4gICAgICAgIC8qIFRoZXNlIG9iamVjdHMgYXJlIGNyZWF0ZWQgd2l0aCBPYmplY3QuY3JlYXRlKG51bGwpLCBzbyB0aGV5IGRvIG5vdFxuICAgICAgICAgKiBoYXZlIGEgcHJvdG90eXBlLCB3aGljaCBtZWFucyB0aGF0IGZvciAoLi4uIGluIC4uLikgbG9vcHMgb3ZlciB0aGVtXG4gICAgICAgICAqIGRvIG5vdCBuZWVkIHRvIGJlIGZpbHRlcmVkICovXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWRpc2FibGUtbmV4dC1saW5lOmZvcmluXG4gICAgICAgIGZvciAoY29uc3QgY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxPYmpBcnJheSA9IHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XTtcbiAgICAgICAgICAgIGNvbnN0IHJlZmVkU3ViY2hhbm5lbHMgPSBzdWJjaGFubmVsT2JqQXJyYXkuZmlsdGVyKHZhbHVlID0+ICF2YWx1ZS5zdWJjaGFubmVsLnVucmVmSWZPbmVSZWYoKSk7XG4gICAgICAgICAgICBpZiAocmVmZWRTdWJjaGFubmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYWxsU3ViY2hhbm5lbHNVbnJlZmVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBGb3IgZWFjaCBzdWJjaGFubmVsIGluIHRoZSBwb29sLCB0cnkgdG8gdW5yZWYgaXQgaWYgaXQgaGFzXG4gICAgICAgICAgICAgKiBleGFjdGx5IG9uZSByZWYgKHdoaWNoIGlzIHRoZSByZWYgZnJvbSB0aGUgcG9vbCBpdHNlbGYpLiBJZiB0aGF0XG4gICAgICAgICAgICAgKiBkb2VzIGhhcHBlbiwgcmVtb3ZlIHRoZSBzdWJjaGFubmVsIGZyb20gdGhlIHBvb2wgKi9cbiAgICAgICAgICAgIHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XSA9IHJlZmVkU3ViY2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgLyogQ3VycmVudGx5IHdlIGRvIG5vdCBkZWxldGUga2V5cyB3aXRoIGVtcHR5IHZhbHVlcy4gSWYgdGhhdCByZXN1bHRzXG4gICAgICAgICAqIGluIHNpZ25pZmljYW50IG1lbW9yeSB1c2FnZSB3ZSBzaG91bGQgY2hhbmdlIGl0LiAqL1xuICAgICAgICAvLyBDYW5jZWwgdGhlIGNsZWFudXAgdGFzayBpZiBhbGwgc3ViY2hhbm5lbHMgaGF2ZSBiZWVuIHVucmVmZWQuXG4gICAgICAgIGlmIChhbGxTdWJjaGFubmVsc1VucmVmZWQgJiYgdGhpcy5jbGVhbnVwVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jbGVhbnVwVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgdGhhdCB0aGUgY2xlYW51cCB0YXNrIGlzIHNwYXduZWQuXG4gICAgICovXG4gICAgZW5zdXJlQ2xlYW51cFRhc2soKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmNsZWFudXBUaW1lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnJlZlVudXNlZFN1YmNoYW5uZWxzKCk7XG4gICAgICAgICAgICB9LCBSRUZfQ0hFQ0tfSU5URVJWQUwpO1xuICAgICAgICAgICAgLy8gVW5yZWYgYmVjYXVzZSB0aGlzIHRpbWVyIHNob3VsZCBub3Qga2VlcCB0aGUgZXZlbnQgbG9vcCBydW5uaW5nLlxuICAgICAgICAgICAgLy8gQ2FsbCB1bnJlZiBvbmx5IGlmIGl0IGV4aXN0cyB0byBhZGRyZXNzIGVsZWN0cm9uL2VsZWN0cm9uIzIxMTYyXG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmNsZWFudXBUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdWJjaGFubmVsIGlmIG9uZSBhbHJlYWR5IGV4aXN0cyB3aXRoIGV4YWN0bHkgbWF0Y2hpbmcgcGFyYW1ldGVycy5cbiAgICAgKiBPdGhlcndpc2UsIGNyZWF0ZSBhbmQgc2F2ZSBhIHN1YmNoYW5uZWwgd2l0aCB0aG9zZSBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBjaGFubmVsVGFyZ2V0XG4gICAgICogQHBhcmFtIHN1YmNoYW5uZWxUYXJnZXRcbiAgICAgKiBAcGFyYW0gY2hhbm5lbEFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSBjaGFubmVsQ3JlZGVudGlhbHNcbiAgICAgKi9cbiAgICBnZXRPckNyZWF0ZVN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlQ2xlYW51cFRhc2soKTtcbiAgICAgICAgY29uc3QgY2hhbm5lbFRhcmdldCA9ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKGNoYW5uZWxUYXJnZXRVcmkpO1xuICAgICAgICBpZiAoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxPYmpBcnJheSA9IHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbE9iaiBvZiBzdWJjaGFubmVsT2JqQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzRXF1YWwpKHN1YmNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbEFkZHJlc3MpICYmXG4gICAgICAgICAgICAgICAgICAgICgwLCBjaGFubmVsX29wdGlvbnNfMS5jaGFubmVsT3B0aW9uc0VxdWFsKShjaGFubmVsQXJndW1lbnRzLCBzdWJjaGFubmVsT2JqLmNoYW5uZWxBcmd1bWVudHMpICYmXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDcmVkZW50aWFscy5fZXF1YWxzKHN1YmNoYW5uZWxPYmouY2hhbm5lbENyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbE9iai5zdWJjaGFubmVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgbm8gbWF0Y2hpbmcgc3ViY2hhbm5lbCB3YXMgZm91bmRcbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbCA9IG5ldyBzdWJjaGFubmVsXzEuU3ViY2hhbm5lbChjaGFubmVsVGFyZ2V0VXJpLCBzdWJjaGFubmVsVGFyZ2V0LCBjaGFubmVsQXJndW1lbnRzLCBjaGFubmVsQ3JlZGVudGlhbHMsIG5ldyB0cmFuc3BvcnRfMS5IdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IoY2hhbm5lbFRhcmdldFVyaSkpO1xuICAgICAgICBpZiAoIShjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkpIHtcbiAgICAgICAgICAgIHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9vbFtjaGFubmVsVGFyZ2V0XS5wdXNoKHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxBZGRyZXNzOiBzdWJjaGFubmVsVGFyZ2V0LFxuICAgICAgICAgICAgY2hhbm5lbEFyZ3VtZW50cyxcbiAgICAgICAgICAgIGNoYW5uZWxDcmVkZW50aWFscyxcbiAgICAgICAgICAgIHN1YmNoYW5uZWwsXG4gICAgICAgIH0pO1xuICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICByZXR1cm4gc3ViY2hhbm5lbDtcbiAgICB9XG59XG5leHBvcnRzLlN1YmNoYW5uZWxQb29sID0gU3ViY2hhbm5lbFBvb2w7XG5jb25zdCBnbG9iYWxTdWJjaGFubmVsUG9vbCA9IG5ldyBTdWJjaGFubmVsUG9vbCgpO1xuLyoqXG4gKiBHZXQgZWl0aGVyIHRoZSBnbG9iYWwgc3ViY2hhbm5lbCBwb29sLCBvciBhIG5ldyBzdWJjaGFubmVsIHBvb2wuXG4gKiBAcGFyYW0gZ2xvYmFsXG4gKi9cbmZ1bmN0aW9uIGdldFN1YmNoYW5uZWxQb29sKGdsb2JhbCkge1xuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbFN1YmNoYW5uZWxQb29sO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdWJjaGFubmVsUG9vbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0U3ViY2hhbm5lbFBvb2wgPSBnZXRTdWJjaGFubmVsUG9vbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtcG9vbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Subchannel = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst TRACER_NAME = 'subchannel';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */\n    constructor(channelTarget, subchannelAddress, options, credentials, connector) {\n        var _a;\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        this.connector = connector;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */\n        this.transport = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */\n        this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */\n        this.stateListeners = new Set();\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */\n        this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        // Channelz socket info\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        const backoffOptions = {\n            initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: options['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\n        if (options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n        }\n        this.trace('Subchannel constructed with options ' +\n            JSON.stringify(options, undefined, 2));\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString,\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n        }\n        else {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */\n    startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    startConnectingInternal() {\n        let options = this.options;\n        if (options['grpc.keepalive_time_ms']) {\n            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });\n        }\n        this.connector\n            .connect(this.subchannelAddress, this.credentials, options)\n            .then(transport => {\n            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\n                this.transport = transport;\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(transport.getChannelzRef());\n                }\n                transport.addDisconnectListener(tooManyPings => {\n                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n                    if (tooManyPings && this.keepaliveTime > 0) {\n                        this.keepaliveTime *= 2;\n                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n                    }\n                });\n            }\n            else {\n                /* If we can't transition from CONNECTING to READY here, we will\n                 * not be using this transport, so release its resources. */\n                transport.shutdown();\n            }\n        }, error => {\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\n        });\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */\n    transitionToState(oldStates, newState, errorMessage) {\n        var _a, _b;\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch (newState) {\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n                this.transport = null;\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n                if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(() => {\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n                this.transport = null;\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        for (const listener of this.stateListeners) {\n            listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n        }\n        return true;\n    }\n    ref() {\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n            }\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            process.nextTick(() => {\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            });\n        }\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    createCall(metadata, host, method, listener) {\n        if (!this.transport) {\n            throw new Error('Cannot create call, subchannel not READY');\n        }\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            this.streamTracker.addCallStarted();\n            statsTracker = {\n                onCallEnd: status => {\n                    if (status.code === constants_1.Status.OK) {\n                        this.callTracker.addCallSucceeded();\n                    }\n                    else {\n                        this.callTracker.addCallFailed();\n                    }\n                },\n            };\n        }\n        else {\n            statsTracker = {};\n        }\n        return this.transport.createCall(metadata, host, method, listener, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */\n    startConnecting() {\n        process.nextTick(() => {\n            /* First, try to transition from IDLE to connecting. If that doesn't happen\n             * because the state is not currently IDLE, check if it is\n             * TRANSIENT_FAILURE, and if so indicate that it should go back to\n             * connecting after the backoff timer ends. Otherwise do nothing */\n            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    this.continueConnecting = true;\n                }\n            }\n        });\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */\n    getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.add(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        this.stateListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */\n    resetBackoff() {\n        process.nextTick(() => {\n            this.backoffTimeout.reset();\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n        });\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getRealSubchannel() {\n        return this;\n    }\n    realSubchannelEquals(other) {\n        return other.getRealSubchannel() === this;\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n        }\n    }\n}\nexports.Subchannel = Subchannel;\n//# sourceMappingURL=subchannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLDZCQUE2QixtQkFBTyxDQUFDLDJHQUFzQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBbUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMscUZBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMseUZBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsNkJBQTZCLG1CQUFPLENBQUMsMkdBQXNCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLHVGQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYyxpREFBaUQ7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsbURBQW1ELEtBQUssOEJBQThCLDBFQUEwRSxvQkFBb0I7QUFDelE7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFKQUFxSixNQUFNO0FBQzNKLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsU0FBUztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN1YmNoYW5uZWwgPSB2b2lkIDA7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3N1YmNoYW5uZWwnO1xuLyogc2V0SW50ZXJ2YWwgYW5kIHNldFRpbWVvdXQgb25seSBhY2NlcHQgc2lnbmVkIDMyIGJpdCBpbnRlZ2Vycy4gSlMgZG9lc24ndFxuICogaGF2ZSBhIGNvbnN0YW50IGZvciB0aGUgbWF4IHNpZ25lZCAzMiBiaXQgaW50ZWdlciwgc28gdGhpcyBpcyBhIHNpbXBsZSB3YXlcbiAqIHRvIGNhbGN1bGF0ZSBpdCAqL1xuY29uc3QgS0VFUEFMSVZFX01BWF9USU1FX01TID0gfigxIDw8IDMxKTtcbmNsYXNzIFN1YmNoYW5uZWwge1xuICAgIC8qKlxuICAgICAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgY29ubmVjdGlvbiB0byBhIHNpbmdsZSBiYWNrZW5kLlxuICAgICAqIEBwYXJhbSBjaGFubmVsVGFyZ2V0IFRoZSB0YXJnZXQgc3RyaW5nIGZvciB0aGUgY2hhbm5lbCBhcyBhIHdob2xlXG4gICAgICogQHBhcmFtIHN1YmNoYW5uZWxBZGRyZXNzIFRoZSBhZGRyZXNzIGZvciB0aGUgYmFja2VuZCB0aGF0IHRoaXMgc3ViY2hhbm5lbFxuICAgICAqICAgICB3aWxsIGNvbm5lY3QgdG9cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgY2hhbm5lbCBvcHRpb25zLCBwbHVzIGFueSBzcGVjaWZpYyBzdWJjaGFubmVsIG9wdGlvbnNcbiAgICAgKiAgICAgZm9yIHRoaXMgc3ViY2hhbm5lbFxuICAgICAqIEBwYXJhbSBjcmVkZW50aWFscyBUaGUgY2hhbm5lbCBjcmVkZW50aWFscyB1c2VkIHRvIGVzdGFibGlzaCB0aGlzXG4gICAgICogICAgIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsQWRkcmVzcywgb3B0aW9ucywgY3JlZGVudGlhbHMsIGNvbm5lY3Rvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuY2hhbm5lbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MgPSBzdWJjaGFubmVsQWRkcmVzcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuIEludmFyaWFudDogYHNlc3Npb25gID09PSBgbnVsbGBcbiAgICAgICAgICogaWYgYW5kIG9ubHkgaWYgYGNvbm5lY3Rpdml0eVN0YXRlYCBpcyBJRExFIG9yIFRSQU5TSUVOVF9GQUlMVVJFLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdW5kZXJseWluZyBodHRwMiBzZXNzaW9uIHVzZWQgdG8gbWFrZSByZXF1ZXN0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBzdWJjaGFubmVsIHNob3VsZCB0cmFuc2l0aW9uIGZyb20gVFJBTlNJRU5UX0ZBSUxVUkUgdG9cbiAgICAgICAgICogQ09OTkVDVElORyBpbnN0ZWFkIG9mIElETEUgd2hlbiB0aGUgYmFja29mZiB0aW1lb3V0IGVuZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBjb25uZWN0aXZpdHlcbiAgICAgICAgICogc3RhdGUgY2hhbmdlcy4gV2lsbCBiZSBtb2RpZmllZCBieSBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmAgYW5kXG4gICAgICAgICAqIGByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyBjaGFubmVscyBhbmQgc3ViY2hhbm5lbCBwb29scyB3aXRoIHJlZmVyZW5jZXMgdG8gdGhpcyBzdWJjaGFubmVsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZmNvdW50ID0gMDtcbiAgICAgICAgLy8gQ2hhbm5lbHogaW5mb1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbFRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNhbGxUcmFja2VyKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgLy8gQ2hhbm5lbHogc29ja2V0IGluZm9cbiAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogb3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogb3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dCA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUJhY2tvZmZUaW1lcigpO1xuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShzdWJjaGFubmVsQWRkcmVzcyk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZSA9IChfYSA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogLTE7XG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsKSh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1N1YmNoYW5uZWwgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ1N1YmNoYW5uZWwgY29uc3RydWN0ZWQgd2l0aCBvcHRpb25zICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkob3B0aW9ucywgdW5kZWZpbmVkLCAyKSk7XG4gICAgfVxuICAgIGdldENoYW5uZWx6SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlLFxuICAgICAgICAgICAgdHJhY2U6IHRoaXMuY2hhbm5lbHpUcmFjZSxcbiAgICAgICAgICAgIGNhbGxUcmFja2VyOiB0aGlzLmNhbGxUcmFja2VyLFxuICAgICAgICAgICAgY2hpbGRyZW46IHRoaXMuY2hpbGRyZW5UcmFja2VyLmdldENoaWxkTGlzdHMoKSxcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIHJlZlRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdzdWJjaGFubmVsX3JlZmNvdW50JywgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgaGFuZGxlQmFja29mZlRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb250aW51ZUNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgYmFja29mZiB0aW1lciB3aXRoIHRoZSBjdXJyZW50IG5leHRCYWNrb2ZmIHRpbWVvdXRcbiAgICAgKi9cbiAgICBzdGFydEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucnVuT25jZSgpO1xuICAgIH1cbiAgICBzdG9wQmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5zdG9wKCk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICB9XG4gICAgc3RhcnRDb25uZWN0aW5nSW50ZXJuYWwoKSB7XG4gICAgICAgIGxldCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyddKSB7XG4gICAgICAgICAgICBjb25zdCBhZGp1c3RlZEtlZXBhbGl2ZVRpbWUgPSBNYXRoLm1pbih0aGlzLmtlZXBhbGl2ZVRpbWUsIEtFRVBBTElWRV9NQVhfVElNRV9NUyk7XG4gICAgICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyAnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyc6IGFkanVzdGVkS2VlcGFsaXZlVGltZSB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3RvclxuICAgICAgICAgICAgLmNvbm5lY3QodGhpcy5zdWJjaGFubmVsQWRkcmVzcywgdGhpcy5jcmVkZW50aWFscywgb3B0aW9ucylcbiAgICAgICAgICAgIC50aGVuKHRyYW5zcG9ydCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZCh0cmFuc3BvcnQuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5hZGREaXNjb25uZWN0TGlzdGVuZXIodG9vTWFueVBpbmdzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb01hbnlQaW5ncyAmJiB0aGlzLmtlZXBhbGl2ZVRpbWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgKj0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgYENvbm5lY3Rpb24gdG8gJHsoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLmNoYW5uZWxUYXJnZXQpfSBhdCAke3RoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmd9IHJlamVjdGVkIGJ5IHNlcnZlciBiZWNhdXNlIG9mIGV4Y2VzcyBwaW5ncy4gSW5jcmVhc2luZyBwaW5nIGludGVydmFsIHRvICR7dGhpcy5rZWVwYWxpdmVUaW1lfSBtc2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBJZiB3ZSBjYW4ndCB0cmFuc2l0aW9uIGZyb20gQ09OTkVDVElORyB0byBSRUFEWSBoZXJlLCB3ZSB3aWxsXG4gICAgICAgICAgICAgICAgICogbm90IGJlIHVzaW5nIHRoaXMgdHJhbnNwb3J0LCBzbyByZWxlYXNlIGl0cyByZXNvdXJjZXMuICovXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNodXRkb3duKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgYCR7ZXJyb3J9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBhIHN0YXRlIHRyYW5zaXRpb24gZnJvbSBhbnkgZWxlbWVudCBvZiBvbGRTdGF0ZXMgdG8gdGhlIG5ld1xuICAgICAqIHN0YXRlLiBJZiB0aGUgY3VycmVudCBjb25uZWN0aXZpdHlTdGF0ZSBpcyBub3QgaW4gb2xkU3RhdGVzLCBkbyBub3RoaW5nLlxuICAgICAqIEBwYXJhbSBvbGRTdGF0ZXMgVGhlIHNldCBvZiBzdGF0ZXMgdG8gdHJhbnNpdGlvbiBmcm9tXG4gICAgICogQHBhcmFtIG5ld1N0YXRlIFRoZSBzdGF0ZSB0byB0cmFuc2l0aW9uIHRvXG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RhdGUgY2hhbmdlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgdHJhbnNpdGlvblRvU3RhdGUob2xkU3RhdGVzLCBuZXdTdGF0ZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChvbGRTdGF0ZXMuaW5kZXhPZih0aGlzLmNvbm5lY3Rpdml0eVN0YXRlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlIHRvICcgKyBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHN3aXRjaCAobmV3U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFk6XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wQmFja29mZigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRCYWNrb2ZmKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3RpbmdJbnRlcm5hbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVDb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCAmJiB0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHRoaXMudHJhbnNwb3J0LmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNodXRkb3duKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBiYWNrb2ZmIHRpbWVyIGhhcyBhbHJlYWR5IGVuZGVkIGJ5IHRoZSB0aW1lIHdlIGdldCB0byB0aGVcbiAgICAgICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSBzdGF0ZSwgd2Ugd2FudCB0byBpbW1lZGlhdGVseSB0cmFuc2l0aW9uIG91dCBvZlxuICAgICAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFIGFzIHRob3VnaCB0aGUgYmFja29mZiB0aW1lciBpcyBlbmRpbmcgcmlnaHQgbm93ICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVCYWNrb2ZmVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCAmJiB0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHRoaXMudHJhbnNwb3J0LmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNodXRkb3duKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGU6IHVua25vd24gQ29ubmVjdGl2aXR5U3RhdGUgJHtuZXdTdGF0ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCB0aGlzLmtlZXBhbGl2ZVRpbWUsIGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlZigpIHtcbiAgICAgICAgdGhpcy5yZWZUcmFjZSgncmVmY291bnQgJyArIHRoaXMucmVmY291bnQgKyAnIC0+ICcgKyAodGhpcy5yZWZjb3VudCArIDEpKTtcbiAgICAgICAgdGhpcy5yZWZjb3VudCArPSAxO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5yZWZUcmFjZSgncmVmY291bnQgJyArIHRoaXMucmVmY291bnQgKyAnIC0+ICcgKyAodGhpcy5yZWZjb3VudCAtIDEpKTtcbiAgICAgICAgdGhpcy5yZWZjb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1NodXR0aW5nIGRvd24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5yZWZJZk9uZVJlZigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWYoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjcmVhdGUgY2FsbCwgc3ViY2hhbm5lbCBub3QgUkVBRFknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHNUcmFja2VyO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgc3RhdHNUcmFja2VyID0ge1xuICAgICAgICAgICAgICAgIG9uQ2FsbEVuZDogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRzVHJhY2tlciA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5jcmVhdGVDYWxsKG1ldGFkYXRhLCBob3N0LCBtZXRob2QsIGxpc3RlbmVyLCBzdGF0c1RyYWNrZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3ViY2hhbm5lbCBpcyBjdXJyZW50bHkgSURMRSwgc3RhcnQgY29ubmVjdGluZyBhbmQgc3dpdGNoIHRvIHRoZVxuICAgICAqIENPTk5FQ1RJTkcgc3RhdGUuIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnQgaW4gVFJBTlNJRU5UX0ZBSUxVUkUsXG4gICAgICogdGhlIG5leHQgdGltZSBpdCB3b3VsZCB0cmFuc2l0aW9uIHRvIElETEUsIHN0YXJ0IGNvbm5lY3RpbmcgYWdhaW4gaW5zdGVhZC5cbiAgICAgKiBPdGhlcndpc2UsIGRvIG5vdGhpbmcuXG4gICAgICovXG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIC8qIEZpcnN0LCB0cnkgdG8gdHJhbnNpdGlvbiBmcm9tIElETEUgdG8gY29ubmVjdGluZy4gSWYgdGhhdCBkb2Vzbid0IGhhcHBlblxuICAgICAgICAgICAgICogYmVjYXVzZSB0aGUgc3RhdGUgaXMgbm90IGN1cnJlbnRseSBJRExFLCBjaGVjayBpZiBpdCBpc1xuICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUsIGFuZCBpZiBzbyBpbmRpY2F0ZSB0aGF0IGl0IHNob3VsZCBnbyBiYWNrIHRvXG4gICAgICAgICAgICAgKiBjb25uZWN0aW5nIGFmdGVyIHRoZSBiYWNrb2ZmIHRpbWVyIGVuZHMuIE90aGVyd2lzZSBkbyBub3RoaW5nICovXG4gICAgICAgICAgICBpZiAoIXRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN1YmNoYW5uZWwnc1xuICAgICAqIGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsaXN0ZW5lciBwcmV2aW91c2x5IGFkZGVkIHdpdGggYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIEEgcmVmZXJlbmNlIHRvIGEgZnVuY3Rpb24gcHJldmlvdXNseSBwYXNzZWQgdG9cbiAgICAgKiAgICAgYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgXG4gICAgICovXG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBiYWNrb2ZmIHRpbWVvdXQsIGFuZCBpbW1lZGlhdGVseSBzdGFydCBjb25uZWN0aW5nIGlmIGluIGJhY2tvZmYuXG4gICAgICovXG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZztcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlYWxTdWJjaGFubmVsRXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5nZXRSZWFsU3ViY2hhbm5lbCgpID09PSB0aGlzO1xuICAgIH1cbiAgICB0aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKSB7XG4gICAgICAgIGlmIChuZXdLZWVwYWxpdmVUaW1lID4gdGhpcy5rZWVwYWxpdmVUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgPSBuZXdLZWVwYWxpdmVUaW1lO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TdWJjaGFubmVsID0gU3ViY2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n}\nexports.getDefaultRootsData = getDefaultRootsData;\n//# sourceMappingURL=tls-helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90bHMtaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHFCQUFxQjtBQUNuRCxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0RGVmYXVsdFJvb3RzRGF0YSA9IGV4cG9ydHMuQ0lQSEVSX1NVSVRFUyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuZXhwb3J0cy5DSVBIRVJfU1VJVEVTID0gcHJvY2Vzcy5lbnYuR1JQQ19TU0xfQ0lQSEVSX1NVSVRFUztcbmNvbnN0IERFRkFVTFRfUk9PVFNfRklMRV9QQVRIID0gcHJvY2Vzcy5lbnYuR1JQQ19ERUZBVUxUX1NTTF9ST09UU19GSUxFX1BBVEg7XG5sZXQgZGVmYXVsdFJvb3RzRGF0YSA9IG51bGw7XG5mdW5jdGlvbiBnZXREZWZhdWx0Um9vdHNEYXRhKCkge1xuICAgIGlmIChERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCkge1xuICAgICAgICBpZiAoZGVmYXVsdFJvb3RzRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdFJvb3RzRGF0YSA9IGZzLnJlYWRGaWxlU3luYyhERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRSb290c0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5nZXREZWZhdWx0Um9vdHNEYXRhID0gZ2V0RGVmYXVsdFJvb3RzRGF0YTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRscy1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/transport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/transport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2SubchannelConnector = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst subchannel_call_1 = __webpack_require__(/*! ./subchannel-call */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(action-browser)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(action-browser)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Http2Transport {\n    constructor(session, subchannelAddress, options, \n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    remoteName) {\n        this.session = session;\n        this.options = options;\n        this.remoteName = remoteName;\n        /**\n         * The amount of time in between sending pings\n         */\n        this.keepaliveTimeMs = -1;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */\n        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Timer reference for timeout that indicates when to send the next ping\n         */\n        this.keepaliveTimerId = null;\n        /**\n         * Indicates that the keepalive timer ran out while there were no active\n         * calls, and a ping should be sent the next time a call starts.\n         */\n        this.pendingSendKeepalivePing = false;\n        /**\n         * Timer reference tracking when the most recent ping will be considered lost\n         */\n        this.keepaliveTimeoutId = null;\n        /**\n         * Indicates whether keepalive pings should be sent without any active calls\n         */\n        this.keepaliveWithoutCalls = false;\n        this.activeCalls = new Set();\n        this.disconnectListeners = [];\n        this.disconnectHandled = false;\n        this.channelzEnabled = true;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        /* Populate subchannelAddressString and channelzRef before doing anything\n         * else, because they are used in the trace methods. */\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        if (options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n        // Build user-agent string.\n        this.userAgent = [\n            options['grpc.primary_user_agent'],\n            `grpc-node-js/${clientVersion}`,\n            options['grpc.secondary_user_agent'],\n        ]\n            .filter(e => e)\n            .join(' '); // remove falsey values first\n        if ('grpc.keepalive_time_ms' in options) {\n            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n        }\n        if ('grpc.keepalive_timeout_ms' in options) {\n            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n        }\n        if ('grpc.keepalive_permit_without_calls' in options) {\n            this.keepaliveWithoutCalls =\n                options['grpc.keepalive_permit_without_calls'] === 1;\n        }\n        else {\n            this.keepaliveWithoutCalls = false;\n        }\n        session.once('close', () => {\n            this.trace('session closed');\n            this.stopKeepalivePings();\n            this.handleDisconnect();\n        });\n        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n            let tooManyPings = false;\n            /* See the last paragraph of\n             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n                opaqueData &&\n                opaqueData.equals(tooManyPingsData)) {\n                tooManyPings = true;\n            }\n            this.trace('connection closed by GOAWAY with code ' + errorCode + ' and data ' + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\n            this.reportDisconnectToOwner(tooManyPings);\n        });\n        session.once('error', error => {\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */\n            this.trace('connection closed with error ' + error.message);\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on('remoteSettings', (settings) => {\n                this.trace('new settings received' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n            session.on('localSettings', (settings) => {\n                this.trace('local settings acknowledged by remote' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n        }\n        /* Start the keepalive timer last, because this can trigger trace logs,\n         * which should only happen after everything else is set up. */\n        if (this.keepaliveWithoutCalls) {\n            this.maybeStartKeepalivePingTimer();\n        }\n    }\n    getChannelzInfo() {\n        var _a, _b, _c;\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)\n            : null;\n        const localAddress = sessionSocket.localAddress\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)\n            : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n                remoteCertificate: peerCertificate && 'raw' in peerCertificate\n                    ? peerCertificate.raw\n                    : null,\n            };\n        }\n        else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null,\n        };\n        return socketInfo;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    /**\n     * Indicate to the owner of this object that this transport should no longer\n     * be used. That happens if the connection drops, or if the server sends a\n     * GOAWAY.\n     * @param tooManyPings If true, this was triggered by a GOAWAY with data\n     * indicating that the session was closed becaues the client sent too many\n     * pings.\n     * @returns\n     */\n    reportDisconnectToOwner(tooManyPings) {\n        if (this.disconnectHandled) {\n            return;\n        }\n        this.disconnectHandled = true;\n        this.disconnectListeners.forEach(listener => listener(tooManyPings));\n    }\n    /**\n     * Handle connection drops, but not GOAWAYs.\n     */\n    handleDisconnect() {\n        this.reportDisconnectToOwner(false);\n        /* Give calls an event loop cycle to finish naturally before reporting the\n         * disconnnection to them. */\n        setImmediate(() => {\n            for (const call of this.activeCalls) {\n                call.onDisconnect();\n            }\n        });\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.push(listener);\n    }\n    clearKeepaliveTimer() {\n        if (!this.keepaliveTimerId) {\n            return;\n        }\n        clearTimeout(this.keepaliveTimerId);\n        this.keepaliveTimerId = null;\n    }\n    clearKeepaliveTimeout() {\n        if (!this.keepaliveTimeoutId) {\n            return;\n        }\n        clearTimeout(this.keepaliveTimeoutId);\n        this.keepaliveTimeoutId = null;\n    }\n    canSendPing() {\n        return (this.keepaliveTimeMs > 0 &&\n            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));\n    }\n    maybeSendPing() {\n        var _a, _b;\n        this.clearKeepaliveTimer();\n        if (!this.canSendPing()) {\n            this.pendingSendKeepalivePing = true;\n            return;\n        }\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n        if (!this.keepaliveTimeoutId) {\n            this.keepaliveTimeoutId = setTimeout(() => {\n                this.keepaliveTrace('Ping timeout passed without response');\n                this.handleDisconnect();\n            }, this.keepaliveTimeoutMs);\n            (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n        try {\n            this.session.ping((err, duration, payload) => {\n                if (err) {\n                    this.keepaliveTrace('Ping failed with error ' + err.message);\n                    this.handleDisconnect();\n                }\n                this.keepaliveTrace('Received ping response');\n                this.clearKeepaliveTimeout();\n                this.maybeStartKeepalivePingTimer();\n            });\n        }\n        catch (e) {\n            /* If we fail to send a ping, the connection is no longer functional, so\n             * we should discard it. */\n            this.handleDisconnect();\n        }\n    }\n    /**\n     * Starts the keepalive ping timer if appropriate. If the timer already ran\n     * out while there were no active requests, instead send a ping immediately.\n     * If the ping timer is already running or a ping is currently in flight,\n     * instead do nothing and wait for them to resolve.\n     */\n    maybeStartKeepalivePingTimer() {\n        var _a, _b;\n        if (!this.canSendPing()) {\n            return;\n        }\n        if (this.pendingSendKeepalivePing) {\n            this.pendingSendKeepalivePing = false;\n            this.maybeSendPing();\n        }\n        else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {\n            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n            this.keepaliveTimerId = (_b = (_a = setTimeout(() => {\n                this.maybeSendPing();\n            }, this.keepaliveTimeMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n        /* Otherwise, there is already either a keepalive timer or a ping pending,\n         * wait for those to resolve. */\n    }\n    stopKeepalivePings() {\n        if (this.keepaliveTimerId) {\n            clearTimeout(this.keepaliveTimerId);\n            this.keepaliveTimerId = null;\n        }\n        this.clearKeepaliveTimeout();\n    }\n    removeActiveCall(call) {\n        this.activeCalls.delete(call);\n        if (this.activeCalls.size === 0) {\n            this.session.unref();\n        }\n    }\n    addActiveCall(call) {\n        this.activeCalls.add(call);\n        if (this.activeCalls.size === 1) {\n            this.session.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.maybeStartKeepalivePingTimer();\n            }\n        }\n    }\n    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = host;\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n        headers[HTTP2_HEADER_METHOD] = 'POST';\n        headers[HTTP2_HEADER_PATH] = method;\n        headers[HTTP2_HEADER_TE] = 'trailers';\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */\n        try {\n            http2Stream = this.session.request(headers);\n        }\n        catch (e) {\n            this.handleDisconnect();\n            throw e;\n        }\n        this.flowControlTrace('local window size: ' +\n            this.session.state.localWindowSize +\n            ' remote window size: ' +\n            this.session.state.remoteWindowSize);\n        this.internalsTrace('session.closed=' +\n            this.session.closed +\n            ' session.destroyed=' +\n            this.session.destroyed +\n            ' session.socket.destroyed=' +\n            this.session.socket.destroyed);\n        let eventTracker;\n        // eslint-disable-next-line prefer-const\n        let call;\n        if (this.channelzEnabled) {\n            this.streamTracker.addCallStarted();\n            eventTracker = {\n                addMessageSent: () => {\n                    var _a;\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: () => {\n                    var _a;\n                    this.messagesReceived += 1;\n                    this.lastMessageReceivedTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: status => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: success => {\n                    var _a;\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    }\n                    else {\n                        this.streamTracker.addCallFailed();\n                    }\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                },\n            };\n        }\n        else {\n            eventTracker = {\n                addMessageSent: () => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: () => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: status => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: success => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                },\n            };\n        }\n        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n        this.addActiveCall(call);\n        return call;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getPeerName() {\n        return this.subchannelAddressString;\n    }\n    getOptions() {\n        return this.options;\n    }\n    shutdown() {\n        this.session.close();\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n}\nclass Http2SubchannelConnector {\n    constructor(channelTarget) {\n        this.channelTarget = channelTarget;\n        this.session = null;\n        this.isShutdown = false;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);\n    }\n    createSession(address, credentials, options, proxyConnectionResult) {\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        return new Promise((resolve, reject) => {\n            var _a, _b, _c;\n            let remoteName;\n            if (proxyConnectionResult.realTarget) {\n                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n                this.trace('creating HTTP/2 session through proxy to ' +\n                    (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\n            }\n            else {\n                remoteName = null;\n                this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n            }\n            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n            let connectionOptions = credentials._getConnectionOptions() || {};\n            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n            if ('grpc-node.max_session_memory' in options) {\n                connectionOptions.maxSessionMemory =\n                    options['grpc-node.max_session_memory'];\n            }\n            else {\n                /* By default, set a very large max session memory limit, to effectively\n                 * disable enforcement of the limit. Some testing indicates that Node's\n                 * behavior degrades badly when this limit is reached, so we solve that\n                 * by disabling the check entirely. */\n                connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n            }\n            let addressScheme = 'http://';\n            if ('secureContext' in connectionOptions) {\n                addressScheme = 'https://';\n                // If provided, the value of grpc.ssl_target_name_override should be used\n                // to override the target hostname when checking server identity.\n                // This option is used for testing only.\n                if (options['grpc.ssl_target_name_override']) {\n                    const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n                    connectionOptions.checkServerIdentity = (host, cert) => {\n                        return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n                    };\n                    connectionOptions.servername = sslTargetNameOverride;\n                }\n                else {\n                    const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n                    // We want to always set servername to support SNI\n                    connectionOptions.servername = authorityHostname;\n                }\n                if (proxyConnectionResult.socket) {\n                    /* This is part of the workaround for\n                     * https://github.com/nodejs/node/issues/32922. Without that bug,\n                     * proxyConnectionResult.socket would always be a plaintext socket and\n                     * this would say\n                     * connectionOptions.socket = proxyConnectionResult.socket; */\n                    connectionOptions.createConnection = (authority, option) => {\n                        return proxyConnectionResult.socket;\n                    };\n                }\n            }\n            else {\n                /* In all but the most recent versions of Node, http2.connect does not use\n                 * the options when establishing plaintext connections, so we need to\n                 * establish that connection explicitly. */\n                connectionOptions.createConnection = (authority, option) => {\n                    if (proxyConnectionResult.socket) {\n                        return proxyConnectionResult.socket;\n                    }\n                    else {\n                        /* net.NetConnectOpts is declared in a way that is more restrictive\n                         * than what net.connect will actually accept, so we use the type\n                         * assertion to work around that. */\n                        return net.connect(address);\n                    }\n                };\n            }\n            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), { enableTrace: options['grpc-node.tls_enable_trace'] === 1 });\n            /* http2.connect uses the options here:\n             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n             * The spread operator overides earlier values with later ones, so any port\n             * or host values in the options will be used rather than any values extracted\n             * from the first argument. In addition, the path overrides the host and port,\n             * as documented for plaintext connections here:\n             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n             * and for TLS connections here:\n             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n             * earlier versions of Node, http2.connect passes these options to\n             * tls.connect but not net.connect, so in the insecure case we still need\n             * to set the createConnection option above to create the connection\n             * explicitly. We cannot do that in the TLS case because http2.connect\n             * passes necessary additional options to tls.connect.\n             * The first argument just needs to be parseable as a URL and the scheme\n             * determines whether the connection will be established over TLS or not.\n             */\n            const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n            this.session = session;\n            let errorMessage = 'Failed to connect';\n            session.unref();\n            session.once('connect', () => {\n                session.removeAllListeners();\n                resolve(new Http2Transport(session, address, options, remoteName));\n                this.session = null;\n            });\n            session.once('close', () => {\n                this.session = null;\n                // Leave time for error event to happen before rejecting\n                setImmediate(() => {\n                    reject(`${errorMessage} (${new Date().toISOString()})`);\n                });\n            });\n            session.once('error', error => {\n                errorMessage = error.message;\n                this.trace('connection failed with error ' + errorMessage);\n            });\n        });\n    }\n    connect(address, credentials, options) {\n        var _a, _b;\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        /* Pass connection options through to the proxy so that it's able to\n         * upgrade it's connection to support tls if needed.\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n        const connectionOptions = credentials._getConnectionOptions() || {};\n        if ('secureContext' in connectionOptions) {\n            connectionOptions.ALPNProtocols = ['h2'];\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (options['grpc.ssl_target_name_override']) {\n                const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n                connectionOptions.checkServerIdentity = (host, cert) => {\n                    return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            }\n            else {\n                if ('grpc.http_connect_target' in options) {\n                    /* This is more or less how servername will be set in createSession\n                     * if a connection is successfully established through the proxy.\n                     * If the proxy is not used, these connectionOptions are discarded\n                     * anyway */\n                    const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n                        path: 'localhost',\n                    });\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n                }\n            }\n            if (options['grpc-node.tls_enable_trace']) {\n                connectionOptions.enableTrace = true;\n            }\n        }\n        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));\n    }\n    shutdown() {\n        var _a;\n        this.isShutdown = true;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n        this.session = null;\n    }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector;\n//# sourceMappingURL=transport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90cmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0M7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyx5RkFBYTtBQUN6QyxxQkFBcUIsbUJBQU8sQ0FBQywyRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxxRkFBVztBQUNuQyxtQkFBbUIsbUJBQU8sQ0FBQyx1RkFBWTtBQUN2Qyw2QkFBNkIsbUJBQU8sQ0FBQywyR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsMkZBQWM7QUFDM0MsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLDBCQUEwQixtQkFBTyxDQUFDLHFHQUFtQjtBQUNyRCxzQkFBc0IsbUJBQU8sQ0FBQyw2RkFBZTtBQUM3QztBQUNBO0FBQ0Esc0JBQXNCLHFIQUFxQztBQUMzRCxRQUFRLHVJQUF1STtBQUMvSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsa0NBQWtDLDBEQUEwRDtBQUN4SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjLEdBQUcseUJBQXlCO0FBQ3hFLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90cmFuc3BvcnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjMgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGh0dHBfcHJveHlfMSA9IHJlcXVpcmUoXCIuL2h0dHBfcHJveHlcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBzdWJjaGFubmVsX2NhbGxfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtY2FsbFwiKTtcbmNvbnN0IGNhbGxfbnVtYmVyXzEgPSByZXF1aXJlKFwiLi9jYWxsLW51bWJlclwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3RyYW5zcG9ydCc7XG5jb25zdCBGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUgPSAndHJhbnNwb3J0X2Zsb3djdHJsJztcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfQVVUSE9SSVRZLCBIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFLCBIVFRQMl9IRUFERVJfTUVUSE9ELCBIVFRQMl9IRUFERVJfUEFUSCwgSFRUUDJfSEVBREVSX1RFLCBIVFRQMl9IRUFERVJfVVNFUl9BR0VOVCwgfSA9IGh0dHAyLmNvbnN0YW50cztcbmNvbnN0IEtFRVBBTElWRV9USU1FT1VUX01TID0gMjAwMDA7XG5jb25zdCB0b29NYW55UGluZ3NEYXRhID0gQnVmZmVyLmZyb20oJ3Rvb19tYW55X3BpbmdzJywgJ2FzY2lpJyk7XG5jbGFzcyBIdHRwMlRyYW5zcG9ydCB7XG4gICAgY29uc3RydWN0b3Ioc2Vzc2lvbiwgc3ViY2hhbm5lbEFkZHJlc3MsIG9wdGlvbnMsIFxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIHJlbW90ZSBzZXJ2ZXIsIGlmIGl0IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgc3ViY2hhbm5lbFxuICAgICAqIGFkZHJlc3MsIGkuZS4gaWYgY29ubmVjdGluZyB0aHJvdWdoIGFuIEhUVFAgQ09OTkVDVCBwcm94eS5cbiAgICAgKi9cbiAgICByZW1vdGVOYW1lKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVtb3RlTmFtZSA9IHJlbW90ZU5hbWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gYmV0d2VlbiBzZW5kaW5nIHBpbmdzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgZm9yIGFuIGFja25vd2xlZGdlbWVudCBhZnRlciBzZW5kaW5nIGEgcGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgPSBLRUVQQUxJVkVfVElNRU9VVF9NUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWVyIHJlZmVyZW5jZSBmb3IgdGltZW91dCB0aGF0IGluZGljYXRlcyB3aGVuIHRvIHNlbmQgdGhlIG5leHQgcGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBrZWVwYWxpdmUgdGltZXIgcmFuIG91dCB3aGlsZSB0aGVyZSB3ZXJlIG5vIGFjdGl2ZVxuICAgICAgICAgKiBjYWxscywgYW5kIGEgcGluZyBzaG91bGQgYmUgc2VudCB0aGUgbmV4dCB0aW1lIGEgY2FsbCBzdGFydHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGltZXIgcmVmZXJlbmNlIHRyYWNraW5nIHdoZW4gdGhlIG1vc3QgcmVjZW50IHBpbmcgd2lsbCBiZSBjb25zaWRlcmVkIGxvc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dElkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGtlZXBhbGl2ZSBwaW5ncyBzaG91bGQgYmUgc2VudCB3aXRob3V0IGFueSBhY3RpdmUgY2FsbHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1NlbnQgPSAwO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIC8qIFBvcHVsYXRlIHN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nIGFuZCBjaGFubmVselJlZiBiZWZvcmUgZG9pbmcgYW55dGhpbmdcbiAgICAgICAgICogZWxzZSwgYmVjYXVzZSB0aGV5IGFyZSB1c2VkIGluIHRoZSB0cmFjZSBtZXRob2RzLiAqL1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nID0gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQpKHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgLy8gQnVpbGQgdXNlci1hZ2VudCBzdHJpbmcuXG4gICAgICAgIHRoaXMudXNlckFnZW50ID0gW1xuICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5wcmltYXJ5X3VzZXJfYWdlbnQnXSxcbiAgICAgICAgICAgIGBncnBjLW5vZGUtanMvJHtjbGllbnRWZXJzaW9ufWAsXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnNlY29uZGFyeV91c2VyX2FnZW50J10sXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIoZSA9PiBlKVxuICAgICAgICAgICAgLmpvaW4oJyAnKTsgLy8gcmVtb3ZlIGZhbHNleSB2YWx1ZXMgZmlyc3RcbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV90aW1lX21zJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVNcyA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dE1zID0gb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfdGltZW91dF9tcyddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzID1cbiAgICAgICAgICAgICAgICBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscyddID09PSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnc2Vzc2lvbiBjbG9zZWQnKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcEtlZXBhbGl2ZVBpbmdzKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlc3Npb24ub25jZSgnZ29hd2F5JywgKGVycm9yQ29kZSwgbGFzdFN0cmVhbUlELCBvcGFxdWVEYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgdG9vTWFueVBpbmdzID0gZmFsc2U7XG4gICAgICAgICAgICAvKiBTZWUgdGhlIGxhc3QgcGFyYWdyYXBoIG9mXG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BOC1jbGllbnQtc2lkZS1rZWVwYWxpdmUubWQjYmFzaWMta2VlcGFsaXZlICovXG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTSAmJlxuICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEgJiZcbiAgICAgICAgICAgICAgICBvcGFxdWVEYXRhLmVxdWFscyh0b29NYW55UGluZ3NEYXRhKSkge1xuICAgICAgICAgICAgICAgIHRvb01hbnlQaW5ncyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGNsb3NlZCBieSBHT0FXQVkgd2l0aCBjb2RlICcgKyBlcnJvckNvZGUgKyAnIGFuZCBkYXRhICcgKyAob3BhcXVlRGF0YSA9PT0gbnVsbCB8fCBvcGFxdWVEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGFxdWVEYXRhLnRvU3RyaW5nKCkpKTtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RGlzY29ubmVjdFRvT3duZXIodG9vTWFueVBpbmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNlc3Npb24ub25jZSgnZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICAvKiBEbyBub3RoaW5nIGhlcmUuIEFueSBlcnJvciBzaG91bGQgYWxzbyB0cmlnZ2VyIGEgY2xvc2UgZXZlbnQsIHdoaWNoIGlzXG4gICAgICAgICAgICAgKiB3aGVyZSB3ZSB3YW50IHRvIGhhbmRsZSB0aGF0LiAgKi9cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkIHdpdGggZXJyb3IgJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvZ2dpbmcuaXNUcmFjZXJFbmFibGVkKFRSQUNFUl9OQU1FKSkge1xuICAgICAgICAgICAgc2Vzc2lvbi5vbigncmVtb3RlU2V0dGluZ3MnLCAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCduZXcgc2V0dGluZ3MgcmVjZWl2ZWQnICtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Vzc2lvbiAhPT0gc2Vzc2lvbiA/ICcgb24gdGhlIG9sZCBjb25uZWN0aW9uJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKCdsb2NhbFNldHRpbmdzJywgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnbG9jYWwgc2V0dGluZ3MgYWNrbm93bGVkZ2VkIGJ5IHJlbW90ZScgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXNzaW9uICE9PSBzZXNzaW9uID8gJyBvbiB0aGUgb2xkIGNvbm5lY3Rpb24nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKiBTdGFydCB0aGUga2VlcGFsaXZlIHRpbWVyIGxhc3QsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlciB0cmFjZSBsb2dzLFxuICAgICAgICAgKiB3aGljaCBzaG91bGQgb25seSBoYXBwZW4gYWZ0ZXIgZXZlcnl0aGluZyBlbHNlIGlzIHNldCB1cC4gKi9cbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzKSB7XG4gICAgICAgICAgICB0aGlzLm1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBzZXNzaW9uU29ja2V0ID0gdGhpcy5zZXNzaW9uLnNvY2tldDtcbiAgICAgICAgY29uc3QgcmVtb3RlQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzc1xuICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzLCBzZXNzaW9uU29ja2V0LnJlbW90ZVBvcnQpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxvY2FsQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzXG4gICAgICAgICAgICA/ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKShzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGxldCB0bHNJbmZvO1xuICAgICAgICBpZiAodGhpcy5zZXNzaW9uLmVuY3J5cHRlZCkge1xuICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gc2Vzc2lvblNvY2tldDtcbiAgICAgICAgICAgIGNvbnN0IGNpcGhlckluZm8gPSB0bHNTb2NrZXQuZ2V0Q2lwaGVyKCk7XG4gICAgICAgICAgICBjb25zdCBjZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgY29uc3QgcGVlckNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldFBlZXJDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgdGxzSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZTogKF9hID0gY2lwaGVySW5mby5zdGFuZGFyZE5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVPdGhlck5hbWU6IGNpcGhlckluZm8uc3RhbmRhcmROYW1lID8gbnVsbCA6IGNpcGhlckluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICBsb2NhbENlcnRpZmljYXRlOiBjZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBjZXJ0aWZpY2F0ZSA/IGNlcnRpZmljYXRlLnJhdyA6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVtb3RlQ2VydGlmaWNhdGU6IHBlZXJDZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBwZWVyQ2VydGlmaWNhdGVcbiAgICAgICAgICAgICAgICAgICAgPyBwZWVyQ2VydGlmaWNhdGUucmF3XG4gICAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0bHNJbmZvID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRJbmZvID0ge1xuICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgIGxvY2FsQWRkcmVzczogbG9jYWxBZGRyZXNzLFxuICAgICAgICAgICAgc2VjdXJpdHk6IHRsc0luZm8sXG4gICAgICAgICAgICByZW1vdGVOYW1lOiB0aGlzLnJlbW90ZU5hbWUsXG4gICAgICAgICAgICBzdHJlYW1zU3RhcnRlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIHN0cmVhbXNTdWNjZWVkZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogdGhpcy5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiB0aGlzLm1lc3NhZ2VzUmVjZWl2ZWQsXG4gICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogdGhpcy5rZWVwYWxpdmVzU2VudCxcbiAgICAgICAgICAgIGxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IHRoaXMuc3RyZWFtVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAsXG4gICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAsXG4gICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAsXG4gICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiAoX2IgPSB0aGlzLnNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgcmVtb3RlRmxvd0NvbnRyb2xXaW5kb3c6IChfYyA9IHRoaXMuc2Vzc2lvbi5zdGF0ZS5yZW1vdGVXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc29ja2V0SW5mbztcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIGtlZXBhbGl2ZVRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdrZWVwYWxpdmUnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBmbG93Q29udHJvbFRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIEZMT1dfQ09OVFJPTF9UUkFDRVJfTkFNRSwgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgaW50ZXJuYWxzVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3RyYW5zcG9ydF9pbnRlcm5hbHMnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZSB0byB0aGUgb3duZXIgb2YgdGhpcyBvYmplY3QgdGhhdCB0aGlzIHRyYW5zcG9ydCBzaG91bGQgbm8gbG9uZ2VyXG4gICAgICogYmUgdXNlZC4gVGhhdCBoYXBwZW5zIGlmIHRoZSBjb25uZWN0aW9uIGRyb3BzLCBvciBpZiB0aGUgc2VydmVyIHNlbmRzIGFcbiAgICAgKiBHT0FXQVkuXG4gICAgICogQHBhcmFtIHRvb01hbnlQaW5ncyBJZiB0cnVlLCB0aGlzIHdhcyB0cmlnZ2VyZWQgYnkgYSBHT0FXQVkgd2l0aCBkYXRhXG4gICAgICogaW5kaWNhdGluZyB0aGF0IHRoZSBzZXNzaW9uIHdhcyBjbG9zZWQgYmVjYXVlcyB0aGUgY2xpZW50IHNlbnQgdG9vIG1hbnlcbiAgICAgKiBwaW5ncy5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlcG9ydERpc2Nvbm5lY3RUb093bmVyKHRvb01hbnlQaW5ncykge1xuICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0SGFuZGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdEhhbmRsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcih0b29NYW55UGluZ3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNvbm5lY3Rpb24gZHJvcHMsIGJ1dCBub3QgR09BV0FZcy5cbiAgICAgKi9cbiAgICBoYW5kbGVEaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnJlcG9ydERpc2Nvbm5lY3RUb093bmVyKGZhbHNlKTtcbiAgICAgICAgLyogR2l2ZSBjYWxscyBhbiBldmVudCBsb29wIGN5Y2xlIHRvIGZpbmlzaCBuYXR1cmFsbHkgYmVmb3JlIHJlcG9ydGluZyB0aGVcbiAgICAgICAgICogZGlzY29ubm5lY3Rpb24gdG8gdGhlbS4gKi9cbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLmFjdGl2ZUNhbGxzKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5vbkRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZERpc2Nvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIGNsZWFyS2VlcGFsaXZlVGltZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVUaW1lcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZXJJZCk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXJJZCA9IG51bGw7XG4gICAgfVxuICAgIGNsZWFyS2VlcGFsaXZlVGltZW91dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgY2FuU2VuZFBpbmcoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5rZWVwYWxpdmVUaW1lTXMgPiAwICYmXG4gICAgICAgICAgICAodGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgfHwgdGhpcy5hY3RpdmVDYWxscy5zaXplID4gMCkpO1xuICAgIH1cbiAgICBtYXliZVNlbmRQaW5nKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmNsZWFyS2VlcGFsaXZlVGltZXIoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhblNlbmRQaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlc1NlbnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdTZW5kaW5nIHBpbmcgd2l0aCB0aW1lb3V0ICcgKyB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyArICdtcycpO1xuICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlVGltZW91dElkKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1BpbmcgdGltZW91dCBwYXNzZWQgd2l0aG91dCByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMpO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5waW5nKChlcnIsIGR1cmF0aW9uLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIGZhaWxlZCB3aXRoIGVycm9yICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdSZWNlaXZlZCBwaW5nIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBJZiB3ZSBmYWlsIHRvIHNlbmQgYSBwaW5nLCB0aGUgY29ubmVjdGlvbiBpcyBubyBsb25nZXIgZnVuY3Rpb25hbCwgc29cbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBkaXNjYXJkIGl0LiAqL1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHRoZSBrZWVwYWxpdmUgcGluZyB0aW1lciBpZiBhcHByb3ByaWF0ZS4gSWYgdGhlIHRpbWVyIGFscmVhZHkgcmFuXG4gICAgICogb3V0IHdoaWxlIHRoZXJlIHdlcmUgbm8gYWN0aXZlIHJlcXVlc3RzLCBpbnN0ZWFkIHNlbmQgYSBwaW5nIGltbWVkaWF0ZWx5LlxuICAgICAqIElmIHRoZSBwaW5nIHRpbWVyIGlzIGFscmVhZHkgcnVubmluZyBvciBhIHBpbmcgaXMgY3VycmVudGx5IGluIGZsaWdodCxcbiAgICAgKiBpbnN0ZWFkIGRvIG5vdGhpbmcgYW5kIHdhaXQgZm9yIHRoZW0gdG8gcmVzb2x2ZS5cbiAgICAgKi9cbiAgICBtYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMuY2FuU2VuZFBpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZykge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTZW5kUGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmtlZXBhbGl2ZVRpbWVySWQgJiYgIXRoaXMua2VlcGFsaXZlVGltZW91dElkKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdTdGFydGluZyBrZWVwYWxpdmUgdGltZXIgZm9yICcgKyB0aGlzLmtlZXBhbGl2ZVRpbWVNcyArICdtcycpO1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lcklkID0gKF9iID0gKF9hID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVNlbmRQaW5nKCk7XG4gICAgICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVNcykpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogT3RoZXJ3aXNlLCB0aGVyZSBpcyBhbHJlYWR5IGVpdGhlciBhIGtlZXBhbGl2ZSB0aW1lciBvciBhIHBpbmcgcGVuZGluZyxcbiAgICAgICAgICogd2FpdCBmb3IgdGhvc2UgdG8gcmVzb2x2ZS4gKi9cbiAgICB9XG4gICAgc3RvcEtlZXBhbGl2ZVBpbmdzKCkge1xuICAgICAgICBpZiAodGhpcy5rZWVwYWxpdmVUaW1lcklkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVUaW1lcklkKTtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXJJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVvdXQoKTtcbiAgICB9XG4gICAgcmVtb3ZlQWN0aXZlQ2FsbChjYWxsKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbHMuZGVsZXRlKGNhbGwpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVDYWxscy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24udW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRBY3RpdmVDYWxsKGNhbGwpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVDYWxscy5hZGQoY2FsbCk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUNhbGxzLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5yZWYoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlU3RhcnRLZWVwYWxpdmVQaW5nVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVDYWxsKG1ldGFkYXRhLCBob3N0LCBtZXRob2QsIGxpc3RlbmVyLCBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcikge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQVVUSE9SSVRZXSA9IGhvc3Q7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1VTRVJfQUdFTlRdID0gdGhpcy51c2VyQWdlbnQ7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRV0gPSAnYXBwbGljYXRpb24vZ3JwYyc7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX01FVEhPRF0gPSAnUE9TVCc7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1BBVEhdID0gbWV0aG9kO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9URV0gPSAndHJhaWxlcnMnO1xuICAgICAgICBsZXQgaHR0cDJTdHJlYW07XG4gICAgICAgIC8qIEluIHRoZW9yeSwgaWYgYW4gZXJyb3IgaXMgdGhyb3duIGJ5IHNlc3Npb24ucmVxdWVzdCBiZWNhdXNlIHNlc3Npb24gaGFzXG4gICAgICAgICAqIGJlY29tZSB1bnVzYWJsZSAoZS5nLiBiZWNhdXNlIGl0IGhhcyByZWNlaXZlZCBhIGdvYXdheSksIHRoaXMgc3ViY2hhbm5lbFxuICAgICAgICAgKiBzaG91bGQgc29vbiBzZWUgdGhlIGNvcnJlc3BvbmRpbmcgY2xvc2Ugb3IgZ29hd2F5IGV2ZW50IGFueXdheSBhbmQgbGVhdmVcbiAgICAgICAgICogUkVBRFkuIEJ1dCB3ZSBoYXZlIHNlZW4gcmVwb3J0cyB0aGF0IHRoaXMgZG9lcyBub3QgaGFwcGVuXG4gICAgICAgICAqIChodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlYXBpcy9ub2RlanMtZmlyZXN0b3JlL2lzc3Vlcy8xMDIzI2lzc3VlY29tbWVudC02NTMyMDQwOTYpXG4gICAgICAgICAqIHNvIGZvciBkZWZlbnNlIGluIGRlcHRoLCB3ZSBqdXN0IGRpc2NhcmQgdGhlIHNlc3Npb24gd2hlbiB3ZSBzZWUgYW5cbiAgICAgICAgICogZXJyb3IgaGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBodHRwMlN0cmVhbSA9IHRoaXMuc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbG93Q29udHJvbFRyYWNlKCdsb2NhbCB3aW5kb3cgc2l6ZTogJyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplICtcbiAgICAgICAgICAgICcgcmVtb3RlIHdpbmRvdyBzaXplOiAnICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdGF0ZS5yZW1vdGVXaW5kb3dTaXplKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbHNUcmFjZSgnc2Vzc2lvbi5jbG9zZWQ9JyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uY2xvc2VkICtcbiAgICAgICAgICAgICcgc2Vzc2lvbi5kZXN0cm95ZWQ9JyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uZGVzdHJveWVkICtcbiAgICAgICAgICAgICcgc2Vzc2lvbi5zb2NrZXQuZGVzdHJveWVkPScgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnNvY2tldC5kZXN0cm95ZWQpO1xuICAgICAgICBsZXQgZXZlbnRUcmFja2VyO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWNvbnN0XG4gICAgICAgIGxldCBjYWxsO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgZXZlbnRUcmFja2VyID0ge1xuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VTZW50OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1NlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlU2VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1JlY2VpdmVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VSZWNlaXZlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25DYWxsRW5kOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uQ2FsbEVuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQWN0aXZlQ2FsbChjYWxsKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uU3RyZWFtRW5kOiBzdWNjZXNzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW1UcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIub25TdHJlYW1FbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLCBzdWNjZXNzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50VHJhY2tlciA9IHtcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlU2VudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VTZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlUmVjZWl2ZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2FsbEVuZDogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vbkNhbGxFbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZUNhbGwoY2FsbCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblN0cmVhbUVuZDogc3VjY2VzcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIub25TdHJlYW1FbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLCBzdWNjZXNzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsID0gbmV3IHN1YmNoYW5uZWxfY2FsbF8xLkh0dHAyU3ViY2hhbm5lbENhbGwoaHR0cDJTdHJlYW0sIGV2ZW50VHJhY2tlciwgbGlzdGVuZXIsIHRoaXMsICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpKTtcbiAgICAgICAgdGhpcy5hZGRBY3RpdmVDYWxsKGNhbGwpO1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBnZXRQZWVyTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmc7XG4gICAgfVxuICAgIGdldE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgKDAsIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKSh0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICB9XG59XG5jbGFzcyBIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsVGFyZ2V0ID0gY2hhbm5lbFRhcmdldDtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc1NodXRkb3duID0gZmFsc2U7XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLmNoYW5uZWxUYXJnZXQpICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGNyZWF0ZVNlc3Npb24oYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMsIHByb3h5Q29ubmVjdGlvblJlc3VsdCkge1xuICAgICAgICBpZiAodGhpcy5pc1NodXRkb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBsZXQgcmVtb3RlTmFtZTtcbiAgICAgICAgICAgIGlmIChwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJlbW90ZU5hbWUgPSAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShwcm94eUNvbm5lY3Rpb25SZXN1bHQucmVhbFRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRpbmcgSFRUUC8yIHNlc3Npb24gdGhyb3VnaCBwcm94eSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbW90ZU5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0aW5nIEhUVFAvMiBzZXNzaW9uIHRvICcgKyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoYWRkcmVzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0QXV0aG9yaXR5ID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkoKF9hID0gcHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY2hhbm5lbFRhcmdldCk7XG4gICAgICAgICAgICBsZXQgY29ubmVjdGlvbk9wdGlvbnMgPSBjcmVkZW50aWFscy5fZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB8fCB7fTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLm1heFNlbmRIZWFkZXJCbG9ja0xlbmd0aCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgaWYgKCdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIEJ5IGRlZmF1bHQsIHNldCBhIHZlcnkgbGFyZ2UgbWF4IHNlc3Npb24gbWVtb3J5IGxpbWl0LCB0byBlZmZlY3RpdmVseVxuICAgICAgICAgICAgICAgICAqIGRpc2FibGUgZW5mb3JjZW1lbnQgb2YgdGhlIGxpbWl0LiBTb21lIHRlc3RpbmcgaW5kaWNhdGVzIHRoYXQgTm9kZSdzXG4gICAgICAgICAgICAgICAgICogYmVoYXZpb3IgZGVncmFkZXMgYmFkbHkgd2hlbiB0aGlzIGxpbWl0IGlzIHJlYWNoZWQsIHNvIHdlIHNvbHZlIHRoYXRcbiAgICAgICAgICAgICAgICAgKiBieSBkaXNhYmxpbmcgdGhlIGNoZWNrIGVudGlyZWx5LiAqL1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBhZGRyZXNzU2NoZW1lID0gJ2h0dHA6Ly8nO1xuICAgICAgICAgICAgaWYgKCdzZWN1cmVDb250ZXh0JyBpbiBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGFkZHJlc3NTY2hlbWUgPSAnaHR0cHM6Ly8nO1xuICAgICAgICAgICAgICAgIC8vIElmIHByb3ZpZGVkLCB0aGUgdmFsdWUgb2YgZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAvLyB0byBvdmVycmlkZSB0aGUgdGFyZ2V0IGhvc3RuYW1lIHdoZW4gY2hlY2tpbmcgc2VydmVyIGlkZW50aXR5LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgb3B0aW9uIGlzIHVzZWQgZm9yIHRlc3Rpbmcgb25seS5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzc2xUYXJnZXROYW1lT3ZlcnJpZGUgPSBvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gKGhvc3QsIGNlcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdGxzXzEuY2hlY2tTZXJ2ZXJJZGVudGl0eSkoc3NsVGFyZ2V0TmFtZU92ZXJyaWRlLCBjZXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IHNzbFRhcmdldE5hbWVPdmVycmlkZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml0eUhvc3RuYW1lID0gKF9jID0gKF9iID0gKDAsIHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KSh0YXJnZXRBdXRob3JpdHkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaG9zdCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogJ2xvY2FsaG9zdCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gYWx3YXlzIHNldCBzZXJ2ZXJuYW1lIHRvIHN1cHBvcnQgU05JXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBhdXRob3JpdHlIb3N0bmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogVGhpcyBpcyBwYXJ0IG9mIHRoZSB3b3JrYXJvdW5kIGZvclxuICAgICAgICAgICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzMyOTIyLiBXaXRob3V0IHRoYXQgYnVnLFxuICAgICAgICAgICAgICAgICAgICAgKiBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0IHdvdWxkIGFsd2F5cyBiZSBhIHBsYWludGV4dCBzb2NrZXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgd291bGQgc2F5XG4gICAgICAgICAgICAgICAgICAgICAqIGNvbm5lY3Rpb25PcHRpb25zLnNvY2tldCA9IHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7ICovXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSAoYXV0aG9yaXR5LCBvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIEluIGFsbCBidXQgdGhlIG1vc3QgcmVjZW50IHZlcnNpb25zIG9mIE5vZGUsIGh0dHAyLmNvbm5lY3QgZG9lcyBub3QgdXNlXG4gICAgICAgICAgICAgICAgICogdGhlIG9wdGlvbnMgd2hlbiBlc3RhYmxpc2hpbmcgcGxhaW50ZXh0IGNvbm5lY3Rpb25zLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICogZXN0YWJsaXNoIHRoYXQgY29ubmVjdGlvbiBleHBsaWNpdGx5LiAqL1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSAoYXV0aG9yaXR5LCBvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogbmV0Lk5ldENvbm5lY3RPcHRzIGlzIGRlY2xhcmVkIGluIGEgd2F5IHRoYXQgaXMgbW9yZSByZXN0cmljdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhhbiB3aGF0IG5ldC5jb25uZWN0IHdpbGwgYWN0dWFsbHkgYWNjZXB0LCBzbyB3ZSB1c2UgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGFzc2VydGlvbiB0byB3b3JrIGFyb3VuZCB0aGF0LiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldC5jb25uZWN0KGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbm5lY3Rpb25PcHRpb25zKSwgYWRkcmVzcyksIHsgZW5hYmxlVHJhY2U6IG9wdGlvbnNbJ2dycGMtbm9kZS50bHNfZW5hYmxlX3RyYWNlJ10gPT09IDEgfSk7XG4gICAgICAgICAgICAvKiBodHRwMi5jb25uZWN0IHVzZXMgdGhlIG9wdGlvbnMgaGVyZTpcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzcwYzMyYTZkMTkwZTJiNWQ3YjlmZjlkNWI2YTQ1OWQxNGU4YjdkNTkvbGliL2ludGVybmFsL2h0dHAyL2NvcmUuanMjTDMwMjgtTDMwMzZcbiAgICAgICAgICAgICAqIFRoZSBzcHJlYWQgb3BlcmF0b3Igb3ZlcmlkZXMgZWFybGllciB2YWx1ZXMgd2l0aCBsYXRlciBvbmVzLCBzbyBhbnkgcG9ydFxuICAgICAgICAgICAgICogb3IgaG9zdCB2YWx1ZXMgaW4gdGhlIG9wdGlvbnMgd2lsbCBiZSB1c2VkIHJhdGhlciB0aGFuIGFueSB2YWx1ZXMgZXh0cmFjdGVkXG4gICAgICAgICAgICAgKiBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudC4gSW4gYWRkaXRpb24sIHRoZSBwYXRoIG92ZXJyaWRlcyB0aGUgaG9zdCBhbmQgcG9ydCxcbiAgICAgICAgICAgICAqIGFzIGRvY3VtZW50ZWQgZm9yIHBsYWludGV4dCBjb25uZWN0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X2Nvbm5lY3Rfb3B0aW9uc19jb25uZWN0bGlzdGVuZXJcbiAgICAgICAgICAgICAqIGFuZCBmb3IgVExTIGNvbm5lY3Rpb25zIGhlcmU6XG4gICAgICAgICAgICAgKiBodHRwczovL25vZGVqcy5vcmcvYXBpL3Rscy5odG1sI3Rsc190bHNfY29ubmVjdF9vcHRpb25zX2NhbGxiYWNrLiBJblxuICAgICAgICAgICAgICogZWFybGllciB2ZXJzaW9ucyBvZiBOb2RlLCBodHRwMi5jb25uZWN0IHBhc3NlcyB0aGVzZSBvcHRpb25zIHRvXG4gICAgICAgICAgICAgKiB0bHMuY29ubmVjdCBidXQgbm90IG5ldC5jb25uZWN0LCBzbyBpbiB0aGUgaW5zZWN1cmUgY2FzZSB3ZSBzdGlsbCBuZWVkXG4gICAgICAgICAgICAgKiB0byBzZXQgdGhlIGNyZWF0ZUNvbm5lY3Rpb24gb3B0aW9uIGFib3ZlIHRvIGNyZWF0ZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICogZXhwbGljaXRseS4gV2UgY2Fubm90IGRvIHRoYXQgaW4gdGhlIFRMUyBjYXNlIGJlY2F1c2UgaHR0cDIuY29ubmVjdFxuICAgICAgICAgICAgICogcGFzc2VzIG5lY2Vzc2FyeSBhZGRpdGlvbmFsIG9wdGlvbnMgdG8gdGxzLmNvbm5lY3QuXG4gICAgICAgICAgICAgKiBUaGUgZmlyc3QgYXJndW1lbnQganVzdCBuZWVkcyB0byBiZSBwYXJzZWFibGUgYXMgYSBVUkwgYW5kIHRoZSBzY2hlbWVcbiAgICAgICAgICAgICAqIGRldGVybWluZXMgd2hldGhlciB0aGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkIG92ZXIgVExTIG9yIG5vdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGh0dHAyLmNvbm5lY3QoYWRkcmVzc1NjaGVtZSArIHRhcmdldEF1dGhvcml0eSwgY29ubmVjdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSAnRmFpbGVkIHRvIGNvbm5lY3QnO1xuICAgICAgICAgICAgc2Vzc2lvbi51bnJlZigpO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbmNlKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlc3Npb24ucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgSHR0cDJUcmFuc3BvcnQoc2Vzc2lvbiwgYWRkcmVzcywgb3B0aW9ucywgcmVtb3RlTmFtZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBMZWF2ZSB0aW1lIGZvciBlcnJvciBldmVudCB0byBoYXBwZW4gYmVmb3JlIHJlamVjdGluZ1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChgJHtlcnJvck1lc3NhZ2V9ICgke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX0pYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnZXJyb3InLCBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGZhaWxlZCB3aXRoIGVycm9yICcgKyBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmlzU2h1dGRvd24pIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFBhc3MgY29ubmVjdGlvbiBvcHRpb25zIHRocm91Z2ggdG8gdGhlIHByb3h5IHNvIHRoYXQgaXQncyBhYmxlIHRvXG4gICAgICAgICAqIHVwZ3JhZGUgaXQncyBjb25uZWN0aW9uIHRvIHN1cHBvcnQgdGxzIGlmIG5lZWRlZC5cbiAgICAgICAgICogVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzI5MjJcbiAgICAgICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMtbm9kZS9wdWxsLzEzNjkgZm9yIG1vcmUgaW5mby4gKi9cbiAgICAgICAgY29uc3QgY29ubmVjdGlvbk9wdGlvbnMgPSBjcmVkZW50aWFscy5fZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB8fCB7fTtcbiAgICAgICAgaWYgKCdzZWN1cmVDb250ZXh0JyBpbiBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuQUxQTlByb3RvY29scyA9IFsnaDInXTtcbiAgICAgICAgICAgIC8vIElmIHByb3ZpZGVkLCB0aGUgdmFsdWUgb2YgZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgIC8vIHRvIG92ZXJyaWRlIHRoZSB0YXJnZXQgaG9zdG5hbWUgd2hlbiBjaGVja2luZyBzZXJ2ZXIgaWRlbnRpdHkuXG4gICAgICAgICAgICAvLyBUaGlzIG9wdGlvbiBpcyB1c2VkIGZvciB0ZXN0aW5nIG9ubHkuXG4gICAgICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNzbFRhcmdldE5hbWVPdmVycmlkZSA9IG9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ107XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9IChob3N0LCBjZXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdGxzXzEuY2hlY2tTZXJ2ZXJJZGVudGl0eSkoc3NsVGFyZ2V0TmFtZU92ZXJyaWRlLCBjZXJ0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBzc2xUYXJnZXROYW1lT3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGlzIGlzIG1vcmUgb3IgbGVzcyBob3cgc2VydmVybmFtZSB3aWxsIGJlIHNldCBpbiBjcmVhdGVTZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAqIGlmIGEgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQgdGhyb3VnaCB0aGUgcHJveHkuXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBwcm94eSBpcyBub3QgdXNlZCwgdGhlc2UgY29ubmVjdGlvbk9wdGlvbnMgYXJlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICAgICAgICAgKiBhbnl3YXkgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9ICgwLCByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkpKChfYSA9ICgwLCB1cmlfcGFyc2VyXzEucGFyc2VVcmkpKG9wdGlvbnNbJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCddKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ2xvY2FsaG9zdCcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSAoX2IgPSBob3N0UG9ydCA9PT0gbnVsbCB8fCBob3N0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdFBvcnQuaG9zdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGFyZ2V0UGF0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy1ub2RlLnRsc19lbmFibGVfdHJhY2UnXSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmVuYWJsZVRyYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGh0dHBfcHJveHlfMS5nZXRQcm94aWVkQ29ubmVjdGlvbikoYWRkcmVzcywgb3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMpLnRoZW4ocmVzdWx0ID0+IHRoaXMuY3JlYXRlU2Vzc2lvbihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucywgcmVzdWx0KSk7XG4gICAgfVxuICAgIHNodXRkb3duKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuaXNTaHV0ZG93biA9IHRydWU7XG4gICAgICAgIChfYSA9IHRoaXMuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMlN1YmNoYW5uZWxDb25uZWN0b3IgPSBIdHRwMlN1YmNoYW5uZWxDb25uZWN0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc3BvcnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/transport.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3],\n    };\n}\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith('[')) {\n        const hostEnd = path.indexOf(']');\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */\n        if (host.indexOf(':') === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === ':') {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString,\n                    };\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host,\n            };\n        }\n    }\n    else {\n        const splitPath = path.split(':');\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */\n        if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1],\n                };\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host: path,\n            };\n        }\n    }\n}\nexports.splitHostPort = splitHostPort;\nfunction uriToString(uri) {\n    let result = '';\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + ':';\n    }\n    if (uri.authority !== undefined) {\n        result += '//' + uri.authority + '/';\n    }\n    result += uri.path;\n    return result;\n}\nexports.uriToString = uriToString;\n//# sourceMappingURL=uri-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy91cmktcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3VyaS1wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXJpVG9TdHJpbmcgPSBleHBvcnRzLnNwbGl0SG9zdFBvcnQgPSBleHBvcnRzLnBhcnNlVXJpID0gdm9pZCAwO1xuLypcbiAqIFRoZSBncm91cHMgY29ycmVzcG9uZCB0byBVUkkgcGFydHMgYXMgZm9sbG93czpcbiAqIDEuIHNjaGVtZVxuICogMi4gYXV0aG9yaXR5XG4gKiAzLiBwYXRoXG4gKi9cbmNvbnN0IFVSSV9SRUdFWCA9IC9eKD86KFtBLVphLXowLTkrLi1dKyk6KT8oPzpcXC9cXC8oW14vXSopXFwvKT8oLispJC87XG5mdW5jdGlvbiBwYXJzZVVyaSh1cmlTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJzZWRVcmkgPSBVUklfUkVHRVguZXhlYyh1cmlTdHJpbmcpO1xuICAgIGlmIChwYXJzZWRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNjaGVtZTogcGFyc2VkVXJpWzFdLFxuICAgICAgICBhdXRob3JpdHk6IHBhcnNlZFVyaVsyXSxcbiAgICAgICAgcGF0aDogcGFyc2VkVXJpWzNdLFxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlVXJpID0gcGFyc2VVcmk7XG5jb25zdCBOVU1CRVJfUkVHRVggPSAvXlxcZCskLztcbmZ1bmN0aW9uIHNwbGl0SG9zdFBvcnQocGF0aCkge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ1snKSkge1xuICAgICAgICBjb25zdCBob3N0RW5kID0gcGF0aC5pbmRleE9mKCddJyk7XG4gICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9zdCA9IHBhdGguc3Vic3RyaW5nKDEsIGhvc3RFbmQpO1xuICAgICAgICAvKiBPbmx5IGFuIElQdjYgYWRkcmVzcyBzaG91bGQgYmUgaW4gYnJhY2tldGVkIG5vdGF0aW9uLCBhbmQgYW4gSVB2NlxuICAgICAgICAgKiBhZGRyZXNzIHNob3VsZCBoYXZlIGF0IGxlYXN0IG9uZSBjb2xvbiAqL1xuICAgICAgICBpZiAoaG9zdC5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPiBob3N0RW5kICsgMSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaG9zdEVuZCArIDFdID09PSAnOicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3J0U3RyaW5nID0gcGF0aC5zdWJzdHJpbmcoaG9zdEVuZCArIDIpO1xuICAgICAgICAgICAgICAgIGlmIChOVU1CRVJfUkVHRVgudGVzdChwb3J0U3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6ICtwb3J0U3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzcGxpdFBhdGggPSBwYXRoLnNwbGl0KCc6Jyk7XG4gICAgICAgIC8qIEV4YWN0bHkgb25lIGNvbG9uIG1lYW5zIHRoYXQgdGhpcyBpcyBob3N0OnBvcnQuIFplcm8gY29sb25zIG1lYW5zIHRoYXRcbiAgICAgICAgICogdGhlcmUgaXMgbm8gcG9ydC4gQW5kIG11bHRpcGxlIGNvbG9ucyBtZWFucyB0aGF0IHRoaXMgaXMgYSBiYXJlIElQdjZcbiAgICAgICAgICogYWRkcmVzcyB3aXRoIG5vIHBvcnQgKi9cbiAgICAgICAgaWYgKHNwbGl0UGF0aC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGlmIChOVU1CRVJfUkVHRVgudGVzdChzcGxpdFBhdGhbMV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogc3BsaXRQYXRoWzBdLFxuICAgICAgICAgICAgICAgICAgICBwb3J0OiArc3BsaXRQYXRoWzFdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaG9zdDogcGF0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnNwbGl0SG9zdFBvcnQgPSBzcGxpdEhvc3RQb3J0O1xuZnVuY3Rpb24gdXJpVG9TdHJpbmcodXJpKSB7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGlmICh1cmkuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ICs9IHVyaS5zY2hlbWUgKyAnOic7XG4gICAgfVxuICAgIGlmICh1cmkuYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVzdWx0ICs9ICcvLycgKyB1cmkuYXV0aG9yaXR5ICsgJy8nO1xuICAgIH1cbiAgICByZXN1bHQgKz0gdXJpLnBhdGg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudXJpVG9TdHJpbmcgPSB1cmlUb1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVyaS1wYXJzZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@grpc/grpc-js","version":"1.9.15","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":"^8.13.0 || >=10.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@types/gulp":"^4.0.6","@types/gulp-mocha":"0.0.32","@types/lodash":"^4.14.186","@types/mocha":"^5.2.6","@types/ncp":"^2.0.1","@types/pify":"^3.0.2","@types/semver":"^7.3.9","@typescript-eslint/eslint-plugin":"^5.59.11","@typescript-eslint/parser":"^5.59.11","@typescript-eslint/typescript-estree":"^5.59.11","clang-format":"^1.0.55","eslint":"^8.42.0","eslint-config-prettier":"^8.8.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","execa":"^2.0.3","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.4","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","prettier":"^2.8.8","rimraf":"^3.0.2","semver":"^7.3.5","ts-node":"^10.9.1","typescript":"^5.1.3"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"eslint src/*.ts test/*.ts","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"npm run lint","fix":"eslint --fix src/*.ts test/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.8","@types/node":">=12.12.47"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(action-browser)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(action-browser)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(action-browser)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(action-browser)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(action-browser)/./node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\n}\nexports.isAnyExtension = isAnyExtension;\nvar IdempotencyLevel;\n(function (IdempotencyLevel) {\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction mapMethodOptions(options) {\n    return (options || []).reduce((obj, item) => {\n        for (const [key, value] of Object.entries(item)) {\n            switch (key) {\n                case 'uninterpreted_option':\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\n                    break;\n                default:\n                    obj[key] = value;\n            }\n        }\n        return obj;\n    }, {\n        deprecated: false,\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\n        uninterpreted_option: [],\n    });\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n        options: mapMethodOptions(method.parsedOptions),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1Q0FBdUMsR0FBRyx1Q0FBdUMsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxZQUFZLEdBQUcsd0JBQXdCLEdBQUcsc0JBQXNCLEdBQUcsWUFBWTtBQUN6TSxrQkFBa0IsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDNUMsaUJBQWlCLG1CQUFPLENBQUMsdUVBQVk7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMscUdBQTJCO0FBQ3RELGVBQWUsbUJBQU8sQ0FBQyxvRkFBUTtBQUMvQixhQUFhLG1CQUFPLENBQUMsK0RBQU07QUFDM0IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Qsd0JBQXdCLEtBQUs7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsVUFBVTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQywyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QgPSBleHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIgPSBleHBvcnRzLmZyb21KU09OID0gZXhwb3J0cy5sb2FkU3luYyA9IGV4cG9ydHMubG9hZCA9IGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCA9IGV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBleHBvcnRzLkxvbmcgPSB2b2lkIDA7XG5jb25zdCBjYW1lbENhc2UgPSByZXF1aXJlKFwibG9kYXNoLmNhbWVsY2FzZVwiKTtcbmNvbnN0IFByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XG5jb25zdCBkZXNjcmlwdG9yID0gcmVxdWlyZShcInByb3RvYnVmanMvZXh0L2Rlc2NyaXB0b3JcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgTG9uZyA9IHJlcXVpcmUoXCJsb25nXCIpO1xuZXhwb3J0cy5Mb25nID0gTG9uZztcbmZ1bmN0aW9uIGlzQW55RXh0ZW5zaW9uKG9iaikge1xuICAgIHJldHVybiAoJ0B0eXBlJyBpbiBvYmopICYmICh0eXBlb2Ygb2JqWydAdHlwZSddID09PSAnc3RyaW5nJyk7XG59XG5leHBvcnRzLmlzQW55RXh0ZW5zaW9uID0gaXNBbnlFeHRlbnNpb247XG52YXIgSWRlbXBvdGVuY3lMZXZlbDtcbihmdW5jdGlvbiAoSWRlbXBvdGVuY3lMZXZlbCkge1xuICAgIElkZW1wb3RlbmN5TGV2ZWxbXCJJREVNUE9URU5DWV9VTktOT1dOXCJdID0gXCJJREVNUE9URU5DWV9VTktOT1dOXCI7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIk5PX1NJREVfRUZGRUNUU1wiXSA9IFwiTk9fU0lERV9FRkZFQ1RTXCI7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIklERU1QT1RFTlRcIl0gPSBcIklERU1QT1RFTlRcIjtcbn0pKElkZW1wb3RlbmN5TGV2ZWwgPSBleHBvcnRzLklkZW1wb3RlbmN5TGV2ZWwgfHwgKGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCA9IHt9KSk7XG5jb25zdCBkZXNjcmlwdG9yT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBkZWZhdWx0czogdHJ1ZSxcbiAgICBvbmVvZnM6IHRydWUsXG4gICAganNvbjogdHJ1ZSxcbn07XG5mdW5jdGlvbiBqb2luTmFtZShiYXNlTmFtZSwgbmFtZSkge1xuICAgIGlmIChiYXNlTmFtZSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYmFzZU5hbWUgKyAnLicgKyBuYW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzSGFuZGxlZFJlZmxlY3Rpb25PYmplY3Qob2JqKSB7XG4gICAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5TZXJ2aWNlIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlR5cGUgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuRW51bSk7XG59XG5mdW5jdGlvbiBpc05hbWVzcGFjZUJhc2Uob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLk5hbWVzcGFjZSB8fCBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5Sb290O1xufVxuZnVuY3Rpb24gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iaiwgcGFyZW50TmFtZSkge1xuICAgIGNvbnN0IG9iak5hbWUgPSBqb2luTmFtZShwYXJlbnROYW1lLCBvYmoubmFtZSk7XG4gICAgaWYgKGlzSGFuZGxlZFJlZmxlY3Rpb25PYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gW1tvYmpOYW1lLCBvYmpdXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc05hbWVzcGFjZUJhc2Uob2JqKSAmJiB0eXBlb2Ygb2JqLm5lc3RlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmoubmVzdGVkKVxuICAgICAgICAgICAgICAgIC5tYXAobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhvYmoubmVzdGVkW25hbWVdLCBvYmpOYW1lKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZSgoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4gYWNjdW11bGF0b3IuY29uY2F0KGN1cnJlbnRWYWx1ZSksIFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5mdW5jdGlvbiBjcmVhdGVEZXNlcmlhbGl6ZXIoY2xzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlc2VyaWFsaXplKGFyZ0J1Zikge1xuICAgICAgICByZXR1cm4gY2xzLnRvT2JqZWN0KGNscy5kZWNvZGUoYXJnQnVmKSwgb3B0aW9ucyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6ZXIoY2xzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNlcmlhbGl6ZShhcmcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gc2VyaWFsaXplIG1lc3NhZ2U6IGV4cGVjdGVkIG9iamVjdCB3aXRoICR7Y2xzLm5hbWV9IHN0cnVjdHVyZSwgZ290IGFycmF5IGluc3RlYWRgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlID0gY2xzLmZyb21PYmplY3QoYXJnKTtcbiAgICAgICAgcmV0dXJuIGNscy5lbmNvZGUobWVzc2FnZSkuZmluaXNoKCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1hcE1ldGhvZE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiAob3B0aW9ucyB8fCBbXSkucmVkdWNlKChvYmosIGl0ZW0pID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5pbnRlcnByZXRlZF9vcHRpb24nOlxuICAgICAgICAgICAgICAgICAgICBvYmoudW5pbnRlcnByZXRlZF9vcHRpb24ucHVzaChpdGVtLnVuaW50ZXJwcmV0ZWRfb3B0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHtcbiAgICAgICAgZGVwcmVjYXRlZDogZmFsc2UsXG4gICAgICAgIGlkZW1wb3RlbmN5X2xldmVsOiBJZGVtcG90ZW5jeUxldmVsLklERU1QT1RFTkNZX1VOS05PV04sXG4gICAgICAgIHVuaW50ZXJwcmV0ZWRfb3B0aW9uOiBbXSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZERlZmluaXRpb24obWV0aG9kLCBzZXJ2aWNlTmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgLyogVGhpcyBpcyBvbmx5IGV2ZXIgY2FsbGVkIGFmdGVyIHRoZSBjb3JyZXNwb25kaW5nIHJvb3QucmVzb2x2ZUFsbCgpLCBzbyB3ZVxuICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgcmVzb2x2ZWQgcmVxdWVzdCBhbmQgcmVzcG9uc2UgdHlwZXMgYXJlIG5vbi1udWxsICovXG4gICAgY29uc3QgcmVxdWVzdFR5cGUgPSBtZXRob2QucmVzb2x2ZWRSZXF1ZXN0VHlwZTtcbiAgICBjb25zdCByZXNwb25zZVR5cGUgPSBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogJy8nICsgc2VydmljZU5hbWUgKyAnLycgKyBtZXRob2QubmFtZSxcbiAgICAgICAgcmVxdWVzdFN0cmVhbTogISFtZXRob2QucmVxdWVzdFN0cmVhbSxcbiAgICAgICAgcmVzcG9uc2VTdHJlYW06ICEhbWV0aG9kLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlcXVlc3RUeXBlKSxcbiAgICAgICAgcmVxdWVzdERlc2VyaWFsaXplOiBjcmVhdGVEZXNlcmlhbGl6ZXIocmVxdWVzdFR5cGUsIG9wdGlvbnMpLFxuICAgICAgICByZXNwb25zZVNlcmlhbGl6ZTogY3JlYXRlU2VyaWFsaXplcihyZXNwb25zZVR5cGUpLFxuICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBjcmVhdGVEZXNlcmlhbGl6ZXIocmVzcG9uc2VUeXBlLCBvcHRpb25zKSxcbiAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpc1xuICAgICAgICBvcmlnaW5hbE5hbWU6IGNhbWVsQ2FzZShtZXRob2QubmFtZSksXG4gICAgICAgIHJlcXVlc3RUeXBlOiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihyZXF1ZXN0VHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihyZXNwb25zZVR5cGUsIGZpbGVEZXNjcmlwdG9ycyksXG4gICAgICAgIG9wdGlvbnM6IG1hcE1ldGhvZE9wdGlvbnMobWV0aG9kLnBhcnNlZE9wdGlvbnMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihzZXJ2aWNlLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBkZWYgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZCBvZiBzZXJ2aWNlLm1ldGhvZHNBcnJheSkge1xuICAgICAgICBkZWZbbWV0aG9kLm5hbWVdID0gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihtZXNzYWdlLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBtZXNzYWdlRGVzY3JpcHRvciA9IG1lc3NhZ2UudG9EZXNjcmlwdG9yKCdwcm90bzMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBEZXNjcmlwdG9yUHJvdG8nLFxuICAgICAgICB0eXBlOiBtZXNzYWdlRGVzY3JpcHRvci4kdHlwZS50b09iamVjdChtZXNzYWdlRGVzY3JpcHRvciwgZGVzY3JpcHRvck9wdGlvbnMpLFxuICAgICAgICBmaWxlRGVzY3JpcHRvclByb3RvczogZmlsZURlc2NyaXB0b3JzLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbnVtRGVmaW5pdGlvbihlbnVtVHlwZSwgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZW51bURlc2NyaXB0b3IgPSBlbnVtVHlwZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIEVudW1EZXNjcmlwdG9yUHJvdG8nLFxuICAgICAgICB0eXBlOiBlbnVtRGVzY3JpcHRvci4kdHlwZS50b09iamVjdChlbnVtRGVzY3JpcHRvciwgZGVzY3JpcHRvck9wdGlvbnMpLFxuICAgICAgICBmaWxlRGVzY3JpcHRvclByb3RvczogZmlsZURlc2NyaXB0b3JzLFxuICAgIH07XG59XG4vKipcbiAqIGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5TZXJ2aWNlLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6XG4gKiBPcHRpb25zKTogU2VydmljZURlZmluaXRpb247IGZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5UeXBlLFxuICogbmFtZTogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTogTWVzc2FnZVR5cGVEZWZpbml0aW9uOyBmdW5jdGlvblxuICogY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLkVudW0sIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6XG4gKiBFbnVtVHlwZURlZmluaXRpb247XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuU2VydmljZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlU2VydmljZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5UeXBlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbihvYmosIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLkVudW0pIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVudW1EZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHlwZSBtaXNtYXRjaCBpbiByZWZsZWN0aW9uIG9iamVjdCBoYW5kbGluZycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKHJvb3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWYgPSB7fTtcbiAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yTGlzdCA9IHJvb3QudG9EZXNjcmlwdG9yKCdwcm90bzMnKS5maWxlO1xuICAgIGNvbnN0IGJ1ZmZlckxpc3QgPSBkZXNjcmlwdG9yTGlzdC5tYXAodmFsdWUgPT4gQnVmZmVyLmZyb20oZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclByb3RvLmVuY29kZSh2YWx1ZSkuZmluaXNoKCkpKTtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBvYmpdIG9mIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhyb290LCAnJykpIHtcbiAgICAgICAgZGVmW25hbWVdID0gY3JlYXRlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGJ1ZmZlckxpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21EZXNjcmlwdG9yKGRlY29kZWREZXNjcmlwdG9yU2V0KTtcbiAgICByb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucyk7XG59XG4vKipcbiAqIExvYWQgYSAucHJvdG8gZmlsZSB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cbiAqIEBwYXJhbSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZSBwYXRocyB0byBsb2FkLiBDYW4gYmUgYW4gYWJzb2x1dGUgcGF0aFxuICogICAgIG9yIHJlbGF0aXZlIHRvIGFuIGluY2x1ZGUgcGF0aC5cbiAqIEBwYXJhbSBvcHRpb25zLmtlZXBDYXNlIFByZXNlcnZlIGZpZWxkIG5hbWVzLiBUaGUgZGVmYXVsdCBpcyB0byBjaGFuZ2UgdGhlbVxuICogICAgIHRvIGNhbWVsIGNhc2UuXG4gKiBAcGFyYW0gb3B0aW9ucy5sb25ncyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgbG9uZ2AgdmFsdWVzLlxuICogICAgIFZhbGlkIG9wdGlvbnMgYXJlIGBOdW1iZXJgIGFuZCBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gYSBgTG9uZ2Agb2JqZWN0IHR5cGVcbiAqICAgICBmcm9tIGEgbGlicmFyeS5cbiAqIEBwYXJhbSBvcHRpb25zLmVudW1zIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBlbnVtYCB2YWx1ZXMuXG4gKiAgICAgVGhlIG9ubHkgdmFsaWQgb3B0aW9uIGlzIGBTdHJpbmdgLiBEZWZhdWx0cyB0byB0aGUgbnVtZXJpYyB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zLmJ5dGVzIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBieXRlc2BcbiAqICAgICB2YWx1ZXMuIFZhbGlkIG9wdGlvbnMgYXJlIGBBcnJheWAgYW5kIGBTdHJpbmdgLiBUaGUgZGVmYXVsdCBpcyB0byB1c2VcbiAqICAgICBgQnVmZmVyYC5cbiAqIEBwYXJhbSBvcHRpb25zLmRlZmF1bHRzIFNldCBkZWZhdWx0IHZhbHVlcyBvbiBvdXRwdXQgb2JqZWN0cy4gRGVmYXVsdHMgdG9cbiAqICAgICBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMuYXJyYXlzIFNldCBlbXB0eSBhcnJheXMgZm9yIG1pc3NpbmcgYXJyYXkgdmFsdWVzIGV2ZW4gaWZcbiAqICAgICBgZGVmYXVsdHNgIGlzIGBmYWxzZWAuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5vYmplY3RzIFNldCBlbXB0eSBvYmplY3RzIGZvciBtaXNzaW5nIG9iamVjdCB2YWx1ZXMgZXZlbiBpZlxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLm9uZW9mcyBTZXQgdmlydHVhbCBvbmVvZiBwcm9wZXJ0aWVzIHRvIHRoZSBwcmVzZW50IGZpZWxkJ3NcbiAqICAgICBuYW1lXG4gKiBAcGFyYW0gb3B0aW9ucy5qc29uIFJlcHJlc2VudCBJbmZpbml0eSBhbmQgTmFOIGFzIHN0cmluZ3MgaW4gZmxvYXQgZmllbGRzLFxuICogICAgIGFuZCBhdXRvbWF0aWNhbGx5IGRlY29kZSBnb29nbGUucHJvdG9idWYuQW55IHZhbHVlcy5cbiAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVEaXJzIFBhdGhzIHRvIHNlYXJjaCBmb3IgaW1wb3J0ZWQgYC5wcm90b2AgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIGxvYWQoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKDAsIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnMpKGZpbGVuYW1lLCBvcHRpb25zKS50aGVuKGxvYWRlZFJvb3QgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsb2FkZWRSb290ID0gKDAsIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jKShmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkU3luYyA9IGxvYWRTeW5jO1xuZnVuY3Rpb24gZnJvbUpTT04oanNvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21KU09OKGpzb24pO1xuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZnJvbUpTT04gPSBmcm9tSlNPTjtcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5kZWNvZGUoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcjtcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5mcm9tT2JqZWN0KGRlc2NyaXB0b3JTZXQpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3Q7XG4oMCwgdXRpbF8xLmFkZENvbW1vblByb3RvcykoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(action-browser)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(action-browser)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target) => {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths) {\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error('The includeDirs option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */\nfunction addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(action-browser)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(action-browser)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(action-browser)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(action-browser)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLGlDQUFpQyxHQUFHLDZCQUE2QjtBQUMzRixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsdUVBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUSx3Q0FBd0MsYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBTyxDQUFDLGdIQUFxQztBQUN2RSxpQ0FBaUMsbUJBQU8sQ0FBQyw4SEFBNEM7QUFDckYsb0NBQW9DLG1CQUFPLENBQUMsc0lBQWdEO0FBQzVGLDJCQUEyQixtQkFBTyxDQUFDLGtIQUFzQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9wcm90by1sb2FkZXIvYnVpbGQvc3JjL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmZ1bmN0aW9uIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgaW5jbHVkZVBhdGhzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlUGF0aCA9IHJvb3QucmVzb2x2ZVBhdGg7XG4gICAgcm9vdC5yZXNvbHZlUGF0aCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgaW5jbHVkZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIHRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmFjY2Vzc1N5bmMoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5SX09LKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgJHt0YXJnZXR9IG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGluY2x1ZGUgcGF0aHMgJHtpbmNsdWRlUGF0aHN9YCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlc29sdmVQYXRoKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gYXdhaXQgcm9vdC5sb2FkKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zO1xuZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSByb290LmxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmM7XG4vKipcbiAqIExvYWQgR29vZ2xlJ3Mgd2VsbC1rbm93biBwcm90byBmaWxlcyB0aGF0IGFyZW4ndCBleHBvc2VkIGJ5IFByb3RvYnVmLmpzLlxuICovXG5mdW5jdGlvbiBhZGRDb21tb25Qcm90b3MoKSB7XG4gICAgLy8gUHJvdG9idWYuanMgZXhwb3NlczogYW55LCBkdXJhdGlvbiwgZW1wdHksIGZpZWxkX21hc2ssIHN0cnVjdCwgdGltZXN0YW1wLFxuICAgIC8vIGFuZCB3cmFwcGVycy4gY29tcGlsZXIvcGx1Z2luIGlzIGV4Y2x1ZGVkIGluIFByb3RvYnVmLmpzIGFuZCBoZXJlLlxuICAgIC8vIFVzaW5nIGNvbnN0YW50IHN0cmluZ3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0b29scyBsaWtlIFdlYnBhY2tcbiAgICBjb25zdCBhcGlEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvYXBpLmpzb24nKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvbicpO1xuICAgIGNvbnN0IHNvdXJjZUNvbnRleHREZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQuanNvbicpO1xuICAgIGNvbnN0IHR5cGVEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvdHlwZS5qc29uJyk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdhcGknLCBhcGlEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdkZXNjcmlwdG9yJywgZGVzY3JpcHRvckRlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3NvdXJjZV9jb250ZXh0Jywgc291cmNlQ29udGV4dERlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3R5cGUnLCB0eXBlRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xufVxuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBhZGRDb21tb25Qcm90b3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addAdminServicesToServer = exports.registerAdminService = void 0;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({ getServiceDefinition, getHandlers });\n}\nexports.registerAdminService = registerAdminService;\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n}\nexports.addAdminServicesToServer = addAdminServicesToServer;\n//# sourceMappingURL=admin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBLG1DQUFtQyxtQ0FBbUM7QUFDdEU7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHZvaWQgMDtcbmNvbnN0IHJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzID0gW107XG5mdW5jdGlvbiByZWdpc3RlckFkbWluU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMpIHtcbiAgICByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcy5wdXNoKHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0pO1xufVxuZXhwb3J0cy5yZWdpc3RlckFkbWluU2VydmljZSA9IHJlZ2lzdGVyQWRtaW5TZXJ2aWNlO1xuZnVuY3Rpb24gYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyKHNlcnZlcikge1xuICAgIGZvciAoY29uc3QgeyBnZXRTZXJ2aWNlRGVmaW5pdGlvbiwgZ2V0SGFuZGxlcnMgfSBvZiByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcykge1xuICAgICAgICBzZXJ2ZXIuYWRkU2VydmljZShnZXRTZXJ2aWNlRGVmaW5pdGlvbigpLCBnZXRIYW5kbGVycygpKTtcbiAgICB9XG59XG5leHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGFkZEFkbWluU2VydmljZXNUb1NlcnZlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFkbWluLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options) {\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */\n        this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */\n        this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */\n        this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */\n        this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */\n        this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */\n        this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */\n        this.startTime = new Date();\n        /**\n         * The approximate time that the currently running timer will end. Only valid\n         * if running is true.\n         */\n        this.endTime = new Date();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(() => { }, 0);\n        clearTimeout(this.timerId);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        this.endTime = this.startTime;\n        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(() => {\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */\n    runOnce() {\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay =\n            nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */\n    stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */\n    reset() {\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            }\n            else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */\n    isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */\n    ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */\n    unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Get the approximate timestamp of when the timer will fire. Only valid if\n     * this.isRunning() is true.\n     */\n    getEndTime() {\n        return this.endTime;\n    }\n}\nexports.BackoffTimeout = BackoffTimeout;\n//# sourceMappingURL=backoff-timeout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2JhY2tvZmYtdGltZW91dC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IHZvaWQgMDtcbmNvbnN0IElOSVRJQUxfQkFDS09GRl9NUyA9IDEwMDA7XG5jb25zdCBCQUNLT0ZGX01VTFRJUExJRVIgPSAxLjY7XG5jb25zdCBNQVhfQkFDS09GRl9NUyA9IDEyMDAwMDtcbmNvbnN0IEJBQ0tPRkZfSklUVEVSID0gMC4yO1xuLyoqXG4gKiBHZXQgYSBudW1iZXIgdW5pZm9ybWx5IGF0IHJhbmRvbSBpbiB0aGUgcmFuZ2UgW21pbiwgbWF4KVxuICogQHBhcmFtIG1pblxuICogQHBhcmFtIG1heFxuICovXG5mdW5jdGlvbiB1bmlmb3JtUmFuZG9tKG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcbn1cbmNsYXNzIEJhY2tvZmZUaW1lb3V0IHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVsYXkgdGltZSBhdCB0aGUgc3RhcnQsIGFuZCBhZnRlciBlYWNoIHJlc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBJTklUSUFMX0JBQ0tPRkZfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZXhwb25lbnRpYWwgYmFja29mZiBtdWx0aXBsaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tdWx0aXBsaWVyID0gQkFDS09GRl9NVUxUSVBMSUVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZGVsYXkgdGltZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhEZWxheSA9IE1BWF9CQUNLT0ZGX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1heGltdW0gZnJhY3Rpb24gYnkgd2hpY2ggdGhlIGRlbGF5IHRpbWUgY2FuIHJhbmRvbWx5IHZhcnkgYWZ0ZXJcbiAgICAgICAgICogYXBwbHlpbmcgdGhlIG11bHRpcGxpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmppdHRlciA9IEJBQ0tPRkZfSklUVEVSO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZXIgc2hvdWxkIGtlZXAgdGhlIE5vZGUgcHJvY2VzcyBydW5uaW5nIGlmIG5vXG4gICAgICAgICAqIG90aGVyIGFzeW5jIG9wZXJhdGlvbiBpcyBkb2luZyBzby5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdhcyBzdGFydGVkLiBPbmx5IHZhbGlkIGlmXG4gICAgICAgICAqIHJ1bm5pbmcgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcHByb3hpbWF0ZSB0aW1lIHRoYXQgdGhlIGN1cnJlbnRseSBydW5uaW5nIHRpbWVyIHdpbGwgZW5kLiBPbmx5IHZhbGlkXG4gICAgICAgICAqIGlmIHJ1bm5pbmcgaXMgdHJ1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbml0aWFsRGVsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxEZWxheSA9IG9wdGlvbnMuaW5pdGlhbERlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubXVsdGlwbGllcikge1xuICAgICAgICAgICAgICAgIHRoaXMubXVsdGlwbGllciA9IG9wdGlvbnMubXVsdGlwbGllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmppdHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaml0dGVyID0gb3B0aW9ucy5qaXR0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXhEZWxheSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4RGVsYXkgPSBvcHRpb25zLm1heERlbGF5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dERlbGF5ID0gdGhpcy5pbml0aWFsRGVsYXk7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgfVxuICAgIHJ1blRpbWVyKGRlbGF5KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmVuZFRpbWUuc2V0TWlsbGlzZWNvbmRzKHRoaXMuZW5kVGltZS5nZXRNaWxsaXNlY29uZHMoKSArIHRoaXMubmV4dERlbGF5KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICAgIHRoaXMudGltZXJJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1JlZikge1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIGNhbGxiYWNrIGFmdGVyIHRoZSBjdXJyZW50IGFtb3VudCBvZiBkZWxheSB0aW1lXG4gICAgICovXG4gICAgcnVuT25jZSgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLnJ1blRpbWVyKHRoaXMubmV4dERlbGF5KTtcbiAgICAgICAgY29uc3QgbmV4dEJhY2tvZmYgPSBNYXRoLm1pbih0aGlzLm5leHREZWxheSAqIHRoaXMubXVsdGlwbGllciwgdGhpcy5tYXhEZWxheSk7XG4gICAgICAgIGNvbnN0IGppdHRlck1hZ25pdHVkZSA9IG5leHRCYWNrb2ZmICogdGhpcy5qaXR0ZXI7XG4gICAgICAgIHRoaXMubmV4dERlbGF5ID1cbiAgICAgICAgICAgIG5leHRCYWNrb2ZmICsgdW5pZm9ybVJhbmRvbSgtaml0dGVyTWFnbml0dWRlLCBqaXR0ZXJNYWduaXR1ZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSB0aW1lci4gVGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCB1bnRpbCBgcnVuT25jZWAgaXMgY2FsbGVkXG4gICAgICogYWdhaW4uXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgZGVsYXkgdGltZSB0byBpdHMgaW5pdGlhbCB2YWx1ZS4gSWYgdGhlIHRpbWVyIGlzIHN0aWxsIHJ1bm5pbmcsXG4gICAgICogcmV0cm9hY3RpdmVseSBhcHBseSB0aGF0IHJlc2V0IHRvIHRoZSBjdXJyZW50IHRpbWVyLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLm5leHREZWxheSA9IHRoaXMuaW5pdGlhbERlbGF5O1xuICAgICAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgbmV3RW5kVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICAgICAgbmV3RW5kVGltZS5zZXRNaWxsaXNlY29uZHMobmV3RW5kVGltZS5nZXRNaWxsaXNlY29uZHMoKSArIHRoaXMubmV4dERlbGF5KTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgICAgICAgICAgaWYgKG5vdyA8IG5ld0VuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVyKG5ld0VuZFRpbWUuZ2V0VGltZSgpIC0gbm93LmdldFRpbWUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSB0aW1lciBpcyBjdXJyZW50bHkgcnVubmluZy5cbiAgICAgKi9cbiAgICBpc1J1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bm5pbmc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGF0IHdoaWxlIHRoZSB0aW1lciBpcyBydW5uaW5nLCBpdCBzaG91bGQga2VlcCB0aGUgTm9kZSBwcm9jZXNzXG4gICAgICogcnVubmluZy5cbiAgICAgKi9cbiAgICByZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaGFzUmVmID0gdHJ1ZTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoYXQgd2hpbGUgdGhlIHRpbWVyIGlzIHJ1bm5pbmcsIGl0IHNob3VsZCBub3Qga2VlcCB0aGUgTm9kZSBwcm9jZXNzXG4gICAgICogcnVubmluZy5cbiAgICAgKi9cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5oYXNSZWYgPSBmYWxzZTtcbiAgICAgICAgKF9iID0gKF9hID0gdGhpcy50aW1lcklkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGFwcHJveGltYXRlIHRpbWVzdGFtcCBvZiB3aGVuIHRoZSB0aW1lciB3aWxsIGZpcmUuIE9ubHkgdmFsaWQgaWZcbiAgICAgKiB0aGlzLmlzUnVubmluZygpIGlzIHRydWUuXG4gICAgICovXG4gICAgZ2V0RW5kVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kVGltZTtcbiAgICB9XG59XG5leHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gQmFja29mZlRpbWVvdXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYWNrb2ZmLXRpbWVvdXQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return ('getRequestHeaders' in client &&\n        typeof client.getRequestHeaders === 'function');\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */\nclass CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */\n    static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */\n    static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback) => {\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            }\n            else {\n                getHeaders = new Promise((resolve, reject) => {\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        if (!headers) {\n                            reject(new Error('Headers not set by metadata plugin'));\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then(headers => {\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)) {\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, err => {\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds) {\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map(cred => cred.generateMetadata(options)));\n        for (const gen of generated) {\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([other]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index) => value._equals(other.creds[index]));\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator) {\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject) => {\n            this.metadataGenerator(options, (err, metadata) => {\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                }\n                else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([this, other]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n}\n//# sourceMappingURL=call-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtY3JlZGVudGlhbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuZnVuY3Rpb24gaXNDdXJyZW50T2F1dGgyQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoJ2dldFJlcXVlc3RIZWFkZXJzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2VuZXJpYyBtZXRob2Qgb2YgYWRkaW5nIGF1dGhlbnRpY2F0aW9uLXJlbGF0ZWRcbiAqIG1ldGFkYXRhIG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMuXG4gKi9cbmNsYXNzIENhbGxDcmVkZW50aWFscyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0IGZyb20gYSBnaXZlbiBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlc1xuICAgICAqIE1ldGFkYXRhIG9iamVjdHMuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhR2VuZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgc2V0IG9mIG9wdGlvbnMsIGFuZFxuICAgICAqIGdlbmVyYXRlcyBhIE1ldGFkYXRhIG9iamVjdCBiYXNlZCBvbiB0aGVzZSBvcHRpb25zLCB3aGljaCBpcyBwYXNzZWQgYmFja1xuICAgICAqIHRvIHRoZSBjYWxsZXIgdmlhIGEgc3VwcGxpZWQgKGVyciwgbWV0YWRhdGEpIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMobWV0YWRhdGFHZW5lcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBnUlBDIGNyZWRlbnRpYWwgZnJvbSBhIEdvb2dsZSBjcmVkZW50aWFsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZ29vZ2xlQ3JlZGVudGlhbHMgVGhlIGF1dGhlbnRpY2F0aW9uIGNsaWVudCB0byB1c2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsKGdvb2dsZUNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBDYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yKChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbGV0IGdldEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAoaXNDdXJyZW50T2F1dGgyQ2xpZW50KGdvb2dsZUNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBnb29nbGVDcmVkZW50aWFscy5nZXRSZXF1ZXN0SGVhZGVycyhvcHRpb25zLnNlcnZpY2VfdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RNZXRhZGF0YShvcHRpb25zLnNlcnZpY2VfdXJsLCAoZXJyLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignSGVhZGVycyBub3Qgc2V0IGJ5IG1ldGFkYXRhIHBsdWdpbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdldEhlYWRlcnMudGhlbihoZWFkZXJzID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuYWRkKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRW1wdHlDYWxsQ3JlZGVudGlhbHMoKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IENhbGxDcmVkZW50aWFscztcbmNsYXNzIENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzIGV4dGVuZHMgQ2FsbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjcmVkcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNyZWRzID0gY3JlZHM7XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICBjb25zdCBiYXNlID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVkID0gYXdhaXQgUHJvbWlzZS5hbGwodGhpcy5jcmVkcy5tYXAoY3JlZCA9PiBjcmVkLmdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykpKTtcbiAgICAgICAgZm9yIChjb25zdCBnZW4gb2YgZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICBiYXNlLm1lcmdlKGdlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyh0aGlzLmNyZWRzLmNvbmNhdChbb3RoZXJdKSk7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NlZENhbGxDcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlZHMuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gdmFsdWUuX2VxdWFscyhvdGhlci5jcmVkc1tpbmRleF0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIFNpbmdsZUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9IG1ldGFkYXRhR2VuZXJhdG9yO1xuICAgIH1cbiAgICBnZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3Iob3B0aW9ucywgKGVyciwgbWV0YWRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcG9zZShvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2FsbENyZWRlbnRpYWxzKFt0aGlzLCBvdGhlcl0pO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2luZ2xlQ2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tZXRhZGF0YUdlbmVyYXRvciA9PT0gb3RoZXIubWV0YWRhdGFHZW5lcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBFbXB0eUNhbGxDcmVkZW50aWFscyBleHRlbmRzIENhbGxDcmVkZW50aWFscyB7XG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSk7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEVtcHR5Q2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwtY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-interface.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-interface.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nfunction isInterceptingListener(listener) {\n    return (listener.onReceiveMetadata !== undefined &&\n        listener.onReceiveMetadata.length === 1);\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener) {\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, metadata => {\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */\n        this.processingMessage = true;\n        this.listener.onReceiveMessage(message, msg => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            }\n            else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, processedStatus => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            }\n            else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\n//# sourceMappingURL=call-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQ0FBZ0MsR0FBRyw4QkFBOEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtaW50ZXJmYWNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCA9IGV4cG9ydHMuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IHZvaWQgMDtcbmZ1bmN0aW9uIGlzSW50ZXJjZXB0aW5nTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICByZXR1cm4gKGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEubGVuZ3RoID09PSAxKTtcbn1cbmV4cG9ydHMuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IGlzSW50ZXJjZXB0aW5nTGlzdGVuZXI7XG5jbGFzcyBJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwge1xuICAgIGNvbnN0cnVjdG9yKGxpc3RlbmVyLCBuZXh0TGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLm5leHRMaXN0ZW5lciA9IG5leHRMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNQZW5kaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IG51bGw7XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UodGhpcy5wZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ1N0YXR1cygpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1N0YXR1cykge1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHRoaXMucGVuZGluZ1N0YXR1cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhLCBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdTdGF0dXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8qIElmIHRoaXMgbGlzdGVuZXIgcHJvY2Vzc2VzIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5LCB0aGUgbGFzdCBtZXNzYWdlIG1heVxuICAgICAgICAgKiBiZSByZW9yZGVyZWQgd2l0aCByZXNwZWN0IHRvIHRoZSBzdGF0dXMgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtZXNzYWdlLCBtc2cgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nU3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHN0YXR1cywgcHJvY2Vzc2VkU3RhdHVzID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSB8fCB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nU3RhdHVzID0gcHJvY2Vzc2VkU3RhdHVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKHByb2Nlc3NlZFN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsID0gSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1pbnRlcmZhY2UuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-number.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-number.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNextCallNumber = void 0;\nlet nextCallNumber = 0;\nfunction getNextCallNumber() {\n    return nextCallNumber++;\n}\nexports.getNextCallNumber = getNextCallNumber;\n//# sourceMappingURL=call-number.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1udW1iZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NhbGwtbnVtYmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE5leHRDYWxsTnVtYmVyID0gdm9pZCAwO1xubGV0IG5leHRDYWxsTnVtYmVyID0gMDtcbmZ1bmN0aW9uIGdldE5leHRDYWxsTnVtYmVyKCkge1xuICAgIHJldHVybiBuZXh0Q2FsbE51bWJlcisrO1xufVxuZXhwb3J0cy5nZXROZXh0Q2FsbE51bWJlciA9IGdldE5leHRDYWxsTnVtYmVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1udW1iZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-number.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */\nfunction callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, { stack });\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor() {\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize) {\n        super({ objectMode: true });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize) {\n        super({ objectMode: true });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : 'unknown';\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb,\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;\n//# sourceMappingURL=call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDhCQUE4QixHQUFHLGdDQUFnQyxHQUFHLGdDQUFnQyxHQUFHLDJCQUEyQixHQUFHLDJCQUEyQjtBQUNoSyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhLEVBQUUsZ0NBQWdDLElBQUksZUFBZTtBQUN6RjtBQUNBLHFCQUFxQixZQUFZLGlCQUFpQixZQUFZO0FBQzlELHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnREdXBsZXhTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50VW5hcnlDYWxsSW1wbCA9IGV4cG9ydHMuY2FsbEVycm9yRnJvbVN0YXR1cyA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuLyoqXG4gKiBDb25zdHJ1Y3QgYSBTZXJ2aWNlRXJyb3IgZnJvbSBhIFN0YXR1c09iamVjdC4gVGhpcyBmdW5jdGlvbiBleGlzdHMgcHJpbWFyaWx5XG4gKiBhcyBhbiBhdHRlbXB0IHRvIG1ha2UgdGhlIGVycm9yIHN0YWNrIHRyYWNlIGNsZWFybHkgY29tbXVuaWNhdGUgdGhhdCB0aGVcbiAqIGVycm9yIGlzIG5vdCBuZWNlc3NhcmlseSBhIHByb2JsZW0gaW4gZ1JQQyBpdHNlbGYuXG4gKiBAcGFyYW0gc3RhdHVzXG4gKi9cbmZ1bmN0aW9uIGNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHtzdGF0dXMuY29kZX0gJHtjb25zdGFudHNfMS5TdGF0dXNbc3RhdHVzLmNvZGVdfTogJHtzdGF0dXMuZGV0YWlsc31gO1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIGNvbnN0IHN0YWNrID0gYCR7ZXJyb3Iuc3RhY2t9XFxuZm9yIGNhbGwgYXRcXG4ke2NhbGxlclN0YWNrfWA7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKG1lc3NhZ2UpLCBzdGF0dXMsIHsgc3RhY2sgfSk7XG59XG5leHBvcnRzLmNhbGxFcnJvckZyb21TdGF0dXMgPSBjYWxsRXJyb3JGcm9tU3RhdHVzO1xuY2xhc3MgQ2xpZW50VW5hcnlDYWxsSW1wbCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudFVuYXJ5Q2FsbEltcGwgPSBDbGllbnRVbmFyeUNhbGxJbXBsO1xuY2xhc3MgQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuUmVhZGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGRlc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF9yZWFkKF9zaXplKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgPSBDbGllbnRSZWFkYWJsZVN0cmVhbUltcGw7XG5jbGFzcyBDbGllbnRXcml0YWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5Xcml0YWJsZSB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmbGFncyA9IE51bWJlcihlbmNvZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGZsYWdzKSkge1xuICAgICAgICAgICAgY29udGV4dC5mbGFncyA9IGZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgY2h1bmspO1xuICAgIH1cbiAgICBfZmluYWwoY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYWxmQ2xvc2UoKTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCA9IENsaWVudFdyaXRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIENsaWVudER1cGxleFN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5EdXBsZXgge1xuICAgIGNvbnN0cnVjdG9yKHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnQ2FuY2VsbGVkIG9uIGNsaWVudCcpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIF9yZWFkKF9zaXplKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBOdW1iZXIoZW5jb2RpbmcpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihmbGFncykpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgfVxuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGNodW5rKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNiKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFsZkNsb3NlKCk7XG4gICAgICAgIGNiKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnREdXBsZXhTdHJlYW1JbXBsID0gQ2xpZW50RHVwbGV4U3RyZWFtSW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhbGwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChannelCredentials = void 0;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */\nclass ChannelCredentials {\n    constructor(callCredentials) {\n        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n    }\n    /**\n     * Gets the set of per-call credentials associated with this instance.\n     */\n    _getCallCredentials() {\n        return this.callCredentials;\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */\n    static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, 'Root certificate');\n        verifyIsBufferOrNull(privateKey, 'Private key');\n        verifyIsBufferOrNull(certChain, 'Certificate chain');\n        if (privateKey && !certChain) {\n            throw new Error('Private key must be given with accompanying certificate chain');\n        }\n        if (!privateKey && certChain) {\n            throw new Error('Certificate chain must be given with accompanying private key');\n        }\n        const secureContext = (0, tls_1.createSecureContext)({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES,\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */\n    static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */\n    static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(callCredentials) {\n        super(callCredentials);\n    }\n    compose(callCredentials) {\n        throw new Error('Cannot compose insecure credentials');\n    }\n    _getConnectionOptions() {\n        return null;\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions) {\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n        this.connectionOptions = {\n            secureContext,\n        };\n        // Node asserts that this option is a function, so we cannot pass undefined\n        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n            this.connectionOptions.checkServerIdentity =\n                verifyOptions.checkServerIdentity;\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        // Copy to prevent callers from mutating this.connectionOptions\n        return Object.assign({}, this.connectionOptions);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return (this.secureContext === other.secureContext &&\n                this.verifyOptions.checkServerIdentity ===\n                    other.verifyOptions.checkServerIdentity);\n        }\n        else {\n            return false;\n        }\n    }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCreds) {\n        super(callCreds);\n        this.channelCredentials = channelCredentials;\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        return this.channelCredentials._getConnectionOptions();\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return (this.channelCredentials._equals(other.channelCredentials) &&\n                this.callCredentials._equals(other.callCredentials));\n        }\n        else {\n            return false;\n        }\n    }\n}\n//# sourceMappingURL=channel-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzSUFBc0k7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgdGxzX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Rscy1oZWxwZXJzXCIpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHZlcmlmeUlzQnVmZmVyT3JOdWxsKG9iaiwgZnJpZW5kbHlOYW1lKSB7XG4gICAgaWYgKG9iaiAmJiAhKG9iaiBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtmcmllbmRseU5hbWV9LCBpZiBwcm92aWRlZCwgbXVzdCBiZSBhIEJ1ZmZlci5gKTtcbiAgICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCBjb250YWlucyBjcmVkZW50aWFscyBmb3IgY29tbXVuaWNhdGluZyBvdmVyIGEgY2hhbm5lbCwgYXMgd2VsbFxuICogYXMgYSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMsIHdoaWNoIGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IG1ldGhvZCBjYWxsIG1hZGVcbiAqIG92ZXIgYSBjaGFubmVsIGluaXRpYWxpemVkIHdpdGggYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcy5cbiAqL1xuY2xhc3MgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5jYWxsQ3JlZGVudGlhbHMgPSBjYWxsQ3JlZGVudGlhbHMgfHwgY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzZXQgb2YgcGVyLWNhbGwgY3JlZGVudGlhbHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICovXG4gICAgX2dldENhbGxDcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbENyZWRlbnRpYWxzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggYSBnaXZlbiBzZXQgb2YgY3JlZGVudGlhbHMuXG4gICAgICogVGhlIHJlc3VsdGluZyBpbnN0YW5jZSBjYW4gYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzXG4gICAgICogb3ZlciBUTFMuXG4gICAgICogQHBhcmFtIHJvb3RDZXJ0cyBUaGUgcm9vdCBjZXJ0aWZpY2F0ZSBkYXRhLlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IFRoZSBjbGllbnQgY2VydGlmaWNhdGUgcHJpdmF0ZSBrZXksIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gY2VydENoYWluIFRoZSBjbGllbnQgY2VydGlmaWNhdGUga2V5IGNoYWluLCBpZiBhdmFpbGFibGUuXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlU3NsKHJvb3RDZXJ0cywgcHJpdmF0ZUtleSwgY2VydENoYWluLCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwocm9vdENlcnRzLCAnUm9vdCBjZXJ0aWZpY2F0ZScpO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChwcml2YXRlS2V5LCAnUHJpdmF0ZSBrZXknKTtcbiAgICAgICAgdmVyaWZ5SXNCdWZmZXJPck51bGwoY2VydENoYWluLCAnQ2VydGlmaWNhdGUgY2hhaW4nKTtcbiAgICAgICAgaWYgKHByaXZhdGVLZXkgJiYgIWNlcnRDaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcml2YXRlIGtleSBtdXN0IGJlIGdpdmVuIHdpdGggYWNjb21wYW55aW5nIGNlcnRpZmljYXRlIGNoYWluJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcml2YXRlS2V5ICYmIGNlcnRDaGFpbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDZXJ0aWZpY2F0ZSBjaGFpbiBtdXN0IGJlIGdpdmVuIHdpdGggYWNjb21wYW55aW5nIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VjdXJlQ29udGV4dCA9ICgwLCB0bHNfMS5jcmVhdGVTZWN1cmVDb250ZXh0KSh7XG4gICAgICAgICAgICBjYTogKF9hID0gcm9vdENlcnRzICE9PSBudWxsICYmIHJvb3RDZXJ0cyAhPT0gdm9pZCAwID8gcm9vdENlcnRzIDogKDAsIHRsc19oZWxwZXJzXzEuZ2V0RGVmYXVsdFJvb3RzRGF0YSkoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAga2V5OiBwcml2YXRlS2V5ICE9PSBudWxsICYmIHByaXZhdGVLZXkgIT09IHZvaWQgMCA/IHByaXZhdGVLZXkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZXJ0OiBjZXJ0Q2hhaW4gIT09IG51bGwgJiYgY2VydENoYWluICE9PSB2b2lkIDAgPyBjZXJ0Q2hhaW4gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVMsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggY3JlZGVudGlhbHMgY3JlYXRlZCB1c2luZ1xuICAgICAqIHRoZSBwcm92aWRlZCBzZWN1cmVDb250ZXh0LiBUaGUgcmVzdWx0aW5nIGluc3RhbmNlcyBjYW4gYmUgdXNlZCB0b1xuICAgICAqIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXMgb3ZlciBUTFMuIGdSUEMgd2lsbCBub3Qgb3ZlcnJpZGVcbiAgICAgKiBhbnl0aGluZyBpbiB0aGUgcHJvdmlkZWQgc2VjdXJlQ29udGV4dCwgc28gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICAgICAqIEdSUENfU1NMX0NJUEhFUl9TVUlURVMgYW5kIEdSUENfREVGQVVMVF9TU0xfUk9PVFNfRklMRV9QQVRIIHdpbGxcbiAgICAgKiBub3QgYmUgYXBwbGllZC5cbiAgICAgKiBAcGFyYW0gc2VjdXJlQ29udGV4dCBUaGUgcmV0dXJuIHZhbHVlIG9mIHRscy5jcmVhdGVTZWN1cmVDb250ZXh0KClcbiAgICAgKiBAcGFyYW0gdmVyaWZ5T3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gbW9kaWZ5IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tU2VjdXJlQ29udGV4dChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbChzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zICE9PSBudWxsICYmIHZlcmlmeU9wdGlvbnMgIT09IHZvaWQgMCA/IHZlcmlmeU9wdGlvbnMgOiB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBubyBjcmVkZW50aWFscy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlSW5zZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSBDaGFubmVsQ3JlZGVudGlhbHM7XG5jbGFzcyBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwgZXh0ZW5kcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBzdXBlcihjYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wb3NlIGluc2VjdXJlIGNyZWRlbnRpYWxzJyk7XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbDtcbiAgICB9XG59XG5jbGFzcyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihzZWN1cmVDb250ZXh0LCB2ZXJpZnlPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2VjdXJlQ29udGV4dCA9IHNlY3VyZUNvbnRleHQ7XG4gICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucyA9IHZlcmlmeU9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBzZWN1cmVDb250ZXh0LFxuICAgICAgICB9O1xuICAgICAgICAvLyBOb2RlIGFzc2VydHMgdGhhdCB0aGlzIG9wdGlvbiBpcyBhIGZ1bmN0aW9uLCBzbyB3ZSBjYW5ub3QgcGFzcyB1bmRlZmluZWRcbiAgICAgICAgaWYgKHZlcmlmeU9wdGlvbnMgPT09IG51bGwgfHwgdmVyaWZ5T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPVxuICAgICAgICAgICAgICAgIHZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb3NlKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICBjb25zdCBjb21iaW5lZENhbGxDcmVkZW50aWFscyA9IHRoaXMuY2FsbENyZWRlbnRpYWxzLmNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENoYW5uZWxDcmVkZW50aWFsc0ltcGwodGhpcywgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgIC8vIENvcHkgdG8gcHJldmVudCBjYWxsZXJzIGZyb20gbXV0YXRpbmcgdGhpcy5jb25uZWN0aW9uT3B0aW9uc1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9lcXVhbHMob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuc2VjdXJlQ29udGV4dCA9PT0gb3RoZXIuc2VjdXJlQ29udGV4dCAmJlxuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID09PVxuICAgICAgICAgICAgICAgICAgICBvdGhlci52ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsQ3JlZGVudGlhbHMsIGNhbGxDcmVkcykge1xuICAgICAgICBzdXBlcihjYWxsQ3JlZHMpO1xuICAgICAgICB0aGlzLmNoYW5uZWxDcmVkZW50aWFscyA9IGNoYW5uZWxDcmVkZW50aWFscztcbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLCBjb21iaW5lZENhbGxDcmVkZW50aWFscyk7XG4gICAgfVxuICAgIF9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuY2hhbm5lbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2hhbm5lbENyZWRlbnRpYWxzKSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuY2FsbENyZWRlbnRpYWxzLl9lcXVhbHMob3RoZXIuY2FsbENyZWRlbnRpYWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.channelOptionsEqual = exports.recognizedOptions = void 0;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */\nexports.recognizedOptions = {\n    'grpc.ssl_target_name_override': true,\n    'grpc.primary_user_agent': true,\n    'grpc.secondary_user_agent': true,\n    'grpc.default_authority': true,\n    'grpc.keepalive_time_ms': true,\n    'grpc.keepalive_timeout_ms': true,\n    'grpc.keepalive_permit_without_calls': true,\n    'grpc.service_config': true,\n    'grpc.max_concurrent_streams': true,\n    'grpc.initial_reconnect_backoff_ms': true,\n    'grpc.max_reconnect_backoff_ms': true,\n    'grpc.use_local_subchannel_pool': true,\n    'grpc.max_send_message_length': true,\n    'grpc.max_receive_message_length': true,\n    'grpc.enable_http_proxy': true,\n    'grpc.enable_channelz': true,\n    'grpc.dns_min_time_between_resolutions_ms': true,\n    'grpc.enable_retries': true,\n    'grpc.per_rpc_retry_buffer_size': true,\n    'grpc.retry_buffer_size': true,\n    'grpc.max_connection_age_ms': true,\n    'grpc.max_connection_age_grace_ms': true,\n    'grpc-node.max_session_memory': true,\n    'grpc.service_config_disable_resolution': true,\n    'grpc.client_idle_timeout_ms': true,\n    'grpc-node.tls_enable_trace': true,\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (let i = 0; i < keys1.length; i += 1) {\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.channelOptionsEqual = channelOptionsEqual;\n//# sourceMappingURL=channel-options.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcseUJBQXlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLW9wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hhbm5lbE9wdGlvbnNFcXVhbCA9IGV4cG9ydHMucmVjb2duaXplZE9wdGlvbnMgPSB2b2lkIDA7XG4vKipcbiAqIFRoaXMgaXMgZm9yIGNoZWNraW5nIHByb3ZpZGVkIG9wdGlvbnMgYXQgcnVudGltZS4gVGhpcyBpcyBhbiBvYmplY3QgZm9yXG4gKiBlYXNpZXIgbWVtYmVyc2hpcCBjaGVja2luZy5cbiAqL1xuZXhwb3J0cy5yZWNvZ25pemVkT3B0aW9ucyA9IHtcbiAgICAnZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnOiB0cnVlLFxuICAgICdncnBjLnByaW1hcnlfdXNlcl9hZ2VudCc6IHRydWUsXG4gICAgJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxuICAgICdncnBjLmRlZmF1bHRfYXV0aG9yaXR5JzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscyc6IHRydWUsXG4gICAgJ2dycGMuc2VydmljZV9jb25maWcnOiB0cnVlLFxuICAgICdncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnOiB0cnVlLFxuICAgICdncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxuICAgICdncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyc6IHRydWUsXG4gICAgJ2dycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCc6IHRydWUsXG4gICAgJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnOiB0cnVlLFxuICAgICdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcbiAgICAnZ3JwYy5lbmFibGVfaHR0cF9wcm94eSc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX2NoYW5uZWx6JzogdHJ1ZSxcbiAgICAnZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX3JldHJpZXMnOiB0cnVlLFxuICAgICdncnBjLnBlcl9ycGNfcmV0cnlfYnVmZmVyX3NpemUnOiB0cnVlLFxuICAgICdncnBjLnJldHJ5X2J1ZmZlcl9zaXplJzogdHJ1ZSxcbiAgICAnZ3JwYy5tYXhfY29ubmVjdGlvbl9hZ2VfbXMnOiB0cnVlLFxuICAgICdncnBjLm1heF9jb25uZWN0aW9uX2FnZV9ncmFjZV9tcyc6IHRydWUsXG4gICAgJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknOiB0cnVlLFxuICAgICdncnBjLnNlcnZpY2VfY29uZmlnX2Rpc2FibGVfcmVzb2x1dGlvbic6IHRydWUsXG4gICAgJ2dycGMuY2xpZW50X2lkbGVfdGltZW91dF9tcyc6IHRydWUsXG4gICAgJ2dycGMtbm9kZS50bHNfZW5hYmxlX3RyYWNlJzogdHJ1ZSxcbn07XG5mdW5jdGlvbiBjaGFubmVsT3B0aW9uc0VxdWFsKG9wdGlvbnMxLCBvcHRpb25zMikge1xuICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob3B0aW9uczEpLnNvcnQoKTtcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9wdGlvbnMyKS5zb3J0KCk7XG4gICAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzMS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoa2V5czFbaV0gIT09IGtleXMyW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMxW2tleXMxW2ldXSAhPT0gb3B0aW9uczJba2V5czJbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmNoYW5uZWxPcHRpb25zRXF1YWwgPSBjaGFubmVsT3B0aW9uc0VxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC1vcHRpb25zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChannelImplementation = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst internal_channel_1 = __webpack_require__(/*! ./internal-channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\");\nclass ChannelImplementation {\n    constructor(target, credentials, options) {\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object') {\n                throw new TypeError('Channel options must be an object');\n            }\n        }\n        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);\n    }\n    close() {\n        this.internalChannel.close();\n    }\n    getTarget() {\n        return this.internalChannel.getTarget();\n    }\n    getConnectivityState(tryToConnect) {\n        return this.internalChannel.getConnectivityState(tryToConnect);\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        this.internalChannel.watchConnectivityState(currentState, deadline, callback);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.internalChannel.getChannelzRef();\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.ChannelImplementation = ChannelImplementation;\n//# sourceMappingURL=channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qiw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGFubmVsSW1wbGVtZW50YXRpb24gPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgaW50ZXJuYWxfY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwtY2hhbm5lbFwiKTtcbmNsYXNzIENoYW5uZWxJbXBsZW1lbnRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgdGFyZ2V0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIGNyZWRlbnRpYWxzIG11c3QgYmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbCA9IG5ldyBpbnRlcm5hbF9jaGFubmVsXzEuSW50ZXJuYWxDaGFubmVsKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbENoYW5uZWwuY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0VGFyZ2V0KCk7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KTtcbiAgICB9XG4gICAgd2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShjdXJyZW50U3RhdGUsIGRlYWRsaW5lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmludGVybmFsQ2hhbm5lbC53YXRjaENvbm5lY3Rpdml0eVN0YXRlKGN1cnJlbnRTdGF0ZSwgZGVhZGxpbmUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFubmVseiByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIGNoYW5uZWwuIFRoZSByZXR1cm5lZCB2YWx1ZSBpc1xuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogbWV0aG9kIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0eXBlb2YgZGVhZGxpbmUgPT09ICdudW1iZXInIHx8IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogZGVhZGxpbmUgbXVzdCBiZSBhIG51bWJlciBvciBEYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDaGFubmVsLmNyZWF0ZUNhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gQ2hhbm5lbEltcGxlbWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name,\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name,\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id,\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name,\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n    constructor() {\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined,\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map(event => {\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel\n                        ? channelRefToMessage(event.childChannel)\n                        : null,\n                    subchannel_ref: event.childSubchannel\n                        ? subchannelRefToMessage(event.childSubchannel)\n                        : null,\n                };\n            }),\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor() {\n        this.channelChildren = new Map();\n        this.subchannelChildren = new Map();\n        this.socketChildren = new Map();\n    }\n    refChild(child) {\n        var _a, _b, _c;\n        switch (child.kind) {\n            case 'channel': {\n                const trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n                    ref: child,\n                    count: 0,\n                };\n                trackedChild.count += 1;\n                this.channelChildren.set(child.id, trackedChild);\n                break;\n            }\n            case 'subchannel': {\n                const trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n                    ref: child,\n                    count: 0,\n                };\n                trackedChild.count += 1;\n                this.subchannelChildren.set(child.id, trackedChild);\n                break;\n            }\n            case 'socket': {\n                const trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n                    ref: child,\n                    count: 0,\n                };\n                trackedChild.count += 1;\n                this.socketChildren.set(child.id, trackedChild);\n                break;\n            }\n        }\n    }\n    unrefChild(child) {\n        switch (child.kind) {\n            case 'channel': {\n                const trackedChild = this.channelChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.channelChildren.delete(child.id);\n                    }\n                    else {\n                        this.channelChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n            case 'subchannel': {\n                const trackedChild = this.subchannelChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.subchannelChildren.delete(child.id);\n                    }\n                    else {\n                        this.subchannelChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n            case 'socket': {\n                const trackedChild = this.socketChildren.get(child.id);\n                if (trackedChild !== undefined) {\n                    trackedChild.count -= 1;\n                    if (trackedChild.count === 0) {\n                        this.socketChildren.delete(child.id);\n                    }\n                    else {\n                        this.socketChildren.set(child.id, trackedChild);\n                    }\n                }\n                break;\n            }\n        }\n    }\n    getChildLists() {\n        const channels = [];\n        for (const { ref } of this.channelChildren.values()) {\n            channels.push(ref);\n        }\n        const subchannels = [];\n        for (const { ref } of this.subchannelChildren.values()) {\n            subchannels.push(ref);\n        }\n        const sockets = [];\n        for (const { ref } of this.socketChildren.values()) {\n            sockets.push(ref);\n        }\n        return { channels, subchannels, sockets };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n    constructor() {\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n    return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'channel' };\n    if (channelzEnabled) {\n        channels[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'subchannel' };\n    if (channelzEnabled) {\n        subchannels[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, kind: 'server' };\n    if (channelzEnabled) {\n        servers[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = { id, name, kind: 'socket' };\n    if (channelzEnabled) {\n        sockets[id] = { ref, getInfo };\n    }\n    return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n    switch (ref.kind) {\n        case 'channel':\n            delete channels[ref.id];\n            return;\n        case 'subchannel':\n            delete subchannels[ref.id];\n            return;\n        case 'server':\n            delete servers[ref.id];\n            return;\n        case 'socket':\n            delete sockets[ref.id];\n            return;\n    }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [(numberValue / 256) | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n    if (addressChunk === '') {\n        return [];\n    }\n    const bytePairs = addressChunk\n        .split(':')\n        .map(section => parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n    if ((0, net_1.isIPv4)(ipAddress)) {\n        return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n    }\n    else if ((0, net_1.isIPv6)(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf('::');\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = '';\n        }\n        else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n    }\n    else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch (state) {\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: 'CONNECTING',\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: 'IDLE',\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: 'READY',\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: 'SHUTDOWN',\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: 'TRANSIENT_FAILURE',\n            };\n        default:\n            return {\n                state: 'UNKNOWN',\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: (millisSinceEpoch / 1000) | 0,\n        nanos: (millisSinceEpoch % 1000) * 1000000,\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n        subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref)),\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = Number.parseInt(call.request.channel_id);\n    const channelEntry = channels[channelId];\n    if (channelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No channel data found for id ' + channelId,\n        });\n        return;\n    }\n    callback(null, { channel: getChannelMessage(channelEntry) });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_channel_id);\n    for (; i < channels.length; i++) {\n        const channelEntry = channels[i];\n        if (channelEntry === undefined) {\n            continue;\n        }\n        resultList.push(getChannelMessage(channelEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        channel: resultList,\n        end: i >= servers.length,\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref)),\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No server data found for id ' + serverId,\n        });\n        return;\n    }\n    callback(null, { server: getServerMessage(serverEntry) });\n}\nfunction GetServers(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_server_id);\n    for (; i < servers.length; i++) {\n        const serverEntry = servers[i];\n        if (serverEntry === undefined) {\n            continue;\n        }\n        resultList.push(getServerMessage(serverEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        server: resultList,\n        end: i >= servers.length,\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\n    const subchannelEntry = subchannels[subchannelId];\n    if (subchannelEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No subchannel data found for id ' + subchannelId,\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage(),\n        },\n        socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref)),\n    };\n    callback(null, { subchannel: subchannelMessage });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\n        return {\n            address: 'tcpip_address',\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port,\n            },\n        };\n    }\n    else {\n        return {\n            address: 'uds_address',\n            uds_address: {\n                filename: subchannelAddress.path,\n            },\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = Number.parseInt(call.request.socket_id);\n    const socketEntry = sockets[socketId];\n    if (socketEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No socket data found for id ' + socketId,\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security\n        ? {\n            model: 'tls',\n            tls: {\n                cipher_suite: resolvedInfo.security.cipherSuiteStandardName\n                    ? 'standard_name'\n                    : 'other_name',\n                standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n                other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n                local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n                remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined,\n            },\n        }\n        : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress\n            ? subchannelAddressToAddressMessage(resolvedInfo.localAddress)\n            : null,\n        remote: resolvedInfo.remoteAddress\n            ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress)\n            : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow\n                ? { value: resolvedInfo.localFlowControlWindow }\n                : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow\n                ? { value: resolvedInfo.remoteFlowControlWindow }\n                : null,\n        },\n    };\n    callback(null, { socket: socketMessage });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            code: constants_1.Status.NOT_FOUND,\n            details: 'No server data found for id ' + serverId,\n        });\n        return;\n    }\n    const startId = Number.parseInt(call.request.start_socket_id);\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n    const resultList = [];\n    let i = 0;\n    for (; i < allSockets.length; i++) {\n        if (allSockets[i].id >= startId) {\n            resultList.push(socketRefToMessage(allSockets[i]));\n            if (resultList.length >= maxResults) {\n                break;\n            }\n        }\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i >= allSockets.length,\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets,\n    };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */\n    const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync('channelz.proto', {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [`${__dirname}/../../proto`],\n    });\n    const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\n    loadedChannelzDefinition =\n        channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n    (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup;\n//# sourceMappingURL=channelz.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxhQUFhLEdBQUcsb0NBQW9DLEdBQUcsMkJBQTJCLEdBQUcsNkJBQTZCLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCLEdBQUcsa0NBQWtDLEdBQUcsK0JBQStCLEdBQUcsMkJBQTJCLEdBQUcsK0JBQStCLEdBQUcscUJBQXFCO0FBQ25WLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELGdCQUFnQixtQkFBTyxDQUFDLHNFQUFTO0FBQ2pDLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsMENBQTBDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQiwrQkFBK0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFNBQVM7QUFDVDtBQUNBLHFCQUFxQix1QkFBdUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNIQUNWO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24gPSBleHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBleHBvcnRzLnVucmVnaXN0ZXJDaGFubmVselJlZiA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNvY2tldCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNlcnZlciA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwgPSBleHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsID0gZXhwb3J0cy5DaGFubmVsekNhbGxUcmFja2VyID0gZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlciA9IGV4cG9ydHMuQ2hhbm5lbHpUcmFjZSA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGFkbWluXzEgPSByZXF1aXJlKFwiLi9hZG1pblwiKTtcbmNvbnN0IG1ha2VfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9tYWtlLWNsaWVudFwiKTtcbmZ1bmN0aW9uIGNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbm5lbF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJjaGFubmVsX2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lLFxuICAgIH07XG59XG5mdW5jdGlvbiBzZXJ2ZXJSZWZUb01lc3NhZ2UocmVmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VydmVyX2lkOiByZWYuaWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNvY2tldFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb2NrZXRfaWQ6IHJlZi5pZCxcbiAgICAgICAgbmFtZTogcmVmLm5hbWUsXG4gICAgfTtcbn1cbi8qKlxuICogVGhlIGxvb3NlIHVwcGVyIGJvdW5kIG9uIHRoZSBudW1iZXIgb2YgZXZlbnRzIHRoYXQgc2hvdWxkIGJlIHJldGFpbmVkIGluIGFcbiAqIHRyYWNlLiBUaGlzIG1heSBiZSBleGNlZWRlZCBieSB1cCB0byBhIGZhY3RvciBvZiAyLiBBcmJpdHJhcmlseSBjaG9zZW4gYXMgYVxuICogbnVtYmVyIHRoYXQgc2hvdWxkIGJlIGxhcmdlIGVub3VnaCB0byBjb250YWluIHRoZSByZWNlbnQgcmVsZXZhbnRcbiAqIGluZm9ybWF0aW9uLCBidXQgc21hbGwgZW5vdWdoIHRvIG5vdCB1c2UgZXhjZXNzaXZlIG1lbW9yeS5cbiAqL1xuY29uc3QgVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyA9IDMyO1xuY2xhc3MgQ2hhbm5lbHpUcmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuZXZlbnRzTG9nZ2VkID0gMDtcbiAgICAgICAgdGhpcy5jcmVhdGlvblRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGFkZFRyYWNlKHNldmVyaXR5LCBkZXNjcmlwdGlvbiwgY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaCh7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBzZXZlcml0eTogc2V2ZXJpdHksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcCxcbiAgICAgICAgICAgIGNoaWxkQ2hhbm5lbDogKGNoaWxkID09PSBudWxsIHx8IGNoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZC5raW5kKSA9PT0gJ2NoYW5uZWwnID8gY2hpbGQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGlsZFN1YmNoYW5uZWw6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQua2luZCkgPT09ICdzdWJjaGFubmVsJyA/IGNoaWxkIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2hlbmV2ZXIgdGhlIHRyYWNlIGFycmF5IGdldHMgdG9vIGxhcmdlLCBkaXNjYXJkIHRoZSBmaXJzdCBoYWxmXG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5sZW5ndGggPj0gVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyAqIDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMuc2xpY2UoVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgKz0gMTtcbiAgICB9XG4gICAgZ2V0VHJhY2VNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRpb25fdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcCh0aGlzLmNyZWF0aW9uVGltZXN0YW1wKSxcbiAgICAgICAgICAgIG51bV9ldmVudHNfbG9nZ2VkOiB0aGlzLmV2ZW50c0xvZ2dlZCxcbiAgICAgICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMubWFwKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZXZlbnQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5OiBldmVudC5zZXZlcml0eSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChldmVudC50aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsX3JlZjogZXZlbnQuY2hpbGRDaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNoYW5uZWxSZWZUb01lc3NhZ2UoZXZlbnQuY2hpbGRDaGFubmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsX3JlZjogZXZlbnQuY2hpbGRTdWJjaGFubmVsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UoZXZlbnQuY2hpbGRTdWJjaGFubmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6VHJhY2UgPSBDaGFubmVselRyYWNlO1xuY2xhc3MgQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHJlZkNoaWxkKGNoaWxkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gKF9hID0gdGhpcy5jaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3N1YmNoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gKF9iID0gdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRyYWNrZWRDaGlsZC5jb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NvY2tldCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSAoX2MgPSB0aGlzLnNvY2tldENoaWxkcmVuLmdldChjaGlsZC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmOiBjaGlsZCxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZkNoaWxkKGNoaWxkKSB7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja2VkQ2hpbGQgPSB0aGlzLmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsQ2hpbGRyZW4uZGVsZXRlKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3N1YmNoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzb2NrZXQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZENoaWxkID0gdGhpcy5zb2NrZXRDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbi5kZWxldGUoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hpbGRMaXN0cygpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IHJlZiB9IG9mIHRoaXMuY2hhbm5lbENoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjaGFubmVscy5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IHJlZiB9IG9mIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVscy5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5zb2NrZXRDaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0cy5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbm5lbHMsIHN1YmNoYW5uZWxzLCBzb2NrZXRzIH07XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlciA9IENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyO1xuY2xhc3MgQ2hhbm5lbHpDYWxsVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCA9IDA7XG4gICAgICAgIHRoaXMuY2FsbHNGYWlsZWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG51bGw7XG4gICAgfVxuICAgIGFkZENhbGxTdGFydGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzU3RhcnRlZCArPSAxO1xuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdWNjZWVkZWQgKz0gMTtcbiAgICB9XG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc0ZhaWxlZCArPSAxO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDYWxsVHJhY2tlciA9IENoYW5uZWx6Q2FsbFRyYWNrZXI7XG5sZXQgbmV4dElkID0gMTtcbmZ1bmN0aW9uIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gbmV4dElkKys7XG59XG5jb25zdCBjaGFubmVscyA9IFtdO1xuY29uc3Qgc3ViY2hhbm5lbHMgPSBbXTtcbmNvbnN0IHNlcnZlcnMgPSBbXTtcbmNvbnN0IHNvY2tldHMgPSBbXTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsKG5hbWUsIGdldEluZm8sIGNoYW5uZWx6RW5hYmxlZCkge1xuICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgcmVmID0geyBpZCwgbmFtZSwga2luZDogJ2NoYW5uZWwnIH07XG4gICAgaWYgKGNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICBjaGFubmVsc1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCA9IHJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnc3ViY2hhbm5lbCcgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIHN1YmNoYW5uZWxzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsID0gcmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWw7XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U2VydmVyKGdldEluZm8sIGNoYW5uZWx6RW5hYmxlZCkge1xuICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgcmVmID0geyBpZCwga2luZDogJ3NlcnZlcicgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIHNlcnZlcnNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNlcnZlciA9IHJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXI7XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U29ja2V0KG5hbWUsIGdldEluZm8sIGNoYW5uZWx6RW5hYmxlZCkge1xuICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgcmVmID0geyBpZCwgbmFtZSwga2luZDogJ3NvY2tldCcgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIHNvY2tldHNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNvY2tldCA9IHJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQ7XG5mdW5jdGlvbiB1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYocmVmKSB7XG4gICAgc3dpdGNoIChyZWYua2luZCkge1xuICAgICAgICBjYXNlICdjaGFubmVsJzpcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFubmVsc1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzdWJjaGFubmVsJzpcbiAgICAgICAgICAgIGRlbGV0ZSBzdWJjaGFubmVsc1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzZXJ2ZXInOlxuICAgICAgICAgICAgZGVsZXRlIHNlcnZlcnNbcmVmLmlkXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnc29ja2V0JzpcbiAgICAgICAgICAgIGRlbGV0ZSBzb2NrZXRzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZXhwb3J0cy51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYgPSB1bnJlZ2lzdGVyQ2hhbm5lbHpSZWY7XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHNlY3Rpb24gb2YgYW4gSVB2NiBhZGRyZXNzIGFzIHR3byBieXRlc1xuICogQHBhcmFtIGFkZHJlc3NTZWN0aW9uIEEgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGxlbmd0aCB1cCB0byA0XG4gKiBAcmV0dXJucyBUaGUgcGFpciBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VJUHY2U2VjdGlvbihhZGRyZXNzU2VjdGlvbikge1xuICAgIGNvbnN0IG51bWJlclZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGFkZHJlc3NTZWN0aW9uLCAxNik7XG4gICAgcmV0dXJuIFsobnVtYmVyVmFsdWUgLyAyNTYpIHwgMCwgbnVtYmVyVmFsdWUgJSAyNTZdO1xufVxuLyoqXG4gKiBQYXJzZSBhIGNodW5rIG9mIGFuIElQdjYgYWRkcmVzcyBzdHJpbmcgdG8gc29tZSBudW1iZXIgb2YgYnl0ZXNcbiAqIEBwYXJhbSBhZGRyZXNzQ2h1bmsgU29tZSBudW1iZXIgb2Ygc2VnbWVudHMgb2YgdXAgdG8gNCBoZXhhZGVjaW1hbFxuICogICBjaGFyYWN0ZXJzIGVhY2gsIGpvaW5lZCBieSBjb2xvbnMuXG4gKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIGNodW5rXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSVB2NkNodW5rKGFkZHJlc3NDaHVuaykge1xuICAgIGlmIChhZGRyZXNzQ2h1bmsgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZVBhaXJzID0gYWRkcmVzc0NodW5rXG4gICAgICAgIC5zcGxpdCgnOicpXG4gICAgICAgIC5tYXAoc2VjdGlvbiA9PiBwYXJzZUlQdjZTZWN0aW9uKHNlY3Rpb24pKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdCguLi5ieXRlUGFpcnMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBJUHY0IG9yIElQdjYgYWRkcmVzcyBmcm9tIHN0cmluZyByZXByZXNlbnRhdGlvbiB0byBiaW5hcnlcbiAqIHJlcHJlc2VudGF0aW9uXG4gKiBAcGFyYW0gaXBBZGRyZXNzIGFuIElQIGFkZHJlc3MgaW4gc3RhbmRhcmQgSVB2NCBvciBJUHY2IHRleHQgZm9ybWF0XG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpcEFkZHJlc3NTdHJpbmdUb0J1ZmZlcihpcEFkZHJlc3MpIHtcbiAgICBpZiAoKDAsIG5ldF8xLmlzSVB2NCkoaXBBZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oVWludDhBcnJheS5mcm9tKGlwQWRkcmVzcy5zcGxpdCgnLicpLm1hcChzZWdtZW50ID0+IE51bWJlci5wYXJzZUludChzZWdtZW50KSkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKDAsIG5ldF8xLmlzSVB2NikoaXBBZGRyZXNzKSkge1xuICAgICAgICBsZXQgbGVmdFNlY3Rpb247XG4gICAgICAgIGxldCByaWdodFNlY3Rpb247XG4gICAgICAgIGNvbnN0IGRvdWJsZUNvbG9uSW5kZXggPSBpcEFkZHJlc3MuaW5kZXhPZignOjonKTtcbiAgICAgICAgaWYgKGRvdWJsZUNvbG9uSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICBsZWZ0U2VjdGlvbiA9IGlwQWRkcmVzcztcbiAgICAgICAgICAgIHJpZ2h0U2VjdGlvbiA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdFNlY3Rpb24gPSBpcEFkZHJlc3Muc3Vic3RyaW5nKDAsIGRvdWJsZUNvbG9uSW5kZXgpO1xuICAgICAgICAgICAgcmlnaHRTZWN0aW9uID0gaXBBZGRyZXNzLnN1YnN0cmluZyhkb3VibGVDb2xvbkluZGV4ICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBhcnNlSVB2NkNodW5rKGxlZnRTZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0QnVmZmVyID0gQnVmZmVyLmZyb20ocGFyc2VJUHY2Q2h1bmsocmlnaHRTZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IG1pZGRsZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiAtIGxlZnRCdWZmZXIubGVuZ3RoIC0gcmlnaHRCdWZmZXIubGVuZ3RoLCAwKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2xlZnRCdWZmZXIsIG1pZGRsZUJ1ZmZlciwgcmlnaHRCdWZmZXJdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHN0YXRlKSB7XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnQ09OTkVDVElORycsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnSURMRScsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1JFQURZJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV046XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnU0hVVERPV04nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdUUkFOU0lFTlRfRkFJTFVSRScsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1VOS05PV04nLFxuICAgICAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBkYXRlVG9Qcm90b1RpbWVzdGFtcChkYXRlKSB7XG4gICAgaWYgKCFkYXRlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBtaWxsaXNTaW5jZUVwb2NoID0gZGF0ZS5nZXRUaW1lKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogKG1pbGxpc1NpbmNlRXBvY2ggLyAxMDAwKSB8IDAsXG4gICAgICAgIG5hbm9zOiAobWlsbGlzU2luY2VFcG9jaCAlIDEwMDApICogMTAwMDAwMCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2hhbm5lbE1lc3NhZ2UoY2hhbm5lbEVudHJ5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gY2hhbm5lbEVudHJ5LmdldEluZm8oKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWY6IGNoYW5uZWxSZWZUb01lc3NhZ2UoY2hhbm5lbEVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRhcmdldDogcmVzb2x2ZWRJbmZvLnRhcmdldCxcbiAgICAgICAgICAgIHN0YXRlOiBjb25uZWN0aXZpdHlTdGF0ZVRvTWVzc2FnZShyZXNvbHZlZEluZm8uc3RhdGUpLFxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKSxcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbm5lbF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5jaGFubmVscy5tYXAocmVmID0+IGNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSksXG4gICAgICAgIHN1YmNoYW5uZWxfcmVmOiByZXNvbHZlZEluZm8uY2hpbGRyZW4uc3ViY2hhbm5lbHMubWFwKHJlZiA9PiBzdWJjaGFubmVsUmVmVG9NZXNzYWdlKHJlZikpLFxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRDaGFubmVsKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgY2hhbm5lbElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5jaGFubmVsX2lkKTtcbiAgICBjb25zdCBjaGFubmVsRW50cnkgPSBjaGFubmVsc1tjaGFubmVsSWRdO1xuICAgIGlmIChjaGFubmVsRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgZGV0YWlsczogJ05vIGNoYW5uZWwgZGF0YSBmb3VuZCBmb3IgaWQgJyArIGNoYW5uZWxJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgeyBjaGFubmVsOiBnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpIH0pO1xufVxuZnVuY3Rpb24gR2V0VG9wQ2hhbm5lbHMoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtYXhSZXN1bHRzID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cyk7XG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdO1xuICAgIGxldCBpID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9jaGFubmVsX2lkKTtcbiAgICBmb3IgKDsgaSA8IGNoYW5uZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxFbnRyeSA9IGNoYW5uZWxzW2ldO1xuICAgICAgICBpZiAoY2hhbm5lbEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRDaGFubmVsTWVzc2FnZShjaGFubmVsRW50cnkpKTtcbiAgICAgICAgaWYgKHJlc3VsdExpc3QubGVuZ3RoID49IG1heFJlc3VsdHMpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgY2hhbm5lbDogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpID49IHNlcnZlcnMubGVuZ3RoLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkge1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWY6IHNlcnZlclJlZlRvTWVzc2FnZShzZXJ2ZXJFbnRyeS5yZWYpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxuICAgICAgICB9LFxuICAgICAgICBsaXN0ZW5fc29ja2V0OiByZXNvbHZlZEluZm8ubGlzdGVuZXJDaGlsZHJlbi5zb2NrZXRzLm1hcChyZWYgPT4gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikpLFxuICAgIH07XG59XG5mdW5jdGlvbiBHZXRTZXJ2ZXIoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZXJ2ZXJJZCA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc2VydmVyX2lkKTtcbiAgICBjb25zdCBzZXJ2ZXJFbnRyeSA9IHNlcnZlcnNbc2VydmVySWRdO1xuICAgIGlmIChzZXJ2ZXJFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICBkZXRhaWxzOiAnTm8gc2VydmVyIGRhdGEgZm91bmQgZm9yIGlkICcgKyBzZXJ2ZXJJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwgeyBzZXJ2ZXI6IGdldFNlcnZlck1lc3NhZ2Uoc2VydmVyRW50cnkpIH0pO1xufVxuZnVuY3Rpb24gR2V0U2VydmVycyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGkgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnN0YXJ0X3NlcnZlcl9pZCk7XG4gICAgZm9yICg7IGkgPCBzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gc2VydmVyc1tpXTtcbiAgICAgICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSk7XG4gICAgICAgIGlmIChyZXN1bHRMaXN0Lmxlbmd0aCA+PSBtYXhSZXN1bHRzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIHNlcnZlcjogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpID49IHNlcnZlcnMubGVuZ3RoLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gR2V0U3ViY2hhbm5lbChjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHN1YmNoYW5uZWxJZCA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc3ViY2hhbm5lbF9pZCk7XG4gICAgY29uc3Qgc3ViY2hhbm5lbEVudHJ5ID0gc3ViY2hhbm5lbHNbc3ViY2hhbm5lbElkXTtcbiAgICBpZiAoc3ViY2hhbm5lbEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzdWJjaGFubmVsIGRhdGEgZm91bmQgZm9yIGlkICcgKyBzdWJjaGFubmVsSWQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHN1YmNoYW5uZWxFbnRyeS5nZXRJbmZvKCk7XG4gICAgY29uc3Qgc3ViY2hhbm5lbE1lc3NhZ2UgPSB7XG4gICAgICAgIHJlZjogc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShzdWJjaGFubmVsRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpLFxuICAgICAgICB9LFxuICAgICAgICBzb2NrZXRfcmVmOiByZXNvbHZlZEluZm8uY2hpbGRyZW4uc29ja2V0cy5tYXAocmVmID0+IHNvY2tldFJlZlRvTWVzc2FnZShyZWYpKSxcbiAgICB9O1xuICAgIGNhbGxiYWNrKG51bGwsIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbE1lc3NhZ2UgfSk7XG59XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvQWRkcmVzc01lc3NhZ2Uoc3ViY2hhbm5lbEFkZHJlc3MpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKShzdWJjaGFubmVsQWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICd0Y3BpcF9hZGRyZXNzJyxcbiAgICAgICAgICAgIHRjcGlwX2FkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBpcF9hZGRyZXNzOiAoX2EgPSBpcEFkZHJlc3NTdHJpbmdUb0J1ZmZlcihzdWJjaGFubmVsQWRkcmVzcy5ob3N0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBvcnQ6IHN1YmNoYW5uZWxBZGRyZXNzLnBvcnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICd1ZHNfYWRkcmVzcycsXG4gICAgICAgICAgICB1ZHNfYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBzdWJjaGFubmVsQWRkcmVzcy5wYXRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBHZXRTb2NrZXQoY2FsbCwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IHNvY2tldElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zb2NrZXRfaWQpO1xuICAgIGNvbnN0IHNvY2tldEVudHJ5ID0gc29ja2V0c1tzb2NrZXRJZF07XG4gICAgaWYgKHNvY2tldEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzb2NrZXQgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNvY2tldElkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzb2NrZXRFbnRyeS5nZXRJbmZvKCk7XG4gICAgY29uc3Qgc2VjdXJpdHlNZXNzYWdlID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5XG4gICAgICAgID8ge1xuICAgICAgICAgICAgbW9kZWw6ICd0bHMnLFxuICAgICAgICAgICAgdGxzOiB7XG4gICAgICAgICAgICAgICAgY2lwaGVyX3N1aXRlOiByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWVcbiAgICAgICAgICAgICAgICAgICAgPyAnc3RhbmRhcmRfbmFtZSdcbiAgICAgICAgICAgICAgICAgICAgOiAnb3RoZXJfbmFtZScsXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRfbmFtZTogKF9hID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlU3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgb3RoZXJfbmFtZTogKF9iID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlT3RoZXJOYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgbG9jYWxfY2VydGlmaWNhdGU6IChfYyA9IHJlc29sdmVkSW5mby5zZWN1cml0eS5sb2NhbENlcnRpZmljYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVtb3RlX2NlcnRpZmljYXRlOiAoX2QgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkucmVtb3RlQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHNvY2tldE1lc3NhZ2UgPSB7XG4gICAgICAgIHJlZjogc29ja2V0UmVmVG9NZXNzYWdlKHNvY2tldEVudHJ5LnJlZiksXG4gICAgICAgIGxvY2FsOiByZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzXG4gICAgICAgICAgICA/IHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShyZXNvbHZlZEluZm8ubG9jYWxBZGRyZXNzKVxuICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICByZW1vdGU6IHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzXG4gICAgICAgICAgICA/IHN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZShyZXNvbHZlZEluZm8ucmVtb3RlQWRkcmVzcylcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgcmVtb3RlX25hbWU6IChfZSA9IHJlc29sdmVkSW5mby5yZW1vdGVOYW1lKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQsXG4gICAgICAgIHNlY3VyaXR5OiBzZWN1cml0eU1lc3NhZ2UsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIGtlZXBfYWxpdmVzX3NlbnQ6IHJlc29sdmVkSW5mby5rZWVwQWxpdmVzU2VudCxcbiAgICAgICAgICAgIHN0cmVhbXNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLnN0cmVhbXNTdGFydGVkLFxuICAgICAgICAgICAgc3RyZWFtc19zdWNjZWVkZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zU3VjY2VlZGVkLFxuICAgICAgICAgICAgc3RyZWFtc19mYWlsZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zRmFpbGVkLFxuICAgICAgICAgICAgbGFzdF9sb2NhbF9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxhc3RfcmVtb3RlX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wKSxcbiAgICAgICAgICAgIG1lc3NhZ2VzX3JlY2VpdmVkOiByZXNvbHZlZEluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIG1lc3NhZ2VzX3NlbnQ6IHJlc29sdmVkSW5mby5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2VfcmVjZWl2ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsYXN0X21lc3NhZ2Vfc2VudF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbG9jYWxfZmxvd19jb250cm9sX3dpbmRvdzogcmVzb2x2ZWRJbmZvLmxvY2FsRmxvd0NvbnRyb2xXaW5kb3dcbiAgICAgICAgICAgICAgICA/IHsgdmFsdWU6IHJlc29sdmVkSW5mby5sb2NhbEZsb3dDb250cm9sV2luZG93IH1cbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZW1vdGVfZmxvd19jb250cm9sX3dpbmRvdzogcmVzb2x2ZWRJbmZvLnJlbW90ZUZsb3dDb250cm9sV2luZG93XG4gICAgICAgICAgICAgICAgPyB7IHZhbHVlOiByZXNvbHZlZEluZm8ucmVtb3RlRmxvd0NvbnRyb2xXaW5kb3cgfVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGNhbGxiYWNrKG51bGwsIHsgc29ja2V0OiBzb2NrZXRNZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gR2V0U2VydmVyU29ja2V0cyhjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHNlcnZlcklkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zZXJ2ZXJfaWQpO1xuICAgIGNvbnN0IHNlcnZlckVudHJ5ID0gc2VydmVyc1tzZXJ2ZXJJZF07XG4gICAgaWYgKHNlcnZlckVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgIGRldGFpbHM6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydElkID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9zb2NrZXRfaWQpO1xuICAgIGNvbnN0IG1heFJlc3VsdHMgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0Lm1heF9yZXN1bHRzKTtcbiAgICBjb25zdCByZXNvbHZlZEluZm8gPSBzZXJ2ZXJFbnRyeS5nZXRJbmZvKCk7XG4gICAgLy8gSWYgd2Ugd2FudGVkIHRvIGluY2x1ZGUgbGlzdGVuZXIgc29ja2V0cyBpbiB0aGUgcmVzdWx0LCB0aGlzIGxpbmUgd291bGRcbiAgICAvLyBpbnN0ZWFkIHNheVxuICAgIC8vIGNvbnN0IGFsbFNvY2tldHMgPSByZXNvbHZlZEluZm8ubGlzdGVuZXJDaGlsZHJlbi5zb2NrZXRzLmNvbmNhdChyZXNvbHZlZEluZm8uc2Vzc2lvbkNoaWxkcmVuLnNvY2tldHMpLnNvcnQoKHJlZjEsIHJlZjIpID0+IHJlZjEuaWQgLSByZWYyLmlkKTtcbiAgICBjb25zdCBhbGxTb2NrZXRzID0gcmVzb2x2ZWRJbmZvLnNlc3Npb25DaGlsZHJlbi5zb2NrZXRzLnNvcnQoKHJlZjEsIHJlZjIpID0+IHJlZjEuaWQgLSByZWYyLmlkKTtcbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgYWxsU29ja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYWxsU29ja2V0c1tpXS5pZCA+PSBzdGFydElkKSB7XG4gICAgICAgICAgICByZXN1bHRMaXN0LnB1c2goc29ja2V0UmVmVG9NZXNzYWdlKGFsbFNvY2tldHNbaV0pKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRMaXN0Lmxlbmd0aCA+PSBtYXhSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICBzb2NrZXRfcmVmOiByZXN1bHRMaXN0LFxuICAgICAgICBlbmQ6IGkgPj0gYWxsU29ja2V0cy5sZW5ndGgsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsekhhbmRsZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIEdldENoYW5uZWwsXG4gICAgICAgIEdldFRvcENoYW5uZWxzLFxuICAgICAgICBHZXRTZXJ2ZXIsXG4gICAgICAgIEdldFNlcnZlcnMsXG4gICAgICAgIEdldFN1YmNoYW5uZWwsXG4gICAgICAgIEdldFNvY2tldCxcbiAgICAgICAgR2V0U2VydmVyU29ja2V0cyxcbiAgICB9O1xufVxuZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZ2V0Q2hhbm5lbHpIYW5kbGVycztcbmxldCBsb2FkZWRDaGFubmVsekRlZmluaXRpb24gPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbigpIHtcbiAgICBpZiAobG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBsb2FkZWRDaGFubmVsekRlZmluaXRpb247XG4gICAgfVxuICAgIC8qIFRoZSBwdXJwb3NlIG9mIHRoaXMgY29tcGxleGl0eSBpcyB0byBhdm9pZCBsb2FkaW5nIEBncnBjL3Byb3RvLWxvYWRlciBhdFxuICAgICAqIHJ1bnRpbWUgZm9yIHVzZXJzIHdobyB3aWxsIG5vdCB1c2UvZW5hYmxlIGNoYW5uZWx6LiAqL1xuICAgIGNvbnN0IGxvYWRlckxvYWRTeW5jID0gcmVxdWlyZSgnQGdycGMvcHJvdG8tbG9hZGVyJylcbiAgICAgICAgLmxvYWRTeW5jO1xuICAgIGNvbnN0IGxvYWRlZFByb3RvID0gbG9hZGVyTG9hZFN5bmMoJ2NoYW5uZWx6LnByb3RvJywge1xuICAgICAgICBrZWVwQ2FzZTogdHJ1ZSxcbiAgICAgICAgbG9uZ3M6IFN0cmluZyxcbiAgICAgICAgZW51bXM6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdHM6IHRydWUsXG4gICAgICAgIG9uZW9mczogdHJ1ZSxcbiAgICAgICAgaW5jbHVkZURpcnM6IFtgJHtfX2Rpcm5hbWV9Ly4uLy4uL3Byb3RvYF0sXG4gICAgfSk7XG4gICAgY29uc3QgY2hhbm5lbHpHcnBjT2JqZWN0ID0gKDAsIG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uKShsb2FkZWRQcm90byk7XG4gICAgbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uID1cbiAgICAgICAgY2hhbm5lbHpHcnBjT2JqZWN0LmdycGMuY2hhbm5lbHoudjEuQ2hhbm5lbHouc2VydmljZTtcbiAgICByZXR1cm4gbG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uO1xufVxuZXhwb3J0cy5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uID0gZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbjtcbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCBhZG1pbl8xLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlKShnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uLCBnZXRDaGFubmVsekhhbmRsZXJzKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYW5uZWx6LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_interface_1 = __webpack_require__(/*! ./call-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-interface.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nclass InterceptorConfigurationError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'InterceptorConfigurationError';\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor() {\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status,\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor() {\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel,\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener = {\n    onReceiveMetadata: (metadata, next) => {\n        next(metadata);\n    },\n    onReceiveMessage: (message, next) => {\n        next(message);\n    },\n    onReceiveStatus: (status, next) => {\n        next(status);\n    },\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester = {\n    start: (metadata, listener, next) => {\n        next(metadata, listener);\n    },\n    sendMessage: (message, next) => {\n        next(message);\n    },\n    halfClose: next => {\n        next();\n    },\n    cancel: next => {\n        next();\n    },\n};\nclass InterceptingCall {\n    constructor(nextCall, requester) {\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */\n        this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */\n        this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */\n        this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel,\n            };\n        }\n        else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(() => {\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata => { }),\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message => { }),\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status => { }),\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if ((0, call_interface_1.isInterceptingListener)(listener)) {\n                finalInterceptingListener = listener;\n            }\n            else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus,\n                };\n                finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, finalMessage => {\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            }\n            else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(() => {\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            }\n            else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall {\n    constructor(call, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition) {\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        }\n        catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: metadata => {\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: message => {\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                }\n                catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,\n                        metadata: new metadata_1.Metadata(),\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: status => {\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                }\n                else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            },\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition) {\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata => { }),\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message) => {\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status) => {\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            },\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    }\n    else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 &&\n        interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' +\n            'to the client constructor. Only one of these is allowed.');\n    }\n    if (interceptorArgs.callInterceptors.length > 0 &&\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' +\n            'options. Only one of these is allowed.');\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 ||\n        interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = []\n            .concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition)))\n            .filter(interceptor => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    else {\n        interceptors = []\n            .concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition)))\n            .filter(interceptor => interceptor);\n        // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition,\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */\n    const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n        return currentOptions => nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall;\n//# sourceMappingURL=client-interceptors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHdCQUF3QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHFDQUFxQztBQUNuSixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb1JBQW9SO0FBQ3BSLGlSQUFpUjtBQUNqUiw4UUFBOFE7QUFDOVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxnQ0FBZ0M7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGdDQUFnQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb09BQW9PO0FBQ3BPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC1pbnRlcmNlcHRvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuUmVxdWVzdGVyQnVpbGRlciA9IGV4cG9ydHMuTGlzdGVuZXJCdWlsZGVyID0gZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IHZvaWQgMDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNhbGxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9jYWxsLWludGVyZmFjZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9yXCIpO1xuLyoqXG4gKiBFcnJvciBjbGFzcyBhc3NvY2lhdGVkIHdpdGggcGFzc2luZyBib3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JcbiAqIHByb3ZpZGVycyB0byBhIGNsaWVudCBjb25zdHJ1Y3RvciBvciBhcyBjYWxsIG9wdGlvbnMuXG4gKi9cbmNsYXNzIEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcic7XG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yID0gSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3I7XG5jbGFzcyBMaXN0ZW5lckJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB3aXRoT25SZWNlaXZlTWV0YWRhdGEob25SZWNlaXZlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG9uUmVjZWl2ZU1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZU1lc3NhZ2Uob25SZWNlaXZlTWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBvblJlY2VpdmVNZXNzYWdlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZVN0YXR1cyhvblJlY2VpdmVTdGF0dXMpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBvblJlY2VpdmVTdGF0dXM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IExpc3RlbmVyQnVpbGRlcjtcbmNsYXNzIFJlcXVlc3RlckJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGFsZkNsb3NlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhbmNlbCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2l0aFN0YXJ0KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhTZW5kTWVzc2FnZShzZW5kTWVzc2FnZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBzZW5kTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhIYWxmQ2xvc2UoaGFsZkNsb3NlKSB7XG4gICAgICAgIHRoaXMuaGFsZkNsb3NlID0gaGFsZkNsb3NlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd2l0aENhbmNlbChjYW5jZWwpIHtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBidWlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIGhhbGZDbG9zZTogdGhpcy5oYWxmQ2xvc2UsXG4gICAgICAgICAgICBjYW5jZWw6IHRoaXMuY2FuY2VsLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuUmVxdWVzdGVyQnVpbGRlciA9IFJlcXVlc3RlckJ1aWxkZXI7XG4vKipcbiAqIEEgTGlzdGVuZXIgd2l0aCBhIGRlZmF1bHQgcGFzcy10aHJvdWdoIGltcGxlbWVudGF0aW9uIG9mIGVhY2ggbWV0aG9kLiBVc2VkXG4gKiBmb3IgZmlsbGluZyBvdXQgTGlzdGVuZXJzIHdpdGggc29tZSBtZXRob2RzIG9taXR0ZWQuXG4gKi9cbmNvbnN0IGRlZmF1bHRMaXN0ZW5lciA9IHtcbiAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWV0YWRhdGEpO1xuICAgIH0sXG4gICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXNzYWdlKTtcbiAgICB9LFxuICAgIG9uUmVjZWl2ZVN0YXR1czogKHN0YXR1cywgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KHN0YXR1cyk7XG4gICAgfSxcbn07XG4vKipcbiAqIEEgUmVxdWVzdGVyIHdpdGggYSBkZWZhdWx0IHBhc3MtdGhyb3VnaCBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIG1ldGhvZC4gVXNlZFxuICogZm9yIGZpbGxpbmcgb3V0IFJlcXVlc3RlcnMgd2l0aCBzb21lIG1ldGhvZHMgb21pdHRlZC5cbiAqL1xuY29uc3QgZGVmYXVsdFJlcXVlc3RlciA9IHtcbiAgICBzdGFydDogKG1ldGFkYXRhLCBsaXN0ZW5lciwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1ldGFkYXRhLCBsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBzZW5kTWVzc2FnZTogKG1lc3NhZ2UsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXNzYWdlKTtcbiAgICB9LFxuICAgIGhhbGZDbG9zZTogbmV4dCA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxuICAgIGNhbmNlbDogbmV4dCA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxufTtcbmNsYXNzIEludGVyY2VwdGluZ0NhbGwge1xuICAgIGNvbnN0cnVjdG9yKG5leHRDYWxsLCByZXF1ZXN0ZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICB0aGlzLm5leHRDYWxsID0gbmV4dENhbGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBtZXRhZGF0YSBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHJlcXVlc3RlcidzIHN0YXJ0XG4gICAgICAgICAqIG1ldGhvZCBidXQgaXQgaGFzIG5vdCBiZWVuIHBhc3NlZCB0byB0aGUgY29ycmVzcG9uZGluZyBuZXh0IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWVzc2FnZSBjb250ZXh0IGZvciBhIHBlbmRpbmcgbWVzc2FnZSB0aGF0IGlzIHdhaXRpbmcgZm9yXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIG1lc3NhZ2UgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSByZXF1ZXN0ZXIncyBzZW5kTWVzc2FnZVxuICAgICAgICAgKiBtZXRob2QgYnV0IGl0IGhhcyBub3QgYmVlbiBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmcgbmV4dCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBzdGF0dXMgd2FzIHJlY2VpdmVkIGJ1dCBjb3VsZCBub3QgYmUgcHJvcGFnYXRlZCBiZWNhdXNlXG4gICAgICAgICAqIGEgbWVzc2FnZSB3YXMgc3RpbGwgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIGlmIChyZXF1ZXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdGVyID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiAoX2EgPSByZXF1ZXN0ZXIuc3RhcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRlZmF1bHRSZXF1ZXN0ZXIuc3RhcnQsXG4gICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChfYiA9IHJlcXVlc3Rlci5zZW5kTWVzc2FnZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVmYXVsdFJlcXVlc3Rlci5zZW5kTWVzc2FnZSxcbiAgICAgICAgICAgICAgICBoYWxmQ2xvc2U6IChfYyA9IHJlcXVlc3Rlci5oYWxmQ2xvc2UpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRSZXF1ZXN0ZXIuaGFsZkNsb3NlLFxuICAgICAgICAgICAgICAgIGNhbmNlbDogKF9kID0gcmVxdWVzdGVyLmNhbmNlbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZGVmYXVsdFJlcXVlc3Rlci5jYW5jZWwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSBkZWZhdWx0UmVxdWVzdGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLmNhbmNlbCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdNZXNzYWdlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCwgdGhpcy5wZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgaW50ZXJjZXB0aW5nTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGNvbnN0IGZ1bGxJbnRlcmNlcHRpbmdMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2IgPSAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKG1ldGFkYXRhID0+IHsgfSksXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAoX2QgPSAoX2MgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAobWVzc2FnZSA9PiB7IH0pLFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoX2YgPSAoX2UgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IChzdGF0dXMgPT4geyB9KSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zdGFydChtZXRhZGF0YSwgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyLCAobWQsIGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgZmluYWxJbnRlcmNlcHRpbmdMaXN0ZW5lcjtcbiAgICAgICAgICAgIGlmICgoMCwgY2FsbF9pbnRlcmZhY2VfMS5pc0ludGVyY2VwdGluZ0xpc3RlbmVyKShsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2EgPSBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAoX2IgPSBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoX2MgPSBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbmV3IGNhbGxfaW50ZXJmYWNlXzEuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsKGZ1bGxMaXN0ZW5lciwgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnQobWQsIGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zZW5kTWVzc2FnZShtZXNzYWdlLCBmaW5hbE1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZUNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIGZpbmFsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ0hhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7fSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbC5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgaGFsZkNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5oYWxmQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhIHx8IHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gSW50ZXJjZXB0aW5nQ2FsbDtcbmZ1bmN0aW9uIGdldENhbGwoY2hhbm5lbCwgcGF0aCwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGVhZGxpbmUgPSAoX2EgPSBvcHRpb25zLmRlYWRsaW5lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcbiAgICBjb25zdCBob3N0ID0gb3B0aW9ucy5ob3N0O1xuICAgIGNvbnN0IHBhcmVudCA9IChfYiA9IG9wdGlvbnMucGFyZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgIGNvbnN0IHByb3BhZ2F0ZUZsYWdzID0gb3B0aW9ucy5wcm9wYWdhdGVfZmxhZ3M7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzO1xuICAgIGNvbnN0IGNhbGwgPSBjaGFubmVsLmNyZWF0ZUNhbGwocGF0aCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudCwgcHJvcGFnYXRlRmxhZ3MpO1xuICAgIGlmIChjcmVkZW50aWFscykge1xuICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGw7XG59XG4vKipcbiAqIEludGVyY2VwdGluZ0NhbGwgaW1wbGVtZW50YXRpb24gdGhhdCBkaXJlY3RseSBvd25zIHRoZSB1bmRlcmx5aW5nIENhbGxcbiAqIG9iamVjdCBhbmQgaGFuZGxlcyBzZXJpYWxpemF0aW9uIGFuZCBkZXNlcmFpemxpYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG1ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRob2REZWZpbml0aW9uID0gbWV0aG9kRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHRoaXMubWV0aG9kRGVmaW5pdGlvbi5yZXF1ZXN0U2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGBSZXF1ZXN0IG1lc3NhZ2Ugc2VyaWFsaXphdGlvbiBmYWlsdXJlOiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZSl9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgc2VyaWFsaXplZCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe30sIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgaW50ZXJjZXB0aW5nTGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IHJlYWRFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FsbC5zdGFydChtZXRhZGF0YSwge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IG1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGxldCBkZXNlcmlhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemVkID0gdGhpcy5tZXRob2REZWZpbml0aW9uLnJlc3BvbnNlRGVzZXJpYWxpemUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZXNwb25zZSBtZXNzYWdlIHBhcnNpbmcgZXJyb3I6ICR7KDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbC5jYW5jZWxXaXRoU3RhdHVzKHJlYWRFcnJvci5jb2RlLCByZWFkRXJyb3IuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCBkZXNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIHJlYWRFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChpbnRlcmNlcHRpbmdMaXN0ZW5lciwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLmNhbGwuc3RhcnRSZWFkKCk7XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jYWxsLmhhbGZDbG9zZSgpO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZUludGVyY2VwdGluZ0NhbGwgd2l0aCBzcGVjaWFsLWNhc2VkIGJlaGF2aW9yIGZvciBtZXRob2RzIHdpdGggdW5hcnlcbiAqIHJlc3BvbnNlcy5cbiAqL1xuY2xhc3MgQmFzZVVuYXJ5SW50ZXJjZXB0aW5nQ2FsbCBleHRlbmRzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgc3VwZXIoY2FsbCwgbWV0aG9kRGVmaW5pdGlvbik7XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVjZWl2ZWRNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2IgPSAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iaW5kKGxpc3RlbmVyKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogKG1ldGFkYXRhID0+IHsgfSksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9iID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwobGlzdGVuZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBzdXBlci5zdGFydChtZXRhZGF0YSwgd3JhcHBlckxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZUludGVyY2VwdGluZ0NhbGwgd2l0aCBzcGVjaWFsLWNhc2VkIGJlaGF2aW9yIGZvciBtZXRob2RzIHdpdGggc3RyZWFtaW5nXG4gKiByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xufVxuZnVuY3Rpb24gZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbChjaGFubmVsLCBvcHRpb25zLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXRob2REZWZpbml0aW9uKSB7XG4gICAgY29uc3QgY2FsbCA9IGdldENhbGwoY2hhbm5lbCwgbWV0aG9kRGVmaW5pdGlvbi5wYXRoLCBvcHRpb25zKTtcbiAgICBpZiAobWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JBcmdzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXRob2REZWZpbml0aW9uLCBvcHRpb25zLCBjaGFubmVsKSB7XG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCAmJlxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgb3B0aW9ucyAnICtcbiAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgIH1cbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCAmJlxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIGNhbGwgJyArXG4gICAgICAgICAgICAnb3B0aW9ucy4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICB9XG4gICAgbGV0IGludGVyY2VwdG9ycyA9IFtdO1xuICAgIC8vIEludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNhbGwgb3ZlcnJpZGUgaW50ZXJjZXB0b3JzIHBhc3NlZCB0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yXG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGludGVyY2VwdG9ycyA9IFtdXG4gICAgICAgICAgICAuY29uY2F0KGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLCBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcChwcm92aWRlciA9PiBwcm92aWRlcihtZXRob2REZWZpbml0aW9uKSkpXG4gICAgICAgICAgICAuZmlsdGVyKGludGVyY2VwdG9yID0+IGludGVyY2VwdG9yKTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBmYWxzeSB2YWx1ZXMgd2hlbiBwcm92aWRlcnMgcmV0dXJuIG5vdGhpbmdcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGludGVyY2VwdG9ycyA9IFtdXG4gICAgICAgICAgICAuY29uY2F0KGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvcnMsIGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycy5tYXAocHJvdmlkZXIgPT4gcHJvdmlkZXIobWV0aG9kRGVmaW5pdGlvbikpKVxuICAgICAgICAgICAgLmZpbHRlcihpbnRlcmNlcHRvciA9PiBpbnRlcmNlcHRvcik7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXG4gICAgfVxuICAgIGNvbnN0IGludGVyY2VwdG9yT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgICAgbWV0aG9kX2RlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgfSk7XG4gICAgLyogRm9yIGVhY2ggaW50ZXJjZXB0b3IgaW4gdGhlIGxpc3QsIHRoZSBuZXh0Q2FsbCBmdW5jdGlvbiBwYXNzZWQgdG8gaXQgaXNcbiAgICAgKiBiYXNlZCBvbiB0aGUgbmV4dCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdXNpbmcgYSBuZXh0Q2FsbCBmdW5jdGlvblxuICAgICAqIGNvbnN0cnVjdGVkIHdpdGggdGhlIGZvbGxvd2luZyBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgYW5kIHNvIG9uLiBUaGVcbiAgICAgKiBpbml0aWFsVmFsdWUsIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QsIGlzIGEgbmV4dENhbGxcbiAgICAgKiBmdW5jdGlvbiB0aGF0IGludm9rZXMgZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbCwgdGhlIHJlc3VsdCBvZiB3aGljaFxuICAgICAqIGhhbmRsZXMgKGRlKXNlcmlhbGl6YXRpb24gYW5kIGFsc28gZ2V0cyB0aGUgdW5kZXJseWluZyBjYWxsIGZyb20gdGhlXG4gICAgICogY2hhbm5lbC4gKi9cbiAgICBjb25zdCBnZXRDYWxsID0gaW50ZXJjZXB0b3JzLnJlZHVjZVJpZ2h0KChuZXh0Q2FsbCwgbmV4dEludGVyY2VwdG9yKSA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50T3B0aW9ucyA9PiBuZXh0SW50ZXJjZXB0b3IoY3VycmVudE9wdGlvbnMsIG5leHRDYWxsKTtcbiAgICB9LCAoZmluYWxPcHRpb25zKSA9PiBnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsKGNoYW5uZWwsIGZpbmFsT3B0aW9ucywgbWV0aG9kRGVmaW5pdGlvbikpO1xuICAgIHJldHVybiBnZXRDYWxsKGludGVyY2VwdG9yT3B0aW9ucyk7XG59XG5leHBvcnRzLmdldEludGVyY2VwdGluZ0NhbGwgPSBnZXRJbnRlcmNlcHRpbmdDYWxsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LWludGVyY2VwdG9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\nfunction getErrorStackString(error) {\n    return error.stack.split('\\n').slice(1).join('\\n');\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\nclass Client {\n    constructor(address, credentials, options = {}) {\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 &&\n            this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error('Both interceptors and interceptor_providers were passed as options ' +\n                'to the client constructor. Only one of these is allowed.');\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] =\n            options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        }\n        else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        }\n        else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err) => {\n            if (err) {\n                callback(new Error('Failed to connect before the deadline'));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            }\n            catch (e) {\n                callback(new Error('The channel has been closed'));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            }\n            else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                }\n                catch (e) {\n                    callback(new Error('The channel has been closed'));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };\n        }\n        else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return { metadata: arg1, options: {}, callback: arg2 };\n            }\n            else {\n                return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };\n            }\n        }\n        else {\n            if (!(arg1 instanceof metadata_1.Metadata &&\n                arg2 instanceof Object &&\n                isFunction(arg3))) {\n                throw new Error('Incorrect arguments passed');\n            }\n            return { metadata: arg1, options: arg2, callback: arg3 };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: metadata => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'No message received',\n                            metadata: status.metadata,\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                emitter.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        emitter.call = call;\n        let responseMessage = null;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: metadata => {\n                emitter.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback((0, call_1.callErrorFromStatus)({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'No message received',\n                            metadata: status.metadata,\n                        }, callerStack));\n                    }\n                    else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                }\n                else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                emitter.emit('status', status);\n            },\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            }\n            else {\n                options = {};\n            }\n        }\n        else {\n            if (arg1) {\n                options = arg1;\n            }\n            else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return { metadata, options };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                stream.emit('status', status);\n            },\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize,\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : [],\n        };\n        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */\n        stream.call = call;\n        let receivedStatus = false;\n        let callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata(metadata) {\n                stream.emit('metadata', metadata);\n            },\n            onReceiveMessage(message) {\n                stream.push(message);\n            },\n            onReceiveStatus(status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit('error', (0, call_1.callErrorFromStatus)(status, callerStack));\n                }\n                /* Avoid retaining the callerStackError object in the call context of\n                 * the status event handler. */\n                callerStackError = null;\n                stream.emit('status', status);\n            },\n        });\n        return stream;\n    }\n}\nexports.Client = Client;\n//# sourceMappingURL=client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGVBQWUsbUJBQU8sQ0FBQyxvRUFBUTtBQUMvQixrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsOEJBQThCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0RBQWdEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgY2FsbF8xID0gcmVxdWlyZShcIi4vY2FsbFwiKTtcbmNvbnN0IGNoYW5uZWxfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgY2xpZW50X2ludGVyY2VwdG9yc18xID0gcmVxdWlyZShcIi4vY2xpZW50LWludGVyY2VwdG9yc1wiKTtcbmNvbnN0IENIQU5ORUxfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBJTlRFUkNFUFRPUl9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IElOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTCA9IFN5bWJvbCgpO1xuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGdldEVycm9yU3RhY2tTdHJpbmcoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDEpLmpvaW4oJ1xcbicpO1xufVxuLyoqXG4gKiBBIGdlbmVyaWMgZ1JQQyBjbGllbnQuIFByaW1hcmlseSB1c2VmdWwgYXMgYSBiYXNlIGNsYXNzIGZvciBhbGwgZ2VuZXJhdGVkXG4gKiBjbGllbnRzLlxuICovXG5jbGFzcyBDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0gPSAoX2EgPSBvcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmludGVyY2VwdG9ycztcbiAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdID0gKF9iID0gb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnM7XG4gICAgICAgIGlmICh0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0ubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yX3Byb3ZpZGVycyB3ZXJlIHBhc3NlZCBhcyBvcHRpb25zICcgK1xuICAgICAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0gPVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyO1xuICAgICAgICBpZiAob3B0aW9ucy5jaGFubmVsT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gb3B0aW9ucy5jaGFubmVsT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVsRmFjdG9yeU92ZXJyaWRlID0gb3B0aW9ucy5jaGFubmVsRmFjdG9yeU92ZXJyaWRlO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZTtcbiAgICAgICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdID0gY2hhbm5lbEZhY3RvcnlPdmVycmlkZShhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IG5ldyBjaGFubmVsXzEuQ2hhbm5lbEltcGxlbWVudGF0aW9uKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0uY2xvc2UoKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbQ0hBTk5FTF9TWU1CT0xdO1xuICAgIH1cbiAgICB3YWl0Rm9yUmVhZHkoZGVhZGxpbmUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrU3RhdGUgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gY29ubmVjdCBiZWZvcmUgdGhlIGRlYWRsaW5lJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXdTdGF0ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGUgPSB0aGlzW0NIQU5ORUxfU1lNQk9MXS5nZXRDb25uZWN0aXZpdHlTdGF0ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY2hhbm5lbCBoYXMgYmVlbiBjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXS53YXRjaENvbm5lY3Rpdml0eVN0YXRlKG5ld1N0YXRlLCBkZWFkbGluZSwgY2hlY2tTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignVGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGNoZWNrU3RhdGUpO1xuICAgIH1cbiAgICBjaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGFyZzEpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSwgb3B0aW9uczoge30sIGNhbGxiYWNrOiBhcmcxIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihhcmcyKSkge1xuICAgICAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBtZXRhZGF0YV8xLk1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IGFyZzEsIG9wdGlvbnM6IHt9LCBjYWxsYmFjazogYXJnMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksIG9wdGlvbnM6IGFyZzEsIGNhbGxiYWNrOiBhcmcyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgIGFyZzIgaW5zdGFuY2VvZiBPYmplY3QgJiZcbiAgICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGFyZzMpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb3JyZWN0IGFyZ3VtZW50cyBwYXNzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBhcmcxLCBvcHRpb25zOiBhcmcyLCBjYWxsYmFjazogYXJnMyB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1ha2VVbmFyeVJlcXVlc3QobWV0aG9kLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBhcmd1bWVudCwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBhcmd1bWVudDogYXJndW1lbnQsXG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50VW5hcnlDYWxsSW1wbCgpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjaGVja2VkQXJndW1lbnRzLmNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9ICgwLCBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbCkoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgZW1pdHRlci5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogbWV0YWRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnbWV0YWRhdGEnLCBtZXRhZGF0YSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZU1lc3NhZ2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgJ1RvbyBtYW55IHJlc3BvbnNlcyByZWNlaXZlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzLmNhbGxiYWNrKG51bGwsIHJlc3BvbnNlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2soKDAsIGNhbGxfMS5jYWxsRXJyb3JGcm9tU3RhdHVzKShzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIEF2b2lkIHJldGFpbmluZyB0aGUgY2FsbGVyU3RhY2tFcnJvciBvYmplY3QgaW4gdGhlIGNhbGwgY29udGV4dCBvZlxuICAgICAgICAgICAgICAgICAqIHRoZSBzdGF0dXMgZXZlbnQgaGFuZGxlci4gKi9cbiAgICAgICAgICAgICAgICBjYWxsZXJTdGFja0Vycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgIH1cbiAgICBtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiBmYWxzZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsKHNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNoZWNrZWRBcmd1bWVudHMuY2FsbGJhY2ssXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ05vIG1lc3NhZ2UgcmVjZWl2ZWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjaygoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMoYXJnMSwgYXJnMikge1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChhcmcyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1ldGFkYXRhLCBvcHRpb25zIH07XG4gICAgfVxuICAgIG1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbChkZXNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gKDAsIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKShpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBzdHJlYW0uY2FsbCA9IGNhbGw7XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsICgwLCBjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cykoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBBdm9pZCByZXRhaW5pbmcgdGhlIGNhbGxlclN0YWNrRXJyb3Igb2JqZWN0IGluIHRoZSBjYWxsIGNvbnRleHQgb2ZcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3RhdHVzIGV2ZW50IGhhbmRsZXIuICovXG4gICAgICAgICAgICAgICAgY2FsbGVyU3RhY2tFcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbC5zZW5kTWVzc2FnZShhcmd1bWVudCk7XG4gICAgICAgIGNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIG1ha2VCaWRpU3RyZWFtUmVxdWVzdChtZXRob2QsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IHNlcmlhbGl6ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY2FsbFByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICBtZXRhZGF0YTogY2hlY2tlZEFyZ3VtZW50cy5tZXRhZGF0YSxcbiAgICAgICAgICAgIGNhbGw6IG5ldyBjYWxsXzEuQ2xpZW50RHVwbGV4U3RyZWFtSW1wbChzZXJpYWxpemUsIGRlc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKSB7XG4gICAgICAgICAgICBjYWxsUHJvcGVydGllcyA9IHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0oY2FsbFByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSAoMCwgY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwpKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcbiAgICAgICAgbGV0IHJlY2VpdmVkU3RhdHVzID0gZmFsc2U7XG4gICAgICAgIGxldCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNlaXZlZFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCAoMCwgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMpKHN0YXR1cywgY2FsbGVyU3RhY2spKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogQXZvaWQgcmV0YWluaW5nIHRoZSBjYWxsZXJTdGFja0Vycm9yIG9iamVjdCBpbiB0aGUgY2FsbCBjb250ZXh0IG9mXG4gICAgICAgICAgICAgICAgICogdGhlIHN0YXR1cyBldmVudCBoYW5kbGVyLiAqL1xuICAgICAgICAgICAgICAgIGNhbGxlclN0YWNrRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jbGllbnQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function (CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms || (exports.CompressionAlgorithms = CompressionAlgorithms = {}));\n//# sourceMappingURL=compression-algorithms.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEIsNkJBQTZCLDZCQUE2QjtBQUN2RiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wcmVzc2lvbkFsZ29yaXRobXMgPSB2b2lkIDA7XG52YXIgQ29tcHJlc3Npb25BbGdvcml0aG1zO1xuKGZ1bmN0aW9uIChDb21wcmVzc2lvbkFsZ29yaXRobXMpIHtcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiaWRlbnRpdHlcIl0gPSAwXSA9IFwiaWRlbnRpdHlcIjtcbiAgICBDb21wcmVzc2lvbkFsZ29yaXRobXNbQ29tcHJlc3Npb25BbGdvcml0aG1zW1wiZGVmbGF0ZVwiXSA9IDFdID0gXCJkZWZsYXRlXCI7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImd6aXBcIl0gPSAyXSA9IFwiZ3ppcFwiO1xufSkoQ29tcHJlc3Npb25BbGdvcml0aG1zIHx8IChleHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IENvbXByZXNzaW9uQWxnb3JpdGhtcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key) => {\n    return (typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string');\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n    async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    constructor(maxRecvMessageLength) {\n        super();\n        this.maxRecvMessageLength = maxRecvMessageLength;\n    }\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.deflate(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            let totalLength = 0;\n            const messageParts = [];\n            const decompresser = zlib.createInflate();\n            decompresser.on('data', (chunk) => {\n                messageParts.push(chunk);\n                totalLength += chunk.byteLength;\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n                    decompresser.destroy();\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n                    });\n                }\n            });\n            decompresser.on('end', () => {\n                resolve(Buffer.concat(messageParts));\n            });\n            decompresser.write(message);\n            decompresser.end();\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    constructor(maxRecvMessageLength) {\n        super();\n        this.maxRecvMessageLength = maxRecvMessageLength;\n    }\n    compressMessage(message) {\n        return new Promise((resolve, reject) => {\n            zlib.gzip(message, (err, output) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject) => {\n            let totalLength = 0;\n            const messageParts = [];\n            const decompresser = zlib.createGunzip();\n            decompresser.on('data', (chunk) => {\n                messageParts.push(chunk);\n                totalLength += chunk.byteLength;\n                if (this.maxRecvMessageLength !== -1 && totalLength > this.maxRecvMessageLength) {\n                    decompresser.destroy();\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`\n                    });\n                }\n            });\n            decompresser.on('end', () => {\n                resolve(Buffer.concat(messageParts));\n            });\n            decompresser.write(message);\n            decompresser.end();\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName) {\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName, maxReceiveMessageSize) {\n    switch (compressionName) {\n        case 'identity':\n            return new IdentityHandler();\n        case 'deflate':\n            return new DeflateHandler(maxReceiveMessageSize);\n        case 'gzip':\n            return new GzipHandler(maxReceiveMessageSize);\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig) {\n        var _a, _b;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n        const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n        this.maxReceiveMessageLength = (_a = channelOptions['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_b = sharedFilterConfig.serverSupportedEncodingHeader) === null || _b === void 0 ? void 0 : _b.split(',');\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */\n                if (!serverSupportedEncodings ||\n                    serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);\n                }\n            }\n            else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n        headers.set('accept-encoding', 'identity');\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === 'identity') {\n            headers.remove('grpc-encoding');\n        }\n        else {\n            headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get('grpc-encoding');\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === 'string') {\n                this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);\n            }\n        }\n        metadata.remove('grpc-encoding');\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n        const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader =\n                serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = 'identity';\n            }\n        }\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */\n        const resolvedMessage = await message;\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        }\n        else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* WriteFlags.NoCompress */) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags,\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */\n        return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options) {\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter() {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory;\n//# sourceMappingURL=compression-filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDLEdBQUcseUJBQXlCO0FBQzVELGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixpQ0FBaUMsbUJBQU8sQ0FBQyx3R0FBMEI7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDBCQUEwQjtBQUN2SCxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RiwwQkFBMEI7QUFDdkgscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLHFCQUFxQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUscUJBQXFCO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFJQUFxSSx3QkFBd0I7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1maWx0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gKGtleSkgPT4ge1xuICAgIHJldHVybiAodHlwZW9mIGtleSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXNba2V5XSA9PT0gJ3N0cmluZycpO1xufTtcbmNsYXNzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgUmF3IHVuY29tcHJlc3NlZCBtZXNzYWdlIGJ5dGVzXG4gICAgICogQHBhcmFtIGNvbXByZXNzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtZXNzYWdlIHNob3VsZCBiZSBjb21wcmVzc2VkXG4gICAgICogQHJldHVybiBGcmFtZWQgbWVzc2FnZSwgY29tcHJlc3NlZCBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XG4gICAgICAgIGxldCBtZXNzYWdlQnVmZmVyID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5jb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lc3NhZ2VCdWZmZXIubGVuZ3RoICsgNSk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KGNvbXByZXNzID8gMSA6IDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlQnVmZmVyLmxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBGcmFtZWQgbWVzc2FnZSwgcG9zc2libHkgY29tcHJlc3NlZFxuICAgICAqIEByZXR1cm4gVW5jb21wcmVzc2VkIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyByZWFkTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBkYXRhLnJlYWRVSW50OCgwKSA9PT0gMTtcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBkYXRhLnNsaWNlKDUpO1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgbWVzc2FnZUJ1ZmZlciA9IGF3YWl0IHRoaXMuZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VCdWZmZXI7XG4gICAgfVxufVxuY2xhc3MgSWRlbnRpdHlIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBhc3luYyBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXNzYWdlLmxlbmd0aCArIDUpO1xuICAgICAgICAvKiBXaXRoIFwiaWRlbnRpdHlcIiBjb21wcmVzc2lvbiwgbWVzc2FnZXMgc2hvdWxkIGFsd2F5cyBiZSBtYXJrZWQgYXNcbiAgICAgICAgICogdW5jb21wcmVzc2VkICovXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlLmxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2UuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1JlY2VpdmVkIGNvbXByZXNzZWQgbWVzc2FnZSBidXQgXCJncnBjLWVuY29kaW5nXCIgaGVhZGVyIHdhcyBpZGVudGl0eScpKTtcbiAgICB9XG59XG5jbGFzcyBEZWZsYXRlSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IobWF4UmVjdk1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXhSZWN2TWVzc2FnZUxlbmd0aCA9IG1heFJlY3ZNZXNzYWdlTGVuZ3RoO1xuICAgIH1cbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5kZWZsYXRlKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVBhcnRzID0gW107XG4gICAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZXIgPSB6bGliLmNyZWF0ZUluZmxhdGUoKTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoICE9PSAtMSAmJiB0b3RhbExlbmd0aCA+IHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSB0aGF0IGRlY29tcHJlc3NlcyB0byBhIHNpemUgbGFyZ2VyIHRoYW4gJHt0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RofWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQobWVzc2FnZVBhcnRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci53cml0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgR3ppcEhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG1heFJlY3ZNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGggPSBtYXhSZWN2TWVzc2FnZUxlbmd0aDtcbiAgICB9XG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHpsaWIuZ3ppcChtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZGVjb21wcmVzc2VyID0gemxpYi5jcmVhdGVHdW56aXAoKTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5vbignZGF0YScsIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RoICE9PSAtMSAmJiB0b3RhbExlbmd0aCA+IHRoaXMubWF4UmVjdk1lc3NhZ2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSB0aGF0IGRlY29tcHJlc3NlcyB0byBhIHNpemUgbGFyZ2VyIHRoYW4gJHt0aGlzLm1heFJlY3ZNZXNzYWdlTGVuZ3RofWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWNvbXByZXNzZXIub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKEJ1ZmZlci5jb25jYXQobWVzc2FnZVBhcnRzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci53cml0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIGRlY29tcHJlc3Nlci5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVW5rbm93bkhhbmRsZXIgZXh0ZW5kcyBDb21wcmVzc2lvbkhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbXByZXNzaW9uTmFtZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbXByZXNzaW9uTmFtZSA9IGNvbXByZXNzaW9uTmFtZTtcbiAgICB9XG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSBjb21wcmVzc2VkIHdpdGggdW5zdXBwb3J0ZWQgY29tcHJlc3Npb24gbWV0aG9kICR7dGhpcy5jb21wcmVzc2lvbk5hbWV9YCkpO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIHVucmVhY2hhYmxlXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYENvbXByZXNzaW9uIG1ldGhvZCBub3Qgc3VwcG9ydGVkOiAke3RoaXMuY29tcHJlc3Npb25OYW1lfWApKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRDb21wcmVzc2lvbkhhbmRsZXIoY29tcHJlc3Npb25OYW1lLCBtYXhSZWNlaXZlTWVzc2FnZVNpemUpIHtcbiAgICBzd2l0Y2ggKGNvbXByZXNzaW9uTmFtZSkge1xuICAgICAgICBjYXNlICdpZGVudGl0eSc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICBjYXNlICdkZWZsYXRlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVmbGF0ZUhhbmRsZXIobWF4UmVjZWl2ZU1lc3NhZ2VTaXplKTtcbiAgICAgICAgY2FzZSAnZ3ppcCc6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEd6aXBIYW5kbGVyKG1heFJlY2VpdmVNZXNzYWdlU2l6ZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVua25vd25IYW5kbGVyKGNvbXByZXNzaW9uTmFtZSk7XG4gICAgfVxufVxuY2xhc3MgQ29tcHJlc3Npb25GaWx0ZXIgZXh0ZW5kcyBmaWx0ZXJfMS5CYXNlRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsT3B0aW9ucywgc2hhcmVkRmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnID0gc2hhcmVkRmlsdGVyQ29uZmlnO1xuICAgICAgICB0aGlzLnNlbmRDb21wcmVzc2lvbiA9IG5ldyBJZGVudGl0eUhhbmRsZXIoKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gJ2lkZW50aXR5JztcbiAgICAgICAgY29uc3QgY29tcHJlc3Npb25BbGdvcml0aG1LZXkgPSBjaGFubmVsT3B0aW9uc1snZ3JwYy5kZWZhdWx0X2NvbXByZXNzaW9uX2FsZ29yaXRobSddO1xuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoID0gKF9hID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5KGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFNlbGVjdGVkRW5jb2RpbmcgPSBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2NvbXByZXNzaW9uQWxnb3JpdGhtS2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSAoX2IgPSBzaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGFyZSB0d28gcG9zc2libGUgc2l0dWF0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICAgICAqIDEpIFdlIGRvbid0IGhhdmUgYW55IGluZm8geWV0IGZyb20gdGhlIHNlcnZlciBhYm91dCB3aGF0IGNvbXByZXNzaW9uIGl0IHN1cHBvcnRzXG4gICAgICAgICAgICAgICAgICogICAgSW4gdGhhdCBjYXNlIHdlIHNob3VsZCBqdXN0IHVzZSB3aGF0IHRoZSBjbGllbnQgdGVsbHMgdXMgdG8gdXNlXG4gICAgICAgICAgICAgICAgICogMikgV2UndmUgcHJldmlvdXNseSByZWNlaXZlZCBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciBpbmNsdWRpbmcgYSBncnBjLWFjY2VwdC1lbmNvZGluZyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugb25seSB3YW50IHRvIHVzZSB0aGUgZW5jb2RpbmcgY2hvc2VuIGJ5IHRoZSBjbGllbnQgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBpdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzIHx8XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncy5pbmNsdWRlcyhjbGllbnRTZWxlY3RlZEVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9IGNsaWVudFNlbGVjdGVkRW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtLCAtMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgSW52YWxpZCB2YWx1ZSBwcm92aWRlZCBmb3IgZ3JwYy5kZWZhdWx0X2NvbXByZXNzaW9uX2FsZ29yaXRobSBvcHRpb246ICR7Y29tcHJlc3Npb25BbGdvcml0aG1LZXl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBhd2FpdCBtZXRhZGF0YTtcbiAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5LGRlZmxhdGUsZ3ppcCcpO1xuICAgICAgICBoZWFkZXJzLnNldCgnYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5Jyk7XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VuZCB0aGUgaGVhZGVyIGlmIGl0J3MgXCJpZGVudGl0eVwiIC0gIGJlaGF2aW9yIGlzIGlkZW50aWNhbDsgc2F2ZSB0aGUgYmFuZHdpZHRoXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgaGVhZGVycy5yZW1vdmUoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdncnBjLWVuY29kaW5nJywgdGhpcy5jdXJyZW50Q29tcHJlc3Npb25BbGdvcml0aG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgcmVjZWl2ZUVuY29kaW5nID0gbWV0YWRhdGEuZ2V0KCdncnBjLWVuY29kaW5nJyk7XG4gICAgICAgIGlmIChyZWNlaXZlRW5jb2RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RpbmcgPSByZWNlaXZlRW5jb2RpbmdbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKGVuY29kaW5nLCB0aGlzLm1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHRoZSBjb21wcmVzc2lvbiB3ZSdyZSB1c2luZyB0byBzZW5kIG1lc3NhZ2VzIGlzIHN1cHBvcnRlZCBieSB0aGUgc2VydmVyXG4gICAgICAgICAqIElmIG5vdCwgcmVzZXQgdGhlIHNlbmRDb21wcmVzc2lvbiBmaWx0ZXIgYW5kIGhhdmUgaXQgdXNlIHRoZSBkZWZhdWx0IElkZW50aXR5SGFuZGxlciAqL1xuICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIgPSBtZXRhZGF0YS5nZXQoJ2dycGMtYWNjZXB0LWVuY29kaW5nJylbMF07XG4gICAgICAgIGlmIChzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnLnNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyID1cbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXI7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gJ2lkZW50aXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtYWNjZXB0LWVuY29kaW5nJyk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qIFRoaXMgZmlsdGVyIGlzIHNwZWNpYWwuIFRoZSBpbnB1dCBtZXNzYWdlIGlzIHRoZSBiYXJlIG1lc3NhZ2UgYnl0ZXMsXG4gICAgICAgICAqIGFuZCB0aGUgb3V0cHV0IGlzIGEgZnJhbWVkIGFuZCBwb3NzaWJseSBjb21wcmVzc2VkIG1lc3NhZ2UuIEZvciB0aGlzXG4gICAgICAgICAqIHJlYXNvbiwgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlIGZpbHRlciBzdGFjayAqL1xuICAgICAgICBjb25zdCByZXNvbHZlZE1lc3NhZ2UgPSBhd2FpdCBtZXNzYWdlO1xuICAgICAgICBsZXQgY29tcHJlc3M7XG4gICAgICAgIGlmICh0aGlzLnNlbmRDb21wcmVzc2lvbiBpbnN0YW5jZW9mIElkZW50aXR5SGFuZGxlcikge1xuICAgICAgICAgICAgY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbXByZXNzID0gKCgoX2EgPSByZXNvbHZlZE1lc3NhZ2UuZmxhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICYgMiAvKiBXcml0ZUZsYWdzLk5vQ29tcHJlc3MgKi8pID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBhd2FpdCB0aGlzLnNlbmRDb21wcmVzc2lvbi53cml0ZU1lc3NhZ2UocmVzb2x2ZWRNZXNzYWdlLm1lc3NhZ2UsIGNvbXByZXNzKSxcbiAgICAgICAgICAgIGZsYWdzOiByZXNvbHZlZE1lc3NhZ2UuZmxhZ3MsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogVGhpcyBmaWx0ZXIgaXMgYWxzbyBzcGVjaWFsLiBUaGUgaW5wdXQgbWVzc2FnZSBpcyBmcmFtZWQgYW5kIHBvc3NpYmx5XG4gICAgICAgICAqIGNvbXByZXNzZWQsIGFuZCB0aGUgb3V0cHV0IG1lc3NhZ2UgaXMgZGVmcmFtZWQgYW5kIHVuY29tcHJlc3NlZC4gU29cbiAgICAgICAgICogdGhpcyBpcyBhbm90aGVyIHJlYXNvbiB0aGF0IHRoaXMgZmlsdGVyIHNob3VsZCBiZSBhdCB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgICAgKiBmaWx0ZXIgc3RhY2suICovXG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVDb21wcmVzc2lvbi5yZWFkTWVzc2FnZShhd2FpdCBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyID0gQ29tcHJlc3Npb25GaWx0ZXI7XG5jbGFzcyBDb21wcmVzc2lvbkZpbHRlckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcgPSB7fTtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbXByZXNzaW9uRmlsdGVyKHRoaXMub3B0aW9ucywgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5ID0gQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcHJlc3Npb24tZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function (ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState || (exports.ConnectivityState = ConnectivityState = {}));\n//# sourceMappingURL=connectivity-state.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0IseUJBQXlCLHlCQUF5QjtBQUMzRSIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlID0gdm9pZCAwO1xudmFyIENvbm5lY3Rpdml0eVN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aXZpdHlTdGF0ZSkge1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiSURMRVwiXSA9IDBdID0gXCJJRExFXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMV0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlJFQURZXCJdID0gMl0gPSBcIlJFQURZXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJUUkFOU0lFTlRfRkFJTFVSRVwiXSA9IDNdID0gXCJUUkFOU0lFTlRfRkFJTFVSRVwiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiU0hVVERPV05cIl0gPSA0XSA9IFwiU0hVVERPV05cIjtcbn0pKENvbm5lY3Rpdml0eVN0YXRlIHx8IChleHBvcnRzLkNvbm5lY3Rpdml0eVN0YXRlID0gQ29ubmVjdGl2aXR5U3RhdGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGl2aXR5LXN0YXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function (Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status || (exports.Status = Status = {}));\nvar LogVerbosity;\n(function (LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity || (exports.LogVerbosity = LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */\nvar Propagate;\n(function (Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate || (exports.Propagate = Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMENBQTBDLEdBQUcsdUNBQXVDLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsY0FBYztBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYSxjQUFjLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUIsb0JBQW9CLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsMENBQTBDO0FBQzFDIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCA9IGV4cG9ydHMuUHJvcGFnYXRlID0gZXhwb3J0cy5Mb2dWZXJib3NpdHkgPSBleHBvcnRzLlN0YXR1cyA9IHZvaWQgMDtcbnZhciBTdGF0dXM7XG4oZnVuY3Rpb24gKFN0YXR1cykge1xuICAgIFN0YXR1c1tTdGF0dXNbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJDQU5DRUxMRURcIl0gPSAxXSA9IFwiQ0FOQ0VMTEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOS05PV05cIl0gPSAyXSA9IFwiVU5LTk9XTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJJTlZBTElEX0FSR1VNRU5UXCJdID0gM10gPSBcIklOVkFMSURfQVJHVU1FTlRcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiREVBRExJTkVfRVhDRUVERURcIl0gPSA0XSA9IFwiREVBRExJTkVfRVhDRUVERURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiTk9UX0ZPVU5EXCJdID0gNV0gPSBcIk5PVF9GT1VORFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBTFJFQURZX0VYSVNUU1wiXSA9IDZdID0gXCJBTFJFQURZX0VYSVNUU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJQRVJNSVNTSU9OX0RFTklFRFwiXSA9IDddID0gXCJQRVJNSVNTSU9OX0RFTklFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJSRVNPVVJDRV9FWEhBVVNURURcIl0gPSA4XSA9IFwiUkVTT1VSQ0VfRVhIQVVTVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkZBSUxFRF9QUkVDT05ESVRJT05cIl0gPSA5XSA9IFwiRkFJTEVEX1BSRUNPTkRJVElPTlwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJBQk9SVEVEXCJdID0gMTBdID0gXCJBQk9SVEVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk9VVF9PRl9SQU5HRVwiXSA9IDExXSA9IFwiT1VUX09GX1JBTkdFXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOSU1QTEVNRU5URURcIl0gPSAxMl0gPSBcIlVOSU1QTEVNRU5URURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiSU5URVJOQUxcIl0gPSAxM10gPSBcIklOVEVSTkFMXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVZBSUxBQkxFXCJdID0gMTRdID0gXCJVTkFWQUlMQUJMRVwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJEQVRBX0xPU1NcIl0gPSAxNV0gPSBcIkRBVEFfTE9TU1wiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJVTkFVVEhFTlRJQ0FURURcIl0gPSAxNl0gPSBcIlVOQVVUSEVOVElDQVRFRFwiO1xufSkoU3RhdHVzIHx8IChleHBvcnRzLlN0YXR1cyA9IFN0YXR1cyA9IHt9KSk7XG52YXIgTG9nVmVyYm9zaXR5O1xuKGZ1bmN0aW9uIChMb2dWZXJib3NpdHkpIHtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiREVCVUdcIl0gPSAwXSA9IFwiREVCVUdcIjtcbiAgICBMb2dWZXJib3NpdHlbTG9nVmVyYm9zaXR5W1wiSU5GT1wiXSA9IDFdID0gXCJJTkZPXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIkVSUk9SXCJdID0gMl0gPSBcIkVSUk9SXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIk5PTkVcIl0gPSAzXSA9IFwiTk9ORVwiO1xufSkoTG9nVmVyYm9zaXR5IHx8IChleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IExvZ1ZlcmJvc2l0eSA9IHt9KSk7XG4vKipcbiAqIE5PVEU6IFRoaXMgZW51bSBpcyBub3QgY3VycmVudGx5IHVzZWQgaW4gYW55IGltcGxlbWVudGVkIEFQSSBpbiB0aGlzXG4gKiBsaWJyYXJ5LiBJdCBpcyBpbmNsdWRlZCBvbmx5IGZvciB0eXBlIHBhcml0eSB3aXRoIHRoZSBvdGhlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIFByb3BhZ2F0ZTtcbihmdW5jdGlvbiAoUHJvcGFnYXRlKSB7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFQURMSU5FXCJdID0gMV0gPSBcIkRFQURMSU5FXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19TVEFUU19DT05URVhUXCJdID0gMl0gPSBcIkNFTlNVU19TVEFUU19DT05URVhUXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIl0gPSA0XSA9IFwiQ0VOU1VTX1RSQUNJTkdfQ09OVEVYVFwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDQU5DRUxMQVRJT05cIl0gPSA4XSA9IFwiQ0FOQ0VMTEFUSU9OXCI7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9pbmNsdWRlL2dycGMvaW1wbC9jb2RlZ2VuL3Byb3BhZ2F0aW9uX2JpdHMuaCNMNDNcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiREVGQVVMVFNcIl0gPSA2NTUzNV0gPSBcIkRFRkFVTFRTXCI7XG59KShQcm9wYWdhdGUgfHwgKGV4cG9ydHMuUHJvcGFnYXRlID0gUHJvcGFnYXRlID0ge30pKTtcbi8vIC0xIG1lYW5zIHVubGltaXRlZFxuZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gLTE7XG4vLyA0IE1CIGRlZmF1bHRcbmV4cG9ydHMuREVGQVVMVF9NQVhfUkVDRUlWRV9NRVNTQUdFX0xFTkdUSCA9IDQgKiAxMDI0ICogMTAyNDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/control-plane-status.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.restrictControlPlaneStatusCode = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS,\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`,\n        };\n    }\n    else {\n        return { code, details };\n    }\n}\nexports.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;\n//# sourceMappingURL=control-plane-status.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQ0FBc0M7QUFDdEMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxNQUFNLEVBQUUsMEJBQTBCLEVBQUUsUUFBUTtBQUN2RztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29udHJvbC1wbGFuZS1zdGF0dXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMgPSBbXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5JTlZBTElEX0FSR1VNRU5ULFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkFMUkVBRFlfRVhJU1RTLFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5GQUlMRURfUFJFQ09ORElUSU9OLFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5BQk9SVEVELFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5PVVRfT0ZfUkFOR0UsXG4gICAgY29uc3RhbnRzXzEuU3RhdHVzLkRBVEFfTE9TUyxcbl07XG5mdW5jdGlvbiByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUoY29kZSwgZGV0YWlscykge1xuICAgIGlmIChJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgIGRldGFpbHM6IGBJbnZhbGlkIHN0YXR1cyBmcm9tIGNvbnRyb2wgcGxhbmU6ICR7Y29kZX0gJHtjb25zdGFudHNfMS5TdGF0dXNbY29kZV19ICR7ZGV0YWlsc31gLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgY29kZSwgZGV0YWlscyB9O1xuICAgIH1cbn1cbmV4cG9ydHMucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlID0gcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udHJvbC1wbGFuZS1zdGF0dXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deadlineToString = exports.getRelativeTimeout = exports.getDeadlineTimeoutString = exports.minDeadline = void 0;\nfunction minDeadline(...deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList) {\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nexports.minDeadline = minDeadline;\nconst units = [\n    ['m', 1],\n    ['S', 1000],\n    ['M', 60 * 1000],\n    ['H', 60 * 60 * 1000],\n];\nfunction getDeadlineTimeoutString(deadline) {\n    const now = new Date().getTime();\n    if (deadline instanceof Date) {\n        deadline = deadline.getTime();\n    }\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units) {\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error('Deadline is too far in the future');\n}\nexports.getDeadlineTimeoutString = getDeadlineTimeoutString;\n/**\n * See https://nodejs.org/api/timers.html#settimeoutcallback-delay-args\n * In particular, \"When delay is larger than 2147483647 or less than 1, the\n * delay will be set to 1. Non-integer delays are truncated to an integer.\"\n * This number of milliseconds is almost 25 days.\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n/**\n * Get the timeout value that should be passed to setTimeout now for the timer\n * to end at the deadline. For any deadline before now, the timer should end\n * immediately, represented by a value of 0. For any deadline more than\n * MAX_TIMEOUT_TIME milliseconds in the future, a timer cannot be set that will\n * end at that time, so it is treated as infinitely far in the future.\n * @param deadline\n * @returns\n */\nfunction getRelativeTimeout(deadline) {\n    const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;\n    const now = new Date().getTime();\n    const timeout = deadlineMs - now;\n    if (timeout < 0) {\n        return 0;\n    }\n    else if (timeout > MAX_TIMEOUT_TIME) {\n        return Infinity;\n    }\n    else {\n        return timeout;\n    }\n}\nexports.getRelativeTimeout = getRelativeTimeout;\nfunction deadlineToString(deadline) {\n    if (deadline instanceof Date) {\n        return deadline.toISOString();\n    }\n    else {\n        const dateDeadline = new Date(deadline);\n        if (Number.isNaN(dateDeadline.getTime())) {\n            return '' + deadline;\n        }\n        else {\n            return dateDeadline.toISOString();\n        }\n    }\n}\nexports.deadlineToString = deadlineToString;\n//# sourceMappingURL=deadline.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRyxnQ0FBZ0MsR0FBRyxtQkFBbUI7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVhZGxpbmVUb1N0cmluZyA9IGV4cG9ydHMuZ2V0UmVsYXRpdmVUaW1lb3V0ID0gZXhwb3J0cy5nZXREZWFkbGluZVRpbWVvdXRTdHJpbmcgPSBleHBvcnRzLm1pbkRlYWRsaW5lID0gdm9pZCAwO1xuZnVuY3Rpb24gbWluRGVhZGxpbmUoLi4uZGVhZGxpbmVMaXN0KSB7XG4gICAgbGV0IG1pblZhbHVlID0gSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBkZWFkbGluZSBvZiBkZWFkbGluZUxpc3QpIHtcbiAgICAgICAgY29uc3QgZGVhZGxpbmVNc2VjcyA9IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSA/IGRlYWRsaW5lLmdldFRpbWUoKSA6IGRlYWRsaW5lO1xuICAgICAgICBpZiAoZGVhZGxpbmVNc2VjcyA8IG1pblZhbHVlKSB7XG4gICAgICAgICAgICBtaW5WYWx1ZSA9IGRlYWRsaW5lTXNlY3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pblZhbHVlO1xufVxuZXhwb3J0cy5taW5EZWFkbGluZSA9IG1pbkRlYWRsaW5lO1xuY29uc3QgdW5pdHMgPSBbXG4gICAgWydtJywgMV0sXG4gICAgWydTJywgMTAwMF0sXG4gICAgWydNJywgNjAgKiAxMDAwXSxcbiAgICBbJ0gnLCA2MCAqIDYwICogMTAwMF0sXG5dO1xuZnVuY3Rpb24gZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nKGRlYWRsaW5lKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgaWYgKGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBkZWFkbGluZSA9IGRlYWRsaW5lLmdldFRpbWUoKTtcbiAgICB9XG4gICAgY29uc3QgdGltZW91dE1zID0gTWF0aC5tYXgoZGVhZGxpbmUgLSBub3csIDApO1xuICAgIGZvciAoY29uc3QgW3VuaXQsIGZhY3Rvcl0gb2YgdW5pdHMpIHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdGltZW91dE1zIC8gZmFjdG9yO1xuICAgICAgICBpZiAoYW1vdW50IDwgMWU4KSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKE1hdGguY2VpbChhbW91bnQpKSArIHVuaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWFkbGluZSBpcyB0b28gZmFyIGluIHRoZSBmdXR1cmUnKTtcbn1cbmV4cG9ydHMuZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nID0gZ2V0RGVhZGxpbmVUaW1lb3V0U3RyaW5nO1xuLyoqXG4gKiBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCNzZXR0aW1lb3V0Y2FsbGJhY2stZGVsYXktYXJnc1xuICogSW4gcGFydGljdWxhciwgXCJXaGVuIGRlbGF5IGlzIGxhcmdlciB0aGFuIDIxNDc0ODM2NDcgb3IgbGVzcyB0aGFuIDEsIHRoZVxuICogZGVsYXkgd2lsbCBiZSBzZXQgdG8gMS4gTm9uLWludGVnZXIgZGVsYXlzIGFyZSB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlci5cIlxuICogVGhpcyBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGlzIGFsbW9zdCAyNSBkYXlzLlxuICovXG5jb25zdCBNQVhfVElNRU9VVF9USU1FID0gMjE0NzQ4MzY0Nztcbi8qKlxuICogR2V0IHRoZSB0aW1lb3V0IHZhbHVlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byBzZXRUaW1lb3V0IG5vdyBmb3IgdGhlIHRpbWVyXG4gKiB0byBlbmQgYXQgdGhlIGRlYWRsaW5lLiBGb3IgYW55IGRlYWRsaW5lIGJlZm9yZSBub3csIHRoZSB0aW1lciBzaG91bGQgZW5kXG4gKiBpbW1lZGlhdGVseSwgcmVwcmVzZW50ZWQgYnkgYSB2YWx1ZSBvZiAwLiBGb3IgYW55IGRlYWRsaW5lIG1vcmUgdGhhblxuICogTUFYX1RJTUVPVVRfVElNRSBtaWxsaXNlY29uZHMgaW4gdGhlIGZ1dHVyZSwgYSB0aW1lciBjYW5ub3QgYmUgc2V0IHRoYXQgd2lsbFxuICogZW5kIGF0IHRoYXQgdGltZSwgc28gaXQgaXMgdHJlYXRlZCBhcyBpbmZpbml0ZWx5IGZhciBpbiB0aGUgZnV0dXJlLlxuICogQHBhcmFtIGRlYWRsaW5lXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVRpbWVvdXQoZGVhZGxpbmUpIHtcbiAgICBjb25zdCBkZWFkbGluZU1zID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdGltZW91dCA9IGRlYWRsaW5lTXMgLSBub3c7XG4gICAgaWYgKHRpbWVvdXQgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aW1lb3V0ID4gTUFYX1RJTUVPVVRfVElNRSkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdGltZW91dDtcbiAgICB9XG59XG5leHBvcnRzLmdldFJlbGF0aXZlVGltZW91dCA9IGdldFJlbGF0aXZlVGltZW91dDtcbmZ1bmN0aW9uIGRlYWRsaW5lVG9TdHJpbmcoZGVhZGxpbmUpIHtcbiAgICBpZiAoZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBkZWFkbGluZS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZGF0ZURlYWRsaW5lID0gbmV3IERhdGUoZGVhZGxpbmUpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGRhdGVEZWFkbGluZS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gJycgKyBkZWFkbGluZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRGVhZGxpbmUudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVhZGxpbmVUb1N0cmluZyA9IGRlYWRsaW5lVG9TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWFkbGluZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isDuration = exports.durationToMs = exports.msToDuration = void 0;\nfunction msToDuration(millis) {\n    return {\n        seconds: (millis / 1000) | 0,\n        nanos: ((millis % 1000) * 1000000) | 0,\n    };\n}\nexports.msToDuration = msToDuration;\nfunction durationToMs(duration) {\n    return (duration.seconds * 1000 + duration.nanos / 1000000) | 0;\n}\nexports.durationToMs = durationToMs;\nfunction isDuration(value) {\n    return typeof value.seconds === 'number' && typeof value.nanos === 'number';\n}\nexports.isDuration = isDuration;\n//# sourceMappingURL=duration.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2R1cmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzRHVyYXRpb24gPSBleHBvcnRzLmR1cmF0aW9uVG9NcyA9IGV4cG9ydHMubXNUb0R1cmF0aW9uID0gdm9pZCAwO1xuZnVuY3Rpb24gbXNUb0R1cmF0aW9uKG1pbGxpcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY29uZHM6IChtaWxsaXMgLyAxMDAwKSB8IDAsXG4gICAgICAgIG5hbm9zOiAoKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCkgfCAwLFxuICAgIH07XG59XG5leHBvcnRzLm1zVG9EdXJhdGlvbiA9IG1zVG9EdXJhdGlvbjtcbmZ1bmN0aW9uIGR1cmF0aW9uVG9NcyhkdXJhdGlvbikge1xuICAgIHJldHVybiAoZHVyYXRpb24uc2Vjb25kcyAqIDEwMDAgKyBkdXJhdGlvbi5uYW5vcyAvIDEwMDAwMDApIHwgMDtcbn1cbmV4cG9ydHMuZHVyYXRpb25Ub01zID0gZHVyYXRpb25Ub01zO1xuZnVuY3Rpb24gaXNEdXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUuc2Vjb25kcyA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLm5hbm9zID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kdXJhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getErrorCode = exports.getErrorMessage = void 0;\nfunction getErrorMessage(error) {\n    if (error instanceof Error) {\n        return error.message;\n    }\n    else {\n        return String(error);\n    }\n}\nexports.getErrorMessage = getErrorMessage;\nfunction getErrorCode(error) {\n    if (typeof error === 'object' &&\n        error !== null &&\n        'code' in error &&\n        typeof error.code === 'number') {\n        return error.code;\n    }\n    else {\n        return null;\n    }\n}\nexports.getErrorCode = getErrorCode;\n//# sourceMappingURL=error.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyx1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9lcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRFcnJvckNvZGUgPSBleHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhlcnJvcik7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRFcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2U7XG5mdW5jdGlvbiBnZXRFcnJvckNvZGUoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICAnY29kZScgaW4gZXJyb3IgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5jb2RlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRFcnJvckNvZGUgPSBnZXRFcnJvckNvZGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.OutlierDetectionLoadBalancingConfig = exports.BaseSubchannelWrapper = exports.registerAdminService = exports.FilterStackFactory = exports.BaseFilter = exports.PickResultType = exports.QueuePicker = exports.UnavailablePicker = exports.ChildLoadBalancerHandler = exports.subchannelAddressToString = exports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = exports.BackoffTimeout = exports.durationToMs = exports.uriToString = exports.createResolver = exports.registerResolver = exports.log = exports.trace = void 0;\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({ enumerable: true, get: function () { return logging_1.trace; } }));\nObject.defineProperty(exports, \"log\", ({ enumerable: true, get: function () { return logging_1.log; } }));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({ enumerable: true, get: function () { return resolver_1.registerResolver; } }));\nObject.defineProperty(exports, \"createResolver\", ({ enumerable: true, get: function () { return resolver_1.createResolver; } }));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({ enumerable: true, get: function () { return uri_parser_1.uriToString; } }));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({ enumerable: true, get: function () { return duration_1.durationToMs; } }));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({ enumerable: true, get: function () { return backoff_timeout_1.BackoffTimeout; } }));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({ enumerable: true, get: function () { return load_balancer_1.createChildChannelControlHelper; } }));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({ enumerable: true, get: function () { return load_balancer_1.registerLoadBalancerType; } }));\nObject.defineProperty(exports, \"getFirstUsableConfig\", ({ enumerable: true, get: function () { return load_balancer_1.getFirstUsableConfig; } }));\nObject.defineProperty(exports, \"validateLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_1.validateLoadBalancingConfig; } }));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({ enumerable: true, get: function () { return subchannel_address_1.subchannelAddressToString; } }));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({ enumerable: true, get: function () { return load_balancer_child_handler_1.ChildLoadBalancerHandler; } }));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({ enumerable: true, get: function () { return picker_1.UnavailablePicker; } }));\nObject.defineProperty(exports, \"QueuePicker\", ({ enumerable: true, get: function () { return picker_1.QueuePicker; } }));\nObject.defineProperty(exports, \"PickResultType\", ({ enumerable: true, get: function () { return picker_1.PickResultType; } }));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({ enumerable: true, get: function () { return filter_1.BaseFilter; } }));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({ enumerable: true, get: function () { return filter_stack_1.FilterStackFactory; } }));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({ enumerable: true, get: function () { return admin_1.registerAdminService; } }));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({ enumerable: true, get: function () { return subchannel_interface_1.BaseSubchannelWrapper; } }));\nvar load_balancer_outlier_detection_1 = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nObject.defineProperty(exports, \"OutlierDetectionLoadBalancingConfig\", ({ enumerable: true, get: function () { return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig; } }));\n//# sourceMappingURL=experimental.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJDQUEyQyxHQUFHLDZCQUE2QixHQUFHLDRCQUE0QixHQUFHLDBCQUEwQixHQUFHLGtCQUFrQixHQUFHLHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLHlCQUF5QixHQUFHLGdDQUFnQyxHQUFHLGlDQUFpQyxHQUFHLG1DQUFtQyxHQUFHLDRCQUE0QixHQUFHLGdDQUFnQyxHQUFHLHVDQUF1QyxHQUFHLHNCQUFzQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQixHQUFHLHNCQUFzQixHQUFHLHdCQUF3QixHQUFHLFdBQVcsR0FBRyxhQUFhO0FBQ3hsQixnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQyx5Q0FBd0MsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDM0csdUNBQXNDLEVBQUUscUNBQXFDLHlCQUF5QixFQUFDO0FBQ3ZHLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDLG9EQUFtRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNsSSxrREFBaUQsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDOUgsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWM7QUFDekMsK0NBQThDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQzFILGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDLGdEQUErQyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUMxSCx3QkFBd0IsbUJBQU8sQ0FBQywwRkFBbUI7QUFDbkQsa0RBQWlELEVBQUUscUNBQXFDLDRDQUE0QyxFQUFDO0FBQ3JJLHNCQUFzQixtQkFBTyxDQUFDLHNGQUFpQjtBQUMvQyxtRUFBa0UsRUFBRSxxQ0FBcUMsMkRBQTJELEVBQUM7QUFDckssNERBQTJELEVBQUUscUNBQXFDLG9EQUFvRCxFQUFDO0FBQ3ZKLHdEQUF1RCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUMvSSwrREFBOEQsRUFBRSxxQ0FBcUMsdURBQXVELEVBQUM7QUFDN0osMkJBQTJCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQ3pELDZEQUE0RCxFQUFFLHFDQUFxQywwREFBMEQsRUFBQztBQUM5SixvQ0FBb0MsbUJBQU8sQ0FBQyxrSEFBK0I7QUFDM0UsNERBQTJELEVBQUUscUNBQXFDLGtFQUFrRSxFQUFDO0FBQ3JLLGVBQWUsbUJBQU8sQ0FBQyx3RUFBVTtBQUNqQyxxREFBb0QsRUFBRSxxQ0FBcUMsc0NBQXNDLEVBQUM7QUFDbEksK0NBQThDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ3RILGtEQUFpRCxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUM1SCxlQUFlLG1CQUFPLENBQUMsd0VBQVU7QUFDakMsOENBQTZDLEVBQUUscUNBQXFDLCtCQUErQixFQUFDO0FBQ3BILHFCQUFxQixtQkFBTyxDQUFDLG9GQUFnQjtBQUM3QyxzREFBcUQsRUFBRSxxQ0FBcUMsNkNBQTZDLEVBQUM7QUFDMUksY0FBYyxtQkFBTyxDQUFDLHNFQUFTO0FBQy9CLHdEQUF1RCxFQUFFLHFDQUFxQyx3Q0FBd0MsRUFBQztBQUN2SSw2QkFBNkIsbUJBQU8sQ0FBQyxvR0FBd0I7QUFDN0QseURBQXdELEVBQUUscUNBQXFDLHdEQUF3RCxFQUFDO0FBQ3hKLHdDQUF3QyxtQkFBTyxDQUFDLDBIQUFtQztBQUNuRix1RUFBc0UsRUFBRSxxQ0FBcUMsaUZBQWlGLEVBQUM7QUFDL0wiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2V4cGVyaW1lbnRhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLkJhc2VTdWJjaGFubmVsV3JhcHBlciA9IGV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSBleHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUZpbHRlciA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSBleHBvcnRzLlF1ZXVlUGlja2VyID0gZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IGV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBleHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBleHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlciA9IGV4cG9ydHMubG9nID0gZXhwb3J0cy50cmFjZSA9IHZvaWQgMDtcbnZhciBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidHJhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZ2dpbmdfMS50cmFjZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLmxvZzsgfSB9KTtcbnZhciByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZWdpc3RlclJlc29sdmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVSZXNvbHZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcjsgfSB9KTtcbnZhciB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXJpVG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZzsgfSB9KTtcbnZhciBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkdXJhdGlvblRvTXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zOyB9IH0pO1xudmFyIGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFja29mZlRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0OyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpcnN0VXNhYmxlQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWc7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nOyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7IH0gfSk7XG52YXIgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmF2YWlsYWJsZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWV1ZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUXVldWVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWNrUmVzdWx0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGU7IH0gfSk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRmlsdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5CYXNlRmlsdGVyOyB9IH0pO1xudmFyIGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsdGVyU3RhY2tGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfc3RhY2tfMS5GaWx0ZXJTdGFja0ZhY3Rvcnk7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJBZG1pblNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2U7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlcjsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb25fMS5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZzsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGVyaW1lbnRhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters) {\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for (let i = 0; i < this.filters.length; i++) {\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for (let i = 0; i < this.filters.length; i++) {\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for (let i = this.filters.length - 1; i >= 0; i--) {\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories) {\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    clone() {\n        return new FilterStackFactory([...this.factories]);\n    }\n    createFilter() {\n        return new FilterStack(this.factories.map(factory => factory.createFilter()));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory;\n//# sourceMappingURL=filter-stack.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCLEdBQUcsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ZpbHRlci1zdGFjay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBleHBvcnRzLkZpbHRlclN0YWNrID0gdm9pZCAwO1xuY2xhc3MgRmlsdGVyU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXRhZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5zZW5kTWV0YWRhdGEocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZU1ldGFkYXRhKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5zZW5kTWVzc2FnZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1lc3NhZ2U7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWVzc2FnZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVUcmFpbGVycyhzdGF0dXMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXR1cztcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVUcmFpbGVycyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHB1c2goZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMudW5zaGlmdCguLi5maWx0ZXJzKTtcbiAgICB9XG4gICAgZ2V0RmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycztcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlclN0YWNrID0gRmlsdGVyU3RhY2s7XG5jbGFzcyBGaWx0ZXJTdGFja0ZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGZhY3Rvcmllcykge1xuICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICB9XG4gICAgcHVzaChmaWx0ZXJGYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMudW5zaGlmdCguLi5maWx0ZXJGYWN0b3JpZXMpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJTdGFja0ZhY3RvcnkoWy4uLnRoaXMuZmFjdG9yaWVzXSk7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJTdGFjayh0aGlzLmZhY3Rvcmllcy5tYXAoZmFjdG9yeSA9PiBmYWN0b3J5LmNyZWF0ZUZpbHRlcigpKSk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJTdGFja0ZhY3RvcnkgPSBGaWx0ZXJTdGFja0ZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXItc3RhY2suanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n}\nexports.BaseFilter = BaseFilter;\n//# sourceMappingURL=filter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ZpbHRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRmlsdGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZUZpbHRlciB7XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUZpbHRlciA9IEJhc2VGaWx0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst resolver_dns_1 = __webpack_require__(/*! ./resolver-dns */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = '';\n    let envVar = '';\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */\n    if (process.env.grpc_proxy) {\n        envVar = 'grpc_proxy';\n        proxyEnv = process.env.grpc_proxy;\n    }\n    else if (process.env.https_proxy) {\n        envVar = 'https_proxy';\n        proxyEnv = process.env.https_proxy;\n    }\n    else if (process.env.http_proxy) {\n        envVar = 'http_proxy';\n        proxyEnv = process.env.http_proxy;\n    }\n    else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    }\n    catch (e) {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== 'http:') {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        }\n        else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */\n    if (port === '') {\n        port = '80';\n    }\n    const result = {\n        address: `${hostname}:${port}`,\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n    let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = 'no_grpc_proxy';\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = 'no_proxy';\n    }\n    if (noProxyStr) {\n        trace('No proxy server list set by environment variable ' + envVar);\n        return noProxyStr.split(',');\n    }\n    else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {},\n    };\n    if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === 'unix') {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()) {\n        if (host === serverHost) {\n            trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target),\n    };\n    if (proxyInfo.creds) {\n        extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: 'dns',\n            path: proxyInfo.address,\n        },\n        extraOptions: extraOptions,\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    var _a;\n    if (!('grpc.http_connect_target' in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions['grpc.http_connect_target'];\n    const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);\n    if (splitHostPost === null) {\n        return Promise.resolve({});\n    }\n    const hostPort = `${splitHostPost.host}:${(_a = splitHostPost.port) !== null && _a !== void 0 ? _a : resolver_dns_1.DEFAULT_PORT}`;\n    const options = {\n        method: 'CONNECT',\n        path: hostPort,\n    };\n    const headers = {\n        Host: hostPort,\n    };\n    // Connect to the subchannel address as a proxy\n    if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    }\n    else {\n        options.socketPath = address.path;\n    }\n    if ('grpc.http_connect_creds' in channelOptions) {\n        headers['Proxy-Authorization'] =\n            'Basic ' +\n                Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n    }\n    options.headers = headers;\n    const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n    trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n    return new Promise((resolve, reject) => {\n        const request = http.request(options);\n        request.once('connect', (res, socket, head) => {\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace('Successfully connected to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString);\n                if ('secureContext' in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n                    const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket: socket }, connectionOptions), () => {\n                        trace('Successfully established a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString);\n                        resolve({ socket: cts, realTarget: parsedTarget });\n                    });\n                    cts.on('error', (error) => {\n                        trace('Failed to establish a TLS connection to ' +\n                            options.path +\n                            ' through proxy ' +\n                            proxyAddressString +\n                            ' with error ' +\n                            error.message);\n                        reject();\n                    });\n                }\n                else {\n                    trace('Successfully established a plaintext connection to ' +\n                        options.path +\n                        ' through proxy ' +\n                        proxyAddressString);\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget,\n                    });\n                }\n            }\n            else {\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with status ' +\n                    res.statusCode);\n                reject();\n            }\n        });\n        request.once('error', err => {\n            request.removeAllListeners();\n            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' +\n                proxyAddressString +\n                ' with error ' +\n                err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection;\n//# sourceMappingURL=http_proxy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLG9CQUFvQjtBQUNuRCxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsdUJBQXVCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLE9BQU87QUFDNUY7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtCQUFrQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxHQUFHLEtBQUs7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx3QkFBd0IsbUJBQW1CLEdBQUcsdUZBQXVGO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwREFBMEQ7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUNBQXVDO0FBQ3pFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9odHRwX3Byb3h5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFByb3hpZWRDb25uZWN0aW9uID0gZXhwb3J0cy5tYXBQcm94eU5hbWUgPSB2b2lkIDA7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCB0bHMgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCB1cmxfMSA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCByZXNvbHZlcl9kbnNfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyLWRuc1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Byb3h5JztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuZnVuY3Rpb24gZ2V0UHJveHlJbmZvKCkge1xuICAgIGxldCBwcm94eUVudiA9ICcnO1xuICAgIGxldCBlbnZWYXIgPSAnJztcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnaHR0cF9wcm94eScgaWYgaXQgaXMgbm90IHNldC5cbiAgICAgKiBBbHNvIHByZWZlciB1c2luZyAnaHR0cHNfcHJveHknIHdpdGggZmFsbGJhY2sgb24gJ2h0dHBfcHJveHknLiBUaGVcbiAgICAgKiBmYWxsYmFjayBiZWhhdmlvciBjYW4gYmUgcmVtb3ZlZCBpZiB0aGVyZSdzIGEgZGVtYW5kIGZvciBpdC5cbiAgICAgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuZ3JwY19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnZ3JwY19wcm94eSc7XG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuZ3JwY19wcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cHNfcHJveHkpIHtcbiAgICAgICAgZW52VmFyID0gJ2h0dHBzX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwc19wcm94eTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvY2Vzcy5lbnYuaHR0cF9wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cF9wcm94eSc7XG4gICAgICAgIHByb3h5RW52ID0gcHJvY2Vzcy5lbnYuaHR0cF9wcm94eTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IHByb3h5VXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHByb3h5VXJsID0gbmV3IHVybF8xLlVSTChwcm94eUVudik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBjYW5ub3QgcGFyc2UgdmFsdWUgb2YgXCIke2VudlZhcn1cIiBlbnYgdmFyYCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKHByb3h5VXJsLnByb3RvY29sICE9PSAnaHR0cDonKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEubG9nKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBcIiR7cHJveHlVcmwucHJvdG9jb2x9XCIgc2NoZW1lIG5vdCBzdXBwb3J0ZWQgaW4gcHJveHkgVVJJYCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgbGV0IHVzZXJDcmVkID0gbnVsbDtcbiAgICBpZiAocHJveHlVcmwudXNlcm5hbWUpIHtcbiAgICAgICAgaWYgKHByb3h5VXJsLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8sICd1c2VyaW5mbyBmb3VuZCBpbiBwcm94eSBVUkknKTtcbiAgICAgICAgICAgIHVzZXJDcmVkID0gYCR7cHJveHlVcmwudXNlcm5hbWV9OiR7cHJveHlVcmwucGFzc3dvcmR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzZXJDcmVkID0gcHJveHlVcmwudXNlcm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaG9zdG5hbWUgPSBwcm94eVVybC5ob3N0bmFtZTtcbiAgICBsZXQgcG9ydCA9IHByb3h5VXJsLnBvcnQ7XG4gICAgLyogVGhlIHByb3h5IFVSTCB1c2VzIHRoZSBzY2hlbWUgXCJodHRwOlwiLCB3aGljaCBoYXMgYSBkZWZhdWx0IHBvcnQgbnVtYmVyIG9mXG4gICAgICogODAuIFdlIG5lZWQgdG8gc2V0IHRoYXQgZXhwbGljaXRseSBoZXJlIGlmIGl0IGlzIG9taXR0ZWQgYmVjYXVzZSBvdGhlcndpc2VcbiAgICAgKiBpdCB3aWxsIHVzZSBnUlBDJ3MgZGVmYXVsdCBwb3J0IDQ0My4gKi9cbiAgICBpZiAocG9ydCA9PT0gJycpIHtcbiAgICAgICAgcG9ydCA9ICc4MCc7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgYWRkcmVzczogYCR7aG9zdG5hbWV9OiR7cG9ydH1gLFxuICAgIH07XG4gICAgaWYgKHVzZXJDcmVkKSB7XG4gICAgICAgIHJlc3VsdC5jcmVkcyA9IHVzZXJDcmVkO1xuICAgIH1cbiAgICB0cmFjZSgnUHJveHkgc2VydmVyICcgKyByZXN1bHQuYWRkcmVzcyArICcgc2V0IGJ5IGVudmlyb25tZW50IHZhcmlhYmxlICcgKyBlbnZWYXIpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXROb1Byb3h5SG9zdExpc3QoKSB7XG4gICAgLyogUHJlZmVyIHVzaW5nICdub19ncnBjX3Byb3h5Jy4gRmFsbGJhY2sgb24gJ25vX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LiAqL1xuICAgIGxldCBub1Byb3h5U3RyID0gcHJvY2Vzcy5lbnYubm9fZ3JwY19wcm94eTtcbiAgICBsZXQgZW52VmFyID0gJ25vX2dycGNfcHJveHknO1xuICAgIGlmICghbm9Qcm94eVN0cikge1xuICAgICAgICBub1Byb3h5U3RyID0gcHJvY2Vzcy5lbnYubm9fcHJveHk7XG4gICAgICAgIGVudlZhciA9ICdub19wcm94eSc7XG4gICAgfVxuICAgIGlmIChub1Byb3h5U3RyKSB7XG4gICAgICAgIHRyYWNlKCdObyBwcm94eSBzZXJ2ZXIgbGlzdCBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgICAgIHJldHVybiBub1Byb3h5U3RyLnNwbGl0KCcsJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFwUHJveHlOYW1lKHRhcmdldCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBub1Byb3h5UmVzdWx0ID0ge1xuICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgZXh0cmFPcHRpb25zOiB7fSxcbiAgICB9O1xuICAgIGlmICgoKF9hID0gb3B0aW9uc1snZ3JwYy5lbmFibGVfaHR0cF9wcm94eSddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09ICd1bml4Jykge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcHJveHlJbmZvID0gZ2V0UHJveHlJbmZvKCk7XG4gICAgaWYgKCFwcm94eUluZm8uYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgaG9zdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRhcmdldC5wYXRoKTtcbiAgICBpZiAoIWhvc3RQb3J0KSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBzZXJ2ZXJIb3N0ID0gaG9zdFBvcnQuaG9zdDtcbiAgICBmb3IgKGNvbnN0IGhvc3Qgb2YgZ2V0Tm9Qcm94eUhvc3RMaXN0KCkpIHtcbiAgICAgICAgaWYgKGhvc3QgPT09IHNlcnZlckhvc3QpIHtcbiAgICAgICAgICAgIHRyYWNlKCdOb3QgdXNpbmcgcHJveHkgZm9yIHRhcmdldCBpbiBub19wcm94eSBsaXN0OiAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSk7XG4gICAgICAgICAgICByZXR1cm4gbm9Qcm94eVJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHRyYU9wdGlvbnMgPSB7XG4gICAgICAgICdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnOiAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0YXJnZXQpLFxuICAgIH07XG4gICAgaWYgKHByb3h5SW5mby5jcmVkcykge1xuICAgICAgICBleHRyYU9wdGlvbnNbJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJ10gPSBwcm94eUluZm8uY3JlZHM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgc2NoZW1lOiAnZG5zJyxcbiAgICAgICAgICAgIHBhdGg6IHByb3h5SW5mby5hZGRyZXNzLFxuICAgICAgICB9LFxuICAgICAgICBleHRyYU9wdGlvbnM6IGV4dHJhT3B0aW9ucyxcbiAgICB9O1xufVxuZXhwb3J0cy5tYXBQcm94eU5hbWUgPSBtYXBQcm94eU5hbWU7XG5mdW5jdGlvbiBnZXRQcm94aWVkQ29ubmVjdGlvbihhZGRyZXNzLCBjaGFubmVsT3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gY2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH1cbiAgICBjb25zdCByZWFsVGFyZ2V0ID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCddO1xuICAgIGNvbnN0IHBhcnNlZFRhcmdldCA9ICgwLCB1cmlfcGFyc2VyXzEucGFyc2VVcmkpKHJlYWxUYXJnZXQpO1xuICAgIGlmIChwYXJzZWRUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7fSk7XG4gICAgfVxuICAgIGNvbnN0IHNwbGl0SG9zdFBvc3QgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBhcnNlZFRhcmdldC5wYXRoKTtcbiAgICBpZiAoc3BsaXRIb3N0UG9zdCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3QgaG9zdFBvcnQgPSBgJHtzcGxpdEhvc3RQb3N0Lmhvc3R9OiR7KF9hID0gc3BsaXRIb3N0UG9zdC5wb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByZXNvbHZlcl9kbnNfMS5ERUZBVUxUX1BPUlR9YDtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBtZXRob2Q6ICdDT05ORUNUJyxcbiAgICAgICAgcGF0aDogaG9zdFBvcnQsXG4gICAgfTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICBIb3N0OiBob3N0UG9ydCxcbiAgICB9O1xuICAgIC8vIENvbm5lY3QgdG8gdGhlIHN1YmNoYW5uZWwgYWRkcmVzcyBhcyBhIHByb3h5XG4gICAgaWYgKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKShhZGRyZXNzKSkge1xuICAgICAgICBvcHRpb25zLmhvc3QgPSBhZGRyZXNzLmhvc3Q7XG4gICAgICAgIG9wdGlvbnMucG9ydCA9IGFkZHJlc3MucG9ydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuc29ja2V0UGF0aCA9IGFkZHJlc3MucGF0aDtcbiAgICB9XG4gICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF9jcmVkcycgaW4gY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgaGVhZGVyc1snUHJveHktQXV0aG9yaXphdGlvbiddID1cbiAgICAgICAgICAgICdCYXNpYyAnICtcbiAgICAgICAgICAgICAgICBCdWZmZXIuZnJvbShjaGFubmVsT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIH1cbiAgICBvcHRpb25zLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIGNvbnN0IHByb3h5QWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKTtcbiAgICB0cmFjZSgnVXNpbmcgcHJveHkgJyArIHByb3h5QWRkcmVzc1N0cmluZyArICcgdG8gY29ubmVjdCB0byAnICsgb3B0aW9ucy5wYXRoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Nvbm5lY3QnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKCdzZWN1cmVDb250ZXh0JyBpbiBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGUgdGhpcyBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgICogY29ubmVjdGlvbiB0byBhIFRMUyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMlxuICAgICAgICAgICAgICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL3B1bGwvMTM2OSBmb3IgbW9yZSBpbmZvLiAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gKDAsIHJlc29sdmVyXzEuZ2V0RGVmYXVsdEF1dGhvcml0eSkocGFyc2VkVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9zdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZW1vdGVIb3N0ID0gKF9hID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRhcmdldFBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN0cyA9IHRscy5jb25uZWN0KE9iamVjdC5hc3NpZ24oeyBob3N0OiByZW1vdGVIb3N0LCBzZXJ2ZXJuYW1lOiByZW1vdGVIb3N0LCBzb2NrZXQ6IHNvY2tldCB9LCBjb25uZWN0aW9uT3B0aW9ucyksICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKCdTdWNjZXNzZnVsbHkgZXN0YWJsaXNoZWQgYSBUTFMgY29ubmVjdGlvbiB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm94eUFkZHJlc3NTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHNvY2tldDogY3RzLCByZWFsVGFyZ2V0OiBwYXJzZWRUYXJnZXQgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjdHMub24oJ2Vycm9yJywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRmFpbGVkIHRvIGVzdGFibGlzaCBhIFRMUyBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIHBsYWludGV4dCBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhbFRhcmdldDogcGFyc2VkVGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAoMCwgbG9nZ2luZ18xLmxvZykoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgJyB3aXRoIHN0YXR1cyAnICtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5vbmNlKCdlcnJvcicsIGVyciA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgJ0ZhaWxlZCB0byBjb25uZWN0IHRvIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0UHJveGllZENvbm5lY3Rpb24gPSBnZXRQcm94aWVkQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBfcHJveHkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.experimental = exports.addAdminServicesToServer = exports.getChannelzHandlers = exports.getChannelzServiceDefinition = exports.InterceptorConfigurationError = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({ enumerable: true, get: function () { return call_credentials_1.CallCredentials; } }));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({ enumerable: true, get: function () { return channel_1.ChannelImplementation; } }));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({ enumerable: true, get: function () { return compression_algorithms_1.CompressionAlgorithms; } }));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({ enumerable: true, get: function () { return connectivity_state_1.ConnectivityState; } }));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({ enumerable: true, get: function () { return channel_credentials_1.ChannelCredentials; } }));\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({ enumerable: true, get: function () { return client_1.Client; } }));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({ enumerable: true, get: function () { return constants_1.LogVerbosity; } }));\nObject.defineProperty(exports, \"status\", ({ enumerable: true, get: function () { return constants_1.Status; } }));\nObject.defineProperty(exports, \"propagate\", ({ enumerable: true, get: function () { return constants_1.Propagate; } }));\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({ enumerable: true, get: function () { return make_client_1.loadPackageDefinition; } }));\nObject.defineProperty(exports, \"makeClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({ enumerable: true, get: function () { return make_client_1.makeClientConstructor; } }));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({ enumerable: true, get: function () { return metadata_1.Metadata; } }));\nconst server_1 = __webpack_require__(/*! ./server */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({ enumerable: true, get: function () { return server_1.Server; } }));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({ enumerable: true, get: function () { return server_credentials_1.ServerCredentials; } }));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({ enumerable: true, get: function () { return status_builder_1.StatusBuilder; } }));\n/**** Client Credentials ****/\n// Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */\n    combineChannelCredentials: (channelCredentials, ...callCredentials) => {\n        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */\n    combineCallCredentials: (first, ...additional) => {\n        return additional.reduce((acc, other) => acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty,\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */\nconst closeClient = (client) => client.close();\nexports.closeClient = closeClient;\nconst waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);\nexports.waitForClientReady = waitForClientReady;\n/* eslint-enable @typescript-eslint/no-explicit-any */\n/**** Unimplemented function stubs ****/\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst loadObject = (value, options) => {\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\nexports.loadObject = loadObject;\nconst load = (filename, format, options) => {\n    throw new Error('Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead');\n};\nexports.load = load;\nconst setLogger = (logger) => {\n    logging.setLogger(logger);\n};\nexports.setLogger = setLogger;\nconst setLogVerbosity = (verbosity) => {\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.setLogVerbosity = setLogVerbosity;\nconst getClientChannel = (client) => {\n    return client_1.Client.prototype.getChannel.call(client);\n};\nexports.getClientChannel = getClientChannel;\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.ListenerBuilder; } }));\nObject.defineProperty(exports, \"RequesterBuilder\", ({ enumerable: true, get: function () { return client_interceptors_1.RequesterBuilder; } }));\nObject.defineProperty(exports, \"InterceptingCall\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptingCall; } }));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({ enumerable: true, get: function () { return client_interceptors_1.InterceptorConfigurationError; } }));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({ enumerable: true, get: function () { return channelz_1.getChannelzServiceDefinition; } }));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({ enumerable: true, get: function () { return channelz_1.getChannelzHandlers; } }));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({ enumerable: true, get: function () { return admin_1.addAdminServicesToServer; } }));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n(() => {\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    channelz.setup();\n})();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkIsR0FBRyxvQ0FBb0MsR0FBRyxxQ0FBcUMsR0FBRyx3QkFBd0IsR0FBRyx3QkFBd0IsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxjQUFjLEdBQUcsdUJBQXVCLEdBQUcsaUJBQWlCLEdBQUcsWUFBWSxHQUFHLGtCQUFrQixHQUFHLHVCQUF1QixHQUFHLDBCQUEwQixHQUFHLDBCQUEwQixHQUFHLG1CQUFtQixHQUFHLGVBQWUsR0FBRyxvQ0FBb0MsR0FBRyw2QkFBNkIsR0FBRyw2QkFBNkIsR0FBRyxjQUFjLEdBQUcsNkJBQTZCLEdBQUcsaUJBQWlCLEdBQUcseUJBQXlCLEdBQUcsY0FBYyxHQUFHLG9CQUFvQixHQUFHLGdCQUFnQixHQUFHLG1CQUFtQjtBQUMzekIsMkJBQTJCLG1CQUFPLENBQUMsNEZBQW9CO0FBQ3ZELG1EQUFrRCxFQUFFLHFDQUFxQyw4Q0FBOEMsRUFBQztBQUN4SSxrQkFBa0IsbUJBQU8sQ0FBQywwRUFBVztBQUNyQywyQ0FBMEMsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUM7QUFDN0gsaUNBQWlDLG1CQUFPLENBQUMsd0dBQTBCO0FBQ25FLHlEQUF3RCxFQUFFLHFDQUFxQywwREFBMEQsRUFBQztBQUMxSiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscURBQW9ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzlJLDhCQUE4QixtQkFBTyxDQUFDLGtHQUF1QjtBQUM3RCxzREFBcUQsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDakosaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsMENBQXlDLEVBQUUscUNBQXFDLDJCQUEyQixFQUFDO0FBQzVHLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLGdEQUErQyxFQUFFLHFDQUFxQyxvQ0FBb0MsRUFBQztBQUMzSCwwQ0FBeUMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDL0csNkNBQTRDLEVBQUUscUNBQXFDLGlDQUFpQyxFQUFDO0FBQ3JILGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDLHlEQUF3RCxFQUFFLHFDQUFxQywrQ0FBK0MsRUFBQztBQUMvSSx5REFBd0QsRUFBRSxxQ0FBcUMsK0NBQStDLEVBQUM7QUFDL0ksZ0VBQStELEVBQUUscUNBQXFDLCtDQUErQyxFQUFDO0FBQ3RKLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLDRDQUEyQyxFQUFFLHFDQUFxQywrQkFBK0IsRUFBQztBQUNsSCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQywwQ0FBeUMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDNUcsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFEQUFvRCxFQUFFLHFDQUFxQyxrREFBa0QsRUFBQztBQUM5SSx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsaURBQWdELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ2xJO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsNEJBQTRCLG1CQUFPLENBQUMsa0dBQXVCO0FBQzNELG1EQUFrRCxFQUFFLHFDQUFxQyxpREFBaUQsRUFBQztBQUMzSSxvREFBbUQsRUFBRSxxQ0FBcUMsa0RBQWtELEVBQUM7QUFDN0ksb0RBQW1ELEVBQUUscUNBQXFDLGtEQUFrRCxFQUFDO0FBQzdJLGlFQUFnRSxFQUFFLHFDQUFxQywrREFBK0QsRUFBQztBQUN2SyxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUNyQyxnRUFBK0QsRUFBRSxxQ0FBcUMsbURBQW1ELEVBQUM7QUFDMUosdURBQXNELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ3hJLGNBQWMsbUJBQU8sQ0FBQyxzRUFBUztBQUMvQiw0REFBMkQsRUFBRSxxQ0FBcUMsNENBQTRDLEVBQUM7QUFDL0kscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQzdDLG9CQUFvQjtBQUNwQixxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDN0MscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLGtGQUFlO0FBQzNDLGlDQUFpQyxtQkFBTyxDQUFDLDRHQUE0QjtBQUNyRSxrQ0FBa0MsbUJBQU8sQ0FBQyw4R0FBNkI7QUFDdkUsd0NBQXdDLG1CQUFPLENBQUMsMEhBQW1DO0FBQ25GLGlCQUFpQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4cGVyaW1lbnRhbCA9IGV4cG9ydHMuYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyID0gZXhwb3J0cy5nZXRDaGFubmVsekhhbmRsZXJzID0gZXhwb3J0cy5nZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uID0gZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IGV4cG9ydHMuSW50ZXJjZXB0aW5nQ2FsbCA9IGV4cG9ydHMuUmVxdWVzdGVyQnVpbGRlciA9IGV4cG9ydHMuTGlzdGVuZXJCdWlsZGVyID0gZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gZXhwb3J0cy5nZXRDbGllbnRDaGFubmVsID0gZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IGV4cG9ydHMuU2VydmVyID0gZXhwb3J0cy5zZXRMb2dWZXJib3NpdHkgPSBleHBvcnRzLnNldExvZ2dlciA9IGV4cG9ydHMubG9hZCA9IGV4cG9ydHMubG9hZE9iamVjdCA9IGV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gZXhwb3J0cy5DaGFubmVsQ3JlZGVudGlhbHMgPSBleHBvcnRzLndhaXRGb3JDbGllbnRSZWFkeSA9IGV4cG9ydHMuY2xvc2VDbGllbnQgPSBleHBvcnRzLkNoYW5uZWwgPSBleHBvcnRzLm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3IgPSBleHBvcnRzLm1ha2VDbGllbnRDb25zdHJ1Y3RvciA9IGV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gZXhwb3J0cy5DbGllbnQgPSBleHBvcnRzLmNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IGV4cG9ydHMucHJvcGFnYXRlID0gZXhwb3J0cy5jb25uZWN0aXZpdHlTdGF0ZSA9IGV4cG9ydHMuc3RhdHVzID0gZXhwb3J0cy5sb2dWZXJib3NpdHkgPSBleHBvcnRzLk1ldGFkYXRhID0gZXhwb3J0cy5jcmVkZW50aWFscyA9IHZvaWQgMDtcbmNvbnN0IGNhbGxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDYWxsQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2hhbm5lbF8xLkNoYW5uZWxJbXBsZW1lbnRhdGlvbjsgfSB9KTtcbmNvbnN0IGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWFsZ29yaXRobXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb21wcmVzc2lvbkFsZ29yaXRobXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXByZXNzaW9uX2FsZ29yaXRobXNfMS5Db21wcmVzc2lvbkFsZ29yaXRobXM7IH0gfSk7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNvbm5lY3Rpdml0eVN0YXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZTsgfSB9KTtcbmNvbnN0IGNoYW5uZWxfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWwtY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDaGFubmVsQ3JlZGVudGlhbHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNsaWVudFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xpZW50XzEuQ2xpZW50OyB9IH0pO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2dWZXJib3NpdHlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInN0YXR1c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuU3RhdHVzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicHJvcGFnYXRlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5Qcm9wYWdhdGU7IH0gfSk7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IG1ha2VfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9tYWtlLWNsaWVudFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRQYWNrYWdlRGVmaW5pdGlvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5sb2FkUGFja2FnZURlZmluaXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJtYWtlQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUdlbmVyaWNDbGllbnRDb25zdHJ1Y3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZV9jbGllbnRfMS5tYWtlQ2xpZW50Q29uc3RydWN0b3I7IH0gfSk7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNZXRhZGF0YVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbWV0YWRhdGFfMS5NZXRhZGF0YTsgfSB9KTtcbmNvbnN0IHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfMS5TZXJ2ZXI7IH0gfSk7XG5jb25zdCBzZXJ2ZXJfY3JlZGVudGlhbHNfMSA9IHJlcXVpcmUoXCIuL3NlcnZlci1jcmVkZW50aWFsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlckNyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfY3JlZGVudGlhbHNfMS5TZXJ2ZXJDcmVkZW50aWFsczsgfSB9KTtcbmNvbnN0IHN0YXR1c19idWlsZGVyXzEgPSByZXF1aXJlKFwiLi9zdGF0dXMtYnVpbGRlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlN0YXR1c0J1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXR1c19idWlsZGVyXzEuU3RhdHVzQnVpbGRlcjsgfSB9KTtcbi8qKioqIENsaWVudCBDcmVkZW50aWFscyAqKioqL1xuLy8gVXNpbmcgYXNzaWduIG9ubHkgY29waWVzIGVudW1lcmFibGUgcHJvcGVydGllcywgd2hpY2ggaXMgd2hhdCB3ZSB3YW50XG5leHBvcnRzLmNyZWRlbnRpYWxzID0ge1xuICAgIC8qKlxuICAgICAqIENvbWJpbmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgd2l0aCBhbnkgbnVtYmVyIG9mIENhbGxDcmVkZW50aWFscyBpbnRvIGFcbiAgICAgKiBzaW5nbGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbENyZWRlbnRpYWxzIFRoZSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBjYWxsQ3JlZGVudGlhbHMgQW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb21iaW5lQ2hhbm5lbENyZWRlbnRpYWxzOiAoY2hhbm5lbENyZWRlbnRpYWxzLCAuLi5jYWxsQ3JlZGVudGlhbHMpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbGxDcmVkZW50aWFscy5yZWR1Y2UoKGFjYywgb3RoZXIpID0+IGFjYy5jb21wb3NlKG90aGVyKSwgY2hhbm5lbENyZWRlbnRpYWxzKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENvbWJpbmUgYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhIHNpbmdsZSBDYWxsQ3JlZGVudGlhbHNcbiAgICAgKiBvYmplY3QuXG4gICAgICogQHBhcmFtIGZpcnN0IFRoZSBmaXJzdCBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsIEFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIFRoZSByZXN1bHRpbmcgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKi9cbiAgICBjb21iaW5lQ2FsbENyZWRlbnRpYWxzOiAoZmlyc3QsIC4uLmFkZGl0aW9uYWwpID0+IHtcbiAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWwucmVkdWNlKChhY2MsIG90aGVyKSA9PiBhY2MuY29tcG9zZShvdGhlciksIGZpcnN0KTtcbiAgICB9LFxuICAgIC8vIGZyb20gY2hhbm5lbC1jcmVkZW50aWFscy50c1xuICAgIGNyZWF0ZUluc2VjdXJlOiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZUluc2VjdXJlLFxuICAgIGNyZWF0ZVNzbDogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVTc2wsXG4gICAgY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQ6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQsXG4gICAgLy8gZnJvbSBjYWxsLWNyZWRlbnRpYWxzLnRzXG4gICAgY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yOiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcixcbiAgICBjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbDogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbCxcbiAgICBjcmVhdGVFbXB0eTogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVFbXB0eSxcbn07XG4vKipcbiAqIENsb3NlIGEgQ2xpZW50IG9iamVjdC5cbiAqIEBwYXJhbSBjbGllbnQgVGhlIGNsaWVudCB0byBjbG9zZS5cbiAqL1xuY29uc3QgY2xvc2VDbGllbnQgPSAoY2xpZW50KSA9PiBjbGllbnQuY2xvc2UoKTtcbmV4cG9ydHMuY2xvc2VDbGllbnQgPSBjbG9zZUNsaWVudDtcbmNvbnN0IHdhaXRGb3JDbGllbnRSZWFkeSA9IChjbGllbnQsIGRlYWRsaW5lLCBjYWxsYmFjaykgPT4gY2xpZW50LndhaXRGb3JSZWFkeShkZWFkbGluZSwgY2FsbGJhY2spO1xuZXhwb3J0cy53YWl0Rm9yQ2xpZW50UmVhZHkgPSB3YWl0Rm9yQ2xpZW50UmVhZHk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKioqIFVuaW1wbGVtZW50ZWQgZnVuY3Rpb24gc3R1YnMgKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IGxvYWRPYmplY3QgPSAodmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMubG9hZE9iamVjdCA9IGxvYWRPYmplY3Q7XG5jb25zdCBsb2FkID0gKGZpbGVuYW1lLCBmb3JtYXQsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5jb25zdCBzZXRMb2dnZXIgPSAobG9nZ2VyKSA9PiB7XG4gICAgbG9nZ2luZy5zZXRMb2dnZXIobG9nZ2VyKTtcbn07XG5leHBvcnRzLnNldExvZ2dlciA9IHNldExvZ2dlcjtcbmNvbnN0IHNldExvZ1ZlcmJvc2l0eSA9ICh2ZXJib3NpdHkpID0+IHtcbiAgICBsb2dnaW5nLnNldExvZ2dlclZlcmJvc2l0eSh2ZXJib3NpdHkpO1xufTtcbmV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gc2V0TG9nVmVyYm9zaXR5O1xuY29uc3QgZ2V0Q2xpZW50Q2hhbm5lbCA9IChjbGllbnQpID0+IHtcbiAgICByZXR1cm4gY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5nZXRDaGFubmVsLmNhbGwoY2xpZW50KTtcbn07XG5leHBvcnRzLmdldENsaWVudENoYW5uZWwgPSBnZXRDbGllbnRDaGFubmVsO1xudmFyIGNsaWVudF9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL2NsaWVudC1pbnRlcmNlcHRvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXN0ZW5lckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5MaXN0ZW5lckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0ZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuUmVxdWVzdGVyQnVpbGRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdGluZ0NhbGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRpbmdDYWxsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjsgfSB9KTtcbnZhciBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVsekhhbmRsZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6SGFuZGxlcnM7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZG1pbl8xLmFkZEFkbWluU2VydmljZXNUb1NlcnZlcjsgfSB9KTtcbmNvbnN0IGV4cGVyaW1lbnRhbCA9IHJlcXVpcmUoXCIuL2V4cGVyaW1lbnRhbFwiKTtcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwZXJpbWVudGFsO1xuY29uc3QgcmVzb2x2ZXJfZG5zID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xuY29uc3QgcmVzb2x2ZXJfdWRzID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItdWRzXCIpO1xuY29uc3QgcmVzb2x2ZXJfaXAgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1pcFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdCA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbiA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb25cIik7XG5jb25zdCBjaGFubmVseiA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuKCgpID0+IHtcbiAgICByZXNvbHZlcl9kbnMuc2V0dXAoKTtcbiAgICByZXNvbHZlcl91ZHMuc2V0dXAoKTtcbiAgICByZXNvbHZlcl9pcC5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfcGlja19maXJzdC5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4uc2V0dXAoKTtcbiAgICBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uLnNldHVwKCk7XG4gICAgY2hhbm5lbHouc2V0dXAoKTtcbn0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/internal-channel.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InternalChannel = void 0;\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst load_balancing_call_1 = __webpack_require__(/*! ./load-balancing-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst resolving_call_1 = __webpack_require__(/*! ./resolving-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst retrying_call_1 = __webpack_require__(/*! ./retrying-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\nconst MIN_IDLE_TIMEOUT_MS = 1000;\n// 30 minutes\nconst DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1000;\nconst RETRY_THROTTLER_MAP = new Map();\nconst DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24; // 16 MB\nconst DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20; // 1 MB\nclass ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, channel) {\n        super(childSubchannel);\n        this.channel = channel;\n        this.refCount = 0;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {\n            channel.throttleKeepalive(keepaliveTime);\n        };\n        childSubchannel.addConnectivityStateListener(this.subchannelStateListener);\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            this.child.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channel.removeWrappedSubchannel(this);\n        }\n    }\n}\nclass InternalChannel {\n    constructor(target, credentials, options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */\n        this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */\n        this.currentResolutionError = null;\n        this.wrappedSubchannels = new Set();\n        this.callCount = 0;\n        this.idleTimer = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        if (typeof target !== 'string') {\n            throw new TypeError('Channel target must be a string');\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError('Channel credentials must be a ChannelCredentials object');\n        }\n        if (options) {\n            if (typeof options !== 'object') {\n                throw new TypeError('Channel options must be an object');\n            }\n        }\n        this.originalTarget = target;\n        const originalTargetUri = (0, uri_parser_1.parseUri)(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */\n        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(() => { }, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n        }\n        if (this.options['grpc.default_authority']) {\n            this.defaultAuthority = this.options['grpc.default_authority'];\n        }\n        else {\n            this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);\n        }\n        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */\n        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options['grpc.retry_buffer_size']) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options['grpc.per_rpc_retry_buffer_size']) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);\n        this.keepaliveTime = (_f = options['grpc.keepalive_time_ms']) !== null && _f !== void 0 ? _f : -1;\n        this.idleTimeoutMs = Math.max((_g = options['grpc.client_idle_timeout_ms']) !== null && _g !== void 0 ? _g : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n                subchannel.throttleKeepalive(this.keepaliveTime);\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n                }\n                const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);\n                this.wrappedSubchannels.add(wrappedSubchannel);\n                return wrappedSubchannel;\n            },\n            updateState: (connectivityState, picker) => {\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                if (queueCopy.length > 0) {\n                    this.callRefTimerUnref();\n                }\n                for (const call of queueCopy) {\n                    call.doPick();\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: () => {\n                // This should never be called.\n                throw new Error('Resolving load balancer should never call requestReresolution');\n            },\n            addChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child) => {\n                if (this.channelzEnabled) {\n                    this.childrenTracker.unrefChild(child);\n                }\n            },\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => {\n            if (serviceConfig.retryThrottling) {\n                RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));\n            }\n            else {\n                RETRY_THROTTLER_MAP.delete(this.getTarget());\n            }\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n            }\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */\n            process.nextTick(() => {\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                if (localQueue.length > 0) {\n                    this.callRefTimerUnref();\n                }\n                for (const call of localQueue) {\n                    call.getConfig();\n                }\n            });\n        }, status => {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' +\n                    status.code +\n                    ' and details \"' +\n                    status.details +\n                    '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace('Name resolution failed with calls queued for config selection');\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            if (localQueue.length > 0) {\n                this.callRefTimerUnref();\n            }\n            for (const call of localQueue) {\n                call.reportResolverError(status);\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new compression_filter_1.CompressionFilterFactory(this, this.options),\n        ]);\n        this.trace('Channel constructed with options ' +\n            JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'channel_stacktrace', '(' +\n            this.channelzRef.id +\n            ') ' +\n            'Channel constructed \\n' +\n            ((_h = error.stack) === null || _h === void 0 ? void 0 : _h.substring(error.stack.indexOf('\\n') + 1)));\n        this.lastActivityTimestamp = new Date();\n    }\n    getChannelzInfo() {\n        return {\n            target: this.originalTarget,\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n        };\n    }\n    trace(text, verbosityOverride) {\n        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + (0, uri_parser_1.uriToString)(this.target) + ' ' + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace('callRefTimer.ref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n            this.trace('callRefTimer.unref | configSelectionQueue.length=' +\n                this.configSelectionQueue.length +\n                ' pickQueue.length=' +\n                this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' +\n            this.channelzRef.id +\n            ') ' +\n            (0, uri_parser_1.uriToString)(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy) {\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n            for (const wrappedSubchannel of this.wrappedSubchannels) {\n                wrappedSubchannel.throttleKeepalive(newKeepaliveTime);\n            }\n        }\n    }\n    removeWrappedSubchannel(wrappedSubchannel) {\n        this.wrappedSubchannels.delete(wrappedSubchannel);\n    }\n    doPick(metadata, extraPickInfo) {\n        return this.currentPicker.pick({\n            metadata: metadata,\n            extraPickInfo: extraPickInfo,\n        });\n    }\n    queueCallForPick(call) {\n        this.pickQueue.push(call);\n        this.callRefTimerRef();\n    }\n    getConfig(method, metadata) {\n        this.resolvingLoadBalancer.exitIdle();\n        if (this.configSelector) {\n            return {\n                type: 'SUCCESS',\n                config: this.configSelector(method, metadata),\n            };\n        }\n        else {\n            if (this.currentResolutionError) {\n                return {\n                    type: 'ERROR',\n                    error: this.currentResolutionError,\n                };\n            }\n            else {\n                return {\n                    type: 'NONE',\n                };\n            }\n        }\n    }\n    queueCallForConfig(call) {\n        this.configSelectionQueue.push(call);\n        this.callRefTimerRef();\n    }\n    enterIdle() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE);\n        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n            this.idleTimer = null;\n        }\n    }\n    startIdleTimeout(timeoutMs) {\n        var _a, _b;\n        this.idleTimer = setTimeout(() => {\n            if (this.callCount > 0) {\n                /* If there is currently a call, the channel will not go idle for a\n                 * period of at least idleTimeoutMs, so check again after that time.\n                 */\n                this.startIdleTimeout(this.idleTimeoutMs);\n                return;\n            }\n            const now = new Date();\n            const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();\n            if (timeSinceLastActivity >= this.idleTimeoutMs) {\n                this.trace('Idle timer triggered after ' +\n                    this.idleTimeoutMs +\n                    'ms of inactivity');\n                this.enterIdle();\n            }\n            else {\n                /* Whenever the timer fires with the latest activity being too recent,\n                 * set the timer again for the time when the time since the last\n                 * activity is equal to the timeout. This should result in the timer\n                 * firing no more than once every idleTimeoutMs/2 on average. */\n                this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);\n            }\n        }, timeoutMs);\n        (_b = (_a = this.idleTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    maybeStartIdleTimer() {\n        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && !this.idleTimer) {\n            this.startIdleTimeout(this.idleTimeoutMs);\n        }\n    }\n    onCallStart() {\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n        }\n        this.callCount += 1;\n    }\n    onCallEnd(status) {\n        if (this.channelzEnabled) {\n            if (status.code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            }\n            else {\n                this.callTracker.addCallFailed();\n            }\n        }\n        this.callCount -= 1;\n        this.lastActivityTimestamp = new Date();\n        this.maybeStartIdleTimer();\n    }\n    createLoadBalancingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createLoadBalancingCall [' + callNumber + '] method=\"' + method + '\"');\n        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);\n    }\n    createRetryingCall(callConfig, method, host, credentials, deadline) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createRetryingCall [' + callNumber + '] method=\"' + method + '\"');\n        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));\n    }\n    createInnerCall(callConfig, method, host, credentials, deadline) {\n        // Create a RetryingCall if retries are enabled\n        if (this.options['grpc.enable_retries'] === 0) {\n            return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);\n        }\n        else {\n            return this.createRetryingCall(callConfig, method, host, credentials, deadline);\n        }\n    }\n    createResolvingCall(method, deadline, host, parentCall, propagateFlags) {\n        const callNumber = (0, call_number_1.getNextCallNumber)();\n        this.trace('createResolvingCall [' +\n            callNumber +\n            '] method=\"' +\n            method +\n            '\", deadline=' +\n            (0, deadline_1.deadlineToString)(deadline));\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall,\n        };\n        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);\n        this.onCallStart();\n        call.addStatusWatcher(status => {\n            this.onCallEnd(status);\n        });\n        return call;\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        if (this.idleTimer) {\n            clearTimeout(this.idleTimer);\n        }\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return (0, uri_parser_1.uriToString)(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n            this.lastActivityTimestamp = new Date();\n            this.maybeStartIdleTimer();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n                return;\n            }\n            timer = setTimeout(() => {\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error('Deadline passed without connectivity state change'));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer,\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== 'string') {\n            throw new TypeError('Channel#createCall: method must be a string');\n        }\n        if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n            throw new TypeError('Channel#createCall: deadline must be a number or Date');\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error('Channel has been shut down');\n        }\n        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);\n    }\n}\nexports.InternalChannel = InternalChannel;\n//# sourceMappingURL=internal-channel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW50ZXJuYWwtY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2Qiw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsMEdBQTJCO0FBQ3JFLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6Qyx1QkFBdUIsbUJBQU8sQ0FBQyxvRkFBZ0I7QUFDL0MsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLDBFQUFXO0FBQ3JDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyw4QkFBOEIsbUJBQU8sQ0FBQyxrR0FBdUI7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsd0ZBQWtCO0FBQ25ELHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDLCtCQUErQixtQkFBTyxDQUFDLG9HQUF3QjtBQUMvRCx3QkFBd0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDakQsK0JBQStCLG1CQUFPLENBQUMsb0dBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsOEZBQThGLDJCQUEyQjtBQUNyTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ludGVybmFsLWNoYW5uZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW50ZXJuYWxDaGFubmVsID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfcG9vbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1wb29sXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuY29uc3QgY29tcHJlc3Npb25fZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1maWx0ZXJcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgaHR0cF9wcm94eV8xID0gcmVxdWlyZShcIi4vaHR0cF9wcm94eVwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jaW5nX2NhbGxfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jaW5nLWNhbGxcIik7XG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XG5jb25zdCByZXNvbHZpbmdfY2FsbF8xID0gcmVxdWlyZShcIi4vcmVzb2x2aW5nLWNhbGxcIik7XG5jb25zdCBjYWxsX251bWJlcl8xID0gcmVxdWlyZShcIi4vY2FsbC1udW1iZXJcIik7XG5jb25zdCBjb250cm9sX3BsYW5lX3N0YXR1c18xID0gcmVxdWlyZShcIi4vY29udHJvbC1wbGFuZS1zdGF0dXNcIik7XG5jb25zdCByZXRyeWluZ19jYWxsXzEgPSByZXF1aXJlKFwiLi9yZXRyeWluZy1jYWxsXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuLyoqXG4gKiBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lcnNfc2V0aW50ZXJ2YWxfY2FsbGJhY2tfZGVsYXlfYXJnc1xuICovXG5jb25zdCBNQVhfVElNRU9VVF9USU1FID0gMjE0NzQ4MzY0NztcbmNvbnN0IE1JTl9JRExFX1RJTUVPVVRfTVMgPSAxMDAwO1xuLy8gMzAgbWludXRlc1xuY29uc3QgREVGQVVMVF9JRExFX1RJTUVPVVRfTVMgPSAzMCAqIDYwICogMTAwMDtcbmNvbnN0IFJFVFJZX1RIUk9UVExFUl9NQVAgPSBuZXcgTWFwKCk7XG5jb25zdCBERUZBVUxUX1JFVFJZX0JVRkZFUl9TSVpFX0JZVEVTID0gMSA8PCAyNDsgLy8gMTYgTUJcbmNvbnN0IERFRkFVTFRfUEVSX1JQQ19SRVRSWV9CVUZGRVJfU0laRV9CWVRFUyA9IDEgPDwgMjA7IC8vIDEgTUJcbmNsYXNzIENoYW5uZWxTdWJjaGFubmVsV3JhcHBlciBleHRlbmRzIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEuQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZFN1YmNoYW5uZWwsIGNoYW5uZWwpIHtcbiAgICAgICAgc3VwZXIoY2hpbGRTdWJjaGFubmVsKTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5yZWZDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUpID0+IHtcbiAgICAgICAgICAgIGNoYW5uZWwudGhyb3R0bGVLZWVwYWxpdmUoa2VlcGFsaXZlVGltZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNoaWxkU3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWwucmVtb3ZlV3JhcHBlZFN1YmNoYW5uZWwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBJbnRlcm5hbENoYW5uZWwge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgY3JlZGVudGlhbHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxscyBxdWV1ZWQgdXAgdG8gZ2V0IGEgY2FsbCBjb25maWcuIFNob3VsZCBvbmx5IGJlIHBvcHVsYXRlZCBiZWZvcmUgdGhlXG4gICAgICAgICAqIGZpcnN0IHRpbWUgdGhlIHJlc29sdmVyIHJldHVybnMgYSByZXN1bHQsIHdoaWNoIGluY2x1ZGVzIHRoZSBDb25maWdTZWxlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5waWNrUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZXJyb3IgZnJvbSB0aGUgbmFtZSByZXNvbHZlciBpZiBpdCBmYWlsZWQgbW9zdCByZWNlbnRseS4gSXRcbiAgICAgICAgICogaXMgb25seSB1c2VkIHRvIGVuZCBjYWxscyB0aGF0IHN0YXJ0IHdoaWxlIHRoZXJlIGlzIG5vIGNvbmZpZyBzZWxlY3RvclxuICAgICAgICAgKiBhbmQgdGhlIG5hbWUgcmVzb2x2ZXIgaXMgaW4gYmFja29mZiwgc28gaXQgc2hvdWxkIGJlIG51bGxlZCBpZlxuICAgICAgICAgKiBjb25maWdTZWxlY3RvciBiZWNvbWVzIHNldCBvciB0aGUgY2hhbm5lbCBzdGF0ZSBiZWNvbWVzIGFueXRoaW5nIG90aGVyXG4gICAgICAgICAqIHRoYW4gVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jYWxsQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2hhbm5lbCB0YXJnZXQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGNyZWRlbnRpYWxzIGluc3RhbmNlb2YgY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgY3JlZGVudGlhbHMgbXVzdCBiZSBhIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3JpZ2luYWxUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVGFyZ2V0VXJpID0gKDAsIHVyaV9wYXJzZXJfMS5wYXJzZVVyaSkodGFyZ2V0KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsVGFyZ2V0VXJpID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSB0YXJnZXQgbmFtZSBcIiR7dGFyZ2V0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRhcmdldCBoYXMgYSBzY2hlbWUgdGhhdCBpcyByZWdpc3RlcmVkIHdpdGggdGhlXG4gICAgICAgICAqIHJlc29sdmVyICovXG4gICAgICAgIGNvbnN0IGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQgPSAoMCwgcmVzb2x2ZXJfMS5tYXBVcmlEZWZhdWx0U2NoZW1lKShvcmlnaW5hbFRhcmdldFVyaSk7XG4gICAgICAgIGlmIChkZWZhdWx0U2NoZW1lTWFwUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgZGVmYXVsdCBzY2hlbWUgZm9yIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgTUFYX1RJTUVPVVRfVElNRSk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9ICgwLCBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsKSh0YXJnZXQsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ2hhbm5lbCBjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5kZWZhdWx0X2F1dGhvcml0eSddKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBdXRob3JpdHkgPSB0aGlzLm9wdGlvbnNbJ2dycGMuZGVmYXVsdF9hdXRob3JpdHknXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEF1dGhvcml0eSA9ICgwLCByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkpKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3h5TWFwUmVzdWx0ID0gKDAsIGh0dHBfcHJveHlfMS5tYXBQcm94eU5hbWUpKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHByb3h5TWFwUmVzdWx0LnRhcmdldDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwcm94eU1hcFJlc3VsdC5leHRyYU9wdGlvbnMpO1xuICAgICAgICAvKiBUaGUgZ2xvYmFsIGJvb2xlYW4gcGFyYW1ldGVyIHRvIGdldFN1YmNoYW5uZWxQb29sIGhhcyB0aGUgaW52ZXJzZSBtZWFuaW5nIHRvIHdoYXRcbiAgICAgICAgICogdGhlIGdycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCBjaGFubmVsIG9wdGlvbiBtZWFucy4gKi9cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsUG9vbCA9ICgwLCBzdWJjaGFubmVsX3Bvb2xfMS5nZXRTdWJjaGFubmVsUG9vbCkoKChfYyA9IG9wdGlvbnNbJ2dycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCddKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwKSA9PT0gMCk7XG4gICAgICAgIHRoaXMucmV0cnlCdWZmZXJUcmFja2VyID0gbmV3IHJldHJ5aW5nX2NhbGxfMS5NZXNzYWdlQnVmZmVyVHJhY2tlcigoX2QgPSBvcHRpb25zWydncnBjLnJldHJ5X2J1ZmZlcl9zaXplJ10pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IERFRkFVTFRfUkVUUllfQlVGRkVSX1NJWkVfQllURVMsIChfZSA9IG9wdGlvbnNbJ2dycGMucGVyX3JwY19yZXRyeV9idWZmZXJfc2l6ZSddKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBERUZBVUxUX1BFUl9SUENfUkVUUllfQlVGRkVSX1NJWkVfQllURVMpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgPSAoX2YgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IC0xO1xuICAgICAgICB0aGlzLmlkbGVUaW1lb3V0TXMgPSBNYXRoLm1heCgoX2cgPSBvcHRpb25zWydncnBjLmNsaWVudF9pZGxlX3RpbWVvdXRfbXMnXSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogREVGQVVMVF9JRExFX1RJTUVPVVRfTVMsIE1JTl9JRExFX1RJTUVPVVRfTVMpO1xuICAgICAgICBjb25zdCBjaGFubmVsQ29udHJvbEhlbHBlciA9IHtcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsUG9vbC5nZXRPckNyZWF0ZVN1YmNoYW5uZWwodGhpcy50YXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHN1YmNoYW5uZWxBcmdzKSwgdGhpcy5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZSh0aGlzLmtlZXBhbGl2ZVRpbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ3JlYXRlZCBzdWJjaGFubmVsIG9yIHVzZWQgZXhpc3Rpbmcgc3ViY2hhbm5lbCcsIHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRTdWJjaGFubmVsID0gbmV3IENoYW5uZWxTdWJjaGFubmVsV3JhcHBlcihzdWJjaGFubmVsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscy5hZGQod3JhcHBlZFN1YmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkU3ViY2hhbm5lbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZTogKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrZXIgPSBwaWNrZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVDb3B5ID0gdGhpcy5waWNrUXVldWUuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZUNvcHkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiBxdWV1ZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5kb1BpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc29sdmluZyBsb2FkIGJhbGFuY2VyIHNob3VsZCBuZXZlciBjYWxsIHJlcXVlc3RSZXJlc29sdXRpb24nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiAoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSBuZXcgcmVzb2x2aW5nX2xvYWRfYmFsYW5jZXJfMS5SZXNvbHZpbmdMb2FkQmFsYW5jZXIodGhpcy50YXJnZXQsIGNoYW5uZWxDb250cm9sSGVscGVyLCBvcHRpb25zLCAoc2VydmljZUNvbmZpZywgY29uZmlnU2VsZWN0b3IpID0+IHtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZykge1xuICAgICAgICAgICAgICAgIFJFVFJZX1RIUk9UVExFUl9NQVAuc2V0KHRoaXMuZ2V0VGFyZ2V0KCksIG5ldyByZXRyeWluZ19jYWxsXzEuUmV0cnlUaHJvdHRsZXIoc2VydmljZUNvbmZpZy5yZXRyeVRocm90dGxpbmcubWF4VG9rZW5zLCBzZXJ2aWNlQ29uZmlnLnJldHJ5VGhyb3R0bGluZy50b2tlblJhdGlvLCBSRVRSWV9USFJPVFRMRVJfTUFQLmdldCh0aGlzLmdldFRhcmdldCgpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUkVUUllfVEhST1RUTEVSX01BUC5kZWxldGUodGhpcy5nZXRUYXJnZXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQWRkcmVzcyByZXNvbHV0aW9uIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IGNvbmZpZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8qIFdlIHByb2Nlc3MgdGhlIHF1ZXVlIGFzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgKiBsb2FkIGJhbGFuY2VyIHVwZGF0ZSBoYXMgY29tcGxldGVkLiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmdldENvbmZpZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9XQVJOSU5HJywgJ0FkZHJlc3MgcmVzb2x1dGlvbiBmYWlsZWQgd2l0aCBjb2RlICcgK1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgICAgICcgYW5kIGRldGFpbHMgXCInICtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdOYW1lIHJlc29sdXRpb24gZmFpbGVkIHdpdGggY2FsbHMgcXVldWVkIGZvciBjb25maWcgc2VsZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpKSwgeyBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICBpZiAobG9jYWxRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJVbnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsIG9mIGxvY2FsUXVldWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnJlcG9ydFJlc29sdmVyRXJyb3Ioc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShbXG4gICAgICAgICAgICBuZXcgY29tcHJlc3Npb25fZmlsdGVyXzEuQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5KHRoaXMsIHRoaXMub3B0aW9ucyksXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLnRyYWNlKCdDaGFubmVsIGNvbnN0cnVjdGVkIHdpdGggb3B0aW9ucyAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIHVuZGVmaW5lZCwgMikpO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjaGFubmVsX3N0YWNrdHJhY2UnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICdDaGFubmVsIGNvbnN0cnVjdGVkIFxcbicgK1xuICAgICAgICAgICAgKChfaCA9IGVycm9yLnN0YWNrKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guc3Vic3RyaW5nKGVycm9yLnN0YWNrLmluZGV4T2YoJ1xcbicpICsgMSkpKTtcbiAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMub3JpZ2luYWxUYXJnZXQsXG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSxcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQsIHZlcmJvc2l0eU92ZXJyaWRlKSB7XG4gICAgICAgICgwLCBsb2dnaW5nXzEudHJhY2UpKHZlcmJvc2l0eU92ZXJyaWRlICE9PSBudWxsICYmIHZlcmJvc2l0eU92ZXJyaWRlICE9PSB2b2lkIDAgPyB2ZXJib3NpdHlPdmVycmlkZSA6IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NoYW5uZWwnLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICBjYWxsUmVmVGltZXJSZWYoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoISgoX2IgPSAoX2EgPSB0aGlzLmNhbGxSZWZUaW1lcikuaGFzUmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuY2FsbFJlZlRpbWVyKS5yZWYpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsUmVmVGltZXJVbnJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLy8gSWYgdGhlIGhhc1JlZiBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdCwgYWx3YXlzIHJ1biB0aGUgY29kZVxuICAgICAgICBpZiAoIXRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZiB8fCB0aGlzLmNhbGxSZWZUaW1lci5oYXNSZWYoKSkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY2FsbFJlZlRpbWVyLnVucmVmIHwgY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoPScgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUubGVuZ3RoICtcbiAgICAgICAgICAgICAgICAnIHBpY2tRdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXJJbmRleCA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5maW5kSW5kZXgodmFsdWUgPT4gdmFsdWUgPT09IHdhdGNoZXJPYmplY3QpO1xuICAgICAgICBpZiAod2F0Y2hlckluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5zcGxpY2Uod2F0Y2hlckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICAoMCwgbG9nZ2luZ18xLnRyYWNlKShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjb25uZWN0aXZpdHlfc3RhdGUnLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jb25uZWN0aXZpdHlTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0Nvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2UgdG8gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBjb25zdCB3YXRjaGVyc0NvcHkgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB3YXRjaGVyT2JqZWN0IG9mIHdhdGNoZXJzQ29weSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB3YXRjaGVyT2JqZWN0LmN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyT2JqZWN0LnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3YXRjaGVyT2JqZWN0LnRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIod2F0Y2hlck9iamVjdCk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlck9iamVjdC5jYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xuICAgICAgICBpZiAobmV3S2VlcGFsaXZlVGltZSA+IHRoaXMua2VlcGFsaXZlVGltZSkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gbmV3S2VlcGFsaXZlVGltZTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgd3JhcHBlZFN1YmNoYW5uZWwgb2YgdGhpcy53cmFwcGVkU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkU3ViY2hhbm5lbC50aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVXcmFwcGVkU3ViY2hhbm5lbCh3cmFwcGVkU3ViY2hhbm5lbCkge1xuICAgICAgICB0aGlzLndyYXBwZWRTdWJjaGFubmVscy5kZWxldGUod3JhcHBlZFN1YmNoYW5uZWwpO1xuICAgIH1cbiAgICBkb1BpY2sobWV0YWRhdGEsIGV4dHJhUGlja0luZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBpY2tlci5waWNrKHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBtZXRhZGF0YSxcbiAgICAgICAgICAgIGV4dHJhUGlja0luZm86IGV4dHJhUGlja0luZm8sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdWV1ZUNhbGxGb3JQaWNrKGNhbGwpIHtcbiAgICAgICAgdGhpcy5waWNrUXVldWUucHVzaChjYWxsKTtcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJSZWYoKTtcbiAgICB9XG4gICAgZ2V0Q29uZmlnKG1ldGhvZCwgbWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1NVQ0NFU1MnLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogdGhpcy5jb25maWdTZWxlY3RvcihtZXRob2QsIG1ldGFkYXRhKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0VSUk9SJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ05PTkUnLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWVDYWxsRm9yQ29uZmlnKGNhbGwpIHtcbiAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5wdXNoKGNhbGwpO1xuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclJlZigpO1xuICAgIH1cbiAgICBlbnRlcklkbGUoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyKTtcbiAgICAgICAgaWYgKHRoaXMuaWRsZVRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0SWRsZVRpbWVvdXQodGltZW91dE1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlcmUgaXMgY3VycmVudGx5IGEgY2FsbCwgdGhlIGNoYW5uZWwgd2lsbCBub3QgZ28gaWRsZSBmb3IgYVxuICAgICAgICAgICAgICAgICAqIHBlcmlvZCBvZiBhdCBsZWFzdCBpZGxlVGltZW91dE1zLCBzbyBjaGVjayBhZ2FpbiBhZnRlciB0aGF0IHRpbWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydElkbGVUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRNcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RBY3Rpdml0eSA9IG5vdy52YWx1ZU9mKCkgLSB0aGlzLmxhc3RBY3Rpdml0eVRpbWVzdGFtcC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAodGltZVNpbmNlTGFzdEFjdGl2aXR5ID49IHRoaXMuaWRsZVRpbWVvdXRNcykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0lkbGUgdGltZXIgdHJpZ2dlcmVkIGFmdGVyICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkbGVUaW1lb3V0TXMgK1xuICAgICAgICAgICAgICAgICAgICAnbXMgb2YgaW5hY3Rpdml0eScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW50ZXJJZGxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBXaGVuZXZlciB0aGUgdGltZXIgZmlyZXMgd2l0aCB0aGUgbGF0ZXN0IGFjdGl2aXR5IGJlaW5nIHRvbyByZWNlbnQsXG4gICAgICAgICAgICAgICAgICogc2V0IHRoZSB0aW1lciBhZ2FpbiBmb3IgdGhlIHRpbWUgd2hlbiB0aGUgdGltZSBzaW5jZSB0aGUgbGFzdFxuICAgICAgICAgICAgICAgICAqIGFjdGl2aXR5IGlzIGVxdWFsIHRvIHRoZSB0aW1lb3V0LiBUaGlzIHNob3VsZCByZXN1bHQgaW4gdGhlIHRpbWVyXG4gICAgICAgICAgICAgICAgICogZmlyaW5nIG5vIG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IGlkbGVUaW1lb3V0TXMvMiBvbiBhdmVyYWdlLiAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRJZGxlVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0TXMgLSB0aW1lU2luY2VMYXN0QWN0aXZpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aW1lb3V0TXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmlkbGVUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICB9XG4gICAgbWF5YmVTdGFydElkbGVUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOICYmICF0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgdGhpcy5zdGFydElkbGVUaW1lb3V0KHRoaXMuaWRsZVRpbWVvdXRNcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DYWxsU3RhcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbENvdW50ICs9IDE7XG4gICAgfVxuICAgIG9uQ2FsbEVuZChzdGF0dXMpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsQ291bnQgLT0gMTtcbiAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHlUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0aGlzLm1heWJlU3RhcnRJZGxlVGltZXIoKTtcbiAgICB9XG4gICAgY3JlYXRlTG9hZEJhbGFuY2luZ0NhbGwoY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUpIHtcbiAgICAgICAgY29uc3QgY2FsbE51bWJlciA9ICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbCBbJyArIGNhbGxOdW1iZXIgKyAnXSBtZXRob2Q9XCInICsgbWV0aG9kICsgJ1wiJyk7XG4gICAgICAgIHJldHVybiBuZXcgbG9hZF9iYWxhbmNpbmdfY2FsbF8xLkxvYWRCYWxhbmNpbmdDYWxsKHRoaXMsIGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyKTtcbiAgICB9XG4gICAgY3JlYXRlUmV0cnlpbmdDYWxsKGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lKSB7XG4gICAgICAgIGNvbnN0IGNhbGxOdW1iZXIgPSAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKTtcbiAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRlUmV0cnlpbmdDYWxsIFsnICsgY2FsbE51bWJlciArICddIG1ldGhvZD1cIicgKyBtZXRob2QgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuIG5ldyByZXRyeWluZ19jYWxsXzEuUmV0cnlpbmdDYWxsKHRoaXMsIGNhbGxDb25maWcsIG1ldGhvZCwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyLCB0aGlzLnJldHJ5QnVmZmVyVHJhY2tlciwgUkVUUllfVEhST1RUTEVSX01BUC5nZXQodGhpcy5nZXRUYXJnZXQoKSkpO1xuICAgIH1cbiAgICBjcmVhdGVJbm5lckNhbGwoY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgUmV0cnlpbmdDYWxsIGlmIHJldHJpZXMgYXJlIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5lbmFibGVfcmV0cmllcyddID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbChjYWxsQ29uZmlnLCBtZXRob2QsIGhvc3QsIGNyZWRlbnRpYWxzLCBkZWFkbGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVSZXRyeWluZ0NhbGwoY2FsbENvbmZpZywgbWV0aG9kLCBob3N0LCBjcmVkZW50aWFscywgZGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVJlc29sdmluZ0NhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpIHtcbiAgICAgICAgY29uc3QgY2FsbE51bWJlciA9ICgwLCBjYWxsX251bWJlcl8xLmdldE5leHRDYWxsTnVtYmVyKSgpO1xuICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGVSZXNvbHZpbmdDYWxsIFsnICtcbiAgICAgICAgICAgIGNhbGxOdW1iZXIgK1xuICAgICAgICAgICAgJ10gbWV0aG9kPVwiJyArXG4gICAgICAgICAgICBtZXRob2QgK1xuICAgICAgICAgICAgJ1wiLCBkZWFkbGluZT0nICtcbiAgICAgICAgICAgICgwLCBkZWFkbGluZV8xLmRlYWRsaW5lVG9TdHJpbmcpKGRlYWRsaW5lKSk7XG4gICAgICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGRlYWRsaW5lOiBkZWFkbGluZSxcbiAgICAgICAgICAgIGZsYWdzOiBwcm9wYWdhdGVGbGFncyAhPT0gbnVsbCAmJiBwcm9wYWdhdGVGbGFncyAhPT0gdm9pZCAwID8gcHJvcGFnYXRlRmxhZ3MgOiBjb25zdGFudHNfMS5Qcm9wYWdhdGUuREVGQVVMVFMsXG4gICAgICAgICAgICBob3N0OiBob3N0ICE9PSBudWxsICYmIGhvc3QgIT09IHZvaWQgMCA/IGhvc3QgOiB0aGlzLmRlZmF1bHRBdXRob3JpdHksXG4gICAgICAgICAgICBwYXJlbnRDYWxsOiBwYXJlbnRDYWxsLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gbmV3IHJlc29sdmluZ19jYWxsXzEuUmVzb2x2aW5nQ2FsbCh0aGlzLCBtZXRob2QsIGZpbmFsT3B0aW9ucywgdGhpcy5maWx0ZXJTdGFja0ZhY3RvcnkuY2xvbmUoKSwgdGhpcy5jcmVkZW50aWFscy5fZ2V0Q2FsbENyZWRlbnRpYWxzKCksIGNhbGxOdW1iZXIpO1xuICAgICAgICB0aGlzLm9uQ2FsbFN0YXJ0KCk7XG4gICAgICAgIGNhbGwuYWRkU3RhdHVzV2F0Y2hlcihzdGF0dXMgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkNhbGxFbmQoc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYWxsO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNhbGxSZWZUaW1lcik7XG4gICAgICAgIGlmICh0aGlzLmlkbGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWRsZVRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsUG9vbC51bnJlZlVudXNlZFN1YmNoYW5uZWxzKCk7XG4gICAgfVxuICAgIGdldFRhcmdldCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KTtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpdml0eVN0YXRlID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgaWYgKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIHRoaXMubGFzdEFjdGl2aXR5VGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydElkbGVUaW1lcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aXZpdHlTdGF0ZTtcbiAgICB9XG4gICAgd2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShjdXJyZW50U3RhdGUsIGRlYWRsaW5lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hhbm5lbCBoYXMgYmVlbiBzaHV0IGRvd24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgICAgICBpZiAoZGVhZGxpbmUgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBjb25zdCBkZWFkbGluZURhdGUgPSBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUgPyBkZWFkbGluZSA6IG5ldyBEYXRlKGRlYWRsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBpZiAoZGVhZGxpbmUgPT09IC1JbmZpbml0eSB8fCBkZWFkbGluZURhdGUgPD0gbm93KSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjaywgbmV3IEVycm9yKCdEZWFkbGluZSBwYXNzZWQgd2l0aG91dCBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIod2F0Y2hlck9iamVjdCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdEZWFkbGluZSBwYXNzZWQgd2l0aG91dCBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlJykpO1xuICAgICAgICAgICAgfSwgZGVhZGxpbmVEYXRlLmdldFRpbWUoKSAtIG5vdy5nZXRUaW1lKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhdGNoZXJPYmplY3QgPSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUsXG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIHRpbWVyLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMucHVzaCh3YXRjaGVyT2JqZWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjaGFubmVseiByZWZlcmVuY2Ugb2JqZWN0IGZvciB0aGlzIGNoYW5uZWwuIFRoZSByZXR1cm5lZCB2YWx1ZSBpc1xuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgY2hhbm5lbC5cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncykge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogbWV0aG9kIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISh0eXBlb2YgZGVhZGxpbmUgPT09ICdudW1iZXInIHx8IGRlYWRsaW5lIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwjY3JlYXRlQ2FsbDogZGVhZGxpbmUgbXVzdCBiZSBhIG51bWJlciBvciBEYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYW5uZWwgaGFzIGJlZW4gc2h1dCBkb3duJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVzb2x2aW5nQ2FsbChtZXRob2QsIGRlYWRsaW5lLCBob3N0LCBwYXJlbnRDYWxsLCBwcm9wYWdhdGVGbGFncyk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcm5hbENoYW5uZWwgPSBJbnRlcm5hbENoYW5uZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcm5hbC1jaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/internal-channel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = 'child_load_balancer_helper';\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.latestConfig = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent) {\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                }\n                else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {\n        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param addressList\n     * @param lbConfig\n     * @param attributes\n     */\n    updateAddressList(addressList, lbConfig, attributes) {\n        let childToUpdate;\n        if (this.currentChild === null ||\n            this.latestConfig === null ||\n            this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            }\n            else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        }\n        else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            }\n            else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        this.latestConfig = lbConfig;\n        childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        /* Note: state updates are only propagated from the child balancer if that\n         * object is equal to this.currentChild or this.pendingChild. Since this\n         * function sets both of those to null, no further state updates will\n         * occur after this function returns. */\n        if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;\n//# sourceMappingURL=load-balancer-child-handler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IFRZUEVfTkFNRSA9ICdjaGlsZF9sb2FkX2JhbGFuY2VyX2hlbHBlcic7XG5jbGFzcyBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy5DaGlsZFBvbGljeUhlbHBlciA9IGNsYXNzIHtcbiAgICAgICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcikge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxsZWRCeVBlbmRpbmdDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY3VycmVudENoaWxkID0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jYWxsZWRCeUN1cnJlbnRDaGlsZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5U3RhdGUsIHBpY2tlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RDaGlsZCA9IChfYSA9IHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5wYXJlbnQuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkID09PSBsYXRlc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5jaGFubmVsQ29udHJvbEhlbHBlci5yZXF1ZXN0UmVyZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Q2hpbGQobmV3Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRDaGFubmVsekNoaWxkKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsZWRCeVBlbmRpbmdDaGlsZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZCA9PT0gdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGVkQnlDdXJyZW50Q2hpbGQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQgPT09IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uZmlnVXBkYXRlUmVxdWlyZXNOZXdQb2xpY3lJbnN0YW5jZShvbGRDb25maWcsIG5ld0NvbmZpZykge1xuICAgICAgICByZXR1cm4gb2xkQ29uZmlnLmdldExvYWRCYWxhbmNlck5hbWUoKSAhPT0gbmV3Q29uZmlnLmdldExvYWRCYWxhbmNlck5hbWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcmVxdWlzaXRlczogbGJDb25maWcgIT09IG51bGwgYW5kIGxiQ29uZmlnLm5hbWUgaXMgcmVnaXN0ZXJlZFxuICAgICAqIEBwYXJhbSBhZGRyZXNzTGlzdFxuICAgICAqIEBwYXJhbSBsYkNvbmZpZ1xuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGxldCBjaGlsZFRvVXBkYXRlO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID09PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ1VwZGF0ZVJlcXVpcmVzTmV3UG9saWN5SW5zdGFuY2UodGhpcy5sYXRlc3RDb25maWcsIGxiQ29uZmlnKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3SGVscGVyID0gbmV3IHRoaXMuQ2hpbGRQb2xpY3lIZWxwZXIodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGlsZCA9ICgwLCBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlTG9hZEJhbGFuY2VyKShsYkNvbmZpZywgbmV3SGVscGVyKTtcbiAgICAgICAgICAgIG5ld0hlbHBlci5zZXRDaGlsZChuZXdDaGlsZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgICAgIGNoaWxkVG9VcGRhdGUgPSB0aGlzLmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMucGVuZGluZ0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnID0gbGJDb25maWc7XG4gICAgICAgIGNoaWxkVG9VcGRhdGUudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmV4aXRJZGxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLnJlc2V0QmFja29mZigpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQucmVzZXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLyogTm90ZTogc3RhdGUgdXBkYXRlcyBhcmUgb25seSBwcm9wYWdhdGVkIGZyb20gdGhlIGNoaWxkIGJhbGFuY2VyIGlmIHRoYXRcbiAgICAgICAgICogb2JqZWN0IGlzIGVxdWFsIHRvIHRoaXMuY3VycmVudENoaWxkIG9yIHRoaXMucGVuZGluZ0NoaWxkLiBTaW5jZSB0aGlzXG4gICAgICAgICAqIGZ1bmN0aW9uIHNldHMgYm90aCBvZiB0aG9zZSB0byBudWxsLCBubyBmdXJ0aGVyIHN0YXRlIHVwZGF0ZXMgd2lsbFxuICAgICAgICAgKiBvY2N1ciBhZnRlciB0aGlzIGZ1bmN0aW9uIHJldHVybnMuICovXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyID0gQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'outlier_detection';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'outlier_detection';\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : 'true') === 'true';\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100,\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50,\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj) {\n        if (!(0, duration_1.isDuration)(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 &&\n            obj[fieldName].seconds <= 315576000000 &&\n            obj[fieldName].nanos >= 0 &&\n            obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, 'number', objectName);\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {\n        this.childPolicy = childPolicy;\n        if (childPolicy.length > 0 &&\n            childPolicy[0].getLoadBalancerName() === 'pick_first') {\n            throw new Error('outlier_detection LB policy cannot have a pick_first child policy');\n        }\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection\n            ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection\n            ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            interval: (0, duration_1.msToDuration)(this.intervalMs),\n            base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),\n            max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),\n            max_ejection_percent: this.maxEjectionPercent,\n            success_rate_ejection: this.successRateEjection,\n            failure_percentage_ejection: this.failurePercentageEjection,\n            child_policy: this.childPolicy.map(policy => policy.toJsonObject()),\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    copyWithChildPolicy(childPolicy) {\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, 'interval');\n        validatePositiveDuration(obj, 'base_ejection_time');\n        validatePositiveDuration(obj, 'max_ejection_time');\n        validatePercentage(obj, 'max_ejection_percent');\n        if ('success_rate_ejection' in obj) {\n            if (typeof obj.success_rate_ejection !== 'object') {\n                throw new Error('outlier detection config success_rate_ejection must be an object');\n            }\n            validateFieldType(obj.success_rate_ejection, 'stdev_factor', 'number', 'success_rate_ejection');\n            validatePercentage(obj.success_rate_ejection, 'enforcement_percentage', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'minimum_hosts', 'number', 'success_rate_ejection');\n            validateFieldType(obj.success_rate_ejection, 'request_volume', 'number', 'success_rate_ejection');\n        }\n        if ('failure_percentage_ejection' in obj) {\n            if (typeof obj.failure_percentage_ejection !== 'object') {\n                throw new Error('outlier detection config failure_percentage_ejection must be an object');\n            }\n            validatePercentage(obj.failure_percentage_ejection, 'threshold', 'failure_percentage_ejection');\n            validatePercentage(obj.failure_percentage_ejection, 'enforcement_percentage', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'minimum_hosts', 'number', 'failure_percentage_ejection');\n            validateFieldType(obj.failure_percentage_ejection, 'request_volume', 'number', 'failure_percentage_ejection');\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry) {\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.stateListeners = [];\n        this.ejected = false;\n        this.refCount = 0;\n        this.childSubchannelState = childSubchannel.getConnectivityState();\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState, keepaliveTime) => {\n            this.childSubchannelState = newState;\n            if (!this.ejected) {\n                for (const listener of this.stateListeners) {\n                    listener(this, previousState, newState, keepaliveTime);\n                }\n            }\n        });\n    }\n    getConnectivityState() {\n        if (this.ejected) {\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n        }\n        else {\n            return this.childSubchannelState;\n        }\n    }\n    /**\n     * Add a listener function to be called whenever the wrapper's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.ejected = true;\n        for (const listener of this.stateListeners) {\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, -1);\n        }\n    }\n    uneject() {\n        this.ejected = false;\n        for (const listener of this.stateListeners) {\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState, -1);\n        }\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0,\n    };\n}\nclass CallCounter {\n    constructor() {\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls) {\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                let onCallEnded = wrappedPick.onCallEnded;\n                if (this.countCalls) {\n                    onCallEnded = statusCode => {\n                        var _a;\n                        if (statusCode === constants_1.Status.OK) {\n                            mapEntry.counter.addSuccess();\n                        }\n                        else {\n                            mapEntry.counter.addFailure();\n                        }\n                        (_a = wrappedPick.onCallEnded) === null || _a === void 0 ? void 0 : _a.call(wrappedPick, statusCode);\n                    };\n                }\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded: onCallEnded });\n            }\n            else {\n                return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });\n            }\n        }\n        else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper) {\n        this.addressMap = new Map();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs) => {\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.addressMap.get((0, subchannel_address_1.subchannelAddressToString)(subchannelAddress));\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker) => {\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n                }\n                else {\n                    channelControlHelper.updateState(connectivityState, picker);\n                }\n            },\n        }));\n        this.ejectionTimer = setInterval(() => { }, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return (this.latestConfig !== null &&\n            (this.latestConfig.getSuccessRateEjectionConfig() !== null ||\n                this.latestConfig.getFailurePercentageEjectionConfig() !== null));\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.addressMap.values()) {\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return (ejectionCount * 100) / this.addressMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace('Running success rate check');\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const [address, mapEntry] of this.addressMap) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace('Stats for ' +\n                address +\n                ': successes=' +\n                successes +\n                ' failures=' +\n                failures +\n                ' targetRequestVolume=' +\n                targetRequestVolume);\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace('Found ' +\n            addresesWithTargetVolume +\n            ' success rate candidates; currentEjectionPercent=' +\n            this.getCurrentEjectionPercent() +\n            ' successRates=[' +\n            successRates +\n            ']');\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates) {\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean -\n            successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace('stdev=' + successRateStdev + ' ejectionThreshold=' + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >=\n                this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace('Checking candidate ' + address + ' successRate=' + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' +\n                    address +\n                    ' randomNumber=' +\n                    randomNumber +\n                    ' enforcement_percentage=' +\n                    successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace('Running failure percentage check. threshold=' +\n            failurePercentageConfig.threshold +\n            ' request volume threshold=' +\n            failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.addressMap.values()) {\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >=\n                this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace('Candidate successes=' + successes + ' failures=' + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = (failures * 100) / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace('Candidate ' +\n                    address +\n                    ' randomNumber=' +\n                    randomNumber +\n                    ' enforcement_percentage=' +\n                    failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace('Ejecting candidate ' + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers) {\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.addressMap.values()) {\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        var _a, _b;\n        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);\n        (_b = (_a = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace('Ejection timer running');\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.addressMap.entries()) {\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            }\n            else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() +\n                    Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace('Unejecting ' + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(addressList, lbConfig, attributes) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        const subchannelAddresses = new Set();\n        for (const address of addressList) {\n            subchannelAddresses.add((0, subchannel_address_1.subchannelAddressToString)(address));\n        }\n        for (const address of subchannelAddresses) {\n            if (!this.addressMap.has(address)) {\n                trace('Adding map entry for ' + address);\n                this.addressMap.set(address, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: [],\n                });\n            }\n        }\n        for (const key of this.addressMap.keys()) {\n            if (!subchannelAddresses.has(key)) {\n                trace('Removing map entry for ' + key);\n                this.addressMap.delete(key);\n            }\n        }\n        const childPolicy = (0, load_balancer_1.getFirstUsableConfig)(lbConfig.getChildPolicy(), true);\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n        if (lbConfig.getSuccessRateEjectionConfig() ||\n            lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace('Previous timer existed. Replacing timer');\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() -\n                    (new Date().getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            }\n            else {\n                trace('Starting new timer');\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        }\n        else {\n            trace('Counting disabled. Cancelling timer.');\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.addressMap.values()) {\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-outlier-detection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLG9DQUFvQyxHQUFHLDJDQUEyQztBQUNsRyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsdUJBQXVCLG1CQUFPLENBQUMsb0ZBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLHNGQUFpQjtBQUNqRCxzQ0FBc0MsbUJBQU8sQ0FBQyxrSEFBK0I7QUFDN0UsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELCtCQUErQixtQkFBTyxDQUFDLG9HQUF3QjtBQUMvRCxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVcsR0FBRyxVQUFVO0FBQ3RFLG9EQUFvRCxlQUFlLHdCQUF3QixhQUFhLFFBQVEsc0JBQXNCO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXLEdBQUcsVUFBVTtBQUNsRTtBQUNBO0FBQ0Esd0RBQXdELGVBQWUsc0NBQXNDLHNCQUFzQjtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVyxHQUFHLFVBQVU7QUFDbEU7QUFDQTtBQUNBLG9EQUFvRCxlQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxrQkFBa0IsZ0ZBQWdGO0FBQ3ZKO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLHNEQUFzRDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIgPSBleHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gdm9pZCAwO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGR1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9kdXJhdGlvblwiKTtcbmNvbnN0IGV4cGVyaW1lbnRhbF8xID0gcmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWludGVyZmFjZVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnb3V0bGllcl9kZXRlY3Rpb24nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAnb3V0bGllcl9kZXRlY3Rpb24nO1xuY29uc3QgT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCA9ICgoX2EgPSBwcm9jZXNzLmVudi5HUlBDX0VYUEVSSU1FTlRBTF9FTkFCTEVfT1VUTElFUl9ERVRFQ1RJT04pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0cnVlJykgPT09ICd0cnVlJztcbmNvbnN0IGRlZmF1bHRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnID0ge1xuICAgIHN0ZGV2X2ZhY3RvcjogMTkwMCxcbiAgICBlbmZvcmNlbWVudF9wZXJjZW50YWdlOiAxMDAsXG4gICAgbWluaW11bV9ob3N0czogNSxcbiAgICByZXF1ZXN0X3ZvbHVtZTogMTAwLFxufTtcbmNvbnN0IGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnID0ge1xuICAgIHRocmVzaG9sZDogODUsXG4gICAgZW5mb3JjZW1lbnRfcGVyY2VudGFnZTogMTAwLFxuICAgIG1pbmltdW1faG9zdHM6IDUsXG4gICAgcmVxdWVzdF92b2x1bWU6IDUwLFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGRUeXBlKG9iaiwgZmllbGROYW1lLCBleHBlY3RlZFR5cGUsIG9iamVjdE5hbWUpIHtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpZWxkTmFtZV0gIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IGV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlfSwgZ290ICR7dHlwZW9mIG9ialtmaWVsZE5hbWVdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosIGZpZWxkTmFtZSwgb2JqZWN0TmFtZSkge1xuICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaikge1xuICAgICAgICBpZiAoISgwLCBkdXJhdGlvbl8xLmlzRHVyYXRpb24pKG9ialtmaWVsZE5hbWVdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogZXhwZWN0ZWQgRHVyYXRpb24sIGdvdCAke3R5cGVvZiBvYmpbZmllbGROYW1lXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShvYmpbZmllbGROYW1lXS5zZWNvbmRzID49IDAgJiZcbiAgICAgICAgICAgIG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPD0gMzE1NTc2MDAwMDAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA+PSAwICYmXG4gICAgICAgICAgICBvYmpbZmllbGROYW1lXS5uYW5vcyA8PSA5OTk5OTk5OTkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZXMgb3V0IG9mIHJhbmdlIGZvciBub24tbmVnYXRpdmUgRHVhcmF0aW9uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCBmaWVsZE5hbWUsIG9iamVjdE5hbWUpIHtcbiAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLCBmaWVsZE5hbWUsICdudW1iZXInLCBvYmplY3ROYW1lKTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiAhKG9ialtmaWVsZE5hbWVdID49IDAgJiYgb2JqW2ZpZWxkTmFtZV0gPD0gMTAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG91dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyAke2Z1bGxGaWVsZE5hbWV9IHBhcnNlIGVycm9yOiB2YWx1ZSBvdXQgb2YgcmFuZ2UgZm9yIHBlcmNlbnRhZ2UgKDAtMTAwKWApO1xuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihpbnRlcnZhbE1zLCBiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblBlcmNlbnQsIHN1Y2Nlc3NSYXRlRWplY3Rpb24sIGZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KSB7XG4gICAgICAgIHRoaXMuY2hpbGRQb2xpY3kgPSBjaGlsZFBvbGljeTtcbiAgICAgICAgaWYgKGNoaWxkUG9saWN5Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIGNoaWxkUG9saWN5WzBdLmdldExvYWRCYWxhbmNlck5hbWUoKSA9PT0gJ3BpY2tfZmlyc3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXJfZGV0ZWN0aW9uIExCIHBvbGljeSBjYW5ub3QgaGF2ZSBhIHBpY2tfZmlyc3QgY2hpbGQgcG9saWN5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnRlcnZhbE1zID0gaW50ZXJ2YWxNcyAhPT0gbnVsbCAmJiBpbnRlcnZhbE1zICE9PSB2b2lkIDAgPyBpbnRlcnZhbE1zIDogMTAwMDA7XG4gICAgICAgIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zID0gYmFzZUVqZWN0aW9uVGltZU1zICE9PSBudWxsICYmIGJhc2VFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gYmFzZUVqZWN0aW9uVGltZU1zIDogMzAwMDA7XG4gICAgICAgIHRoaXMubWF4RWplY3Rpb25UaW1lTXMgPSBtYXhFamVjdGlvblRpbWVNcyAhPT0gbnVsbCAmJiBtYXhFamVjdGlvblRpbWVNcyAhPT0gdm9pZCAwID8gbWF4RWplY3Rpb25UaW1lTXMgOiAzMDAwMDA7XG4gICAgICAgIHRoaXMubWF4RWplY3Rpb25QZXJjZW50ID0gbWF4RWplY3Rpb25QZXJjZW50ICE9PSBudWxsICYmIG1heEVqZWN0aW9uUGVyY2VudCAhPT0gdm9pZCAwID8gbWF4RWplY3Rpb25QZXJjZW50IDogMTA7XG4gICAgICAgIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbiA9IHN1Y2Nlc3NSYXRlRWplY3Rpb25cbiAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZyksIHN1Y2Nlc3NSYXRlRWplY3Rpb24pIDogbnVsbDtcbiAgICAgICAgdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uID0gZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvblxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKSwgZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXRMb2FkQmFsYW5jZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnRlcnZhbDogKDAsIGR1cmF0aW9uXzEubXNUb0R1cmF0aW9uKSh0aGlzLmludGVydmFsTXMpLFxuICAgICAgICAgICAgYmFzZV9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zKSxcbiAgICAgICAgICAgIG1heF9lamVjdGlvbl90aW1lOiAoMCwgZHVyYXRpb25fMS5tc1RvRHVyYXRpb24pKHRoaXMubWF4RWplY3Rpb25UaW1lTXMpLFxuICAgICAgICAgICAgbWF4X2VqZWN0aW9uX3BlcmNlbnQ6IHRoaXMubWF4RWplY3Rpb25QZXJjZW50LFxuICAgICAgICAgICAgc3VjY2Vzc19yYXRlX2VqZWN0aW9uOiB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb24sXG4gICAgICAgICAgICBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb246IHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbixcbiAgICAgICAgICAgIGNoaWxkX3BvbGljeTogdGhpcy5jaGlsZFBvbGljeS5tYXAocG9saWN5ID0+IHBvbGljeS50b0pzb25PYmplY3QoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldEludGVydmFsTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsTXM7XG4gICAgfVxuICAgIGdldEJhc2VFamVjdGlvblRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zO1xuICAgIH1cbiAgICBnZXRNYXhFamVjdGlvblRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25UaW1lTXM7XG4gICAgfVxuICAgIGdldE1heEVqZWN0aW9uUGVyY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4RWplY3Rpb25QZXJjZW50O1xuICAgIH1cbiAgICBnZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uO1xuICAgIH1cbiAgICBnZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uO1xuICAgIH1cbiAgICBnZXRDaGlsZFBvbGljeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRQb2xpY3k7XG4gICAgfVxuICAgIGNvcHlXaXRoQ2hpbGRQb2xpY3koY2hpbGRQb2xpY3kpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyh0aGlzLmludGVydmFsTXMsIHRoaXMuYmFzZUVqZWN0aW9uVGltZU1zLCB0aGlzLm1heEVqZWN0aW9uVGltZU1zLCB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCwgdGhpcy5zdWNjZXNzUmF0ZUVqZWN0aW9uLCB0aGlzLmZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb24sIGNoaWxkUG9saWN5KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdpbnRlcnZhbCcpO1xuICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCAnYmFzZV9lamVjdGlvbl90aW1lJyk7XG4gICAgICAgIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosICdtYXhfZWplY3Rpb25fdGltZScpO1xuICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLCAnbWF4X2VqZWN0aW9uX3BlcmNlbnQnKTtcbiAgICAgICAgaWYgKCdzdWNjZXNzX3JhdGVfZWplY3Rpb24nIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0bGllciBkZXRlY3Rpb24gY29uZmlnIHN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ3N0ZGV2X2ZhY3RvcicsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ2VuZm9yY2VtZW50X3BlcmNlbnRhZ2UnLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAnbWluaW11bV9ob3N0cycsICdudW1iZXInLCAnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyk7XG4gICAgICAgICAgICB2YWxpZGF0ZUZpZWxkVHlwZShvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCAncmVxdWVzdF92b2x1bWUnLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAndGhyZXNob2xkJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKG9iai5pbnRlcnZhbCA/ICgwLCBkdXJhdGlvbl8xLmR1cmF0aW9uVG9Ncykob2JqLmludGVydmFsKSA6IG51bGwsIG9iai5iYXNlX2VqZWN0aW9uX3RpbWUgPyAoMCwgZHVyYXRpb25fMS5kdXJhdGlvblRvTXMpKG9iai5iYXNlX2VqZWN0aW9uX3RpbWUpIDogbnVsbCwgb2JqLm1heF9lamVjdGlvbl90aW1lID8gKDAsIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKShvYmoubWF4X2VqZWN0aW9uX3RpbWUpIDogbnVsbCwgKF9hID0gb2JqLm1heF9lamVjdGlvbl9wZXJjZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCBvYmouc3VjY2Vzc19yYXRlX2VqZWN0aW9uLCBvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCBvYmouY2hpbGRfcG9saWN5Lm1hcChsb2FkX2JhbGFuY2VyXzEudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnO1xuY2xhc3MgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyIGV4dGVuZHMgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMS5CYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkU3ViY2hhbm5lbCwgbWFwRW50cnkpIHtcbiAgICAgICAgc3VwZXIoY2hpbGRTdWJjaGFubmVsKTtcbiAgICAgICAgdGhpcy5tYXBFbnRyeSA9IG1hcEVudHJ5O1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkU3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICBjaGlsZFN1YmNoYW5uZWwuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcigoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIGtlZXBhbGl2ZVRpbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aXZpdHlTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWplY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSB3cmFwcGVyJ3NcbiAgICAgKiBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGxpc3RlbmVyIHByZXZpb3VzbHkgYWRkZWQgd2l0aCBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQSByZWZlcmVuY2UgdG8gYSBmdW5jdGlvbiBwcmV2aW91c2x5IHBhc3NlZCB0b1xuICAgICAqICAgICBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgKi9cbiAgICByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVySW5kZXggPSB0aGlzLnN0YXRlTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAobGlzdGVuZXJJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLnNwbGljZShsaXN0ZW5lckluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQudW5yZWYoKTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5yZWZDb3VudCA8PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdCgpIHtcbiAgICAgICAgdGhpcy5lamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgLTEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuZWplY3QoKSB7XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlLCAtMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TWFwRW50cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcEVudHJ5O1xuICAgIH1cbiAgICBnZXRXcmFwcGVkU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQ7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlRW1wdHlCdWNrZXQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogMCxcbiAgICAgICAgZmFpbHVyZTogMCxcbiAgICB9O1xufVxuY2xhc3MgQ2FsbENvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgICAgIHRoaXMuaW5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xuICAgIH1cbiAgICBhZGRTdWNjZXNzKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldC5zdWNjZXNzICs9IDE7XG4gICAgfVxuICAgIGFkZEZhaWx1cmUoKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQnVja2V0LmZhaWx1cmUgKz0gMTtcbiAgICB9XG4gICAgc3dpdGNoQnVja2V0cygpIHtcbiAgICAgICAgdGhpcy5pbmFjdGl2ZUJ1Y2tldCA9IHRoaXMuYWN0aXZlQnVja2V0O1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldCA9IGNyZWF0ZUVtcHR5QnVja2V0KCk7XG4gICAgfVxuICAgIGdldExhc3RTdWNjZXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluYWN0aXZlQnVja2V0LnN1Y2Nlc3M7XG4gICAgfVxuICAgIGdldExhc3RGYWlsdXJlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5hY3RpdmVCdWNrZXQuZmFpbHVyZTtcbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uUGlja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkUGlja2VyLCBjb3VudENhbGxzKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZFBpY2tlciA9IHdyYXBwZWRQaWNrZXI7XG4gICAgICAgIHRoaXMuY291bnRDYWxscyA9IGNvdW50Q2FsbHM7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZFBpY2sgPSB0aGlzLndyYXBwZWRQaWNrZXIucGljayhwaWNrQXJncyk7XG4gICAgICAgIGlmICh3cmFwcGVkUGljay5waWNrUmVzdWx0VHlwZSA9PT0gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyID0gd3JhcHBlZFBpY2suc3ViY2hhbm5lbDtcbiAgICAgICAgICAgIGNvbnN0IG1hcEVudHJ5ID0gc3ViY2hhbm5lbFdyYXBwZXIuZ2V0TWFwRW50cnkoKTtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGxldCBvbkNhbGxFbmRlZCA9IHdyYXBwZWRQaWNrLm9uQ2FsbEVuZGVkO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvdW50Q2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DYWxsRW5kZWQgPSBzdGF0dXNDb2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5jb3VudGVyLmFkZFN1Y2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuYWRkRmFpbHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gd3JhcHBlZFBpY2sub25DYWxsRW5kZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdyYXBwZWRQaWNrLCBzdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgd3JhcHBlZFBpY2spLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxXcmFwcGVyLmdldFdyYXBwZWRTdWJjaGFubmVsKCksIG9uQ2FsbEVuZGVkOiBvbkNhbGxFbmRlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRQaWNrKSwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsV3JhcHBlci5nZXRXcmFwcGVkU3ViY2hhbm5lbCgpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRQaWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxhdGVzdENvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKCgwLCBleHBlcmltZW50YWxfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKShjaGFubmVsQ29udHJvbEhlbHBlciwge1xuICAgICAgICAgICAgY3JlYXRlU3ViY2hhbm5lbDogKHN1YmNoYW5uZWxBZGRyZXNzLCBzdWJjaGFubmVsQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3ViY2hhbm5lbCA9IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXBFbnRyeSA9IHRoaXMuYWRkcmVzc01hcC5nZXQoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKHN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSBuZXcgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyKG9yaWdpbmFsU3ViY2hhbm5lbCwgbWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICgobWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFkZHJlc3MgaXMgZWplY3RlZCwgcHJvcGFnYXRlIHRoYXQgdG8gdGhlIG5ldyBzdWJjaGFubmVsIHdyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5wdXNoKHN1YmNoYW5uZWxXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbFdyYXBwZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgbmV3IE91dGxpZXJEZXRlY3Rpb25QaWNrZXIocGlja2VyLCB0aGlzLmlzQ291bnRpbmdFbmFibGVkKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5lamVjdGlvblRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4geyB9LCAwKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmVqZWN0aW9uVGltZXIpO1xuICAgIH1cbiAgICBpc0NvdW50aW5nRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxhdGVzdENvbmZpZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMubGF0ZXN0Q29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSAhPT0gbnVsbCkpO1xuICAgIH1cbiAgICBnZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkge1xuICAgICAgICBsZXQgZWplY3Rpb25Db3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWplY3Rpb25Db3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZWplY3Rpb25Db3VudCAqIDEwMCkgLyB0aGlzLmFkZHJlc3NNYXAuc2l6ZTtcbiAgICB9XG4gICAgcnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVDb25maWcgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCk7XG4gICAgICAgIGlmICghc3VjY2Vzc1JhdGVDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUnVubmluZyBzdWNjZXNzIHJhdGUgY2hlY2snKTtcbiAgICAgICAgLy8gU3RlcCAxXG4gICAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3RWb2x1bWUgPSBzdWNjZXNzUmF0ZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZTtcbiAgICAgICAgbGV0IGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSA9IDA7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5hZGRyZXNzTWFwKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIHRyYWNlKCdTdGF0cyBmb3IgJyArXG4gICAgICAgICAgICAgICAgYWRkcmVzcyArXG4gICAgICAgICAgICAgICAgJzogc3VjY2Vzc2VzPScgK1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NlcyArXG4gICAgICAgICAgICAgICAgJyBmYWlsdXJlcz0nICtcbiAgICAgICAgICAgICAgICBmYWlsdXJlcyArXG4gICAgICAgICAgICAgICAgJyB0YXJnZXRSZXF1ZXN0Vm9sdW1lPScgK1xuICAgICAgICAgICAgICAgIHRhcmdldFJlcXVlc3RWb2x1bWUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzID49IHRhcmdldFJlcXVlc3RWb2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcbiAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZXMucHVzaChzdWNjZXNzZXMgLyAoc3VjY2Vzc2VzICsgZmFpbHVyZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnRm91bmQgJyArXG4gICAgICAgICAgICBhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgK1xuICAgICAgICAgICAgJyBzdWNjZXNzIHJhdGUgY2FuZGlkYXRlczsgY3VycmVudEVqZWN0aW9uUGVyY2VudD0nICtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpICtcbiAgICAgICAgICAgICcgc3VjY2Vzc1JhdGVzPVsnICtcbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcyArXG4gICAgICAgICAgICAnXScpO1xuICAgICAgICBpZiAoYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lIDwgc3VjY2Vzc1JhdGVDb25maWcubWluaW11bV9ob3N0cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0ZXAgMlxuICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZU1lYW4gPSBzdWNjZXNzUmF0ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYikgLyBzdWNjZXNzUmF0ZXMubGVuZ3RoO1xuICAgICAgICBsZXQgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHJhdGUgb2Ygc3VjY2Vzc1JhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCBkZXZpYXRpb24gPSByYXRlIC0gc3VjY2Vzc1JhdGVNZWFuO1xuICAgICAgICAgICAgc3VjY2Vzc1JhdGVEZXZpYXRpb25TdW0gKz0gZGV2aWF0aW9uICogZGV2aWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlVmFyaWFuY2UgPSBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlU3RkZXYgPSBNYXRoLnNxcnQoc3VjY2Vzc1JhdGVWYXJpYW5jZSk7XG4gICAgICAgIGNvbnN0IGVqZWN0aW9uVGhyZXNob2xkID0gc3VjY2Vzc1JhdGVNZWFuIC1cbiAgICAgICAgICAgIHN1Y2Nlc3NSYXRlU3RkZXYgKiAoc3VjY2Vzc1JhdGVDb25maWcuc3RkZXZfZmFjdG9yIC8gMTAwMCk7XG4gICAgICAgIHRyYWNlKCdzdGRldj0nICsgc3VjY2Vzc1JhdGVTdGRldiArICcgZWplY3Rpb25UaHJlc2hvbGQ9JyArIGVqZWN0aW9uVGhyZXNob2xkKTtcbiAgICAgICAgLy8gU3RlcCAzXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDMuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMy5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPCB0YXJnZXRSZXF1ZXN0Vm9sdW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdGVwIDMuaWlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzUmF0ZSA9IHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcyk7XG4gICAgICAgICAgICB0cmFjZSgnQ2hlY2tpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzICsgJyBzdWNjZXNzUmF0ZT0nICsgc3VjY2Vzc1JhdGUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSYXRlIDwgZWplY3Rpb25UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgc3VjY2Vzc1JhdGVDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5GYWlsdXJlUGVyY2VudGFnZUNoZWNrKGVqZWN0aW9uVGltZXN0YW1wKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKTtcbiAgICAgICAgaWYgKCFmYWlsdXJlUGVyY2VudGFnZUNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSdW5uaW5nIGZhaWx1cmUgcGVyY2VudGFnZSBjaGVjay4gdGhyZXNob2xkPScgK1xuICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcudGhyZXNob2xkICtcbiAgICAgICAgICAgICcgcmVxdWVzdCB2b2x1bWUgdGhyZXNob2xkPScgK1xuICAgICAgICAgICAgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpO1xuICAgICAgICAvLyBTdGVwIDFcbiAgICAgICAgbGV0IGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXNXaXRoVGFyZ2V0Vm9sdW1lICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgPCBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5taW5pbXVtX2hvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAyXG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAvLyBTdGVwIDIuaVxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0Q3VycmVudEVqZWN0aW9uUGVyY2VudCgpID49XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlIHN1Y2Nlc3Nlcz0nICsgc3VjY2Vzc2VzICsgJyBmYWlsdXJlcz0nICsgZmFpbHVyZXMpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paWlcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVQZXJjZW50YWdlID0gKGZhaWx1cmVzICogMTAwKSAvIChmYWlsdXJlcyArIHN1Y2Nlc3Nlcyk7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZVBlcmNlbnRhZ2UgPiBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgK1xuICAgICAgICAgICAgICAgICAgICAnIHJhbmRvbU51bWJlcj0nICtcbiAgICAgICAgICAgICAgICAgICAgcmFuZG9tTnVtYmVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApIHtcbiAgICAgICAgbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciArPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyIG9mIG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmVqZWN0KG1hcEVudHJ5KSB7XG4gICAgICAgIG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci51bmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoQWxsQnVja2V0cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuc3dpdGNoQnVja2V0cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VGltZXIoZGVsYXlNcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmVqZWN0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucnVuQ2hlY2tzKCksIGRlbGF5TXMpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmVqZWN0aW9uVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIHJ1bkNoZWNrcygpIHtcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB0cmFjZSgnRWplY3Rpb24gdGltZXIgcnVubmluZycpO1xuICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBlamVjdGlvblRpbWVzdGFtcDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWVyKHRoaXMubGF0ZXN0Q29uZmlnLmdldEludGVydmFsTXMoKSk7XG4gICAgICAgIHRoaXMucnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIHRoaXMucnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayhlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIG1hcEVudHJ5XSBvZiB0aGlzLmFkZHJlc3NNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcEVudHJ5LmVqZWN0aW9uVGltZU11bHRpcGxpZXIgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlRWplY3Rpb25UaW1lTXMgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRCYXNlRWplY3Rpb25UaW1lTXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhFamVjdGlvblRpbWVNcyA9IHRoaXMubGF0ZXN0Q29uZmlnLmdldE1heEVqZWN0aW9uVGltZU1zKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0dXJuVGltZSA9IG5ldyBEYXRlKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcC5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIHJldHVyblRpbWUuc2V0TWlsbGlzZWNvbmRzKHJldHVyblRpbWUuZ2V0TWlsbGlzZWNvbmRzKCkgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihiYXNlRWplY3Rpb25UaW1lTXMgKiBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyLCBNYXRoLm1heChiYXNlRWplY3Rpb25UaW1lTXMsIG1heEVqZWN0aW9uVGltZU1zKSkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UaW1lIDwgbmV3IERhdGUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnVW5lamVjdGluZyAnICsgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZywgYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoIShsYkNvbmZpZyBpbnN0YW5jZW9mIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxBZGRyZXNzZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBhZGRyZXNzTGlzdCkge1xuICAgICAgICAgICAgc3ViY2hhbm5lbEFkZHJlc3Nlcy5hZGQoKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2Ygc3ViY2hhbm5lbEFkZHJlc3Nlcykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFkZHJlc3NNYXAuaGFzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0FkZGluZyBtYXAgZW50cnkgZm9yICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuc2V0KGFkZHJlc3MsIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcjogbmV3IENhbGxDb3VudGVyKCksXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFamVjdGlvblRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZWplY3Rpb25UaW1lTXVsdGlwbGllcjogMCxcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXJzOiBbXSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLmFkZHJlc3NNYXAua2V5cygpKSB7XG4gICAgICAgICAgICBpZiAoIXN1YmNoYW5uZWxBZGRyZXNzZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUmVtb3ZpbmcgbWFwIGVudHJ5IGZvciAnICsga2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZHJlc3NNYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRQb2xpY3kgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKShsYkNvbmZpZy5nZXRDaGlsZFBvbGljeSgpLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyLnVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBjaGlsZFBvbGljeSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChsYkNvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkgfHxcbiAgICAgICAgICAgIGxiQ29uZmlnLmdldEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGltZXJTdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnUHJldmlvdXMgdGltZXIgZXhpc3RlZC4gUmVwbGFjaW5nIHRpbWVyJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nRGVsYXkgPSBsYkNvbmZpZy5nZXRJbnRlcnZhbE1zKCkgLVxuICAgICAgICAgICAgICAgICAgICAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnRpbWVyU3RhcnRUaW1lLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKHJlbWFpbmluZ0RlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdTdGFydGluZyBuZXcgdGltZXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIobGJDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNlKCdDb3VudGluZyBkaXNhYmxlZC4gQ2FuY2VsbGluZyB0aW1lci4nKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBpZiAoT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCkge1xuICAgICAgICAoMCwgZXhwZXJpbWVudGFsXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKShUWVBFX05BTUUsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIsIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnKTtcbiAgICB9XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.PickFirstLoadBalancer = exports.shuffled = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    constructor(shuffleAddressList) {\n        this.shuffleAddressList = shuffleAddressList;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {\n                shuffleAddressList: this.shuffleAddressList,\n            },\n        };\n    }\n    getShuffleAddressList() {\n        return this.shuffleAddressList;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        if ('shuffleAddressList' in obj &&\n            !(typeof obj.shuffleAddressList === 'boolean')) {\n            throw new Error('pick_first config field shuffleAddressList must be a boolean if provided');\n        }\n        return new PickFirstLoadBalancingConfig(obj.shuffleAddressList === true);\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n    constructor(subchannel) {\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n}\n/**\n * Return a new array with the elements of the input array in a random order\n * @param list The input array\n * @returns A shuffled array of the elements of list\n */\nfunction shuffled(list) {\n    const result = list.slice();\n    for (let i = result.length - 1; i > 1; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const temp = result[i];\n        result[i] = result[j];\n        result[j] = temp;\n    }\n    return result;\n}\nexports.shuffled = shuffled;\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */\n        this.children = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */\n        this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */\n        this.currentPick = null;\n        /**\n         * Listener callback attached to each subchannel in the `subchannels` list\n         * while establishing a connection.\n         */\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\n            this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);\n        };\n        this.triedAllSubchannels = false;\n        /**\n         * The LB policy enters sticky TRANSIENT_FAILURE mode when all\n         * subchannels have failed to connect at least once, and it stays in that\n         * mode until a connection attempt is successful. While in sticky TF mode,\n         * the LB policy continuously attempts to connect to all of its subchannels.\n         */\n        this.stickyTransientFailureMode = false;\n        /**\n         * Indicates whether we called channelControlHelper.requestReresolution since\n         * the last call to updateAddressList\n         */\n        this.requestedResolutionSinceLastUpdate = false;\n        /**\n         * The most recent error reported by any subchannel as it transitioned to\n         * TRANSIENT_FAILURE.\n         */\n        this.lastError = null;\n        this.latestAddressList = null;\n        this.connectionDelayTimeout = setTimeout(() => { }, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    allChildrenHaveReportedTF() {\n        return this.children.every(child => child.hasReportedTransientFailure);\n    }\n    calculateAndReportNewState() {\n        if (this.currentPick) {\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));\n        }\n        else if (this.children.length === 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n        else {\n            if (this.stickyTransientFailureMode) {\n                this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({ details: `No connection established. Last error: ${this.lastError}` }));\n            }\n            else {\n                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n            }\n        }\n    }\n    requestReresolution() {\n        this.requestedResolutionSinceLastUpdate = true;\n        this.channelControlHelper.requestReresolution();\n    }\n    maybeEnterStickyTransientFailureMode() {\n        if (!this.allChildrenHaveReportedTF()) {\n            return;\n        }\n        if (!this.requestedResolutionSinceLastUpdate) {\n            /* Each time we get an update we reset each subchannel's\n             * hasReportedTransientFailure flag, so the next time we get to this\n             * point after that, each subchannel has reported TRANSIENT_FAILURE\n             * at least once since then. That is the trigger for requesting\n             * reresolution, whether or not the LB policy is already in sticky TF\n             * mode. */\n            this.requestReresolution();\n        }\n        if (this.stickyTransientFailureMode) {\n            return;\n        }\n        this.stickyTransientFailureMode = true;\n        for (const { subchannel } of this.children) {\n            subchannel.startConnecting();\n        }\n        this.calculateAndReportNewState();\n    }\n    removeCurrentPick() {\n        if (this.currentPick !== null) {\n            /* Unref can cause a state change, which can cause a change in the value\n             * of this.currentPick, so we hold a local reference to make sure that\n             * does not impact this function. */\n            const currentPick = this.currentPick;\n            this.currentPick = null;\n            currentPick.unref();\n            currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n        }\n    }\n    onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {\n        var _a;\n        if ((_a = this.currentPick) === null || _a === void 0 ? void 0 : _a.realSubchannelEquals(subchannel)) {\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.removeCurrentPick();\n                this.calculateAndReportNewState();\n                this.requestReresolution();\n            }\n            return;\n        }\n        for (const [index, child] of this.children.entries()) {\n            if (subchannel.realSubchannelEquals(child.subchannel)) {\n                if (newState === connectivity_state_1.ConnectivityState.READY) {\n                    this.pickSubchannel(child.subchannel);\n                }\n                if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    child.hasReportedTransientFailure = true;\n                    if (errorMessage) {\n                        this.lastError = errorMessage;\n                    }\n                    this.maybeEnterStickyTransientFailureMode();\n                    if (index === this.currentSubchannelIndex) {\n                        this.startNextSubchannelConnecting(index + 1);\n                    }\n                }\n                child.subchannel.startConnecting();\n                return;\n            }\n        }\n    }\n    startNextSubchannelConnecting(startIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, child] of this.children.entries()) {\n            if (index >= startIndex) {\n                const subchannelState = child.subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                    subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n        this.maybeEnterStickyTransientFailureMode();\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */\n    startConnecting(subchannelIndex) {\n        var _a, _b;\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.children[subchannelIndex].subchannel.getConnectivityState() ===\n            connectivity_state_1.ConnectivityState.IDLE) {\n            trace('Start connecting to subchannel with address ' +\n                this.children[subchannelIndex].subchannel.getAddress());\n            process.nextTick(() => {\n                var _a;\n                (_a = this.children[subchannelIndex]) === null || _a === void 0 ? void 0 : _a.subchannel.startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = (_b = (_a = setTimeout(() => {\n            this.startNextSubchannelConnecting(subchannelIndex + 1);\n        }, CONNECTION_DELAY_INTERVAL_MS)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    pickSubchannel(subchannel) {\n        if (this.currentPick && subchannel.realSubchannelEquals(this.currentPick)) {\n            return;\n        }\n        trace('Pick subchannel with address ' + subchannel.getAddress());\n        this.stickyTransientFailureMode = false;\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());\n            this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n        this.calculateAndReportNewState();\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const child of this.children) {\n            if (!(this.currentPick && child.subchannel.realSubchannelEquals(this.currentPick))) {\n                /* The connectivity state listener is the same whether the subchannel\n                 * is in the list of children or it is the currentPick, so if it is in\n                 * both, removing it here would cause problems. In particular, that\n                 * always happens immediately after the subchannel is picked. */\n                child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            }\n            /* Refs are counted independently for the children list and the\n             * currentPick, so we call unref whether or not the child is the\n             * currentPick. Channelz child references are also refcounted, so\n             * removeChannelzChild can be handled the same way. */\n            child.subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.children = [];\n        this.triedAllSubchannels = false;\n        this.requestedResolutionSinceLastUpdate = false;\n    }\n    connectToAddressList(addressList) {\n        const newChildrenList = addressList.map(address => ({\n            subchannel: this.channelControlHelper.createSubchannel(address, {}),\n            hasReportedTransientFailure: false,\n        }));\n        /* Ref each subchannel before resetting the list, to ensure that\n         * subchannels shared between the list don't drop to 0 refs during the\n         * transition. */\n        for (const { subchannel } of newChildrenList) {\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        this.resetSubchannelList();\n        this.children = newChildrenList;\n        for (const { subchannel } of this.children) {\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            }\n        }\n        for (const child of this.children) {\n            if (child.subchannel.getConnectivityState() ===\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                child.hasReportedTransientFailure = true;\n            }\n        }\n        this.startNextSubchannelConnecting(0);\n        this.calculateAndReportNewState();\n    }\n    updateAddressList(addressList, lbConfig) {\n        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {\n            return;\n        }\n        /* Previously, an update would be discarded if it was identical to the\n         * previous update, to minimize churn. Now the DNS resolver is\n         * rate-limited, so that is less of a concern. */\n        if (lbConfig.getShuffleAddressList()) {\n            addressList = shuffled(addressList);\n        }\n        this.latestAddressList = addressList;\n        this.connectToAddressList(addressList);\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {\n            this.connectToAddressList(this.latestAddressList);\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n        this.removeCurrentPick();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-pick-first.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLDZCQUE2QixHQUFHLGdCQUFnQixHQUFHLG9DQUFvQztBQUN2Ryx3QkFBd0IsbUJBQU8sQ0FBQyxzRkFBaUI7QUFDakQsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVO0FBQ25DLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEhBQTRILG1EQUFtRCxlQUFlLEdBQUc7QUFDak07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItcGljay1maXJzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2VyID0gZXhwb3J0cy5zaHVmZmxlZCA9IGV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3BpY2tfZmlyc3QnO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAncGlja19maXJzdCc7XG4vKipcbiAqIERlbGF5IGFmdGVyIHN0YXJ0aW5nIGEgY29ubmVjdGlvbiBvbiBhIHN1YmNoYW5uZWwgYmVmb3JlIHN0YXJ0aW5nIGFcbiAqIGNvbm5lY3Rpb24gb24gdGhlIG5leHQgc3ViY2hhbm5lbCBpbiB0aGUgbGlzdCwgZm9yIEhhcHB5IEV5ZWJhbGxzIGFsZ29yaXRobS5cbiAqL1xuY29uc3QgQ09OTkVDVElPTl9ERUxBWV9JTlRFUlZBTF9NUyA9IDI1MDtcbmNsYXNzIFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKHNodWZmbGVBZGRyZXNzTGlzdCkge1xuICAgICAgICB0aGlzLnNodWZmbGVBZGRyZXNzTGlzdCA9IHNodWZmbGVBZGRyZXNzTGlzdDtcbiAgICB9XG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG4gICAgdG9Kc29uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1RZUEVfTkFNRV06IHtcbiAgICAgICAgICAgICAgICBzaHVmZmxlQWRkcmVzc0xpc3Q6IHRoaXMuc2h1ZmZsZUFkZHJlc3NMaXN0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0U2h1ZmZsZUFkZHJlc3NMaXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaHVmZmxlQWRkcmVzc0xpc3Q7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICBpZiAoJ3NodWZmbGVBZGRyZXNzTGlzdCcgaW4gb2JqICYmXG4gICAgICAgICAgICAhKHR5cGVvZiBvYmouc2h1ZmZsZUFkZHJlc3NMaXN0ID09PSAnYm9vbGVhbicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpY2tfZmlyc3QgY29uZmlnIGZpZWxkIHNodWZmbGVBZGRyZXNzTGlzdCBtdXN0IGJlIGEgYm9vbGVhbiBpZiBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyhvYmouc2h1ZmZsZUFkZHJlc3NMaXN0ID09PSB0cnVlKTtcbiAgICB9XG59XG5leHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcgPSBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnO1xuLyoqXG4gKiBQaWNrZXIgZm9yIGEgYFBpY2tGaXJzdExvYWRCYWxhbmNlcmAgaW4gdGhlIFJFQURZIHN0YXRlLiBBbHdheXMgcmV0dXJucyB0aGVcbiAqIHBpY2tlZCBzdWJjaGFubmVsLlxuICovXG5jbGFzcyBQaWNrRmlyc3RQaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN1YmNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsID0gc3ViY2hhbm5lbDtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkNPTVBMRVRFLFxuICAgICAgICAgICAgc3ViY2hhbm5lbDogdGhpcy5zdWJjaGFubmVsLFxuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIG9mIHRoZSBpbnB1dCBhcnJheSBpbiBhIHJhbmRvbSBvcmRlclxuICogQHBhcmFtIGxpc3QgVGhlIGlucHV0IGFycmF5XG4gKiBAcmV0dXJucyBBIHNodWZmbGVkIGFycmF5IG9mIHRoZSBlbGVtZW50cyBvZiBsaXN0XG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVkKGxpc3QpIHtcbiAgICBjb25zdCByZXN1bHQgPSBsaXN0LnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IHJlc3VsdC5sZW5ndGggLSAxOyBpID4gMTsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGogPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoaSArIDEpKTtcbiAgICAgICAgY29uc3QgdGVtcCA9IHJlc3VsdFtpXTtcbiAgICAgICAgcmVzdWx0W2ldID0gcmVzdWx0W2pdO1xuICAgICAgICByZXN1bHRbal0gPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5zaHVmZmxlZCA9IHNodWZmbGVkO1xuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2VyIHtcbiAgICAvKipcbiAgICAgKiBMb2FkIGJhbGFuY2VyIHRoYXQgYXR0ZW1wdHMgdG8gY29ubmVjdCB0byBlYWNoIGJhY2tlbmQgaW4gdGhlIGFkZHJlc3MgbGlzdFxuICAgICAqIGluIG9yZGVyLCBhbmQgcGlja3MgdGhlIGZpcnN0IG9uZSB0aGF0IGNvbm5lY3RzLCB1c2luZyBpdCBmb3IgZXZlcnlcbiAgICAgKiByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBjaGFubmVsQ29udHJvbEhlbHBlciBgQ2hhbm5lbENvbnRyb2xIZWxwZXJgIGluc3RhbmNlIHByb3ZpZGVkIGJ5XG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIHN1YmNoYW5uZWxzIHRoaXMgbG9hZCBiYWxhbmNlciBpcyBjdXJyZW50bHkgYXR0ZW1wdGluZyB0b1xuICAgICAgICAgKiBjb25uZWN0IHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlIG9mIHRoZSBsb2FkIGJhbGFuY2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IHdpdGhpbiB0aGUgYHN1YmNoYW5uZWxzYCBhcnJheSBvZiB0aGUgc3ViY2hhbm5lbCB3aXRoIHRoZSBtb3N0XG4gICAgICAgICAqIHJlY2VudGx5IHN0YXJ0ZWQgY29ubmVjdGlvbiBhdHRlbXB0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgcGlja2VkIHN1YmNoYW5uZWwgdXNlZCBmb3IgbWFraW5nIGNhbGxzLiBQb3B1bGF0ZWQgaWZcbiAgICAgICAgICogYW5kIG9ubHkgaWYgdGhlIGxvYWQgYmFsYW5jZXIncyBjdXJyZW50IHN0YXRlIGlzIFJFQURZLiBJbiB0aGF0IGNhc2UsXG4gICAgICAgICAqIHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBzdGF0ZSBpcyBhbHNvIFJFQURZLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50UGljayA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0ZW5lciBjYWxsYmFjayBhdHRhY2hlZCB0byBlYWNoIHN1YmNoYW5uZWwgaW4gdGhlIGBzdWJjaGFubmVsc2AgbGlzdFxuICAgICAgICAgKiB3aGlsZSBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lciA9IChzdWJjaGFubmVsLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwga2VlcGFsaXZlVGltZSwgZXJyb3JNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uU3ViY2hhbm5lbFN0YXRlVXBkYXRlKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBMQiBwb2xpY3kgZW50ZXJzIHN0aWNreSBUUkFOU0lFTlRfRkFJTFVSRSBtb2RlIHdoZW4gYWxsXG4gICAgICAgICAqIHN1YmNoYW5uZWxzIGhhdmUgZmFpbGVkIHRvIGNvbm5lY3QgYXQgbGVhc3Qgb25jZSwgYW5kIGl0IHN0YXlzIGluIHRoYXRcbiAgICAgICAgICogbW9kZSB1bnRpbCBhIGNvbm5lY3Rpb24gYXR0ZW1wdCBpcyBzdWNjZXNzZnVsLiBXaGlsZSBpbiBzdGlja3kgVEYgbW9kZSxcbiAgICAgICAgICogdGhlIExCIHBvbGljeSBjb250aW51b3VzbHkgYXR0ZW1wdHMgdG8gY29ubmVjdCB0byBhbGwgb2YgaXRzIHN1YmNoYW5uZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgd2UgY2FsbGVkIGNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24gc2luY2VcbiAgICAgICAgICogdGhlIGxhc3QgY2FsbCB0byB1cGRhdGVBZGRyZXNzTGlzdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXF1ZXN0ZWRSZXNvbHV0aW9uU2luY2VMYXN0VXBkYXRlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbW9zdCByZWNlbnQgZXJyb3IgcmVwb3J0ZWQgYnkgYW55IHN1YmNoYW5uZWwgYXMgaXQgdHJhbnNpdGlvbmVkIHRvXG4gICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdEFkZHJlc3NMaXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICB9XG4gICAgYWxsQ2hpbGRyZW5IYXZlUmVwb3J0ZWRURigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW4uZXZlcnkoY2hpbGQgPT4gY2hpbGQuaGFzUmVwb3J0ZWRUcmFuc2llbnRGYWlsdXJlKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZLCBuZXcgUGlja0ZpcnN0UGlja2VyKHRoaXMuY3VycmVudFBpY2spKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoeyBkZXRhaWxzOiBgTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZC4gTGFzdCBlcnJvcjogJHt0aGlzLmxhc3RFcnJvcn1gIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXF1ZXN0UmVyZXNvbHV0aW9uKCkge1xuICAgICAgICB0aGlzLnJlcXVlc3RlZFJlc29sdXRpb25TaW5jZUxhc3RVcGRhdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICB9XG4gICAgbWF5YmVFbnRlclN0aWNreVRyYW5zaWVudEZhaWx1cmVNb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWxsQ2hpbGRyZW5IYXZlUmVwb3J0ZWRURigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RlZFJlc29sdXRpb25TaW5jZUxhc3RVcGRhdGUpIHtcbiAgICAgICAgICAgIC8qIEVhY2ggdGltZSB3ZSBnZXQgYW4gdXBkYXRlIHdlIHJlc2V0IGVhY2ggc3ViY2hhbm5lbCdzXG4gICAgICAgICAgICAgKiBoYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUgZmxhZywgc28gdGhlIG5leHQgdGltZSB3ZSBnZXQgdG8gdGhpc1xuICAgICAgICAgICAgICogcG9pbnQgYWZ0ZXIgdGhhdCwgZWFjaCBzdWJjaGFubmVsIGhhcyByZXBvcnRlZCBUUkFOU0lFTlRfRkFJTFVSRVxuICAgICAgICAgICAgICogYXQgbGVhc3Qgb25jZSBzaW5jZSB0aGVuLiBUaGF0IGlzIHRoZSB0cmlnZ2VyIGZvciByZXF1ZXN0aW5nXG4gICAgICAgICAgICAgKiByZXJlc29sdXRpb24sIHdoZXRoZXIgb3Igbm90IHRoZSBMQiBwb2xpY3kgaXMgYWxyZWFkeSBpbiBzdGlja3kgVEZcbiAgICAgICAgICAgICAqIG1vZGUuICovXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHsgc3ViY2hhbm5lbCB9IG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRSZXBvcnROZXdTdGF0ZSgpO1xuICAgIH1cbiAgICByZW1vdmVDdXJyZW50UGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIFVucmVmIGNhbiBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgd2hpY2ggY2FuIGNhdXNlIGEgY2hhbmdlIGluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICogb2YgdGhpcy5jdXJyZW50UGljaywgc28gd2UgaG9sZCBhIGxvY2FsIHJlZmVyZW5jZSB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgICAgICAgICogZG9lcyBub3QgaW1wYWN0IHRoaXMgZnVuY3Rpb24uICovXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UGljayA9IHRoaXMuY3VycmVudFBpY2s7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gbnVsbDtcbiAgICAgICAgICAgIGN1cnJlbnRQaWNrLnVucmVmKCk7XG4gICAgICAgICAgICBjdXJyZW50UGljay5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKGN1cnJlbnRQaWNrLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uU3ViY2hhbm5lbFN0YXRlVXBkYXRlKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5jdXJyZW50UGljaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWxTdWJjaGFubmVsRXF1YWxzKHN1YmNoYW5uZWwpKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgIT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDdXJyZW50UGljaygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RSZXJlc29sdXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRdIG9mIHRoaXMuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbC5yZWFsU3ViY2hhbm5lbEVxdWFscyhjaGlsZC5zdWJjaGFubmVsKSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWNrU3ViY2hhbm5lbChjaGlsZC5zdWJjaGFubmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RFcnJvciA9IGVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heWJlRW50ZXJTdGlja3lUcmFuc2llbnRGYWlsdXJlTW9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhpbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCk7XG4gICAgICAgIGlmICh0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgY2hpbGRdIG9mIHRoaXMuY2hpbGRyZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IGNoaWxkLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXliZUVudGVyU3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGF2ZSBhIHNpbmdsZSBzdWJjaGFubmVsIGluIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3Qgc3RhcnQgY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbEluZGV4IFRoZSBpbmRleCBpbnRvIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3QuXG4gICAgICovXG4gICAgc3RhcnRDb25uZWN0aW5nKHN1YmNoYW5uZWxJbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gc3ViY2hhbm5lbEluZGV4O1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdLnN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT1cbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpIHtcbiAgICAgICAgICAgIHRyYWNlKCdTdGFydCBjb25uZWN0aW5nIHRvIHN1YmNoYW5uZWwgd2l0aCBhZGRyZXNzICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5bc3ViY2hhbm5lbEluZGV4XS5zdWJjaGFubmVsLmdldEFkZHJlc3MoKSk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jaGlsZHJlbltzdWJjaGFubmVsSW5kZXhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyhzdWJjaGFubmVsSW5kZXggKyAxKTtcbiAgICAgICAgfSwgQ09OTkVDVElPTl9ERUxBWV9JTlRFUlZBTF9NUykpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxuICAgIHBpY2tTdWJjaGFubmVsKHN1YmNoYW5uZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgJiYgc3ViY2hhbm5lbC5yZWFsU3ViY2hhbm5lbEVxdWFscyh0aGlzLmN1cnJlbnRQaWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdQaWNrIHN1YmNoYW5uZWwgd2l0aCBhZGRyZXNzICcgKyBzdWJjaGFubmVsLmdldEFkZHJlc3MoKSk7XG4gICAgICAgIHRoaXMuc3RpY2t5VHJhbnNpZW50RmFpbHVyZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBpY2sudW5yZWYoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZCh0aGlzLmN1cnJlbnRQaWNrLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljay5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBzdWJjaGFubmVsO1xuICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFJlcG9ydE5ld1N0YXRlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICByZXNldFN1YmNoYW5uZWxMaXN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuY3VycmVudFBpY2sgJiYgY2hpbGQuc3ViY2hhbm5lbC5yZWFsU3ViY2hhbm5lbEVxdWFscyh0aGlzLmN1cnJlbnRQaWNrKSkpIHtcbiAgICAgICAgICAgICAgICAvKiBUaGUgY29ubmVjdGl2aXR5IHN0YXRlIGxpc3RlbmVyIGlzIHRoZSBzYW1lIHdoZXRoZXIgdGhlIHN1YmNoYW5uZWxcbiAgICAgICAgICAgICAgICAgKiBpcyBpbiB0aGUgbGlzdCBvZiBjaGlsZHJlbiBvciBpdCBpcyB0aGUgY3VycmVudFBpY2ssIHNvIGlmIGl0IGlzIGluXG4gICAgICAgICAgICAgICAgICogYm90aCwgcmVtb3ZpbmcgaXQgaGVyZSB3b3VsZCBjYXVzZSBwcm9ibGVtcy4gSW4gcGFydGljdWxhciwgdGhhdFxuICAgICAgICAgICAgICAgICAqIGFsd2F5cyBoYXBwZW5zIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBzdWJjaGFubmVsIGlzIHBpY2tlZC4gKi9cbiAgICAgICAgICAgICAgICBjaGlsZC5zdWJjaGFubmVsLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBSZWZzIGFyZSBjb3VudGVkIGluZGVwZW5kZW50bHkgZm9yIHRoZSBjaGlsZHJlbiBsaXN0IGFuZCB0aGVcbiAgICAgICAgICAgICAqIGN1cnJlbnRQaWNrLCBzbyB3ZSBjYWxsIHVucmVmIHdoZXRoZXIgb3Igbm90IHRoZSBjaGlsZCBpcyB0aGVcbiAgICAgICAgICAgICAqIGN1cnJlbnRQaWNrLiBDaGFubmVseiBjaGlsZCByZWZlcmVuY2VzIGFyZSBhbHNvIHJlZmNvdW50ZWQsIHNvXG4gICAgICAgICAgICAgKiByZW1vdmVDaGFubmVsekNoaWxkIGNhbiBiZSBoYW5kbGVkIHRoZSBzYW1lIHdheS4gKi9cbiAgICAgICAgICAgIGNoaWxkLnN1YmNoYW5uZWwudW5yZWYoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZC5zdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVxdWVzdGVkUmVzb2x1dGlvblNpbmNlTGFzdFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBjb25uZWN0VG9BZGRyZXNzTGlzdChhZGRyZXNzTGlzdCkge1xuICAgICAgICBjb25zdCBuZXdDaGlsZHJlbkxpc3QgPSBhZGRyZXNzTGlzdC5tYXAoYWRkcmVzcyA9PiAoe1xuICAgICAgICAgICAgc3ViY2hhbm5lbDogdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKGFkZHJlc3MsIHt9KSxcbiAgICAgICAgICAgIGhhc1JlcG9ydGVkVHJhbnNpZW50RmFpbHVyZTogZmFsc2UsXG4gICAgICAgIH0pKTtcbiAgICAgICAgLyogUmVmIGVhY2ggc3ViY2hhbm5lbCBiZWZvcmUgcmVzZXR0aW5nIHRoZSBsaXN0LCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAgKiBzdWJjaGFubmVscyBzaGFyZWQgYmV0d2VlbiB0aGUgbGlzdCBkb24ndCBkcm9wIHRvIDAgcmVmcyBkdXJpbmcgdGhlXG4gICAgICAgICAqIHRyYW5zaXRpb24uICovXG4gICAgICAgIGZvciAoY29uc3QgeyBzdWJjaGFubmVsIH0gb2YgbmV3Q2hpbGRyZW5MaXN0KSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXdDaGlsZHJlbkxpc3Q7XG4gICAgICAgIGZvciAoY29uc3QgeyBzdWJjaGFubmVsIH0gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tTdWJjaGFubmVsKHN1YmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChjaGlsZC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09XG4gICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5oYXNSZXBvcnRlZFRyYW5zaWVudEZhaWx1cmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoMCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kUmVwb3J0TmV3U3RhdGUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGxiQ29uZmlnKSB7XG4gICAgICAgIGlmICghKGxiQ29uZmlnIGluc3RhbmNlb2YgUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBQcmV2aW91c2x5LCBhbiB1cGRhdGUgd291bGQgYmUgZGlzY2FyZGVkIGlmIGl0IHdhcyBpZGVudGljYWwgdG8gdGhlXG4gICAgICAgICAqIHByZXZpb3VzIHVwZGF0ZSwgdG8gbWluaW1pemUgY2h1cm4uIE5vdyB0aGUgRE5TIHJlc29sdmVyIGlzXG4gICAgICAgICAqIHJhdGUtbGltaXRlZCwgc28gdGhhdCBpcyBsZXNzIG9mIGEgY29uY2Vybi4gKi9cbiAgICAgICAgaWYgKGxiQ29uZmlnLmdldFNodWZmbGVBZGRyZXNzTGlzdCgpKSB7XG4gICAgICAgICAgICBhZGRyZXNzTGlzdCA9IHNodWZmbGVkKGFkZHJlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhdGVzdEFkZHJlc3NMaXN0ID0gYWRkcmVzc0xpc3Q7XG4gICAgICAgIHRoaXMuY29ubmVjdFRvQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFICYmIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRvQWRkcmVzc0xpc3QodGhpcy5sYXRlc3RBZGRyZXNzTGlzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICAvKiBUaGUgcGljayBmaXJzdCBsb2FkIGJhbGFuY2VyIGRvZXMgbm90IGhhdmUgYSBjb25uZWN0aW9uIGJhY2tvZmYsIHNvIHRoaXNcbiAgICAgICAgICogZG9lcyBub3RoaW5nICovXG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUN1cnJlbnRQaWNrKCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuUGlja0ZpcnN0TG9hZEJhbGFuY2VyID0gUGlja0ZpcnN0TG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgUGlja0ZpcnN0TG9hZEJhbGFuY2VyLCBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKTtcbiAgICAoMCwgbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSk7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLXBpY2stZmlyc3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor() { }\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {},\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0) {\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */\n    peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper) {\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.lastError = null;\n        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {\n            this.calculateAndUpdateState();\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE ||\n                newState === connectivity_state_1.ConnectivityState.IDLE) {\n                if (errorMessage) {\n                    this.lastError = errorMessage;\n                }\n                this.channelControlHelper.requestReresolution();\n                subchannel.startConnecting();\n            }\n        };\n    }\n    countSubchannelsWithState(state) {\n        return this.subchannels.filter(subchannel => subchannel.getConnectivityState() === state).length;\n    }\n    calculateAndUpdateState() {\n        if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.READY) > 0) {\n            const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        }\n        else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        else if (this.countSubchannelsWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({ details: `No connection established. Last error: ${this.lastError}` }));\n        }\n        else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        }\n        else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels) {\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace('Connect to address list ' +\n            addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)));\n        this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels) {\n            subchannel.ref();\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE ||\n                subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels) {\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n        /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */\n    }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup;\n//# sourceMappingURL=load-balancer-round-robin.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyw4QkFBOEI7QUFDOUMsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBVTtBQUNuQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILG1EQUFtRCxlQUFlLEdBQUc7QUFDN0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IHBpY2tlcl8xID0gcmVxdWlyZShcIi4vcGlja2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncm91bmRfcm9iaW4nO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAncm91bmRfcm9iaW4nO1xuY2xhc3MgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgdG9Kc29uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1RZUEVfTkFNRV06IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5QaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN1YmNoYW5uZWxMaXN0LCBuZXh0SW5kZXggPSAwKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbExpc3QgPSBzdWJjaGFubmVsTGlzdDtcbiAgICAgICAgdGhpcy5uZXh0SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3QgcGlja2VkU3ViY2hhbm5lbCA9IHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9ICh0aGlzLm5leHRJbmRleCArIDEpICUgdGhpcy5zdWJjaGFubmVsTGlzdC5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwaWNrUmVzdWx0VHlwZTogcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUsXG4gICAgICAgICAgICBzdWJjaGFubmVsOiBwaWNrZWRTdWJjaGFubmVsLFxuICAgICAgICAgICAgc3RhdHVzOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgICAgIG9uQ2FsbEVuZGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGF0IHRoZSBuZXh0IHN1YmNoYW5uZWwgcmV0dXJuZWQgd291bGQgYmUuIFVzZWQgYnkgdGhlIGxvYWRcbiAgICAgKiBiYWxhbmNlciBpbXBsZW1lbnRhdGlvbiB0byBwcmVzZXJ2ZSB0aGlzIHBhcnQgb2YgdGhlIHBpY2tlciBzdGF0ZSBpZlxuICAgICAqIHBvc3NpYmxlIHdoZW4gYSBzdWJjaGFubmVsIGNvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzLlxuICAgICAqL1xuICAgIHBlZWtOZXh0U3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUxpc3RlbmVyID0gKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlLCBrZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUgfHxcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbHMuZmlsdGVyKHN1YmNoYW5uZWwgPT4gc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpID09PSBzdGF0ZSkubGVuZ3RoO1xuICAgIH1cbiAgICBjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY291bnRTdWJjaGFubmVsc1dpdGhTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCByZWFkeVN1YmNoYW5uZWxzID0gdGhpcy5zdWJjaGFubmVscy5maWx0ZXIoc3ViY2hhbm5lbCA9PiBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlYWR5U3ViY2hhbm5lbHMuaW5kZXhPZih0aGlzLmN1cnJlbnRSZWFkeVBpY2tlci5wZWVrTmV4dFN1YmNoYW5uZWwoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFJvdW5kUm9iaW5QaWNrZXIocmVhZHlTdWJjaGFubmVscywgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvdW50U3ViY2hhbm5lbHNXaXRoU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb3VudFN1YmNoYW5uZWxzV2l0aFN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcih7IGRldGFpbHM6IGBObyBjb25uZWN0aW9uIGVzdGFibGlzaGVkLiBMYXN0IGVycm9yOiAke3RoaXMubGFzdEVycm9yfWAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZWFkeVBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xuICAgIH1cbiAgICByZXNldFN1YmNoYW5uZWxMaXN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRyYWNlKCdDb25uZWN0IHRvIGFkZHJlc3MgbGlzdCAnICtcbiAgICAgICAgICAgIGFkZHJlc3NMaXN0Lm1hcChhZGRyZXNzID0+ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShhZGRyZXNzKSkpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gYWRkcmVzc0xpc3QubWFwKGFkZHJlc3MgPT4gdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsKGFkZHJlc3MsIHt9KSk7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci5hZGRDaGFubmVsekNoaWxkKHN1YmNoYW5uZWwuZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsU3RhdGUgPSBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgICAgICAgICBpZiAoc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSgpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXRCYWNrb2ZmKCkge1xuICAgICAgICAvKiBUaGUgcGljayBmaXJzdCBsb2FkIGJhbGFuY2VyIGRvZXMgbm90IGhhdmUgYSBjb25uZWN0aW9uIGJhY2tvZmYsIHNvIHRoaXNcbiAgICAgICAgICogZG9lcyBub3RoaW5nICovXG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLlJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIgPSBSb3VuZFJvYmluTG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIGxvYWRfYmFsYW5jZXJfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUpKFRZUEVfTkFNRSwgUm91bmRSb2JpbkxvYWRCYWxhbmNlciwgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */\nfunction createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent),\n    };\n}\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType,\n    };\n}\nexports.registerLoadBalancerType = registerLoadBalancerType;\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    }\n    else {\n        return null;\n    }\n}\nexports.createLoadBalancer = createLoadBalancer;\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nfunction getFirstUsableConfig(configs, fallbackTodefault = false) {\n    for (const config of configs) {\n        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\n            return config;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        }\n        else {\n            return null;\n        }\n    }\n    else {\n        return null;\n    }\n}\nexports.getFirstUsableConfig = getFirstUsableConfig;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validateLoadBalancingConfig(obj) {\n    if (!(obj !== null && typeof obj === 'object')) {\n        throw new Error('Load balancing config must be an object');\n    }\n    const keys = Object.keys(obj);\n    if (keys.length !== 1) {\n        throw new Error('Provided load balancing config has multiple conflicting entries');\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);\n    }\n    else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nexports.validateLoadBalancingConfig = validateLoadBalancingConfig;\n//# sourceMappingURL=load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1DQUFtQyxHQUFHLDRCQUE0QixHQUFHLG9DQUFvQyxHQUFHLDBCQUEwQixHQUFHLHVDQUF1QyxHQUFHLGdDQUFnQyxHQUFHLHVDQUF1QztBQUM3UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxTQUFTO0FBQzVFO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnID0gZXhwb3J0cy5nZXRGaXJzdFVzYWJsZUNvbmZpZyA9IGV4cG9ydHMuaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCA9IGV4cG9ydHMuY3JlYXRlTG9hZEJhbGFuY2VyID0gZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gZXhwb3J0cy5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSB2b2lkIDA7XG4vKipcbiAqIENyZWF0ZSBhIGNoaWxkIENoYW5uZWxDb250cm9sSGVscGVyIHRoYXQgb3ZlcnJpZGVzIHNvbWUgbWV0aG9kcyBvZiB0aGVcbiAqIHBhcmVudCB3aGlsZSBsZXR0aW5nIG90aGVycyBwYXNzIHRocm91Z2ggdG8gdGhlIHBhcmVudCB1bm1vZGlmaWVkLiBUaGlzXG4gKiBhbGxvd3Mgb3RoZXIgY29kZSB0byBjcmVhdGUgdGhlc2UgY2hpbGRyZW4gd2l0aG91dCBuZWVkaW5nIHRvIGtub3cgYWJvdXRcbiAqIGFsbCBvZiB0aGUgbWV0aG9kcyB0byBiZSBwYXNzZWQgdGhyb3VnaC5cbiAqIEBwYXJhbSBwYXJlbnRcbiAqIEBwYXJhbSBvdmVycmlkZXNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcihwYXJlbnQsIG92ZXJyaWRlcykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICByZXR1cm4ge1xuICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoX2IgPSAoX2EgPSBvdmVycmlkZXMuY3JlYXRlU3ViY2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcGFyZW50LmNyZWF0ZVN1YmNoYW5uZWwuYmluZChwYXJlbnQpLFxuICAgICAgICB1cGRhdGVTdGF0ZTogKF9kID0gKF9jID0gb3ZlcnJpZGVzLnVwZGF0ZVN0YXRlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBwYXJlbnQudXBkYXRlU3RhdGUuYmluZChwYXJlbnQpLFxuICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoX2YgPSAoX2UgPSBvdmVycmlkZXMucmVxdWVzdFJlcmVzb2x1dGlvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogcGFyZW50LnJlcXVlc3RSZXJlc29sdXRpb24uYmluZChwYXJlbnQpLFxuICAgICAgICBhZGRDaGFubmVsekNoaWxkOiAoX2ggPSAoX2cgPSBvdmVycmlkZXMuYWRkQ2hhbm5lbHpDaGlsZCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogcGFyZW50LmFkZENoYW5uZWx6Q2hpbGQuYmluZChwYXJlbnQpLFxuICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiAoX2sgPSAoX2ogPSBvdmVycmlkZXMucmVtb3ZlQ2hhbm5lbHpDaGlsZCkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLmJpbmQob3ZlcnJpZGVzKSkgIT09IG51bGwgJiYgX2sgIT09IHZvaWQgMCA/IF9rIDogcGFyZW50LnJlbW92ZUNoYW5uZWx6Q2hpbGQuYmluZChwYXJlbnQpLFxuICAgIH07XG59XG5leHBvcnRzLmNyZWF0ZUNoaWxkQ2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyO1xuY29uc3QgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzID0ge307XG5sZXQgZGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSBudWxsO1xuZnVuY3Rpb24gcmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKHR5cGVOYW1lLCBsb2FkQmFsYW5jZXJUeXBlLCBsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSkge1xuICAgIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0gPSB7XG4gICAgICAgIExvYWRCYWxhbmNlcjogbG9hZEJhbGFuY2VyVHlwZSxcbiAgICAgICAgTG9hZEJhbGFuY2luZ0NvbmZpZzogbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUsXG4gICAgfTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlID0gcmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlO1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSh0eXBlTmFtZSkge1xuICAgIGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gdHlwZU5hbWU7XG59XG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSByZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlO1xuZnVuY3Rpb24gY3JlYXRlTG9hZEJhbGFuY2VyKGNvbmZpZywgY2hhbm5lbENvbnRyb2xIZWxwZXIpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IGNvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCk7XG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2VyKGNoYW5uZWxDb250cm9sSGVscGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuY3JlYXRlTG9hZEJhbGFuY2VyID0gY3JlYXRlTG9hZEJhbGFuY2VyO1xuZnVuY3Rpb24gaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCh0eXBlTmFtZSkge1xuICAgIHJldHVybiB0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXM7XG59XG5leHBvcnRzLmlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQgPSBpc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkO1xuZnVuY3Rpb24gZ2V0Rmlyc3RVc2FibGVDb25maWcoY29uZmlncywgZmFsbGJhY2tUb2RlZmF1bHQgPSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCkgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmYWxsYmFja1RvZGVmYXVsdCkge1xuICAgICAgICBpZiAoZGVmYXVsdExvYWRCYWxhbmNlclR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW2RlZmF1bHRMb2FkQmFsYW5jZXJUeXBlXS5Mb2FkQmFsYW5jaW5nQ29uZmlnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGaXJzdFVzYWJsZUNvbmZpZyA9IGdldEZpcnN0VXNhYmxlQ29uZmlnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIHZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyhvYmopIHtcbiAgICBpZiAoIShvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTG9hZCBiYWxhbmNpbmcgY29uZmlnIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBoYXMgbXVsdGlwbGUgY29uZmxpY3RpbmcgZW50cmllcycpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlTmFtZSA9IGtleXNbMF07XG4gICAgaWYgKHR5cGVOYW1lIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzW3R5cGVOYW1lXS5Mb2FkQmFsYW5jaW5nQ29uZmlnLmNyZWF0ZUZyb21Kc29uKG9ialt0eXBlTmFtZV0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgbG9hZCBiYWxhbmNpbmcgY29uZmlnIG5hbWUgJHt0eXBlTmFtZX1gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyA9IHZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst TRACER_NAME = 'load_balancing_call';\nclass LoadBalancingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {\n        var _a, _b;\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.metadata = null;\n        this.listener = null;\n        this.onCallEnded = null;\n        const splitPath = this.methodName.split('/');\n        let serviceName = '';\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */\n        if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */\n        this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    outputStatus(status, progress) {\n        var _a, _b;\n        if (!this.ended) {\n            this.ended = true;\n            this.trace('ended with status: code=' +\n                status.code +\n                ' details=\"' +\n                status.details +\n                '\"');\n            const finalStatus = Object.assign(Object.assign({}, status), { progress });\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n            (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\n        }\n    }\n    doPick() {\n        var _a, _b;\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata) {\n            throw new Error('doPick called before start');\n        }\n        this.trace('Pick called');\n        const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n        const subchannelString = pickResult.subchannel\n            ? '(' +\n                pickResult.subchannel.getChannelzRef().id +\n                ') ' +\n                pickResult.subchannel.getAddress()\n            : '' + pickResult.subchannel;\n        this.trace('Pick result: ' +\n            picker_1.PickResultType[pickResult.pickResultType] +\n            ' subchannel: ' +\n            subchannelString +\n            ' status: ' +\n            ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) +\n            ' ' +\n            ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch (pickResult.pickResultType) {\n            case picker_1.PickResultType.COMPLETE:\n                this.credentials\n                    .generateMetadata({ service_url: this.serviceUrl })\n                    .then(credsMetadata => {\n                    var _a, _b, _c;\n                    /* If this call was cancelled (e.g. by the deadline) before\n                     * metadata generation finished, we shouldn't do anything with\n                     * it. */\n                    if (this.ended) {\n                        this.trace('Credentials metadata generation finished after call ended');\n                        return;\n                    }\n                    const finalMetadata = this.metadata.clone();\n                    finalMetadata.merge(credsMetadata);\n                    if (finalMetadata.get('authorization').length > 1) {\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: '\"authorization\" metadata cannot have multiple values',\n                            metadata: new metadata_1.Metadata(),\n                        }, 'PROCESSED');\n                    }\n                    if (pickResult.subchannel.getConnectivityState() !==\n                        connectivity_state_1.ConnectivityState.READY) {\n                        this.trace('Picked subchannel ' +\n                            subchannelString +\n                            ' has state ' +\n                            connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] +\n                            ' after getting credentials metadata. Retrying pick');\n                        this.doPick();\n                        return;\n                    }\n                    if (this.deadline !== Infinity) {\n                        finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n                    }\n                    try {\n                        this.child = pickResult\n                            .subchannel.getRealSubchannel()\n                            .createCall(finalMetadata, this.host, this.methodName, {\n                            onReceiveMetadata: metadata => {\n                                this.trace('Received metadata');\n                                this.listener.onReceiveMetadata(metadata);\n                            },\n                            onReceiveMessage: message => {\n                                this.trace('Received message');\n                                this.listener.onReceiveMessage(message);\n                            },\n                            onReceiveStatus: status => {\n                                this.trace('Received status');\n                                if (status.rstCode ===\n                                    http2.constants.NGHTTP2_REFUSED_STREAM) {\n                                    this.outputStatus(status, 'REFUSED');\n                                }\n                                else {\n                                    this.outputStatus(status, 'PROCESSED');\n                                }\n                            },\n                        });\n                    }\n                    catch (error) {\n                        this.trace('Failed to start call on picked subchannel ' +\n                            subchannelString +\n                            ' with error ' +\n                            error.message);\n                        this.outputStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: 'Failed to start HTTP/2 stream with error ' +\n                                error.message,\n                            metadata: new metadata_1.Metadata(),\n                        }, 'NOT_STARTED');\n                        return;\n                    }\n                    (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                    this.onCallEnded = pickResult.onCallEnded;\n                    this.trace('Created child call [' + this.child.getCallNumber() + ']');\n                    if (this.readPending) {\n                        this.child.startRead();\n                    }\n                    if (this.pendingMessage) {\n                        this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n                    }\n                    if (this.pendingHalfClose) {\n                        this.child.halfClose();\n                    }\n                }, (error) => {\n                    // We assume the error code isn't 0 (Status.OK)\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                    this.outputStatus({\n                        code: code,\n                        details: details,\n                        metadata: new metadata_1.Metadata(),\n                    }, 'PROCESSED');\n                });\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                setImmediate(() => {\n                    this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'DROP');\n                });\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (this.metadata.getOptions().waitForReady) {\n                    this.channel.queueCallForPick(this);\n                }\n                else {\n                    const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n                    setImmediate(() => {\n                        this.outputStatus({ code, details, metadata: pickResult.status.metadata }, 'PROCESSED');\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.channel.queueCallForPick(this);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({ code: status, details: details, metadata: new metadata_1.Metadata() }, 'PROCESSED');\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.listener = listener;\n        this.metadata = metadata;\n        this.doPick();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        if (this.child) {\n            this.child.sendMessageWithContext(context, message);\n        }\n        else {\n            this.pendingMessage = { context, message };\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        if (this.child) {\n            this.child.startRead();\n        }\n        else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        if (this.child) {\n            this.child.halfClose();\n        }\n        else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        throw new Error('Method not implemented.');\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.LoadBalancingCall = LoadBalancingCall;\n//# sourceMappingURL=load-balancing-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6Qiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsb0dBQXdCO0FBQy9ELGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWSxFQUFFLFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTLEdBQUcsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDRCQUE0QixnQkFBZ0IsMExBQTBMLGNBQWM7QUFDcFA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0Esd0NBQXdDLHFEQUFxRDtBQUM3RixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBLDRDQUE0QyxxREFBcUQ7QUFDakcscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFFQUFxRTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNpbmctY2FsbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2FkQmFsYW5jaW5nQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBkZWFkbGluZV8xID0gcmVxdWlyZShcIi4vZGVhZGxpbmVcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEgPSByZXF1aXJlKFwiLi9jb250cm9sLXBsYW5lLXN0YXR1c1wiKTtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnbG9hZF9iYWxhbmNpbmdfY2FsbCc7XG5jbGFzcyBMb2FkQmFsYW5jaW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbENvbmZpZywgbWV0aG9kTmFtZSwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuY2FsbENvbmZpZyA9IGNhbGxDb25maWc7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IGRlYWRsaW5lO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQ2FsbEVuZGVkID0gbnVsbDtcbiAgICAgICAgY29uc3Qgc3BsaXRQYXRoID0gdGhpcy5tZXRob2ROYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIGxldCBzZXJ2aWNlTmFtZSA9ICcnO1xuICAgICAgICAvKiBUaGUgc3RhbmRhcmQgcGF0aCBmb3JtYXQgaXMgXCIve3NlcnZpY2VOYW1lfS97bWV0aG9kTmFtZX1cIiwgc28gaWYgd2Ugc3BsaXRcbiAgICAgICAgICogYnkgJy8nLCB0aGUgZmlyc3QgaXRlbSBzaG91bGQgYmUgZW1wdHkgYW5kIHRoZSBzZWNvbmQgc2hvdWxkIGJlIHRoZVxuICAgICAgICAgKiBzZXJ2aWNlIG5hbWUgKi9cbiAgICAgICAgaWYgKHNwbGl0UGF0aC5sZW5ndGggPj0gMikge1xuICAgICAgICAgICAgc2VydmljZU5hbWUgPSBzcGxpdFBhdGhbMV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSAoX2IgPSAoX2EgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRoaXMuaG9zdCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnbG9jYWxob3N0JztcbiAgICAgICAgLyogQ3VycmVudGx5LCBjYWxsIGNyZWRlbnRpYWxzIGFyZSBvbmx5IGFsbG93ZWQgb24gSFRUUFMgY29ubmVjdGlvbnMsIHNvIHdlXG4gICAgICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgc2NoZW1lIGlzIFwiaHR0cHNcIiAqL1xuICAgICAgICB0aGlzLnNlcnZpY2VVcmwgPSBgaHR0cHM6Ly8ke2hvc3RuYW1lfS8ke3NlcnZpY2VOYW1lfWA7XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIG91dHB1dFN0YXR1cyhzdGF0dXMsIHByb2dyZXNzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5lbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICBzdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgY29uc3QgZmluYWxTdGF0dXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXR1cyksIHsgcHJvZ3Jlc3MgfSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25SZWNlaXZlU3RhdHVzKGZpbmFsU3RhdHVzKTtcbiAgICAgICAgICAgIChfYiA9IHRoaXMub25DYWxsRW5kZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKHRoaXMsIGZpbmFsU3RhdHVzLmNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvUGljaygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9QaWNrIGNhbGxlZCBiZWZvcmUgc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdQaWNrIGNhbGxlZCcpO1xuICAgICAgICBjb25zdCBwaWNrUmVzdWx0ID0gdGhpcy5jaGFubmVsLmRvUGljayh0aGlzLm1ldGFkYXRhLCB0aGlzLmNhbGxDb25maWcucGlja0luZm9ybWF0aW9uKTtcbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFN0cmluZyA9IHBpY2tSZXN1bHQuc3ViY2hhbm5lbFxuICAgICAgICAgICAgPyAnKCcgK1xuICAgICAgICAgICAgICAgIHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpLmlkICtcbiAgICAgICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgICAgICBwaWNrUmVzdWx0LnN1YmNoYW5uZWwuZ2V0QWRkcmVzcygpXG4gICAgICAgICAgICA6ICcnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsO1xuICAgICAgICB0aGlzLnRyYWNlKCdQaWNrIHJlc3VsdDogJyArXG4gICAgICAgICAgICBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZVtwaWNrUmVzdWx0LnBpY2tSZXN1bHRUeXBlXSArXG4gICAgICAgICAgICAnIHN1YmNoYW5uZWw6ICcgK1xuICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAnIHN0YXR1czogJyArXG4gICAgICAgICAgICAoKF9hID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgKChfYiA9IHBpY2tSZXN1bHQuc3RhdHVzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGV0YWlscykpO1xuICAgICAgICBzd2l0Y2ggKHBpY2tSZXN1bHQucGlja1Jlc3VsdFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEU6XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVkZW50aWFsc1xuICAgICAgICAgICAgICAgICAgICAuZ2VuZXJhdGVNZXRhZGF0YSh7IHNlcnZpY2VfdXJsOiB0aGlzLnNlcnZpY2VVcmwgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oY3JlZHNNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGlzIGNhbGwgd2FzIGNhbmNlbGxlZCAoZS5nLiBieSB0aGUgZGVhZGxpbmUpIGJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgKiBtZXRhZGF0YSBnZW5lcmF0aW9uIGZpbmlzaGVkLCB3ZSBzaG91bGRuJ3QgZG8gYW55dGhpbmcgd2l0aFxuICAgICAgICAgICAgICAgICAgICAgKiBpdC4gKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0NyZWRlbnRpYWxzIG1ldGFkYXRhIGdlbmVyYXRpb24gZmluaXNoZWQgYWZ0ZXIgY2FsbCBlbmRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWV0YWRhdGEubWVyZ2UoY3JlZHNNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbE1ldGFkYXRhLmdldCgnYXV0aG9yaXphdGlvbicpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ1wiYXV0aG9yaXphdGlvblwiIG1ldGFkYXRhIGNhbm5vdCBoYXZlIG11bHRpcGxlIHZhbHVlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1BpY2tlZCBzdWJjaGFubmVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaGFzIHN0YXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3BpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpXSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBhZnRlciBnZXR0aW5nIGNyZWRlbnRpYWxzIG1ldGFkYXRhLiBSZXRyeWluZyBwaWNrJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUGljaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYWRsaW5lICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxNZXRhZGF0YS5zZXQoJ2dycGMtdGltZW91dCcsICgwLCBkZWFkbGluZV8xLmdldERlYWRsaW5lVGltZW91dFN0cmluZykodGhpcy5kZWFkbGluZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gcGlja1Jlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJjaGFubmVsLmdldFJlYWxTdWJjaGFubmVsKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3JlYXRlQ2FsbChmaW5hbE1ldGFkYXRhLCB0aGlzLmhvc3QsIHRoaXMubWV0aG9kTmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1ldGFkYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogbWVzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiBzdGF0dXMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBzdGF0dXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5yc3RDb2RlID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfUkVGVVNFRF9TVFJFQU0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cywgJ1JFRlVTRUQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHN0YXR1cywgJ1BST0NFU1NFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIHN0YXJ0IGNhbGwgb24gcGlja2VkIHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnRmFpbGVkIHRvIHN0YXJ0IEhUVFAvMiBzdHJlYW0gd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sICdOT1RfU1RBUlRFRCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbENvbmZpZykub25Db21taXR0ZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICAgICAgKF9jID0gcGlja1Jlc3VsdC5vbkNhbGxTdGFydGVkKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChwaWNrUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNhbGxFbmRlZCA9IHBpY2tSZXN1bHQub25DYWxsRW5kZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0NyZWF0ZWQgY2hpbGQgY2FsbCBbJyArIHRoaXMuY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh0aGlzLnBlbmRpbmdNZXNzYWdlLmNvbnRleHQsIHRoaXMucGVuZGluZ01lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhlIGVycm9yIGNvZGUgaXNuJ3QgMCAoU3RhdHVzLk9LKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkodHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInID8gZXJyb3IuY29kZSA6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLCBgR2V0dGluZyBtZXRhZGF0YSBmcm9tIHBsdWdpbiBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZGV0YWlscyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkRST1A6XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSAoMCwgY29udHJvbF9wbGFuZV9zdGF0dXNfMS5yZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUpKHBpY2tSZXN1bHQuc3RhdHVzLmNvZGUsIHBpY2tSZXN1bHQuc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGE6IHBpY2tSZXN1bHQuc3RhdHVzLm1ldGFkYXRhIH0sICdEUk9QJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvclBpY2sodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvZGUsIGRldGFpbHMgfSA9ICgwLCBjb250cm9sX3BsYW5lX3N0YXR1c18xLnJlc3RyaWN0Q29udHJvbFBsYW5lU3RhdHVzQ29kZSkocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7IGNvZGUsIGRldGFpbHMsIG1ldGFkYXRhOiBwaWNrUmVzdWx0LnN0YXR1cy5tZXRhZGF0YSB9LCAnUFJPQ0VTU0VEJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuUVVFVUU6XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVsLnF1ZXVlQ2FsbEZvclBpY2sodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgKF9hID0gdGhpcy5jaGlsZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoeyBjb2RlOiBzdGF0dXMsIGRldGFpbHM6IGRldGFpbHMsIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpIH0sICdQUk9DRVNTRUQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgc3RhcnQobWV0YWRhdGEsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5kb1BpY2soKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSB7IGNvbnRleHQsIG1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0UmVhZCBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnRSZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2hhbGZDbG9zZSBjYWxsZWQnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9XG4gICAgZ2V0Q2FsbE51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbE51bWJlcjtcbiAgICB9XG59XG5leHBvcnRzLkxvYWRCYWxhbmNpbmdDYWxsID0gTG9hZEJhbGFuY2luZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2luZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancing-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nvar _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst process_1 = __webpack_require__(/*! process */ \"process\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams) => {\n        console.error('E ' + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams) => {\n        console.error('I ' + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams) => {\n        console.error('D ' + message, ...optionalParams);\n    },\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : '';\nswitch (verbosityString.toUpperCase()) {\n    case 'DEBUG':\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case 'INFO':\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case 'ERROR':\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case 'NONE':\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n    // Ignore any other values\n}\nconst getLogger = () => {\n    return _logger;\n};\nexports.getLogger = getLogger;\nconst setLogger = (logger) => {\n    _logger = logger;\n};\nexports.setLogger = setLogger;\nconst setLoggerVerbosity = (verbosity) => {\n    _logVerbosity = verbosity;\n};\nexports.setLoggerVerbosity = setLoggerVerbosity;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst log = (severity, ...args) => {\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch (severity) {\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */\n        if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nexports.log = log;\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : '';\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(',')) {\n    if (tracerName.startsWith('-')) {\n        disabledTracers.add(tracerName.substring(1));\n    }\n    else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has('all');\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        (0, exports.log)(severity, new Date().toISOString() + ' | v' + clientVersion + ' ' + process_1.pid + ' | ' + tracer + ' | ' + text);\n    }\n}\nexports.trace = trace;\nfunction isTracerEnabled(tracer) {\n    return (!disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer)));\n}\nexports.isTracerEnabled = isTracerEnabled;\n//# sourceMappingURL=logging.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRywwQkFBMEIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDMUgsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMsd0JBQVM7QUFDbkMsc0JBQXNCLDBHQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xudmFyIF9hLCBfYiwgX2MsIF9kO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1RyYWNlckVuYWJsZWQgPSBleHBvcnRzLnRyYWNlID0gZXhwb3J0cy5sb2cgPSBleHBvcnRzLnNldExvZ2dlclZlcmJvc2l0eSA9IGV4cG9ydHMuc2V0TG9nZ2VyID0gZXhwb3J0cy5nZXRMb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHByb2Nlc3NfMSA9IHJlcXVpcmUoXCJwcm9jZXNzXCIpO1xuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG5jb25zdCBERUZBVUxUX0xPR0dFUiA9IHtcbiAgICBlcnJvcjogKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0UgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICB9LFxuICAgIGluZm86IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdJICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbiAgICBkZWJ1ZzogKG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0QgJyArIG1lc3NhZ2UsIC4uLm9wdGlvbmFsUGFyYW1zKTtcbiAgICB9LFxufTtcbmxldCBfbG9nZ2VyID0gREVGQVVMVF9MT0dHRVI7XG5sZXQgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjtcbmNvbnN0IHZlcmJvc2l0eVN0cmluZyA9IChfYiA9IChfYSA9IHByb2Nlc3MuZW52LkdSUENfTk9ERV9WRVJCT1NJVFkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHByb2Nlc3MuZW52LkdSUENfVkVSQk9TSVRZKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbnN3aXRjaCAodmVyYm9zaXR5U3RyaW5nLnRvVXBwZXJDYXNlKCkpIHtcbiAgICBjYXNlICdERUJVRyc6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUc7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0lORk8nOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk87XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0VSUk9SJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUjtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnTk9ORSc6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuTk9ORTtcbiAgICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAvLyBJZ25vcmUgYW55IG90aGVyIHZhbHVlc1xufVxuY29uc3QgZ2V0TG9nZ2VyID0gKCkgPT4ge1xuICAgIHJldHVybiBfbG9nZ2VyO1xufTtcbmV4cG9ydHMuZ2V0TG9nZ2VyID0gZ2V0TG9nZ2VyO1xuY29uc3Qgc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICAgIF9sb2dnZXIgPSBsb2dnZXI7XG59O1xuZXhwb3J0cy5zZXRMb2dnZXIgPSBzZXRMb2dnZXI7XG5jb25zdCBzZXRMb2dnZXJWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XG4gICAgX2xvZ1ZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbn07XG5leHBvcnRzLnNldExvZ2dlclZlcmJvc2l0eSA9IHNldExvZ2dlclZlcmJvc2l0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBsb2cgPSAoc2V2ZXJpdHksIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgbG9nRnVuY3Rpb247XG4gICAgaWYgKHNldmVyaXR5ID49IF9sb2dWZXJib3NpdHkpIHtcbiAgICAgICAgc3dpdGNoIChzZXZlcml0eSkge1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUc6XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmRlYnVnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTzpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuaW5mbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBGYWxsIGJhY2sgdG8gX2xvZ2dlci5lcnJvciB3aGVuIG90aGVyIG1ldGhvZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yXG4gICAgICAgICAqIGNvbXBhdGlibGl0eSB3aXRoIG9sZGVyIGJlaGF2aW9yIHRoYXQgYWx3YXlzIGxvZ2dlZCB0byBfbG9nZ2VyLmVycm9yICovXG4gICAgICAgIGlmICghbG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uLmJpbmQoX2xvZ2dlcikoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5jb25zdCB0cmFjZXJzU3RyaW5nID0gKF9kID0gKF9jID0gcHJvY2Vzcy5lbnYuR1JQQ19OT0RFX1RSQUNFKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBwcm9jZXNzLmVudi5HUlBDX1RSQUNFKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAnJztcbmNvbnN0IGVuYWJsZWRUcmFjZXJzID0gbmV3IFNldCgpO1xuY29uc3QgZGlzYWJsZWRUcmFjZXJzID0gbmV3IFNldCgpO1xuZm9yIChjb25zdCB0cmFjZXJOYW1lIG9mIHRyYWNlcnNTdHJpbmcuc3BsaXQoJywnKSkge1xuICAgIGlmICh0cmFjZXJOYW1lLnN0YXJ0c1dpdGgoJy0nKSkge1xuICAgICAgICBkaXNhYmxlZFRyYWNlcnMuYWRkKHRyYWNlck5hbWUuc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuYWJsZWRUcmFjZXJzLmFkZCh0cmFjZXJOYW1lKTtcbiAgICB9XG59XG5jb25zdCBhbGxFbmFibGVkID0gZW5hYmxlZFRyYWNlcnMuaGFzKCdhbGwnKTtcbmZ1bmN0aW9uIHRyYWNlKHNldmVyaXR5LCB0cmFjZXIsIHRleHQpIHtcbiAgICBpZiAoaXNUcmFjZXJFbmFibGVkKHRyYWNlcikpIHtcbiAgICAgICAgKDAsIGV4cG9ydHMubG9nKShzZXZlcml0eSwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyB8IHYnICsgY2xpZW50VmVyc2lvbiArICcgJyArIHByb2Nlc3NfMS5waWQgKyAnIHwgJyArIHRyYWNlciArICcgfCAnICsgdGV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy50cmFjZSA9IHRyYWNlO1xuZnVuY3Rpb24gaXNUcmFjZXJFbmFibGVkKHRyYWNlcikge1xuICAgIHJldHVybiAoIWRpc2FibGVkVHJhY2Vycy5oYXModHJhY2VyKSAmJiAoYWxsRW5hYmxlZCB8fCBlbmFibGVkVHJhY2Vycy5oYXModHJhY2VyKSkpO1xufVxuZXhwb3J0cy5pc1RyYWNlckVuYWJsZWQgPSBpc1RyYWNlckVuYWJsZWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnaW5nLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\nconst requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest,\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */\nfunction isPrototypePolluted(key) {\n    return ['__proto__', 'prototype', 'constructor'].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach(name => {\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === 'string' && name.charAt(0) === '$') {\n            throw new Error('Method names cannot start with $');\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = 'bidi';\n            }\n            else {\n                methodType = 'client_stream';\n            }\n        }\n        else {\n            if (attrs.responseStream) {\n                methodType = 'server_stream';\n            }\n            else {\n                methodType = 'unary';\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] =\n                ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function (...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return 'format' in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\nfunction loadPackageDefinition(packageDef) {\n    const result = {};\n    for (const serviceFqn in packageDef) {\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split('.');\n            if (nameComponents.some((comp) => isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)) {\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            }\n            else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition;\n//# sourceMappingURL=make-client.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw2QkFBNkI7QUFDN0QsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrQkFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tYWtlLWNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2FkUGFja2FnZURlZmluaXRpb24gPSBleHBvcnRzLm1ha2VDbGllbnRDb25zdHJ1Y3RvciA9IHZvaWQgMDtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuLyoqXG4gKiBNYXAgd2l0aCBzaG9ydCBuYW1lcyBmb3IgZWFjaCBvZiB0aGUgcmVxdWVzdGVyIG1ha2VyIGZ1bmN0aW9ucy4gVXNlZCBpblxuICogbWFrZUNsaWVudENvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCByZXF1ZXN0ZXJGdW5jcyA9IHtcbiAgICB1bmFyeTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlVW5hcnlSZXF1ZXN0LFxuICAgIHNlcnZlcl9zdHJlYW06IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZVNlcnZlclN0cmVhbVJlcXVlc3QsXG4gICAgY2xpZW50X3N0cmVhbTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlQ2xpZW50U3RyZWFtUmVxdWVzdCxcbiAgICBiaWRpOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VCaWRpU3RyZWFtUmVxdWVzdCxcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSwgaWYgZ2l2ZW4ga2V5IGlzIGluY2x1ZGVkIGluIHRoZSBibGFja2xpc3RlZFxuICoga2V5cy5cbiAqIEBwYXJhbSBrZXkga2V5IGZvciBjaGVjaywgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZVBvbGx1dGVkKGtleSkge1xuICAgIHJldHVybiBbJ19fcHJvdG9fXycsICdwcm90b3R5cGUnLCAnY29uc3RydWN0b3InXS5pbmNsdWRlcyhrZXkpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgY29uc3RydWN0b3IgZm9yIGEgY2xpZW50IHdpdGggdGhlIGdpdmVuIG1ldGhvZHMsIGFzIHNwZWNpZmllZCBpblxuICogdGhlIG1ldGhvZHMgYXJndW1lbnQuIFRoZSByZXN1bHRpbmcgY2xhc3Mgd2lsbCBoYXZlIGFuIGluc3RhbmNlIG1ldGhvZCBmb3JcbiAqIGVhY2ggbWV0aG9kIGluIHRoZSBzZXJ2aWNlLCB3aGljaCBpcyBhIHBhcnRpYWwgYXBwbGljYXRpb24gb2Ygb25lIG9mIHRoZVxuICogW0NsaWVudF17QGxpbmsgZ3JwYy5DbGllbnR9IHJlcXVlc3QgbWV0aG9kcywgZGVwZW5kaW5nIG9uIGByZXF1ZXN0U2VyaWFsaXplYFxuICogYW5kIGByZXNwb25zZVNlcmlhbGl6ZWAsIHdpdGggdGhlIGBtZXRob2RgLCBgc2VyaWFsaXplYCwgYW5kIGBkZXNlcmlhbGl6ZWBcbiAqIGFyZ3VtZW50cyBwcmVkZWZpbmVkLlxuICogQHBhcmFtIG1ldGhvZHMgQW4gb2JqZWN0IG1hcHBpbmcgbWV0aG9kIG5hbWVzIHRvXG4gKiAgICAgbWV0aG9kIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSBzZXJ2aWNlTmFtZSBUaGUgZnVsbHkgcXVhbGlmaWVkIG5hbWUgb2YgdGhlIHNlcnZpY2VcbiAqIEBwYXJhbSBjbGFzc09wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuXG4gKiBAcmV0dXJuIE5ldyBjbGllbnQgY29uc3RydWN0b3IsIHdoaWNoIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqICAgICB7QGxpbmsgZ3JwYy5DbGllbnR9LCBhbmQgaGFzIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyB0aGF0IGNvbnN0cnVjdG9yLlxuICovXG5mdW5jdGlvbiBtYWtlQ2xpZW50Q29uc3RydWN0b3IobWV0aG9kcywgc2VydmljZU5hbWUsIGNsYXNzT3B0aW9ucykge1xuICAgIGlmICghY2xhc3NPcHRpb25zKSB7XG4gICAgICAgIGNsYXNzT3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjbGFzcyBTZXJ2aWNlQ2xpZW50SW1wbCBleHRlbmRzIGNsaWVudF8xLkNsaWVudCB7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG1ldGhvZHMpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgIGlmIChpc1Byb3RvdHlwZVBvbGx1dGVkKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cnMgPSBtZXRob2RzW25hbWVdO1xuICAgICAgICBsZXQgbWV0aG9kVHlwZTtcbiAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBWZXJpZnkgdGhhdCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWUuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoICQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMucmVxdWVzdFN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50X3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3NlcnZlcl9zdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICd1bmFyeSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplID0gYXR0cnMucmVxdWVzdFNlcmlhbGl6ZTtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemUgPSBhdHRycy5yZXNwb25zZURlc2VyaWFsaXplO1xuICAgICAgICBjb25zdCBtZXRob2RGdW5jID0gcGFydGlhbChyZXF1ZXN0ZXJGdW5jc1ttZXRob2RUeXBlXSwgYXR0cnMucGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSk7XG4gICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZEZ1bmM7XG4gICAgICAgIC8vIEFzc29jaWF0ZSBhbGwgcHJvdmlkZWQgYXR0cmlidXRlcyB3aXRoIHRoZSBtZXRob2RcbiAgICAgICAgT2JqZWN0LmFzc2lnbihTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0sIGF0dHJzKTtcbiAgICAgICAgaWYgKGF0dHJzLm9yaWdpbmFsTmFtZSAmJiAhaXNQcm90b3R5cGVQb2xsdXRlZChhdHRycy5vcmlnaW5hbE5hbWUpKSB7XG4gICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbYXR0cnMub3JpZ2luYWxOYW1lXSA9XG4gICAgICAgICAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgU2VydmljZUNsaWVudEltcGwuc2VydmljZSA9IG1ldGhvZHM7XG4gICAgU2VydmljZUNsaWVudEltcGwuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICByZXR1cm4gU2VydmljZUNsaWVudEltcGw7XG59XG5leHBvcnRzLm1ha2VDbGllbnRDb25zdHJ1Y3RvciA9IG1ha2VDbGllbnRDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHBhcnRpYWwoZm4sIHBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBwYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKG9iaikge1xuICAgIHJldHVybiAnZm9ybWF0JyBpbiBvYmo7XG59XG4vKipcbiAqIExvYWQgYSBnUlBDIHBhY2thZ2UgZGVmaW5pdGlvbiBhcyBhIGdSUEMgb2JqZWN0IGhpZXJhcmNoeS5cbiAqIEBwYXJhbSBwYWNrYWdlRGVmIFRoZSBwYWNrYWdlIGRlZmluaXRpb24gb2JqZWN0LlxuICogQHJldHVybiBUaGUgcmVzdWx0aW5nIGdSUEMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBsb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qgc2VydmljZUZxbiBpbiBwYWNrYWdlRGVmKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFja2FnZURlZiwgc2VydmljZUZxbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwYWNrYWdlRGVmW3NlcnZpY2VGcW5dO1xuICAgICAgICAgICAgY29uc3QgbmFtZUNvbXBvbmVudHMgPSBzZXJ2aWNlRnFuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBpZiAobmFtZUNvbXBvbmVudHMuc29tZSgoY29tcCkgPT4gaXNQcm90b3R5cGVQb2xsdXRlZChjb21wKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VOYW1lID0gbmFtZUNvbXBvbmVudHNbbmFtZUNvbXBvbmVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHJlc3VsdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFja2FnZU5hbWUgb2YgbmFtZUNvbXBvbmVudHMuc2xpY2UoMCwgLTEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3BhY2thZ2VOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50W3BhY2thZ2VOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYWNrYWdlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKHNlcnZpY2UpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBzZXJ2aWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBtYWtlQ2xpZW50Q29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5sb2FkUGFja2FnZURlZmluaXRpb24gPSBsb2FkUGFja2FnZURlZmluaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith('-bin');\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith('grpc-');\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        }\n        else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */\nclass Metadata {\n    constructor(options = {}) {\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [value]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */\n    add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [value]);\n        }\n        else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */\n    remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */\n    get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */\n    getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */\n    clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr) {\n            const clonedValue = value.map(v => {\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                }\n                else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */\n    merge(other) {\n        for (const [key, values] of other.internalRepr) {\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */\n    toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */\n    toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr) {\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */\n    static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)) {\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === ':') {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach(value => {\n                            result.add(key, Buffer.from(value, 'base64'));\n                        });\n                    }\n                    else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(',').forEach(v => {\n                                result.add(key, Buffer.from(v.trim(), 'base64'));\n                            });\n                        }\n                        else {\n                            result.add(key, Buffer.from(values, 'base64'));\n                        }\n                    }\n                }\n                else {\n                    if (Array.isArray(values)) {\n                        values.forEach(value => {\n                            result.add(key, value);\n                        });\n                    }\n                    else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            }\n            catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val) => {\n    return Buffer.isBuffer(val) ? val.toString('base64') : val;\n};\n//# sourceMappingURL=metadata.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQVc7QUFDckMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsSUFBSSxJQUFJLE9BQU8sSUFBSSxvQ0FBb0M7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9tZXRhZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXRhZGF0YSA9IHZvaWQgMDtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmNvbnN0IExFR0FMX0tFWV9SRUdFWCA9IC9eWzAtOWEtel8uLV0rJC87XG5jb25zdCBMRUdBTF9OT05fQklOQVJZX1ZBTFVFX1JFR0VYID0gL15bIC1+XSokLztcbmZ1bmN0aW9uIGlzTGVnYWxLZXkoa2V5KSB7XG4gICAgcmV0dXJuIExFR0FMX0tFWV9SRUdFWC50ZXN0KGtleSk7XG59XG5mdW5jdGlvbiBpc0xlZ2FsTm9uQmluYXJ5VmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gTEVHQUxfTk9OX0JJTkFSWV9WQUxVRV9SRUdFWC50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGlzQmluYXJ5S2V5KGtleSkge1xuICAgIHJldHVybiBrZXkuZW5kc1dpdGgoJy1iaW4nKTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tTWV0YWRhdGEoa2V5KSB7XG4gICAgcmV0dXJuICFrZXkuc3RhcnRzV2l0aCgnZ3JwYy0nKTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKCFpc0xlZ2FsS2V5KGtleSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhZGF0YSBrZXkgXCInICsga2V5ICsgJ1wiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycycpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNCaW5hcnlLZXkoa2V5KSkge1xuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5cyB0aGF0IGVuZCB3aXRoICctYmluJyBtdXN0IGhhdmUgQnVmZmVyIHZhbHVlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwia2V5cyB0aGF0IGRvbid0IGVuZCB3aXRoICctYmluJyBtdXN0IGhhdmUgU3RyaW5nIHZhbHVlc1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNMZWdhbE5vbkJpbmFyeVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YWRhdGEgc3RyaW5nIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIGNsYXNzIGZvciBzdG9yaW5nIG1ldGFkYXRhLiBLZXlzIGFyZSBub3JtYWxpemVkIHRvIGxvd2VyY2FzZSBBU0NJSS5cbiAqL1xuY2xhc3MgTWV0YWRhdGEge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmludGVybmFsUmVwciA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkgYnkgcmVwbGFjaW5nIGFueSBvdGhlciB2YWx1ZXNcbiAgICAgKiBhc3NvY2lhdGVkIHdpdGggdGhhdCBrZXkuIE5vcm1hbGl6ZXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gd2hvc2UgdmFsdWUgc2hvdWxkIGJlIHNldC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC4gTXVzdCBiZSBhIGJ1ZmZlciBpZiBhbmQgb25seVxuICAgICAqICAgaWYgdGhlIG5vcm1hbGl6ZWQga2V5IGVuZHMgd2l0aCAnLWJpbicuXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG4gICAgICAgIHZhbGlkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBbdmFsdWVdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gdmFsdWUgZm9yIHRoZSBnaXZlbiBrZXkgYnkgYXBwZW5kaW5nIHRvIGEgbGlzdCBvZiBwcmV2aW91c1xuICAgICAqIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhhdCBrZXkuIE5vcm1hbGl6ZXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgZm9yIHdoaWNoIGEgbmV3IHZhbHVlIHNob3VsZCBiZSBhcHBlbmRlZC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC4gTXVzdCBiZSBhIGJ1ZmZlciBpZiBhbmQgb25seVxuICAgICAqICAgaWYgdGhlIG5vcm1hbGl6ZWQga2V5IGVuZHMgd2l0aCAnLWJpbicuXG4gICAgICovXG4gICAgYWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG4gICAgICAgIHZhbGlkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gdGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSk7XG4gICAgICAgIGlmIChleGlzdGluZ1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLnNldChrZXksIFt2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBrZXkgYW5kIGFueSBhc3NvY2lhdGVkIHZhbHVlcy4gTm9ybWFsaXplcyB0aGUga2V5LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB3aG9zZSB2YWx1ZXMgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgLy8gdmFsaWRhdGUoa2V5KTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGFsbCB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXkuIE5vcm1hbGl6ZXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgd2hvc2UgdmFsdWUgc2hvdWxkIGJlIHJldHJpZXZlZC5cbiAgICAgKiBAcmV0dXJuIEEgbGlzdCBvZiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBrZXkuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcbiAgICAgICAgLy8gdmFsaWRhdGUoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxSZXByLmdldChrZXkpIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcGxhaW4gb2JqZWN0IG1hcHBpbmcgZWFjaCBrZXkgdG8gdGhlIGZpcnN0IHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgKiBUaGlzIHJlZmxlY3RzIHRoZSBtb3N0IGNvbW1vbiB3YXkgdGhhdCBwZW9wbGUgd2lsbCB3YW50IHRvIHNlZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJuIEEga2V5L3ZhbHVlIG1hcHBpbmcgb2YgdGhlIG1ldGFkYXRhLlxuICAgICAqL1xuICAgIGdldE1hcCgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiB0aGlzLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IEJ1ZmZlci5pc0J1ZmZlcih2KSA/IEJ1ZmZlci5mcm9tKHYpIDogdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIG1ldGFkYXRhIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBuZXdseSBjbG9uZWQgb2JqZWN0LlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBuZXdNZXRhZGF0YSA9IG5ldyBNZXRhZGF0YSh0aGlzLm9wdGlvbnMpO1xuICAgICAgICBjb25zdCBuZXdJbnRlcm5hbFJlcHIgPSBuZXdNZXRhZGF0YS5pbnRlcm5hbFJlcHI7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWRWYWx1ZSA9IHZhbHVlLm1hcCh2ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3SW50ZXJuYWxSZXByLnNldChrZXksIGNsb25lZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3TWV0YWRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhbGwga2V5LXZhbHVlIHBhaXJzIGZyb20gYSBnaXZlbiBNZXRhZGF0YSBvYmplY3QgaW50byB0aGlzIG9uZS5cbiAgICAgKiBJZiBib3RoIHRoaXMgb2JqZWN0IGFuZCB0aGUgZ2l2ZW4gb2JqZWN0IGhhdmUgdmFsdWVzIGluIHRoZSBzYW1lIGtleSxcbiAgICAgKiB2YWx1ZXMgZnJvbSB0aGUgb3RoZXIgTWV0YWRhdGEgb2JqZWN0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpcyBvYmplY3Qnc1xuICAgICAqIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gb3RoZXIgQSBNZXRhZGF0YSBvYmplY3QuXG4gICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIG90aGVyLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkVmFsdWUgPSAodGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW10pLmNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgbWVyZ2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE91dGdvaW5nSHR0cEhlYWRlcnMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgaHR0cDIgQVBJLlxuICAgICAqL1xuICAgIHRvSHR0cDJIZWFkZXJzKCkge1xuICAgICAgICAvLyBOT1RFOiBOb2RlIDw4LjkgZm9ybWF0cyBodHRwMiBoZWFkZXJzIGluY29ycmVjdGx5LlxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCB0aGUgdXNlcidzIGludGVyYWN0aW9uIHdpdGggdGhpcyBvYmplY3QgaXMgbGltaXRlZCB0b1xuICAgICAgICAgICAgLy8gdGhyb3VnaCBpdHMgcHVibGljIEFQSSAoaS5lLiBrZXlzIGFuZCB2YWx1ZXMgYXJlIGFscmVhZHkgdmFsaWRhdGVkKS5cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzLm1hcChidWZUb1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtb2RpZmllcyB0aGUgYmVoYXZpb3Igb2YgSlNPTi5zdHJpbmdpZnkgdG8gc2hvdyBhbiBvYmplY3RcbiAgICAgKiByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWV0YWRhdGEgbWFwLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVzXSBvZiB0aGlzLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBNZXRhZGF0YSBvYmplY3QgYmFzZWQgZmllbGRzIGluIGEgZ2l2ZW4gSW5jb21pbmdIdHRwSGVhZGVyc1xuICAgICAqIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gaGVhZGVycyBBbiBJbmNvbWluZ0h0dHBIZWFkZXJzIG9iamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNZXRhZGF0YSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgLy8gUmVzZXJ2ZWQgaGVhZGVycyAoYmVnaW5uaW5nIHdpdGggYDpgKSBhcmUgbm90IHZhbGlkIGtleXMuXG4gICAgICAgICAgICBpZiAoa2V5LmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBoZWFkZXJzW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpc0JpbmFyeUtleShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tTWV0YWRhdGEoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zcGxpdCgnLCcpLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2LnRyaW0oKSwgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCBCdWZmZXIuZnJvbSh2YWx1ZXMsICdiYXNlNjQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGQoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBGYWlsZWQgdG8gYWRkIG1ldGFkYXRhIGVudHJ5ICR7a2V5fTogJHt2YWx1ZXN9LiAkeygwLCBlcnJvcl8xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IpfS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMtbm9kZS9pc3N1ZXMvMTE3M2A7XG4gICAgICAgICAgICAgICAgKDAsIGxvZ2dpbmdfMS5sb2cpKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XG5jb25zdCBidWZUb1N0cmluZyA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKHZhbCkgPyB2YWwudG9TdHJpbmcoJ2Jhc2U2NCcpIDogdmFsO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function (PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType || (exports.PickResultType = PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */\nclass UnavailablePicker {\n    constructor(status) {\n        this.status = Object.assign({ code: constants_1.Status.UNAVAILABLE, details: 'No connection established', metadata: new metadata_1.Metadata() }, status);\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */\nclass QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer) {\n        this.loadBalancer = loadBalancer;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(() => {\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        return {\n            pickResultType: PickResultType.QUEUE,\n            subchannel: null,\n            status: null,\n            onCallStarted: null,\n            onCallEnded: null,\n        };\n    }\n}\nexports.QueuePicker = QueuePicker;\n//# sourceMappingURL=picker.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLEdBQUcseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ3hFLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlIQUFpSDtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlF1ZXVlUGlja2VyID0gZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbnZhciBQaWNrUmVzdWx0VHlwZTtcbihmdW5jdGlvbiAoUGlja1Jlc3VsdFR5cGUpIHtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkNPTVBMRVRFXCJdID0gMF0gPSBcIkNPTVBMRVRFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJRVUVVRVwiXSA9IDFdID0gXCJRVUVVRVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiVFJBTlNJRU5UX0ZBSUxVUkVcIl0gPSAyXSA9IFwiVFJBTlNJRU5UX0ZBSUxVUkVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIkRST1BcIl0gPSAzXSA9IFwiRFJPUFwiO1xufSkoUGlja1Jlc3VsdFR5cGUgfHwgKGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSBQaWNrUmVzdWx0VHlwZSA9IHt9KSk7XG4vKipcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIFRSQU5TSUVOVF9GQUlMVVJFXG4gKiBzdGF0ZS4gQWx3YXlzIHJlc3BvbmRzIHRvIGV2ZXJ5IHBpY2sgcmVxdWVzdCB3aXRoIGFuIFVOQVZBSUxBQkxFIHN0YXR1cy5cbiAqL1xuY2xhc3MgVW5hdmFpbGFibGVQaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0YXR1cykge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IE9iamVjdC5hc3NpZ24oeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsIGRldGFpbHM6ICdObyBjb25uZWN0aW9uIGVzdGFibGlzaGVkJywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSwgc3RhdHVzKTtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFLFxuICAgICAgICAgICAgc3ViY2hhbm5lbDogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5VbmF2YWlsYWJsZVBpY2tlciA9IFVuYXZhaWxhYmxlUGlja2VyO1xuLyoqXG4gKiBBIHN0YW5kYXJkIHBpY2tlciByZXByZXNlbnRpbmcgYSBsb2FkIGJhbGFuY2VyIGluIHRoZSBJRExFIG9yIENPTk5FQ1RJTkdcbiAqIHN0YXRlLiBBbHdheXMgcmVzcG9uZHMgdG8gZXZlcnkgcGljayByZXF1ZXN0IHdpdGggYSBRVUVVRSBwaWNrIHJlc3VsdFxuICogaW5kaWNhdGluZyB0aGF0IHRoZSBwaWNrIHNob3VsZCBiZSB0cmllZCBhZ2FpbiB3aXRoIHRoZSBuZXh0IGBQaWNrZXJgLiBBbHNvXG4gKiByZXBvcnRzIGJhY2sgdG8gdGhlIGxvYWQgYmFsYW5jZXIgdGhhdCBhIGNvbm5lY3Rpb24gc2hvdWxkIGJlIGVzdGFibGlzaGVkXG4gKiBvbmNlIGFueSBwaWNrIGlzIGF0dGVtcHRlZC5cbiAqL1xuY2xhc3MgUXVldWVQaWNrZXIge1xuICAgIC8vIENvbnN0cnVjdGVkIHdpdGggYSBsb2FkIGJhbGFuY2VyLiBDYWxscyBleGl0SWRsZSBvbiBpdCB0aGUgZmlyc3QgdGltZSBwaWNrIGlzIGNhbGxlZFxuICAgIGNvbnN0cnVjdG9yKGxvYWRCYWxhbmNlcikge1xuICAgICAgICB0aGlzLmxvYWRCYWxhbmNlciA9IGxvYWRCYWxhbmNlcjtcbiAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBwaWNrKHBpY2tBcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsZWRFeGl0SWRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jYWxsZWRFeGl0SWRsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5RVUVVRSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICAgICAgb25DYWxsRW5kZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5RdWV1ZVBpY2tlciA9IFF1ZXVlUGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = exports.DEFAULT_PORT = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst TRACER_NAME = 'dns_resolver';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nexports.DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */\nfunction mergeArrays(...arrays) {\n    const result = [];\n    for (let i = 0; i <\n        Math.max.apply(null, arrays.map(array => array.length)); i++) {\n        for (const array of arrays) {\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */\nclass DnsResolver {\n    constructor(target, listener, channelOptions) {\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        this.isServiceConfigEnabled = true;\n        this.returnedIpResult = false;\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\n        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        }\n        else {\n            if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : exports.DEFAULT_PORT,\n                    },\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            }\n            else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : exports.DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        if (channelOptions['grpc.service_config_disable_resolution'] === 1) {\n            this.isServiceConfigEnabled = false;\n        }\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,\n            metadata: new metadata_1.Metadata(),\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs =\n            (_c = channelOptions['grpc.dns_min_time_between_resolutions_ms']) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(() => { }, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */\n    startResolution() {\n        if (this.ipResult !== null) {\n            if (!this.returnedIpResult) {\n                trace('Returning IP address for target ' + (0, uri_parser_1.uriToString)(this.target));\n                setImmediate(() => {\n                    this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n                });\n                this.returnedIpResult = true;\n            }\n            this.backoff.stop();\n            this.backoff.reset();\n            this.stopNextResolutionTimer();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace('Failed to parse DNS address ' + (0, uri_parser_1.uriToString)(this.target));\n            setImmediate(() => {\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,\n                    metadata: new metadata_1.Metadata(),\n                });\n            });\n            this.stopNextResolutionTimer();\n        }\n        else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace('Looking up DNS hostname ' + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */\n            this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */\n            this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });\n            this.pendingLookupPromise.then(addressList => {\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                const ip4Addresses = addressList.filter(addr => addr.family === 4);\n                const ip6Addresses = addressList.filter(addr => addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map(addr => ({ host: addr.address, port: +this.port }));\n                const allAddressesString = '[' +\n                    this.latestLookupResult\n                        .map(addr => addr.host + ':' + addr.port)\n                        .join(',') +\n                    ']';\n                trace('Resolved addresses for target ' +\n                    (0, uri_parser_1.uriToString)(this.target) +\n                    ': ' +\n                    allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */\n                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, err => {\n                if (this.pendingLookupPromise === null) {\n                    return;\n                }\n                trace('Resolution error for target ' +\n                    (0, uri_parser_1.uriToString)(this.target) +\n                    ': ' +\n                    err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */\n            if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */\n                this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then(txtRecord => {\n                    if (this.pendingTxtPromise === null) {\n                        return;\n                    }\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);\n                    }\n                    catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: `Parsing service config failed with error ${err.message}`,\n                            metadata: new metadata_1.Metadata(),\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */\n                        this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, err => {\n                    /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */\n                });\n            }\n        }\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = (_b = (_a = setTimeout(() => {\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n            this.startResolution();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */\n        if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                if (this.isNextResolutionTimerRunning) {\n                    trace('resolution update delayed by \"min time between resolutions\" rate limit');\n                }\n                else {\n                    trace('resolution update delayed by backoff timer until ' + this.backoff.getEndTime().toISOString());\n                }\n                this.continueResolving = true;\n            }\n            else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    /**\n     * Reset the resolver to the same state it had when it was created. In-flight\n     * DNS requests cannot be cancelled, but they are discarded and their results\n     * will be ignored.\n     */\n    destroy() {\n        this.continueResolving = false;\n        this.backoff.reset();\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.returnedIpResult = false;\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */\n    static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */\nfunction setup() {\n    (0, resolver_1.registerResolver)('dns', DnsResolver);\n    (0, resolver_1.registerDefaultScheme)('dns');\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-dns.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWEsR0FBRyxvQkFBb0I7QUFDcEMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQix5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsMkNBQTJDO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMkNBQTJDO0FBQ3ZHO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxXQUFXO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxzQ0FBc0M7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtJQUErSTtBQUMvSSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFlBQVk7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVKQUF1SjtBQUN2SjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLWRucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5ERUZBVUxUX1BPUlQgPSB2b2lkIDA7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBkbnMgPSByZXF1aXJlKFwiZG5zXCIpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3Qgc2VydmljZV9jb25maWdfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2UtY29uZmlnXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnZG5zX3Jlc29sdmVyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuLyoqXG4gKiBUaGUgZGVmYXVsdCBUQ1AgcG9ydCB0byBjb25uZWN0IHRvIGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCBpbiB0aGUgdGFyZ2V0LlxuICovXG5leHBvcnRzLkRFRkFVTFRfUE9SVCA9IDQ0MztcbmNvbnN0IERFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUyA9IDMwMDAwO1xuY29uc3QgcmVzb2x2ZVR4dFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMucmVzb2x2ZVR4dCk7XG5jb25zdCBkbnNMb29rdXBQcm9taXNlID0gdXRpbC5wcm9taXNpZnkoZG5zLmxvb2t1cCk7XG4vKipcbiAqIE1lcmdlIGFueSBudW1iZXIgb2YgYXJyYXlzIGludG8gYSBzaW5nbGUgYWx0ZXJuYXRpbmcgYXJyYXlcbiAqIEBwYXJhbSBhcnJheXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2VBcnJheXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPFxuICAgICAgICBNYXRoLm1heC5hcHBseShudWxsLCBhcnJheXMubWFwKGFycmF5ID0+IGFycmF5Lmxlbmd0aCkpOyBpKyspIHtcbiAgICAgICAgZm9yIChjb25zdCBhcnJheSBvZiBhcnJheXMpIHtcbiAgICAgICAgICAgIGlmIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJlc29sdmVyIGltcGxlbWVudGF0aW9uIHRoYXQgaGFuZGxlcyBETlMgbmFtZXMgYW5kIElQIGFkZHJlc3Nlcy5cbiAqL1xuY2xhc3MgRG5zUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzU2VydmljZUNvbmZpZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJldHVybmVkSXBSZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdHJhY2UoJ1Jlc29sdmVyIGNvbnN0cnVjdGVkIGZvciB0YXJnZXQgJyArICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCkpO1xuICAgICAgICBjb25zdCBob3N0UG9ydCA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0LnBhdGgpO1xuICAgICAgICBpZiAoaG9zdFBvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCgwLCBuZXRfMS5pc0lQdjQpKGhvc3RQb3J0Lmhvc3QpIHx8ICgwLCBuZXRfMS5pc0lQdjYpKGhvc3RQb3J0Lmhvc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogaG9zdFBvcnQuaG9zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IChfYSA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGV4cG9ydHMuREVGQVVMVF9QT1JULFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuZG5zSG9zdG5hbWUgPSBob3N0UG9ydC5ob3N0O1xuICAgICAgICAgICAgICAgIHRoaXMucG9ydCA9IChfYiA9IGhvc3RQb3J0LnBvcnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGV4cG9ydHMuREVGQVVMVF9QT1JUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyY2VudGFnZSA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICAgIGlmIChjaGFubmVsT3B0aW9uc1snZ3JwYy5zZXJ2aWNlX2NvbmZpZ19kaXNhYmxlX3Jlc29sdXRpb24nXSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5pc1NlcnZpY2VDb25maWdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWZhdWx0UmVzb2x1dGlvbkVycm9yID0ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgZGV0YWlsczogYE5hbWUgcmVzb2x1dGlvbiBmYWlsZWQgZm9yIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KX1gLFxuICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5pbml0aWFsX3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgICAgICBtYXhEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja29mZiA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhY2tvZmYudW5yZWYoKTtcbiAgICAgICAgdGhpcy5taW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMgPVxuICAgICAgICAgICAgKF9jID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMuZG5zX21pbl90aW1lX2JldHdlZW5fcmVzb2x1dGlvbnNfbXMnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TO1xuICAgICAgICB0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdGFyZ2V0IGlzIGFuIElQIGFkZHJlc3MsIGp1c3QgcHJvdmlkZSB0aGF0IGFkZHJlc3MgYXMgYSByZXN1bHQuXG4gICAgICogT3RoZXJ3aXNlLCBpbml0aWF0ZSBBLCBBQUFBLCBhbmQgVFhUIGxvb2t1cHNcbiAgICAgKi9cbiAgICBzdGFydFJlc29sdXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlwUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmV0dXJuZWRJcFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXR1cm5pbmcgSVAgYWRkcmVzcyBmb3IgdGFyZ2V0ICcgKyAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKSh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmlwUmVzdWx0LCBudWxsLCBudWxsLCBudWxsLCB7fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXR1cm5lZElwUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kbnNIb3N0bmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhY2UoJ0ZhaWxlZCB0byBwYXJzZSBETlMgYWRkcmVzcyAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpKTtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlIEROUyBhZGRyZXNzICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpfWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlKCdMb29raW5nIHVwIEROUyBob3N0bmFtZSAnICsgdGhpcy5kbnNIb3N0bmFtZSk7XG4gICAgICAgICAgICAvKiBXZSBjbGVhciBvdXQgbGF0ZXN0TG9va3VwUmVzdWx0IGhlcmUgdG8gZW5zdXJlIHRoYXQgaXQgY29udGFpbnMgdGhlXG4gICAgICAgICAgICAgKiBsYXRlc3QgcmVzdWx0IHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc3RhcnRlZCByZXNvbHZpbmcuIFRoYXQgd2F5LCB0aGVcbiAgICAgICAgICAgICAqIFRYVCByZXNvbHV0aW9uIGhhbmRsZXIgY2FuIHVzZSBpdCwgYnV0IG9ubHkgaWYgaXQgZmluaXNoZXMgc2Vjb25kLiBXZVxuICAgICAgICAgICAgICogZG9uJ3QgY2xlYXIgb3V0IGFueSBwcmV2aW91cyBzZXJ2aWNlIGNvbmZpZyByZXN1bHRzIGJlY2F1c2UgaXQnc1xuICAgICAgICAgICAgICogYmV0dGVyIHRvIHVzZSBhIHNlcnZpY2UgY29uZmlnIHRoYXQncyBzbGlnaHRseSBvdXQgb2YgZGF0ZSB0aGFuIHRvXG4gICAgICAgICAgICAgKiByZXZlcnQgdG8gYW4gZWZmZWN0aXZlbHkgYmxhbmsgb25lLiAqL1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSB0aGlzLmRuc0hvc3RuYW1lO1xuICAgICAgICAgICAgLyogV2UgbG9va3VwIGJvdGggYWRkcmVzcyBmYW1pbGllcyBoZXJlIGFuZCB0aGVuIHNwbGl0IHRoZW0gdXAgbGF0ZXJcbiAgICAgICAgICAgICAqIGJlY2F1c2Ugd2hlbiBsb29raW5nIHVwIGEgc2luZ2xlIGZhbWlseSwgZG5zLmxvb2t1cCBvdXRwdXRzIGFuIGVycm9yXG4gICAgICAgICAgICAgKiBpZiB0aGUgbmFtZSBleGlzdHMgYnV0IHRoZXJlIGFyZSBubyByZWNvcmRzIGZvciB0aGF0IGZhbWlseSwgYW5kIHRoYXRcbiAgICAgICAgICAgICAqIGVycm9yIGlzIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gb3RoZXIga2luZHMgb2YgZXJyb3JzICovXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gZG5zTG9va3VwUHJvbWlzZShob3N0bmFtZSwgeyBhbGw6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlLnRoZW4oYWRkcmVzc0xpc3QgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpcDRBZGRyZXNzZXMgPSBhZGRyZXNzTGlzdC5maWx0ZXIoYWRkciA9PiBhZGRyLmZhbWlseSA9PT0gNCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXA2QWRkcmVzc2VzID0gYWRkcmVzc0xpc3QuZmlsdGVyKGFkZHIgPT4gYWRkci5mYW1pbHkgPT09IDYpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ID0gbWVyZ2VBcnJheXMoaXA2QWRkcmVzc2VzLCBpcDRBZGRyZXNzZXMpLm1hcChhZGRyID0+ICh7IGhvc3Q6IGFkZHIuYWRkcmVzcywgcG9ydDogK3RoaXMucG9ydCB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQWRkcmVzc2VzU3RyaW5nID0gJ1snICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoYWRkciA9PiBhZGRyLmhvc3QgKyAnOicgKyBhZGRyLnBvcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignLCcpICtcbiAgICAgICAgICAgICAgICAgICAgJ10nO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHZlZCBhZGRyZXNzZXMgZm9yIHRhcmdldCAnICtcbiAgICAgICAgICAgICAgICAgICAgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIGFsbEFkZHJlc3Nlc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3IodGhpcy5kZWZhdWx0UmVzb2x1dGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgVFhUIGxvb2t1cCBoYXMgbm90IHlldCBmaW5pc2hlZCwgYm90aCBvZiB0aGUgbGFzdCB0d29cbiAgICAgICAgICAgICAgICAgKiBhcmd1bWVudHMgd2lsbCBiZSBudWxsLCB3aGljaCBpcyB0aGUgZXF1aXZhbGVudCBvZiBnZXR0aW5nIGFuXG4gICAgICAgICAgICAgICAgICogZW1wdHkgVFhUIHJlc3BvbnNlLiBXaGVuIHRoZSBUWFQgbG9va3VwIGRvZXMgZmluaXNoLCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICAgICAqIGNhbiB1cGRhdGUgdGhlIHNlcnZpY2UgY29uZmlnIGJ5IHVzaW5nIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCAqL1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCwgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnLCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciwgbnVsbCwge30pO1xuICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHV0aW9uIGVycm9yIGZvciB0YXJnZXQgJyArXG4gICAgICAgICAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wTmV4dFJlc29sdXRpb25UaW1lcigpO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25FcnJvcih0aGlzLmRlZmF1bHRSZXNvbHV0aW9uRXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKiBJZiB0aGVyZSBhbHJlYWR5IGlzIGEgc3RpbGwtcGVuZGluZyBUWFQgcmVzb2x1dGlvbiwgd2UgY2FuIGp1c3QgdXNlXG4gICAgICAgICAgICAgKiB0aGF0IHJlc3VsdCB3aGVuIGl0IGNvbWVzIGluICovXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NlcnZpY2VDb25maWdFbmFibGVkICYmIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvKiBXZSBoYW5kbGUgdGhlIFRYVCBxdWVyeSBwcm9taXNlIGRpZmZlcmVudGx5IHRoYW4gdGhlIG90aGVycyBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICogdGhlIG5hbWUgcmVzb2x1dGlvbiBhdHRlbXB0IGFzIGEgd2hvbGUgaXMgYSBzdWNjZXNzIGV2ZW4gaWYgdGhlIFRYVFxuICAgICAgICAgICAgICAgICAqIGxvb2t1cCBmYWlscyAqL1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSByZXNvbHZlVHh0UHJvbWlzZShob3N0bmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZS50aGVuKHR4dFJlY29yZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdUeHRQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSAoMCwgc2VydmljZV9jb25maWdfMS5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZykodHh0UmVjb3JkLCB0aGlzLnBlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUGFyc2luZyBzZXJ2aWNlIGNvbmZpZyBmYWlsZWQgd2l0aCBlcnJvciAke2Vyci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogV2UgcmVseSBoZXJlIG9uIHRoZSBhc3N1bXB0aW9uIHRoYXQgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGlkZW50aWNhbCBwYXJhbWV0ZXJzIHdpbGwgYmUgZXNzZW50aWFseSBpZGVtcG90ZW50LCBhbmQgY2FsbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgd2l0aCB0aGUgc2FtZSBhZGRyZXNzIGxpc3QgYW5kIGEgZGlmZmVyZW50IHNlcnZpY2UgY29uZmlnXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzaG91bGQgcmVzdWx0IGluIGEgZmFzdCBhbmQgc2VhbWxlc3Mgc3dpdGNob3Zlci4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCwgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnLCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciwgbnVsbCwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgVFhUIGxvb2t1cCBmYWlscyB3ZSBzaG91bGQgZG8gbm90aGluZywgd2hpY2ggbWVhbnMgdGhhdCB3ZVxuICAgICAgICAgICAgICAgICAgICAgKiBjb250aW51ZSB0byB1c2UgdGhlIHJlc3VsdCBvZiB0aGUgbW9zdCByZWNlbnQgc3VjY2Vzc2Z1bCBsb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAqIG9yIHRoZSBkZWZhdWx0IG51bGwgY29uZmlnIG9iamVjdCBpZiB0aGVyZSBoYXMgbmV2ZXIgYmVlbiBhXG4gICAgICAgICAgICAgICAgICAgICAqIHN1Y2Nlc3NmdWwgbG9va3VwLiBXZSBkbyBub3Qgc2V0IHRoZSBsYXRlc3RTZXJ2aWNlQ29uZmlnRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICogaGVyZSBiZWNhdXNlIHRoYXQgaXMgc3BlY2lmaWNhbGx5IHVzZWQgZm9yIHJlc3BvbnNlIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICogZXJyb3JzLiBXZSBzdGlsbCBuZWVkIHRvIGhhbmRsZSB0aGlzIGVycm9yIHNvIHRoYXQgaXQgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgICAgICogYnViYmxlIHVwIGFzIGFuIHVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvbi4gKi9cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydE5leHRSZXNvbHV0aW9uVGltZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIpO1xuICAgICAgICB0aGlzLm5leHRSZXNvbHV0aW9uVGltZXIgPSAoX2IgPSAoX2EgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlc29sdXRpb25XaXRoQmFja29mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcykpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyA9IHRydWU7XG4gICAgfVxuICAgIHN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJ1bk9uY2UoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIC8qIElmIHRoZXJlIGlzIGEgcGVuZGluZyBsb29rdXAsIGp1c3QgbGV0IGl0IGZpbmlzaC4gT3RoZXJ3aXNlLCBpZiB0aGVcbiAgICAgICAgICogbmV4dFJlc29sdXRpb25UaW1lciBvciBiYWNrb2ZmIHRpbWVyIGlzIHJ1bm5pbmcsIHNldCB0aGVcbiAgICAgICAgICogY29udGludWVSZXNvbHZpbmcgZmxhZyB0byByZXNvbHZlIHdoZW4gd2hpY2hldmVyIG9mIHRob3NlIHRpbWVyc1xuICAgICAgICAgKiBmaXJlcy4gT3RoZXJ3aXNlLCBzdGFydCByZXNvbHZpbmcgaW1tZWRpYXRlbHkuICovXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc05leHRSZXNvbHV0aW9uVGltZXJSdW5uaW5nIHx8IHRoaXMuYmFja29mZi5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ3Jlc29sdXRpb24gdXBkYXRlIGRlbGF5ZWQgYnkgXCJtaW4gdGltZSBiZXR3ZWVuIHJlc29sdXRpb25zXCIgcmF0ZSBsaW1pdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ3Jlc29sdXRpb24gdXBkYXRlIGRlbGF5ZWQgYnkgYmFja29mZiB0aW1lciB1bnRpbCAnICsgdGhpcy5iYWNrb2ZmLmdldEVuZFRpbWUoKS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UmVzb2x1dGlvbldpdGhCYWNrb2ZmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHJlc29sdmVyIHRvIHRoZSBzYW1lIHN0YXRlIGl0IGhhZCB3aGVuIGl0IHdhcyBjcmVhdGVkLiBJbi1mbGlnaHRcbiAgICAgKiBETlMgcmVxdWVzdHMgY2Fubm90IGJlIGNhbmNlbGxlZCwgYnV0IHRoZXkgYXJlIGRpc2NhcmRlZCBhbmQgdGhlaXIgcmVzdWx0c1xuICAgICAqIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdUeHRQcm9taXNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IG51bGw7XG4gICAgICAgIHRoaXMucmV0dXJuZWRJcFJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZmF1bHQgYXV0aG9yaXR5IGZvciB0aGUgZ2l2ZW4gdGFyZ2V0LiBGb3IgSVAgdGFyZ2V0cywgdGhhdCBpc1xuICAgICAqIHRoZSBJUCBhZGRyZXNzLiBGb3IgRE5TIHRhcmdldHMsIGl0IGlzIHRoZSBob3N0bmFtZS5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0XG4gICAgICovXG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQucGF0aDtcbiAgICB9XG59XG4vKipcbiAqIFNldCB1cCB0aGUgRE5TIHJlc29sdmVyIGNsYXNzIGJ5IHJlZ2lzdGVyaW5nIGl0IGFzIHRoZSBoYW5kbGVyIGZvciB0aGVcbiAqIFwiZG5zOlwiIHByZWZpeCBhbmQgYXMgdGhlIGRlZmF1bHQgcmVzb2x2ZXIuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKCdkbnMnLCBEbnNSZXNvbHZlcik7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJEZWZhdWx0U2NoZW1lKSgnZG5zJyk7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci1kbnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'ip_resolver';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = 'ipv4';\nconst IPV6_SCHEME = 'ipv6';\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */\nconst DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions) {\n        var _a;\n        this.listener = listener;\n        this.addresses = [];\n        this.error = null;\n        this.hasReturnedResult = false;\n        trace('Resolver constructed for target ' + (0, uri_parser_1.uriToString)(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata(),\n            };\n            return;\n        }\n        const pathList = target.path.split(',');\n        for (const path of pathList) {\n            const hostPort = (0, uri_parser_1.splitHostPort)(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata(),\n                };\n                return;\n            }\n            if ((target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host)) ||\n                (target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host))) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata(),\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT,\n            });\n        }\n        this.addresses = addresses;\n        trace('Parsed ' + target.scheme + ' address list ' + this.addresses);\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(() => {\n                if (this.error) {\n                    this.listener.onError(this.error);\n                }\n                else {\n                    this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});\n                }\n            });\n        }\n    }\n    destroy() {\n        this.hasReturnedResult = false;\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(',')[0];\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);\n    (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-ip.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGVBQWUsVUFBVSxLQUFLO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZSxVQUFVLEtBQUs7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci1pcC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdpcF9yZXNvbHZlcic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IElQVjRfU0NIRU1FID0gJ2lwdjQnO1xuY29uc3QgSVBWNl9TQ0hFTUUgPSAnaXB2Nic7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRDUCBwb3J0IHRvIGNvbm5lY3QgdG8gaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSB0YXJnZXQuXG4gKi9cbmNvbnN0IERFRkFVTFRfUE9SVCA9IDQ0MztcbmNsYXNzIElwUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmFkZHJlc3NlcyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB0cmFjZSgnUmVzb2x2ZXIgY29uc3RydWN0ZWQgZm9yIHRhcmdldCAnICsgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGFyZ2V0KSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBpZiAoISh0YXJnZXQuc2NoZW1lID09PSBJUFY0X1NDSEVNRSB8fCB0YXJnZXQuc2NoZW1lID09PSBJUFY2X1NDSEVNRSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBVbnJlY29nbml6ZWQgc2NoZW1lICR7dGFyZ2V0LnNjaGVtZX0gaW4gSVAgcmVzb2x2ZXJgLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoTGlzdCA9IHRhcmdldC5wYXRoLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgaG9zdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHBhdGgpO1xuICAgICAgICAgICAgaWYgKGhvc3RQb3J0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgRmFpbGVkIHRvIHBhcnNlICR7dGFyZ2V0LnNjaGVtZX0gYWRkcmVzcyAke3BhdGh9YCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRhcmdldC5zY2hlbWUgPT09IElQVjRfU0NIRU1FICYmICEoMCwgbmV0XzEuaXNJUHY0KShob3N0UG9ydC5ob3N0KSkgfHxcbiAgICAgICAgICAgICAgICAodGFyZ2V0LnNjaGVtZSA9PT0gSVBWNl9TQ0hFTUUgJiYgISgwLCBuZXRfMS5pc0lQdjYpKGhvc3RQb3J0Lmhvc3QpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYEZhaWxlZCB0byBwYXJzZSAke3RhcmdldC5zY2hlbWV9IGFkZHJlc3MgJHtwYXRofWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3RQb3J0Lmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogKF9hID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9QT1JULFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBhZGRyZXNzZXM7XG4gICAgICAgIHRyYWNlKCdQYXJzZWQgJyArIHRhcmdldC5zY2hlbWUgKyAnIGFkZHJlc3MgbGlzdCAnICsgdGhpcy5hZGRyZXNzZXMpO1xuICAgIH1cbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzUmV0dXJuZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMuYWRkcmVzc2VzLCBudWxsLCBudWxsLCBudWxsLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5wYXRoLnNwbGl0KCcsJylbMF07XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0dXAoKSB7XG4gICAgKDAsIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcikoSVBWNF9TQ0hFTUUsIElwUmVzb2x2ZXIpO1xuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKElQVjZfU0NIRU1FLCBJcFJlc29sdmVyKTtcbn1cbmV4cG9ydHMuc2V0dXAgPSBzZXR1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLWlwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions) {\n        this.listener = listener;\n        this.addresses = [];\n        this.hasReturnedResult = false;\n        let path;\n        if (target.authority === '') {\n            path = '/' + target.path;\n        }\n        else {\n            path = target.path;\n        }\n        this.addresses = [{ path }];\n    }\n    updateResolution() {\n        if (!this.hasReturnedResult) {\n            this.hasReturnedResult = true;\n            process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});\n        }\n    }\n    destroy() {\n        // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return 'localhost';\n    }\n}\nfunction setup() {\n    (0, resolver_1.registerResolver)('unix', UdsResolver);\n}\nexports.setup = setup;\n//# sourceMappingURL=resolver-uds.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLXVkcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gdm9pZCAwO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY2xhc3MgVWRzUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5oYXNSZXR1cm5lZFJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBsZXQgcGF0aDtcbiAgICAgICAgaWYgKHRhcmdldC5hdXRob3JpdHkgPT09ICcnKSB7XG4gICAgICAgICAgICBwYXRoID0gJy8nICsgdGFyZ2V0LnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoID0gdGFyZ2V0LnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbeyBwYXRoIH1dO1xuICAgIH1cbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzUmV0dXJuZWRSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzUmV0dXJuZWRSZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24sIHRoaXMuYWRkcmVzc2VzLCBudWxsLCBudWxsLCBudWxsLCB7fSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gVGhpcyByZXNvbHZlciBvd25zIG5vIHJlc291cmNlcywgc28gd2UgZG8gbm90aGluZyBoZXJlLlxuICAgIH1cbiAgICBzdGF0aWMgZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuICdsb2NhbGhvc3QnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAgICgwLCByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIpKCd1bml4JywgVWRzUmVzb2x2ZXIpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXItdWRzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nfunction registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nfunction registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nfunction createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    }\n    else {\n        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nfunction getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    }\n    else {\n        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);\n    }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: (0, uri_parser_1.uriToString)(target),\n            };\n        }\n        else {\n            return null;\n        }\n    }\n    return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme;\n//# sourceMappingURL=resolver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRywyQkFBMkIsR0FBRyxzQkFBc0IsR0FBRyw2QkFBNkIsR0FBRyx3QkFBd0I7QUFDN0kscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxzQ0FBc0M7QUFDekc7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxzQ0FBc0M7QUFDaEY7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hcFVyaURlZmF1bHRTY2hlbWUgPSBleHBvcnRzLmdldERlZmF1bHRBdXRob3JpdHkgPSBleHBvcnRzLmNyZWF0ZVJlc29sdmVyID0gZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRTY2hlbWUgPSBleHBvcnRzLnJlZ2lzdGVyUmVzb2x2ZXIgPSB2b2lkIDA7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgcmVnaXN0ZXJlZFJlc29sdmVycyA9IHt9O1xubGV0IGRlZmF1bHRTY2hlbWUgPSBudWxsO1xuLyoqXG4gKiBSZWdpc3RlciBhIHJlc29sdmVyIGNsYXNzIHRvIGhhbmRsZSB0YXJnZXQgbmFtZXMgcHJlZml4ZWQgd2l0aCB0aGUgYHByZWZpeGBcbiAqIHN0cmluZy4gVGhpcyBwcmVmaXggc2hvdWxkIGNvcnJlc3BvbmQgdG8gYSBVUkkgc2NoZW1lIG5hbWUgbGlzdGVkIGluIHRoZVxuICogW2dSUEMgTmFtZSBSZXNvbHV0aW9uIGRvY3VtZW50XShodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9uYW1pbmcubWQpXG4gKiBAcGFyYW0gcHJlZml4XG4gKiBAcGFyYW0gcmVzb2x2ZXJDbGFzc1xuICovXG5mdW5jdGlvbiByZWdpc3RlclJlc29sdmVyKHNjaGVtZSwgcmVzb2x2ZXJDbGFzcykge1xuICAgIHJlZ2lzdGVyZWRSZXNvbHZlcnNbc2NoZW1lXSA9IHJlc29sdmVyQ2xhc3M7XG59XG5leHBvcnRzLnJlZ2lzdGVyUmVzb2x2ZXIgPSByZWdpc3RlclJlc29sdmVyO1xuLyoqXG4gKiBSZWdpc3RlciBhIGRlZmF1bHQgcmVzb2x2ZXIgdG8gaGFuZGxlIHRhcmdldCBuYW1lcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoXG4gKiBhbnkgcmVnaXN0ZXJlZCBwcmVmaXguXG4gKiBAcGFyYW0gcmVzb2x2ZXJDbGFzc1xuICovXG5mdW5jdGlvbiByZWdpc3RlckRlZmF1bHRTY2hlbWUoc2NoZW1lKSB7XG4gICAgZGVmYXVsdFNjaGVtZSA9IHNjaGVtZTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0U2NoZW1lID0gcmVnaXN0ZXJEZWZhdWx0U2NoZW1lO1xuLyoqXG4gKiBDcmVhdGUgYSBuYW1lIHJlc29sdmVyIGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gc3VjaCBuYW1lIHJlc29sdmVyIGNhbiBiZSBjcmVhdGVkLlxuICogQHBhcmFtIHRhcmdldFxuICogQHBhcmFtIGxpc3RlbmVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmVyKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykge1xuICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0odGFyZ2V0LCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJlc29sdmVyIGNvdWxkIGJlIGNyZWF0ZWQgZm9yIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGNyZWF0ZVJlc29sdmVyO1xuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgYXV0aG9yaXR5IGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCwgaWYgcG9zc2libGUuIFRocm93cyBhblxuICogZXJyb3IgaWYgbm8gcmVnaXN0ZXJlZCBuYW1lIHJlc29sdmVyIGNhbiBwYXJzZSB0aGF0IHRhcmdldCBzdHJpbmcuXG4gKiBAcGFyYW0gdGFyZ2V0XG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRSZXNvbHZlcnNbdGFyZ2V0LnNjaGVtZV0uZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRhcmdldCAkeygwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREZWZhdWx0QXV0aG9yaXR5ID0gZ2V0RGVmYXVsdEF1dGhvcml0eTtcbmZ1bmN0aW9uIG1hcFVyaURlZmF1bHRTY2hlbWUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09IHVuZGVmaW5lZCB8fCAhKHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1lOiBkZWZhdWx0U2NoZW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhdGg6ICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRhcmdldCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmV4cG9ydHMubWFwVXJpRGVmYXVsdFNjaGVtZSA9IG1hcFVyaURlZmF1bHRTY2hlbWU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-call.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResolvingCall = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst deadline_1 = __webpack_require__(/*! ./deadline */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst control_plane_status_1 = __webpack_require__(/*! ./control-plane-status */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/control-plane-status.js\");\nconst TRACER_NAME = 'resolving_call';\nclass ResolvingCall {\n    constructor(channel, method, options, filterStackFactory, credentials, callNumber) {\n        this.channel = channel;\n        this.method = method;\n        this.filterStackFactory = filterStackFactory;\n        this.credentials = credentials;\n        this.callNumber = callNumber;\n        this.child = null;\n        this.readPending = false;\n        this.pendingMessage = null;\n        this.pendingHalfClose = false;\n        this.ended = false;\n        this.readFilterPending = false;\n        this.writeFilterPending = false;\n        this.pendingChildStatus = null;\n        this.metadata = null;\n        this.listener = null;\n        this.statusWatchers = [];\n        this.deadlineTimer = setTimeout(() => { }, 0);\n        this.filterStack = null;\n        this.deadline = options.deadline;\n        this.host = options.host;\n        if (options.parentCall) {\n            if (options.flags & constants_1.Propagate.CANCELLATION) {\n                options.parentCall.on('cancelled', () => {\n                    this.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled by parent call');\n                });\n            }\n            if (options.flags & constants_1.Propagate.DEADLINE) {\n                this.trace('Propagating deadline from parent: ' +\n                    options.parentCall.getDeadline());\n                this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());\n            }\n        }\n        this.trace('Created');\n        this.runDeadlineTimer();\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    runDeadlineTimer() {\n        clearTimeout(this.deadlineTimer);\n        this.trace('Deadline: ' + (0, deadline_1.deadlineToString)(this.deadline));\n        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);\n        if (timeout !== Infinity) {\n            this.trace('Deadline will be reached in ' + timeout + 'ms');\n            const handleDeadline = () => {\n                this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, 'Deadline exceeded');\n            };\n            if (timeout <= 0) {\n                process.nextTick(handleDeadline);\n            }\n            else {\n                this.deadlineTimer = setTimeout(handleDeadline, timeout);\n            }\n        }\n    }\n    outputStatus(status) {\n        if (!this.ended) {\n            this.ended = true;\n            if (!this.filterStack) {\n                this.filterStack = this.filterStackFactory.createFilter();\n            }\n            clearTimeout(this.deadlineTimer);\n            const filteredStatus = this.filterStack.receiveTrailers(status);\n            this.trace('ended with status: code=' +\n                filteredStatus.code +\n                ' details=\"' +\n                filteredStatus.details +\n                '\"');\n            this.statusWatchers.forEach(watcher => watcher(filteredStatus));\n            process.nextTick(() => {\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n        }\n    }\n    sendMessageOnChild(context, message) {\n        if (!this.child) {\n            throw new Error('sendMessageonChild called with child not populated');\n        }\n        const child = this.child;\n        this.writeFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve({ message: message, flags: context.flags })).then(filteredMessage => {\n            this.writeFilterPending = false;\n            child.sendMessageWithContext(context, filteredMessage.message);\n            if (this.pendingHalfClose) {\n                child.halfClose();\n            }\n        }, (status) => {\n            this.cancelWithStatus(status.code, status.details);\n        });\n    }\n    getConfig() {\n        if (this.ended) {\n            return;\n        }\n        if (!this.metadata || !this.listener) {\n            throw new Error('getConfig called before start');\n        }\n        const configResult = this.channel.getConfig(this.method, this.metadata);\n        if (configResult.type === 'NONE') {\n            this.channel.queueCallForConfig(this);\n            return;\n        }\n        else if (configResult.type === 'ERROR') {\n            if (this.metadata.getOptions().waitForReady) {\n                this.channel.queueCallForConfig(this);\n            }\n            else {\n                this.outputStatus(configResult.error);\n            }\n            return;\n        }\n        // configResult.type === 'SUCCESS'\n        const config = configResult.config;\n        if (config.status !== constants_1.Status.OK) {\n            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, 'Failed to route call to method ' + this.method);\n            this.outputStatus({\n                code: code,\n                details: details,\n                metadata: new metadata_1.Metadata(),\n            });\n            return;\n        }\n        if (config.methodConfig.timeout) {\n            const configDeadline = new Date();\n            configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);\n            configDeadline.setMilliseconds(configDeadline.getMilliseconds() +\n                config.methodConfig.timeout.nanos / 1000000);\n            this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);\n            this.runDeadlineTimer();\n        }\n        this.filterStackFactory.push(config.dynamicFilterFactories);\n        this.filterStack = this.filterStackFactory.createFilter();\n        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then(filteredMetadata => {\n            this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);\n            this.trace('Created child [' + this.child.getCallNumber() + ']');\n            this.child.start(filteredMetadata, {\n                onReceiveMetadata: metadata => {\n                    this.trace('Received metadata');\n                    this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));\n                },\n                onReceiveMessage: message => {\n                    this.trace('Received message');\n                    this.readFilterPending = true;\n                    this.filterStack.receiveMessage(message).then(filteredMesssage => {\n                        this.trace('Finished filtering received message');\n                        this.readFilterPending = false;\n                        this.listener.onReceiveMessage(filteredMesssage);\n                        if (this.pendingChildStatus) {\n                            this.outputStatus(this.pendingChildStatus);\n                        }\n                    }, (status) => {\n                        this.cancelWithStatus(status.code, status.details);\n                    });\n                },\n                onReceiveStatus: status => {\n                    this.trace('Received status');\n                    if (this.readFilterPending) {\n                        this.pendingChildStatus = status;\n                    }\n                    else {\n                        this.outputStatus(status);\n                    }\n                },\n            });\n            if (this.readPending) {\n                this.child.startRead();\n            }\n            if (this.pendingMessage) {\n                this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);\n            }\n            else if (this.pendingHalfClose) {\n                this.child.halfClose();\n            }\n        }, (status) => {\n            this.outputStatus(status);\n        });\n    }\n    reportResolverError(status) {\n        var _a;\n        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {\n            this.channel.queueCallForConfig(this);\n        }\n        else {\n            this.outputStatus(status);\n        }\n    }\n    cancelWithStatus(status, details) {\n        var _a;\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n        this.outputStatus({\n            code: status,\n            details: details,\n            metadata: new metadata_1.Metadata(),\n        });\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.metadata = metadata.clone();\n        this.listener = listener;\n        this.getConfig();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        if (this.child) {\n            this.sendMessageOnChild(context, message);\n        }\n        else {\n            this.pendingMessage = { context, message };\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        if (this.child) {\n            this.child.startRead();\n        }\n        else {\n            this.readPending = true;\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        if (this.child && !this.writeFilterPending) {\n            this.child.halfClose();\n        }\n        else {\n            this.pendingHalfClose = true;\n        }\n    }\n    setCredentials(credentials) {\n        this.credentials = this.credentials.compose(credentials);\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n}\nexports.ResolvingCall = ResolvingCall;\n//# sourceMappingURL=resolving-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckIsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsK0JBQStCLG1CQUFPLENBQUMsb0dBQXdCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3Q0FBd0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Jlc29sdmluZy1jYWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlc29sdmluZ0NhbGwgPSB2b2lkIDA7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGRlYWRsaW5lXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZVwiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29udHJvbF9wbGFuZV9zdGF0dXNfMSA9IHJlcXVpcmUoXCIuL2NvbnRyb2wtcGxhbmUtc3RhdHVzXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmVzb2x2aW5nX2NhbGwnO1xuY2xhc3MgUmVzb2x2aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgbWV0aG9kLCBvcHRpb25zLCBmaWx0ZXJTdGFja0ZhY3RvcnksIGNyZWRlbnRpYWxzLCBjYWxsTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeSA9IGZpbHRlclN0YWNrRmFjdG9yeTtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmNhbGxOdW1iZXIgPSBjYWxsTnVtYmVyO1xuICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWFkUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGFsZkNsb3NlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWFkRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLndyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZFN0YXR1cyA9IG51bGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNXYXRjaGVycyA9IFtdO1xuICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmRlYWRsaW5lID0gb3B0aW9ucy5kZWFkbGluZTtcbiAgICAgICAgdGhpcy5ob3N0ID0gb3B0aW9ucy5ob3N0O1xuICAgICAgICBpZiAob3B0aW9ucy5wYXJlbnRDYWxsKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mbGFncyAmIGNvbnN0YW50c18xLlByb3BhZ2F0ZS5DQU5DRUxMQVRJT04pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudENhbGwub24oJ2NhbmNlbGxlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgYnkgcGFyZW50IGNhbGwnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFQURMSU5FKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUHJvcGFnYXRpbmcgZGVhZGxpbmUgZnJvbSBwYXJlbnQ6ICcgK1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhcmVudENhbGwuZ2V0RGVhZGxpbmUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9ICgwLCBkZWFkbGluZV8xLm1pbkRlYWRsaW5lKSh0aGlzLmRlYWRsaW5lLCBvcHRpb25zLnBhcmVudENhbGwuZ2V0RGVhZGxpbmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCcpO1xuICAgICAgICB0aGlzLnJ1bkRlYWRsaW5lVGltZXIoKTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICdbJyArIHRoaXMuY2FsbE51bWJlciArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgcnVuRGVhZGxpbmVUaW1lcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGVhZGxpbmVUaW1lcik7XG4gICAgICAgIHRoaXMudHJhY2UoJ0RlYWRsaW5lOiAnICsgKDAsIGRlYWRsaW5lXzEuZGVhZGxpbmVUb1N0cmluZykodGhpcy5kZWFkbGluZSkpO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKDAsIGRlYWRsaW5lXzEuZ2V0UmVsYXRpdmVUaW1lb3V0KSh0aGlzLmRlYWRsaW5lKTtcbiAgICAgICAgaWYgKHRpbWVvdXQgIT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdEZWFkbGluZSB3aWxsIGJlIHJlYWNoZWQgaW4gJyArIHRpbWVvdXQgKyAnbXMnKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZURlYWRsaW5lID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuREVBRExJTkVfRVhDRUVERUQsICdEZWFkbGluZSBleGNlZWRlZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGhhbmRsZURlYWRsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoaGFuZGxlRGVhZGxpbmUsIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG91dHB1dFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmVuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdGhpcy5maWx0ZXJTdGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5jcmVhdGVGaWx0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xuICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRTdGF0dXMgPSB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVUcmFpbGVycyhzdGF0dXMpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnZW5kZWQgd2l0aCBzdGF0dXM6IGNvZGU9JyArXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0dXMuY29kZSArXG4gICAgICAgICAgICAgICAgJyBkZXRhaWxzPVwiJyArXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRTdGF0dXMuZGV0YWlscyArXG4gICAgICAgICAgICAgICAgJ1wiJyk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzLmZvckVhY2god2F0Y2hlciA9PiB3YXRjaGVyKGZpbHRlcmVkU3RhdHVzKSk7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyhmaWx0ZXJlZFN0YXR1cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZU9uQ2hpbGQoY29udGV4dCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VuZE1lc3NhZ2VvbkNoaWxkIGNhbGxlZCB3aXRoIGNoaWxkIG5vdCBwb3B1bGF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hpbGQ7XG4gICAgICAgIHRoaXMud3JpdGVGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5zZW5kTWVzc2FnZShQcm9taXNlLnJlc29sdmUoeyBtZXNzYWdlOiBtZXNzYWdlLCBmbGFnczogY29udGV4dC5mbGFncyB9KSkudGhlbihmaWx0ZXJlZE1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgdGhpcy53cml0ZUZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGNoaWxkLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgZmlsdGVyZWRNZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0hhbGZDbG9zZSkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENvbmZpZygpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5kZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMubWV0YWRhdGEgfHwgIXRoaXMubGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0Q29uZmlnIGNhbGxlZCBiZWZvcmUgc3RhcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdSZXN1bHQgPSB0aGlzLmNoYW5uZWwuZ2V0Q29uZmlnKHRoaXMubWV0aG9kLCB0aGlzLm1ldGFkYXRhKTtcbiAgICAgICAgaWYgKGNvbmZpZ1Jlc3VsdC50eXBlID09PSAnTk9ORScpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JDb25maWcodGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnUmVzdWx0LnR5cGUgPT09ICdFUlJPUicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWwucXVldWVDYWxsRm9yQ29uZmlnKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoY29uZmlnUmVzdWx0LmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25maWdSZXN1bHQudHlwZSA9PT0gJ1NVQ0NFU1MnXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ1Jlc3VsdC5jb25maWc7XG4gICAgICAgIGlmIChjb25maWcuc3RhdHVzICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgZGV0YWlscyB9ID0gKDAsIGNvbnRyb2xfcGxhbmVfc3RhdHVzXzEucmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKShjb25maWcuc3RhdHVzLCAnRmFpbGVkIHRvIHJvdXRlIGNhbGwgdG8gbWV0aG9kICcgKyB0aGlzLm1ldGhvZCk7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5tZXRob2RDb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnRGVhZGxpbmUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uZmlnRGVhZGxpbmUuc2V0U2Vjb25kcyhjb25maWdEZWFkbGluZS5nZXRTZWNvbmRzKCkgKyBjb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQuc2Vjb25kcyk7XG4gICAgICAgICAgICBjb25maWdEZWFkbGluZS5zZXRNaWxsaXNlY29uZHMoY29uZmlnRGVhZGxpbmUuZ2V0TWlsbGlzZWNvbmRzKCkgK1xuICAgICAgICAgICAgICAgIGNvbmZpZy5tZXRob2RDb25maWcudGltZW91dC5uYW5vcyAvIDEwMDAwMDApO1xuICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9ICgwLCBkZWFkbGluZV8xLm1pbkRlYWRsaW5lKSh0aGlzLmRlYWRsaW5lLCBjb25maWdEZWFkbGluZSk7XG4gICAgICAgICAgICB0aGlzLnJ1bkRlYWRsaW5lVGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeS5wdXNoKGNvbmZpZy5keW5hbWljRmlsdGVyRmFjdG9yaWVzKTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5LmNyZWF0ZUZpbHRlcigpO1xuICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnNlbmRNZXRhZGF0YShQcm9taXNlLnJlc29sdmUodGhpcy5tZXRhZGF0YSkpLnRoZW4oZmlsdGVyZWRNZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkID0gdGhpcy5jaGFubmVsLmNyZWF0ZUlubmVyQ2FsbChjb25maWcsIHRoaXMubWV0aG9kLCB0aGlzLmhvc3QsIHRoaXMuY3JlZGVudGlhbHMsIHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCBjaGlsZCBbJyArIHRoaXMuY2hpbGQuZ2V0Q2FsbE51bWJlcigpICsgJ10nKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuc3RhcnQoZmlsdGVyZWRNZXRhZGF0YSwge1xuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIG1ldGFkYXRhJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEodGhpcy5maWx0ZXJTdGFjay5yZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZEZpbHRlclBlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlclN0YWNrLnJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpLnRoZW4oZmlsdGVyZWRNZXNzc2FnZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdGaW5pc2hlZCBmaWx0ZXJpbmcgcmVjZWl2ZWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKGZpbHRlcmVkTWVzc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXModGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLmNvZGUsIHN0YXR1cy5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHN0YXR1cycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkRmlsdGVyUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGRTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhZFBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0UmVhZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlT25DaGlsZCh0aGlzLnBlbmRpbmdNZXNzYWdlLmNvbnRleHQsIHRoaXMucGVuZGluZ01lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmdIYWxmQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVwb3J0UmVzb2x2ZXJFcnJvcihzdGF0dXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5xdWV1ZUNhbGxGb3JDb25maWcodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XG4gICAgICAgIChfYSA9IHRoaXMuY2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscyk7XG4gICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgIGRldGFpbHM6IGRldGFpbHMsXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UGVlcigpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmNoYW5uZWwuZ2V0VGFyZ2V0KCk7XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnRyYWNlKCdzdGFydCBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhLmNsb25lKCk7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5nZXRDb25maWcoKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VPbkNoaWxkKGNvbnRleHQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IHsgY29udGV4dCwgbWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnRSZWFkIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnaGFsZkNsb3NlIGNhbGxlZCcpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZCAmJiAhdGhpcy53cml0ZUZpbHRlclBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGQuaGFsZkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0aGlzLmNyZWRlbnRpYWxzLmNvbXBvc2UoY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBhZGRTdGF0dXNXYXRjaGVyKHdhdGNoZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNXYXRjaGVycy5wdXNoKHdhdGNoZXIpO1xuICAgIH1cbiAgICBnZXRDYWxsTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsTnVtYmVyO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2aW5nQ2FsbCA9IFJlc29sdmluZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZpbmctY2FsbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * Name match levels in order from most to least specific. This is the order in\n * which searches will be performed.\n */\nconst NAME_MATCH_LEVEL_ORDER = [\n    'SERVICE_AND_METHOD',\n    'SERVICE',\n    'EMPTY',\n];\nfunction hasMatchingName(service, method, methodConfig, matchLevel) {\n    for (const name of methodConfig.name) {\n        switch (matchLevel) {\n            case 'EMPTY':\n                if (!name.service && !name.method) {\n                    return true;\n                }\n                break;\n            case 'SERVICE':\n                if (name.service === service && !name.method) {\n                    return true;\n                }\n                break;\n            case 'SERVICE_AND_METHOD':\n                if (name.service === service && name.method === method) {\n                    return true;\n                }\n        }\n    }\n    return false;\n}\nfunction findMatchingConfig(service, method, methodConfigs, matchLevel) {\n    for (const config of methodConfigs) {\n        if (hasMatchingName(service, method, config, matchLevel)) {\n            return config;\n        }\n    }\n    return null;\n}\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split('/').filter(x => x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n        if (serviceConfig && serviceConfig.methodConfig) {\n            /* Check for the following in order, and return the first method\n             * config that matches:\n             * 1. A name that exactly matches the service and method\n             * 2. A name with no method set that matches the service\n             * 3. An empty name\n             */\n            for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {\n                const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);\n                if (matchingConfig) {\n                    return {\n                        methodConfig: matchingConfig,\n                        pickInformation: {},\n                        status: constants_1.Status.OK,\n                        dynamicFilterFactories: [],\n                    };\n                }\n            }\n        }\n        return {\n            methodConfig: { name: [] },\n            pickInformation: {},\n            status: constants_1.Status.OK,\n            dynamicFilterFactories: [],\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */\n    constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */\n        this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */\n        this.continueResolving = false;\n        if (channelOptions['grpc.service_config']) {\n            this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));\n        }\n        else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: [],\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: () => {\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */\n                if (this.backoffTimeout.isRunning()) {\n                    trace('requestReresolution delayed by backoff timer until ' + this.backoffTimeout.getEndTime().toISOString());\n                    this.continueResolving = true;\n                }\n                else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker) => {\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper),\n        });\n        this.innerResolver = (0, resolver_1.createResolver)(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n                var _a;\n                this.backoffTimeout.stop();\n                this.backoffTimeout.reset();\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */\n                if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    }\n                    else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        }\n                        else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                }\n                else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = (0, load_balancer_1.getFirstUsableConfig)(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: 'All load balancer options in service config are not compatible',\n                        metadata: new metadata_1.Metadata(),\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error) => {\n                this.handleResolutionFailure(error);\n            },\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            }\n            else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker) {\n        trace((0, uri_parser_1.uriToString)(this.target) +\n            ' ' +\n            connectivity_state_1.ConnectivityState[this.currentState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE ||\n            this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            }\n            else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.backoffTimeout.reset();\n        this.backoffTimeout.stop();\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.previousServiceConfig = null;\n        this.continueResolving = false;\n    }\n    getTypeName() {\n        return 'resolving_load_balancer';\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;\n//# sourceMappingURL=resolving-load-balancer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0Isd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pELHlCQUF5QixtQkFBTyxDQUFDLHdGQUFrQjtBQUNuRCw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsaUJBQWlCLG1CQUFPLENBQUMsd0VBQVU7QUFDbkMsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFZO0FBQ3ZDLGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLHNDQUFzQyxtQkFBTyxDQUFDLGtIQUErQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IHNlcnZpY2VfY29uZmlnXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlLWNvbmZpZ1wiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlclwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3Jlc29sdmluZ19sb2FkX2JhbGFuY2VyJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18yLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuLyoqXG4gKiBOYW1lIG1hdGNoIGxldmVscyBpbiBvcmRlciBmcm9tIG1vc3QgdG8gbGVhc3Qgc3BlY2lmaWMuIFRoaXMgaXMgdGhlIG9yZGVyIGluXG4gKiB3aGljaCBzZWFyY2hlcyB3aWxsIGJlIHBlcmZvcm1lZC5cbiAqL1xuY29uc3QgTkFNRV9NQVRDSF9MRVZFTF9PUkRFUiA9IFtcbiAgICAnU0VSVklDRV9BTkRfTUVUSE9EJyxcbiAgICAnU0VSVklDRScsXG4gICAgJ0VNUFRZJyxcbl07XG5mdW5jdGlvbiBoYXNNYXRjaGluZ05hbWUoc2VydmljZSwgbWV0aG9kLCBtZXRob2RDb25maWcsIG1hdGNoTGV2ZWwpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbWV0aG9kQ29uZmlnLm5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChtYXRjaExldmVsKSB7XG4gICAgICAgICAgICBjYXNlICdFTVBUWSc6XG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lLnNlcnZpY2UgJiYgIW5hbWUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NFUlZJQ0UnOlxuICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlcnZpY2UgJiYgIW5hbWUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1NFUlZJQ0VfQU5EX01FVEhPRCc6XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc2VydmljZSA9PT0gc2VydmljZSAmJiBuYW1lLm1ldGhvZCA9PT0gbWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdDb25maWcoc2VydmljZSwgbWV0aG9kLCBtZXRob2RDb25maWdzLCBtYXRjaExldmVsKSB7XG4gICAgZm9yIChjb25zdCBjb25maWcgb2YgbWV0aG9kQ29uZmlncykge1xuICAgICAgICBpZiAoaGFzTWF0Y2hpbmdOYW1lKHNlcnZpY2UsIG1ldGhvZCwgY29uZmlnLCBtYXRjaExldmVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRDb25maWdTZWxlY3RvcihzZXJ2aWNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlZmF1bHRDb25maWdTZWxlY3RvcihtZXRob2ROYW1lLCBtZXRhZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBzcGxpdE5hbWUgPSBtZXRob2ROYW1lLnNwbGl0KCcvJykuZmlsdGVyKHggPT4geC5sZW5ndGggPiAwKTtcbiAgICAgICAgY29uc3Qgc2VydmljZSA9IChfYSA9IHNwbGl0TmFtZVswXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IChfYiA9IHNwbGl0TmFtZVsxXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG4gICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnICYmIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnKSB7XG4gICAgICAgICAgICAvKiBDaGVjayBmb3IgdGhlIGZvbGxvd2luZyBpbiBvcmRlciwgYW5kIHJldHVybiB0aGUgZmlyc3QgbWV0aG9kXG4gICAgICAgICAgICAgKiBjb25maWcgdGhhdCBtYXRjaGVzOlxuICAgICAgICAgICAgICogMS4gQSBuYW1lIHRoYXQgZXhhY3RseSBtYXRjaGVzIHRoZSBzZXJ2aWNlIGFuZCBtZXRob2RcbiAgICAgICAgICAgICAqIDIuIEEgbmFtZSB3aXRoIG5vIG1ldGhvZCBzZXQgdGhhdCBtYXRjaGVzIHRoZSBzZXJ2aWNlXG4gICAgICAgICAgICAgKiAzLiBBbiBlbXB0eSBuYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2hMZXZlbCBvZiBOQU1FX01BVENIX0xFVkVMX09SREVSKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdDb25maWcgPSBmaW5kTWF0Y2hpbmdDb25maWcoc2VydmljZSwgbWV0aG9kLCBzZXJ2aWNlQ29uZmlnLm1ldGhvZENvbmZpZywgbWF0Y2hMZXZlbCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RDb25maWc6IG1hdGNoaW5nQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGlja0luZm9ybWF0aW9uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXRob2RDb25maWc6IHsgbmFtZTogW10gfSxcbiAgICAgICAgICAgIHBpY2tJbmZvcm1hdGlvbjoge30sXG4gICAgICAgICAgICBzdGF0dXM6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJGYWN0b3JpZXM6IFtdLFxuICAgICAgICB9O1xuICAgIH07XG59XG5jbGFzcyBSZXNvbHZpbmdMb2FkQmFsYW5jZXIge1xuICAgIC8qKlxuICAgICAqIFdyYXBwZXIgY2xhc3MgdGhhdCBiZWhhdmVzIGxpa2UgYSBgTG9hZEJhbGFuY2VyYCBhbmQgYWxzbyBoYW5kbGVzIG5hbWVcbiAgICAgKiByZXNvbHV0aW9uIGludGVybmFsbHkuXG4gICAgICogQHBhcmFtIHRhcmdldCBUaGUgYWRkcmVzcyBvZiB0aGUgYmFja2VuZCB0byBjb25uZWN0IHRvLlxuICAgICAqIEBwYXJhbSBjaGFubmVsQ29udHJvbEhlbHBlciBgQ2hhbm5lbENvbnRyb2xIZWxwZXJgIGluc3RhbmNlIHByb3ZpZGVkIGJ5XG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxuICAgICAqIEBwYXJhbSBkZWZhdWx0U2VydmljZUNvbmZpZyBUaGUgZGVmYXVsdCBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gdG8gYmUgdXNlZFxuICAgICAqICAgICBpZiBub25lIGlzIHByb3ZpZGVkIGJ5IHRoZSBuYW1lIHJlc29sdmVyLiBBIGBudWxsYCB2YWx1ZSBpbmRpY2F0ZXNcbiAgICAgKiAgICAgdGhhdCB0aGUgZGVmYXVsdCBiZWhhdmlvciBzaG91bGQgYmUgdGhlIGRlZmF1bHQgdW5jb25maWd1cmVkIGJlaGF2aW9yLlxuICAgICAqICAgICBJbiBwcmFjdGljZSwgdGhhdCBtZWFucyB1c2luZyB0aGUgXCJwaWNrIGZpcnN0XCIgbG9hZCBiYWxhbmNlclxuICAgICAqICAgICBpbXBsbWVudGF0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgY2hhbm5lbE9wdGlvbnMsIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb24sIG9uRmFpbGVkUmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlciA9IGNoYW5uZWxDb250cm9sSGVscGVyO1xuICAgICAgICB0aGlzLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24gPSBvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLm9uRmFpbGVkUmVzb2x1dGlvbiA9IG9uRmFpbGVkUmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmVzb2x2aW5nIGxvYWQgYmFsYW5jZXIncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXJ2aWNlIGNvbmZpZyBvYmplY3QgZnJvbSB0aGUgbGFzdCBzdWNjZXNzZnVsIHJlc29sdXRpb24sIGlmXG4gICAgICAgICAqIGF2YWlsYWJsZS4gQSB2YWx1ZSBvZiBudWxsIGluZGljYXRlcyB0aGF0IHdlIGhhdmUgbm90IHlldCByZWNlaXZlZCBhIHZhbGlkXG4gICAgICAgICAqIHNlcnZpY2UgY29uZmlnIGZyb20gdGhlIHJlc29sdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmVzb2x2ZSBhZ2FpbiBhZnRlciB0aGUgYmFja29mZlxuICAgICAgICAgKiB0aW1lciBydW5zIG91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnJ10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWcgPSAoMCwgc2VydmljZV9jb25maWdfMS52YWxpZGF0ZVNlcnZpY2VDb25maWcpKEpTT04ucGFyc2UoY2hhbm5lbE9wdGlvbnNbJ2dycGMuc2VydmljZV9jb25maWcnXSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBsb2FkQmFsYW5jaW5nQ29uZmlnOiBbXSxcbiAgICAgICAgICAgICAgICBtZXRob2RDb25maWc6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIHRoaXMuY2hpbGRMb2FkQmFsYW5jZXIgPSBuZXcgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEuQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyKHtcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IGNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGJhY2tvZmZUaW1lb3V0IGlzIHJ1bm5pbmcsIHdlJ3JlIHN0aWxsIGJhY2tpbmcgb2ZmIGZyb21cbiAgICAgICAgICAgICAgICAgKiBtYWtpbmcgcmVzb2x2ZSByZXF1ZXN0cywgc28gd2Ugc2hvdWxkbid0IG1ha2UgYW5vdGhlciBvbmUgaGVyZS5cbiAgICAgICAgICAgICAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSBiYWNrb2ZmIHRpbWVyIGNhbGxiYWNrIHdpbGwgY2FsbFxuICAgICAgICAgICAgICAgICAqIHVwZGF0ZVJlc29sdXRpb24gKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgncmVxdWVzdFJlcmVzb2x1dGlvbiBkZWxheWVkIGJ5IGJhY2tvZmYgdGltZXIgdW50aWwgJyArIHRoaXMuYmFja29mZlRpbWVvdXQuZ2V0RW5kVGltZSgpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZTogKG5ld1N0YXRlLCBwaWNrZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENoaWxkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENoaWxkUGlja2VyID0gcGlja2VyO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZDogY2hhbm5lbENvbnRyb2xIZWxwZXIuYWRkQ2hhbm5lbHpDaGlsZC5iaW5kKGNoYW5uZWxDb250cm9sSGVscGVyKSxcbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IGNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlubmVyUmVzb2x2ZXIgPSAoMCwgcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcikodGFyZ2V0LCB7XG4gICAgICAgICAgICBvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uOiAoYWRkcmVzc0xpc3QsIHNlcnZpY2VDb25maWcsIHNlcnZpY2VDb25maWdFcnJvciwgY29uZmlnU2VsZWN0b3IsIGF0dHJpYnV0ZXMpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGxldCB3b3JraW5nU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgLyogVGhpcyBmaXJzdCBncm91cCBvZiBjb25kaXRpb25hbHMgaW1wbGVtZW50cyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZFxuICAgICAgICAgICAgICAgICAqIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EyMS1zZXJ2aWNlLWNvbmZpZy1lcnJvci1oYW5kbGluZy5tZFxuICAgICAgICAgICAgICAgICAqIGluIHRoZSBzZWN0aW9uIGNhbGxlZCBcIkJlaGF2aW9yIG9uIHJlY2VpdmluZyBhIG5ldyBnUlBDIENvbmZpZ1wiLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNCBhbmQgNVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmljZUNvbmZpZ0Vycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0LmlpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShzZXJ2aWNlQ29uZmlnRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0LmlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDNcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSBzZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtpbmdDb25maWdMaXN0ID0gKF9hID0gd29ya2luZ1NlcnZpY2VDb25maWcgPT09IG51bGwgfHwgd29ya2luZ1NlcnZpY2VDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdvcmtpbmdTZXJ2aWNlQ29uZmlnLmxvYWRCYWxhbmNpbmdDb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRCYWxhbmNpbmdDb25maWcgPSAoMCwgbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKSh3b3JraW5nQ29uZmlnTGlzdCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvYWRCYWxhbmNpbmdDb25maWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgd2VyZSBsb2FkIGJhbGFuY2luZyBjb25maWdzIGJ1dCBub25lIGFyZSBzdXBwb3J0ZWQuIFRoaXMgY291bnRzIGFzIGEgcmVzb2x1dGlvbiBmYWlsdXJlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ0FsbCBsb2FkIGJhbGFuY2VyIG9wdGlvbnMgaW4gc2VydmljZSBjb25maWcgYXJlIG5vdCBjb21wYXRpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLnVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsb2FkQmFsYW5jaW5nQ29uZmlnLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaW5hbFNlcnZpY2VDb25maWcgPSB3b3JraW5nU2VydmljZUNvbmZpZyAhPT0gbnVsbCAmJiB3b3JraW5nU2VydmljZUNvbmZpZyAhPT0gdm9pZCAwID8gd29ya2luZ1NlcnZpY2VDb25maWcgOiB0aGlzLmRlZmF1bHRTZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgIHRoaXMub25TdWNjZXNzZnVsUmVzb2x1dGlvbihmaW5hbFNlcnZpY2VDb25maWcsIGNvbmZpZ1NlbGVjdG9yICE9PSBudWxsICYmIGNvbmZpZ1NlbGVjdG9yICE9PSB2b2lkIDAgPyBjb25maWdTZWxlY3RvciA6IGdldERlZmF1bHRDb25maWdTZWxlY3RvcihmaW5hbFNlcnZpY2VDb25maWcpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKGVycm9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sIGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dCA9IG5ldyBiYWNrb2ZmX3RpbWVvdXRfMS5CYWNrb2ZmVGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5sYXRlc3RDaGlsZFN0YXRlLCB0aGlzLmxhdGVzdENoaWxkUGlja2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnVucmVmKCk7XG4gICAgfVxuICAgIHVwZGF0ZVJlc29sdXRpb24oKSB7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucnVuT25jZSgpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgIHRyYWNlKCgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtjb25uZWN0aXZpdHlTdGF0ZV0pO1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGlzLmV4aXRJZGxlKCkgaXMgY2FsbGVkIGJ5IHRoZSBwaWNrZXJcbiAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICBwaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKTtcbiAgICB9XG4gICAgaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKGVycm9yKSk7XG4gICAgICAgICAgICB0aGlzLm9uRmFpbGVkUmVzb2x1dGlvbihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1cGRhdGVBZGRyZXNzTGlzdCBub3Qgc3VwcG9ydGVkIG9uIFJlc29sdmluZ0xvYWRCYWxhbmNlcicpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW5uZXJSZXNvbHZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5zdG9wKCk7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3Jlc29sdmluZ19sb2FkX2JhbGFuY2VyJztcbiAgICB9XG59XG5leHBvcnRzLlJlc29sdmluZ0xvYWRCYWxhbmNlciA9IFJlc29sdmluZ0xvYWRCYWxhbmNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmluZy1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/retrying-call.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = 'retrying_call';\nclass RetryThrottler {\n    constructor(maxTokens, tokenRatio, previousRetryThrottler) {\n        this.maxTokens = maxTokens;\n        this.tokenRatio = tokenRatio;\n        if (previousRetryThrottler) {\n            /* When carrying over tokens from a previous config, rescale them to the\n             * new max value */\n            this.tokens =\n                previousRetryThrottler.tokens *\n                    (maxTokens / previousRetryThrottler.maxTokens);\n        }\n        else {\n            this.tokens = maxTokens;\n        }\n    }\n    addCallSucceeded() {\n        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n    }\n    addCallFailed() {\n        this.tokens = Math.min(this.tokens - 1, 0);\n    }\n    canRetryCall() {\n        return this.tokens > this.maxTokens / 2;\n    }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n    constructor(totalLimit, limitPerCall) {\n        this.totalLimit = totalLimit;\n        this.limitPerCall = limitPerCall;\n        this.totalAllocated = 0;\n        this.allocatedPerCall = new Map();\n    }\n    allocate(size, callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.limitPerCall - currentPerCall < size ||\n            this.totalLimit - this.totalAllocated < size) {\n            return false;\n        }\n        this.allocatedPerCall.set(callId, currentPerCall + size);\n        this.totalAllocated += size;\n        return true;\n    }\n    free(size, callId) {\n        var _a;\n        if (this.totalAllocated < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= size;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (currentPerCall < size) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n        }\n        this.allocatedPerCall.set(callId, currentPerCall - size);\n    }\n    freeAll(callId) {\n        var _a;\n        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n        if (this.totalAllocated < currentPerCall) {\n            throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n        }\n        this.totalAllocated -= currentPerCall;\n        this.allocatedPerCall.delete(callId);\n    }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\nclass RetryingCall {\n    constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\n        this.channel = channel;\n        this.callConfig = callConfig;\n        this.methodName = methodName;\n        this.host = host;\n        this.credentials = credentials;\n        this.deadline = deadline;\n        this.callNumber = callNumber;\n        this.bufferTracker = bufferTracker;\n        this.retryThrottler = retryThrottler;\n        this.listener = null;\n        this.initialMetadata = null;\n        this.underlyingCalls = [];\n        this.writeBuffer = [];\n        /**\n         * The offset of message indices in the writeBuffer. For example, if\n         * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n         * is in writeBuffer[5].\n         */\n        this.writeBufferOffset = 0;\n        /**\n         * Tracks whether a read has been started, so that we know whether to start\n         * reads on new child calls. This only matters for the first read, because\n         * once a message comes in the child call becomes committed and there will\n         * be no new child calls.\n         */\n        this.readStarted = false;\n        this.transparentRetryUsed = false;\n        /**\n         * Number of attempts so far\n         */\n        this.attempts = 0;\n        this.hedgingTimer = null;\n        this.committedCallIndex = null;\n        this.initialRetryBackoffSec = 0;\n        this.nextRetryBackoffSec = 0;\n        if (callConfig.methodConfig.retryPolicy) {\n            this.state = 'RETRY';\n            const retryPolicy = callConfig.methodConfig.retryPolicy;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n        }\n        else if (callConfig.methodConfig.hedgingPolicy) {\n            this.state = 'HEDGING';\n        }\n        else {\n            this.state = 'TRANSPARENT_ONLY';\n        }\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n    }\n    reportStatus(statusObject) {\n        this.trace('ended with status: code=' +\n            statusObject.code +\n            ' details=\"' +\n            statusObject.details +\n            '\"');\n        this.bufferTracker.freeAll(this.callNumber);\n        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n        this.writeBuffer = [];\n        process.nextTick(() => {\n            var _a;\n            // Explicitly construct status object to remove progress field\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n                code: statusObject.code,\n                details: statusObject.details,\n                metadata: statusObject.metadata,\n            });\n        });\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });\n        for (const { call } of this.underlyingCalls) {\n            call.cancelWithStatus(status, details);\n        }\n    }\n    getPeer() {\n        if (this.committedCallIndex !== null) {\n            return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getBufferEntry(messageIndex) {\n        var _a;\n        return ((_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n            entryType: 'FREED',\n            allocated: false,\n        });\n    }\n    getNextBufferIndex() {\n        return this.writeBufferOffset + this.writeBuffer.length;\n    }\n    clearSentMessages() {\n        if (this.state !== 'COMMITTED') {\n            return;\n        }\n        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\n            const bufferEntry = this.getBufferEntry(messageIndex);\n            if (bufferEntry.allocated) {\n                this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n            }\n        }\n        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n        this.writeBufferOffset = earliestNeededMessageIndex;\n    }\n    commitCall(index) {\n        if (this.state === 'COMMITTED') {\n            return;\n        }\n        if (this.underlyingCalls[index].state === 'COMPLETED') {\n            return;\n        }\n        this.trace('Committing call [' +\n            this.underlyingCalls[index].call.getCallNumber() +\n            '] at index ' +\n            index);\n        this.state = 'COMMITTED';\n        this.committedCallIndex = index;\n        for (let i = 0; i < this.underlyingCalls.length; i++) {\n            if (i === index) {\n                continue;\n            }\n            if (this.underlyingCalls[i].state === 'COMPLETED') {\n                continue;\n            }\n            this.underlyingCalls[i].state = 'COMPLETED';\n            this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n        }\n        this.clearSentMessages();\n    }\n    commitCallWithMostMessages() {\n        if (this.state === 'COMMITTED') {\n            return;\n        }\n        let mostMessages = -1;\n        let callWithMostMessages = -1;\n        for (const [index, childCall] of this.underlyingCalls.entries()) {\n            if (childCall.state === 'ACTIVE' &&\n                childCall.nextMessageToSend > mostMessages) {\n                mostMessages = childCall.nextMessageToSend;\n                callWithMostMessages = index;\n            }\n        }\n        if (callWithMostMessages === -1) {\n            /* There are no active calls, disable retries to force the next call that\n             * is started to be committed. */\n            this.state = 'TRANSPARENT_ONLY';\n        }\n        else {\n            this.commitCall(callWithMostMessages);\n        }\n    }\n    isStatusCodeInList(list, code) {\n        return list.some(value => value === code ||\n            value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());\n    }\n    getNextRetryBackoffMs() {\n        var _a;\n        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n        if (!retryPolicy) {\n            return 0;\n        }\n        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n        return nextBackoffMs;\n    }\n    maybeRetryCall(pushback, callback) {\n        if (this.state !== 'RETRY') {\n            callback(false);\n            return;\n        }\n        const retryPolicy = this.callConfig.methodConfig.retryPolicy;\n        if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n            callback(false);\n            return;\n        }\n        let retryDelayMs;\n        if (pushback === null) {\n            retryDelayMs = this.getNextRetryBackoffMs();\n        }\n        else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            callback(false);\n            return;\n        }\n        else {\n            retryDelayMs = pushback;\n            this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n        }\n        setTimeout(() => {\n            var _a, _b;\n            if (this.state !== 'RETRY') {\n                callback(false);\n                return;\n            }\n            if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n                callback(true);\n                this.attempts += 1;\n                this.startNewAttempt();\n            }\n        }, retryDelayMs);\n    }\n    countActiveCalls() {\n        let count = 0;\n        for (const call of this.underlyingCalls) {\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\n                count += 1;\n            }\n        }\n        return count;\n    }\n    handleProcessedStatus(status, callIndex, pushback) {\n        var _a, _b, _c;\n        switch (this.state) {\n            case 'COMMITTED':\n            case 'TRANSPARENT_ONLY':\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case 'HEDGING':\n                if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n                    (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n                    let delayMs;\n                    if (pushback === null) {\n                        delayMs = 0;\n                    }\n                    else if (pushback < 0) {\n                        this.state = 'TRANSPARENT_ONLY';\n                        this.commitCall(callIndex);\n                        this.reportStatus(status);\n                        return;\n                    }\n                    else {\n                        delayMs = pushback;\n                    }\n                    setTimeout(() => {\n                        this.maybeStartHedgingAttempt();\n                        // If after trying to start a call there are no active calls, this was the last one\n                        if (this.countActiveCalls() === 0) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    }, delayMs);\n                }\n                else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n            case 'RETRY':\n                if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n                    (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n                    this.maybeRetryCall(pushback, retried => {\n                        if (!retried) {\n                            this.commitCall(callIndex);\n                            this.reportStatus(status);\n                        }\n                    });\n                }\n                else {\n                    this.commitCall(callIndex);\n                    this.reportStatus(status);\n                }\n                break;\n        }\n    }\n    getPushback(metadata) {\n        const mdValue = metadata.get('grpc-retry-pushback-ms');\n        if (mdValue.length === 0) {\n            return null;\n        }\n        try {\n            return parseInt(mdValue[0]);\n        }\n        catch (e) {\n            return -1;\n        }\n    }\n    handleChildStatus(status, callIndex) {\n        var _a;\n        if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n            return;\n        }\n        this.trace('state=' +\n            this.state +\n            ' handling status with progress ' +\n            status.progress +\n            ' from child [' +\n            this.underlyingCalls[callIndex].call.getCallNumber() +\n            '] in state ' +\n            this.underlyingCalls[callIndex].state);\n        this.underlyingCalls[callIndex].state = 'COMPLETED';\n        if (status.code === constants_1.Status.OK) {\n            (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n        }\n        if (this.state === 'COMMITTED') {\n            this.reportStatus(status);\n            return;\n        }\n        const pushback = this.getPushback(status.metadata);\n        switch (status.progress) {\n            case 'NOT_STARTED':\n                // RPC never leaves the client, always safe to retry\n                this.startNewAttempt();\n                break;\n            case 'REFUSED':\n                // RPC reaches the server library, but not the server application logic\n                if (this.transparentRetryUsed) {\n                    this.handleProcessedStatus(status, callIndex, pushback);\n                }\n                else {\n                    this.transparentRetryUsed = true;\n                    this.startNewAttempt();\n                }\n                break;\n            case 'DROP':\n                this.commitCall(callIndex);\n                this.reportStatus(status);\n                break;\n            case 'PROCESSED':\n                this.handleProcessedStatus(status, callIndex, pushback);\n                break;\n        }\n    }\n    maybeStartHedgingAttempt() {\n        if (this.state !== 'HEDGING') {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n            return;\n        }\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    maybeStartHedgingTimer() {\n        var _a, _b, _c;\n        if (this.hedgingTimer) {\n            clearTimeout(this.hedgingTimer);\n        }\n        if (this.state !== 'HEDGING') {\n            return;\n        }\n        if (!this.callConfig.methodConfig.hedgingPolicy) {\n            return;\n        }\n        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n            return;\n        }\n        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\n        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n        this.hedgingTimer = setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n        }, hedgingDelaySec * 1000);\n        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n    }\n    startNewAttempt() {\n        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n        this.trace('Created child call [' +\n            child.getCallNumber() +\n            '] for attempt ' +\n            this.attempts);\n        const index = this.underlyingCalls.length;\n        this.underlyingCalls.push({\n            state: 'ACTIVE',\n            call: child,\n            nextMessageToSend: 0,\n        });\n        const previousAttempts = this.attempts - 1;\n        const initialMetadata = this.initialMetadata.clone();\n        if (previousAttempts > 0) {\n            initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        let receivedMetadata = false;\n        child.start(initialMetadata, {\n            onReceiveMetadata: metadata => {\n                this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n                this.commitCall(index);\n                receivedMetadata = true;\n                if (previousAttempts > 0) {\n                    metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\n                    this.listener.onReceiveMetadata(metadata);\n                }\n            },\n            onReceiveMessage: message => {\n                this.trace('Received message from child [' + child.getCallNumber() + ']');\n                this.commitCall(index);\n                if (this.underlyingCalls[index].state === 'ACTIVE') {\n                    this.listener.onReceiveMessage(message);\n                }\n            },\n            onReceiveStatus: status => {\n                this.trace('Received status from child [' + child.getCallNumber() + ']');\n                if (!receivedMetadata && previousAttempts > 0) {\n                    status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n                }\n                this.handleChildStatus(status, index);\n            },\n        });\n        this.sendNextChildMessage(index);\n        if (this.readStarted) {\n            child.startRead();\n        }\n    }\n    start(metadata, listener) {\n        this.trace('start called');\n        this.listener = listener;\n        this.initialMetadata = metadata;\n        this.attempts += 1;\n        this.startNewAttempt();\n        this.maybeStartHedgingTimer();\n    }\n    handleChildWriteCompleted(childIndex) {\n        var _a, _b;\n        const childCall = this.underlyingCalls[childIndex];\n        const messageIndex = childCall.nextMessageToSend;\n        (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.clearSentMessages();\n        childCall.nextMessageToSend += 1;\n        this.sendNextChildMessage(childIndex);\n    }\n    sendNextChildMessage(childIndex) {\n        const childCall = this.underlyingCalls[childIndex];\n        if (childCall.state === 'COMPLETED') {\n            return;\n        }\n        if (this.getBufferEntry(childCall.nextMessageToSend)) {\n            const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n            switch (bufferEntry.entryType) {\n                case 'MESSAGE':\n                    childCall.call.sendMessageWithContext({\n                        callback: error => {\n                            // Ignore error\n                            this.handleChildWriteCompleted(childIndex);\n                        },\n                    }, bufferEntry.message.message);\n                    break;\n                case 'HALF_CLOSE':\n                    childCall.nextMessageToSend += 1;\n                    childCall.call.halfClose();\n                    break;\n                case 'FREED':\n                    // Should not be possible\n                    break;\n            }\n        }\n    }\n    sendMessageWithContext(context, message) {\n        var _a;\n        this.trace('write() called with message of length ' + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags,\n        };\n        const messageIndex = this.getNextBufferIndex();\n        const bufferEntry = {\n            entryType: 'MESSAGE',\n            message: writeObj,\n            allocated: this.bufferTracker.allocate(message.length, this.callNumber),\n        };\n        this.writeBuffer.push(bufferEntry);\n        if (bufferEntry.allocated) {\n            (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            for (const [callIndex, call] of this.underlyingCalls.entries()) {\n                if (call.state === 'ACTIVE' &&\n                    call.nextMessageToSend === messageIndex) {\n                    call.call.sendMessageWithContext({\n                        callback: error => {\n                            // Ignore error\n                            this.handleChildWriteCompleted(callIndex);\n                        },\n                    }, message);\n                }\n            }\n        }\n        else {\n            this.commitCallWithMostMessages();\n            // commitCallWithMostMessages can fail if we are between ping attempts\n            if (this.committedCallIndex === null) {\n                return;\n            }\n            const call = this.underlyingCalls[this.committedCallIndex];\n            bufferEntry.callback = context.callback;\n            if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n                call.call.sendMessageWithContext({\n                    callback: error => {\n                        // Ignore error\n                        this.handleChildWriteCompleted(this.committedCallIndex);\n                    },\n                }, message);\n            }\n        }\n    }\n    startRead() {\n        this.trace('startRead called');\n        this.readStarted = true;\n        for (const underlyingCall of this.underlyingCalls) {\n            if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\n                underlyingCall.call.startRead();\n            }\n        }\n    }\n    halfClose() {\n        this.trace('halfClose called');\n        const halfCloseIndex = this.getNextBufferIndex();\n        this.writeBuffer.push({\n            entryType: 'HALF_CLOSE',\n            allocated: false,\n        });\n        for (const call of this.underlyingCalls) {\n            if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' &&\n                call.nextMessageToSend === halfCloseIndex) {\n                call.nextMessageToSend += 1;\n                call.call.halfClose();\n            }\n        }\n    }\n    setCredentials(newCredentials) {\n        throw new Error('Method not implemented.');\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.host;\n    }\n}\nexports.RetryingCall = RetryingCall;\n//# sourceMappingURL=retrying-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmV0cnlpbmctY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLDRCQUE0QixHQUFHLHNCQUFzQjtBQUM1RSxvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQywwRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxRQUFRLFFBQVEsTUFBTSxvQkFBb0Isb0JBQW9CO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsUUFBUSxNQUFNLHVCQUF1QixlQUFlO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFFBQVEsWUFBWSxnQkFBZ0Isb0JBQW9CLG9CQUFvQjtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDREQUE0RDtBQUN4RixxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsMkNBQTJDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXRyeWluZy1jYWxsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIyIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJldHJ5aW5nQ2FsbCA9IGV4cG9ydHMuTWVzc2FnZUJ1ZmZlclRyYWNrZXIgPSBleHBvcnRzLlJldHJ5VGhyb3R0bGVyID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3JldHJ5aW5nX2NhbGwnO1xuY2xhc3MgUmV0cnlUaHJvdHRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG1heFRva2VucywgdG9rZW5SYXRpbywgcHJldmlvdXNSZXRyeVRocm90dGxlcikge1xuICAgICAgICB0aGlzLm1heFRva2VucyA9IG1heFRva2VucztcbiAgICAgICAgdGhpcy50b2tlblJhdGlvID0gdG9rZW5SYXRpbztcbiAgICAgICAgaWYgKHByZXZpb3VzUmV0cnlUaHJvdHRsZXIpIHtcbiAgICAgICAgICAgIC8qIFdoZW4gY2Fycnlpbmcgb3ZlciB0b2tlbnMgZnJvbSBhIHByZXZpb3VzIGNvbmZpZywgcmVzY2FsZSB0aGVtIHRvIHRoZVxuICAgICAgICAgICAgICogbmV3IG1heCB2YWx1ZSAqL1xuICAgICAgICAgICAgdGhpcy50b2tlbnMgPVxuICAgICAgICAgICAgICAgIHByZXZpb3VzUmV0cnlUaHJvdHRsZXIudG9rZW5zICpcbiAgICAgICAgICAgICAgICAgICAgKG1heFRva2VucyAvIHByZXZpb3VzUmV0cnlUaHJvdHRsZXIubWF4VG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zID0gbWF4VG9rZW5zO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XG4gICAgICAgIHRoaXMudG9rZW5zID0gTWF0aC5tYXgodGhpcy50b2tlbnMgKyB0aGlzLnRva2VuUmF0aW8sIHRoaXMubWF4VG9rZW5zKTtcbiAgICB9XG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBNYXRoLm1pbih0aGlzLnRva2VucyAtIDEsIDApO1xuICAgIH1cbiAgICBjYW5SZXRyeUNhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VucyA+IHRoaXMubWF4VG9rZW5zIC8gMjtcbiAgICB9XG59XG5leHBvcnRzLlJldHJ5VGhyb3R0bGVyID0gUmV0cnlUaHJvdHRsZXI7XG5jbGFzcyBNZXNzYWdlQnVmZmVyVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IodG90YWxMaW1pdCwgbGltaXRQZXJDYWxsKSB7XG4gICAgICAgIHRoaXMudG90YWxMaW1pdCA9IHRvdGFsTGltaXQ7XG4gICAgICAgIHRoaXMubGltaXRQZXJDYWxsID0gbGltaXRQZXJDYWxsO1xuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkID0gMDtcbiAgICAgICAgdGhpcy5hbGxvY2F0ZWRQZXJDYWxsID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhbGxvY2F0ZShzaXplLCBjYWxsSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdXJyZW50UGVyQ2FsbCA9IChfYSA9IHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5nZXQoY2FsbElkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgaWYgKHRoaXMubGltaXRQZXJDYWxsIC0gY3VycmVudFBlckNhbGwgPCBzaXplIHx8XG4gICAgICAgICAgICB0aGlzLnRvdGFsTGltaXQgLSB0aGlzLnRvdGFsQWxsb2NhdGVkIDwgc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5zZXQoY2FsbElkLCBjdXJyZW50UGVyQ2FsbCArIHNpemUpO1xuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkICs9IHNpemU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmcmVlKHNpemUsIGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsQWxsb2NhdGVkIDwgc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1ZmZlciBhbGxvY2F0aW9uIHN0YXRlOiBjYWxsICR7Y2FsbElkfSBmcmVlZCAke3NpemV9ID4gdG90YWwgYWxsb2NhdGVkICR7dGhpcy50b3RhbEFsbG9jYXRlZH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGVkIC09IHNpemU7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQZXJDYWxsID0gKF9hID0gdGhpcy5hbGxvY2F0ZWRQZXJDYWxsLmdldChjYWxsSWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBpZiAoY3VycmVudFBlckNhbGwgPCBzaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgYnVmZmVyIGFsbG9jYXRpb24gc3RhdGU6IGNhbGwgJHtjYWxsSWR9IGZyZWVkICR7c2l6ZX0gPiBhbGxvY2F0ZWQgZm9yIGNhbGwgJHtjdXJyZW50UGVyQ2FsbH1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG9jYXRlZFBlckNhbGwuc2V0KGNhbGxJZCwgY3VycmVudFBlckNhbGwgLSBzaXplKTtcbiAgICB9XG4gICAgZnJlZUFsbChjYWxsSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjdXJyZW50UGVyQ2FsbCA9IChfYSA9IHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5nZXQoY2FsbElkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgaWYgKHRoaXMudG90YWxBbGxvY2F0ZWQgPCBjdXJyZW50UGVyQ2FsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJ1ZmZlciBhbGxvY2F0aW9uIHN0YXRlOiBjYWxsICR7Y2FsbElkfSBhbGxvY2F0ZWQgJHtjdXJyZW50UGVyQ2FsbH0gPiB0b3RhbCBhbGxvY2F0ZWQgJHt0aGlzLnRvdGFsQWxsb2NhdGVkfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG90YWxBbGxvY2F0ZWQgLT0gY3VycmVudFBlckNhbGw7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkUGVyQ2FsbC5kZWxldGUoY2FsbElkKTtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VCdWZmZXJUcmFja2VyID0gTWVzc2FnZUJ1ZmZlclRyYWNrZXI7XG5jb25zdCBQUkVWSU9OU19SUENfQVRURU1QVFNfTUVUQURBVEFfS0VZID0gJ2dycGMtcHJldmlvdXMtcnBjLWF0dGVtcHRzJztcbmNsYXNzIFJldHJ5aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbENvbmZpZywgbWV0aG9kTmFtZSwgaG9zdCwgY3JlZGVudGlhbHMsIGRlYWRsaW5lLCBjYWxsTnVtYmVyLCBidWZmZXJUcmFja2VyLCByZXRyeVRocm90dGxlcikge1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmNhbGxDb25maWcgPSBjYWxsQ29uZmlnO1xuICAgICAgICB0aGlzLm1ldGhvZE5hbWUgPSBtZXRob2ROYW1lO1xuICAgICAgICB0aGlzLmhvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuZGVhZGxpbmUgPSBkZWFkbGluZTtcbiAgICAgICAgdGhpcy5jYWxsTnVtYmVyID0gY2FsbE51bWJlcjtcbiAgICAgICAgdGhpcy5idWZmZXJUcmFja2VyID0gYnVmZmVyVHJhY2tlcjtcbiAgICAgICAgdGhpcy5yZXRyeVRocm90dGxlciA9IHJldHJ5VGhyb3R0bGVyO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbml0aWFsTWV0YWRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxscyA9IFtdO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb2Zmc2V0IG9mIG1lc3NhZ2UgaW5kaWNlcyBpbiB0aGUgd3JpdGVCdWZmZXIuIEZvciBleGFtcGxlLCBpZlxuICAgICAgICAgKiB3cml0ZUJ1ZmZlck9mZnNldCBpcyAxMCwgbWVzc2FnZSAxMCBpcyBpbiB3cml0ZUJ1ZmZlclswXSBhbmQgbWVzc2FnZSAxNVxuICAgICAgICAgKiBpcyBpbiB3cml0ZUJ1ZmZlcls1XS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIHdoZXRoZXIgYSByZWFkIGhhcyBiZWVuIHN0YXJ0ZWQsIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIHRvIHN0YXJ0XG4gICAgICAgICAqIHJlYWRzIG9uIG5ldyBjaGlsZCBjYWxscy4gVGhpcyBvbmx5IG1hdHRlcnMgZm9yIHRoZSBmaXJzdCByZWFkLCBiZWNhdXNlXG4gICAgICAgICAqIG9uY2UgYSBtZXNzYWdlIGNvbWVzIGluIHRoZSBjaGlsZCBjYWxsIGJlY29tZXMgY29tbWl0dGVkIGFuZCB0aGVyZSB3aWxsXG4gICAgICAgICAqIGJlIG5vIG5ldyBjaGlsZCBjYWxscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZFN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudFJldHJ5VXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTnVtYmVyIG9mIGF0dGVtcHRzIHNvIGZhclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMuaGVkZ2luZ1RpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPSBudWxsO1xuICAgICAgICB0aGlzLmluaXRpYWxSZXRyeUJhY2tvZmZTZWMgPSAwO1xuICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSAwO1xuICAgICAgICBpZiAoY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3kpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnUkVUUlknO1xuICAgICAgICAgICAgY29uc3QgcmV0cnlQb2xpY3kgPSBjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcbiAgICAgICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYyA9IE51bWJlcihyZXRyeVBvbGljeS5pbml0aWFsQmFja29mZi5zdWJzdHJpbmcoMCwgcmV0cnlQb2xpY3kuaW5pdGlhbEJhY2tvZmYubGVuZ3RoIC0gMSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnSEVER0lORyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gJ1RSQU5TUEFSRU5UX09OTFknO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxOdW1iZXI7XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxOdW1iZXIgKyAnXSAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJlcG9ydFN0YXR1cyhzdGF0dXNPYmplY3QpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnZW5kZWQgd2l0aCBzdGF0dXM6IGNvZGU9JyArXG4gICAgICAgICAgICBzdGF0dXNPYmplY3QuY29kZSArXG4gICAgICAgICAgICAnIGRldGFpbHM9XCInICtcbiAgICAgICAgICAgIHN0YXR1c09iamVjdC5kZXRhaWxzICtcbiAgICAgICAgICAgICdcIicpO1xuICAgICAgICB0aGlzLmJ1ZmZlclRyYWNrZXIuZnJlZUFsbCh0aGlzLmNhbGxOdW1iZXIpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ID0gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCArIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gRXhwbGljaXRseSBjb25zdHJ1Y3Qgc3RhdHVzIG9iamVjdCB0byByZW1vdmUgcHJvZ3Jlc3MgZmllbGRcbiAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblJlY2VpdmVTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNvZGU6IHN0YXR1c09iamVjdC5jb2RlLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHN0YXR1c09iamVjdC5kZXRhaWxzLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBzdGF0dXNPYmplY3QubWV0YWRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbmNlbFdpdGhTdGF0dXMgY29kZTogJyArIHN0YXR1cyArICcgZGV0YWlsczogXCInICsgZGV0YWlscyArICdcIicpO1xuICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyh7IGNvZGU6IHN0YXR1cywgZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSk7XG4gICAgICAgIGZvciAoY29uc3QgeyBjYWxsIH0gb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMpIHtcbiAgICAgICAgICAgIGNhbGwuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbW1pdHRlZENhbGxJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5kZXJseWluZ0NhbGxzW3RoaXMuY29tbWl0dGVkQ2FsbEluZGV4XS5jYWxsLmdldFBlZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QnVmZmVyRW50cnkobWVzc2FnZUluZGV4KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSB0aGlzLndyaXRlQnVmZmVyW21lc3NhZ2VJbmRleCAtIHRoaXMud3JpdGVCdWZmZXJPZmZzZXRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7XG4gICAgICAgICAgICBlbnRyeVR5cGU6ICdGUkVFRCcsXG4gICAgICAgICAgICBhbGxvY2F0ZWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TmV4dEJ1ZmZlckluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUJ1ZmZlck9mZnNldCArIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBjbGVhclNlbnRNZXNzYWdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXggPSB0aGlzLnVuZGVybHlpbmdDYWxsc1t0aGlzLmNvbW1pdHRlZENhbGxJbmRleF0ubmV4dE1lc3NhZ2VUb1NlbmQ7XG4gICAgICAgIGZvciAobGV0IG1lc3NhZ2VJbmRleCA9IHRoaXMud3JpdGVCdWZmZXJPZmZzZXQ7IG1lc3NhZ2VJbmRleCA8IGVhcmxpZXN0TmVlZGVkTWVzc2FnZUluZGV4OyBtZXNzYWdlSW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyRW50cnkgPSB0aGlzLmdldEJ1ZmZlckVudHJ5KG1lc3NhZ2VJbmRleCk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyRW50cnkuYWxsb2NhdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJUcmFja2VyLmZyZWUoYnVmZmVyRW50cnkubWVzc2FnZS5tZXNzYWdlLmxlbmd0aCwgdGhpcy5jYWxsTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gdGhpcy53cml0ZUJ1ZmZlci5zbGljZShlYXJsaWVzdE5lZWRlZE1lc3NhZ2VJbmRleCAtIHRoaXMud3JpdGVCdWZmZXJPZmZzZXQpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyT2Zmc2V0ID0gZWFybGllc3ROZWVkZWRNZXNzYWdlSW5kZXg7XG4gICAgfVxuICAgIGNvbW1pdENhbGwoaW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdDb21taXR0aW5nIGNhbGwgWycgK1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaW5kZXhdLmNhbGwuZ2V0Q2FsbE51bWJlcigpICtcbiAgICAgICAgICAgICddIGF0IGluZGV4ICcgK1xuICAgICAgICAgICAgaW5kZXgpO1xuICAgICAgICB0aGlzLnN0YXRlID0gJ0NPTU1JVFRFRCc7XG4gICAgICAgIHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy51bmRlcmx5aW5nQ2FsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2ldLnN0YXRlID09PSAnQ09NUExFVEVEJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbaV0uc3RhdGUgPSAnQ09NUExFVEVEJztcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2ldLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELCAnRGlzY2FyZGVkIGluIGZhdm9yIG9mIG90aGVyIGhlZGdlZCBhdHRlbXB0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclNlbnRNZXNzYWdlcygpO1xuICAgIH1cbiAgICBjb21taXRDYWxsV2l0aE1vc3RNZXNzYWdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdDT01NSVRURUQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1vc3RNZXNzYWdlcyA9IC0xO1xuICAgICAgICBsZXQgY2FsbFdpdGhNb3N0TWVzc2FnZXMgPSAtMTtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIGNoaWxkQ2FsbF0gb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRDYWxsLnN0YXRlID09PSAnQUNUSVZFJyAmJlxuICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA+IG1vc3RNZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIG1vc3RNZXNzYWdlcyA9IGNoaWxkQ2FsbC5uZXh0TWVzc2FnZVRvU2VuZDtcbiAgICAgICAgICAgICAgICBjYWxsV2l0aE1vc3RNZXNzYWdlcyA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsV2l0aE1vc3RNZXNzYWdlcyA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8qIFRoZXJlIGFyZSBubyBhY3RpdmUgY2FsbHMsIGRpc2FibGUgcmV0cmllcyB0byBmb3JjZSB0aGUgbmV4dCBjYWxsIHRoYXRcbiAgICAgICAgICAgICAqIGlzIHN0YXJ0ZWQgdG8gYmUgY29tbWl0dGVkLiAqL1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsV2l0aE1vc3RNZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNTdGF0dXNDb2RlSW5MaXN0KGxpc3QsIGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Quc29tZSh2YWx1ZSA9PiB2YWx1ZSA9PT0gY29kZSB8fFxuICAgICAgICAgICAgdmFsdWUudG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpID09PSBjb25zdGFudHNfMS5TdGF0dXNbY29kZV0udG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGdldE5leHRSZXRyeUJhY2tvZmZNcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXRyeVBvbGljeSA9IChfYSA9IHRoaXMuY2FsbENvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1ldGhvZENvbmZpZy5yZXRyeVBvbGljeTtcbiAgICAgICAgaWYgKCFyZXRyeVBvbGljeSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEJhY2tvZmZNcyA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgKiAxMDAwO1xuICAgICAgICBjb25zdCBtYXhCYWNrb2ZmU2VjID0gTnVtYmVyKHJldHJ5UG9saWN5Lm1heEJhY2tvZmYuc3Vic3RyaW5nKDAsIHJldHJ5UG9saWN5Lm1heEJhY2tvZmYubGVuZ3RoIC0gMSkpO1xuICAgICAgICB0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgPSBNYXRoLm1pbih0aGlzLm5leHRSZXRyeUJhY2tvZmZTZWMgKiByZXRyeVBvbGljeS5iYWNrb2ZmTXVsdGlwbGllciwgbWF4QmFja29mZlNlYyk7XG4gICAgICAgIHJldHVybiBuZXh0QmFja29mZk1zO1xuICAgIH1cbiAgICBtYXliZVJldHJ5Q2FsbChwdXNoYmFjaywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdSRVRSWScpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXRyeVBvbGljeSA9IHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3k7XG4gICAgICAgIGlmICh0aGlzLmF0dGVtcHRzID49IE1hdGgubWluKHJldHJ5UG9saWN5Lm1heEF0dGVtcHRzLCA1KSkge1xuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXRyeURlbGF5TXM7XG4gICAgICAgIGlmIChwdXNoYmFjayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0cnlEZWxheU1zID0gdGhpcy5nZXROZXh0UmV0cnlCYWNrb2ZmTXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwdXNoYmFjayA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSAnVFJBTlNQQVJFTlRfT05MWSc7XG4gICAgICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXRyeURlbGF5TXMgPSBwdXNoYmFjaztcbiAgICAgICAgICAgIHRoaXMubmV4dFJldHJ5QmFja29mZlNlYyA9IHRoaXMuaW5pdGlhbFJldHJ5QmFja29mZlNlYztcbiAgICAgICAgfVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ1JFVFJZJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKF9iID0gKF9hID0gdGhpcy5yZXRyeVRocm90dGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblJldHJ5Q2FsbCgpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnROZXdBdHRlbXB0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHJldHJ5RGVsYXlNcyk7XG4gICAgfVxuICAgIGNvdW50QWN0aXZlQ2FsbHMoKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbCBvZiB0aGlzLnVuZGVybHlpbmdDYWxscykge1xuICAgICAgICAgICAgaWYgKChjYWxsID09PSBudWxsIHx8IGNhbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGwuc3RhdGUpID09PSAnQUNUSVZFJykge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBoYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ0NPTU1JVFRFRCc6XG4gICAgICAgICAgICBjYXNlICdUUkFOU1BBUkVOVF9PTkxZJzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnSEVER0lORyc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0dXNDb2RlSW5MaXN0KChfYSA9IHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeS5ub25GYXRhbFN0YXR1c0NvZGVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSwgc3RhdHVzLmNvZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYiA9IHRoaXMucmV0cnlUaHJvdHRsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZWxheU1zO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHVzaGJhY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5TXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHB1c2hiYWNrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9ICdUUkFOU1BBUkVOVF9PTkxZJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5TXMgPSBwdXNoYmFjaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdBdHRlbXB0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhZnRlciB0cnlpbmcgdG8gc3RhcnQgYSBjYWxsIHRoZXJlIGFyZSBubyBhY3RpdmUgY2FsbHMsIHRoaXMgd2FzIHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY291bnRBY3RpdmVDYWxscygpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXlNcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdENhbGwoY2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdSRVRSWSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdGF0dXNDb2RlSW5MaXN0KHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcucmV0cnlQb2xpY3kucmV0cnlhYmxlU3RhdHVzQ29kZXMsIHN0YXR1cy5jb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1heWJlUmV0cnlDYWxsKHB1c2hiYWNrLCByZXRyaWVkID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmV0cmllZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFB1c2hiYWNrKG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IG1kVmFsdWUgPSBtZXRhZGF0YS5nZXQoJ2dycGMtcmV0cnktcHVzaGJhY2stbXMnKTtcbiAgICAgICAgaWYgKG1kVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KG1kVmFsdWVbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlQ2hpbGRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdzdGF0ZT0nICtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgK1xuICAgICAgICAgICAgJyBoYW5kbGluZyBzdGF0dXMgd2l0aCBwcm9ncmVzcyAnICtcbiAgICAgICAgICAgIHN0YXR1cy5wcm9ncmVzcyArXG4gICAgICAgICAgICAnIGZyb20gY2hpbGQgWycgK1xuICAgICAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHNbY2FsbEluZGV4XS5jYWxsLmdldENhbGxOdW1iZXIoKSArXG4gICAgICAgICAgICAnXSBpbiBzdGF0ZSAnICtcbiAgICAgICAgICAgIHRoaXMudW5kZXJseWluZ0NhbGxzW2NhbGxJbmRleF0uc3RhdGUpO1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdDYWxsc1tjYWxsSW5kZXhdLnN0YXRlID0gJ0NPTVBMRVRFRCc7XG4gICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJldHJ5VGhyb3R0bGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGNhbGxJbmRleCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydFN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnQ09NTUlUVEVEJykge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdXNoYmFjayA9IHRoaXMuZ2V0UHVzaGJhY2soc3RhdHVzLm1ldGFkYXRhKTtcbiAgICAgICAgc3dpdGNoIChzdGF0dXMucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGNhc2UgJ05PVF9TVEFSVEVEJzpcbiAgICAgICAgICAgICAgICAvLyBSUEMgbmV2ZXIgbGVhdmVzIHRoZSBjbGllbnQsIGFsd2F5cyBzYWZlIHRvIHJldHJ5XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1JFRlVTRUQnOlxuICAgICAgICAgICAgICAgIC8vIFJQQyByZWFjaGVzIHRoZSBzZXJ2ZXIgbGlicmFyeSwgYnV0IG5vdCB0aGUgc2VydmVyIGFwcGxpY2F0aW9uIGxvZ2ljXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwYXJlbnRSZXRyeVVzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQcm9jZXNzZWRTdGF0dXMoc3RhdHVzLCBjYWxsSW5kZXgsIHB1c2hiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbnRSZXRyeVVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0RST1AnOlxuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChjYWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0U3RhdHVzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQUk9DRVNTRUQnOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUHJvY2Vzc2VkU3RhdHVzKHN0YXR1cywgY2FsbEluZGV4LCBwdXNoYmFjayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF5YmVTdGFydEhlZGdpbmdBdHRlbXB0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ0hFREdJTkcnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNhbGxDb25maWcubWV0aG9kQ29uZmlnLmhlZGdpbmdQb2xpY3kpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWRnaW5nUG9saWN5ID0gdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5O1xuICAgICAgICBpZiAodGhpcy5hdHRlbXB0cyA+PSBNYXRoLm1pbihoZWRnaW5nUG9saWN5Lm1heEF0dGVtcHRzLCA1KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgdGhpcy5zdGFydE5ld0F0dGVtcHQoKTtcbiAgICAgICAgdGhpcy5tYXliZVN0YXJ0SGVkZ2luZ1RpbWVyKCk7XG4gICAgfVxuICAgIG1heWJlU3RhcnRIZWRnaW5nVGltZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAodGhpcy5oZWRnaW5nVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmhlZGdpbmdUaW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdIRURHSU5HJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYWxsQ29uZmlnLm1ldGhvZENvbmZpZy5oZWRnaW5nUG9saWN5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVkZ2luZ1BvbGljeSA9IHRoaXMuY2FsbENvbmZpZy5tZXRob2RDb25maWcuaGVkZ2luZ1BvbGljeTtcbiAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdHMgPj0gTWF0aC5taW4oaGVkZ2luZ1BvbGljeS5tYXhBdHRlbXB0cywgNSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWRnaW5nRGVsYXlTdHJpbmcgPSAoX2EgPSBoZWRnaW5nUG9saWN5LmhlZGdpbmdEZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJzBzJztcbiAgICAgICAgY29uc3QgaGVkZ2luZ0RlbGF5U2VjID0gTnVtYmVyKGhlZGdpbmdEZWxheVN0cmluZy5zdWJzdHJpbmcoMCwgaGVkZ2luZ0RlbGF5U3RyaW5nLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgdGhpcy5oZWRnaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVTdGFydEhlZGdpbmdBdHRlbXB0KCk7XG4gICAgICAgIH0sIGhlZGdpbmdEZWxheVNlYyAqIDEwMDApO1xuICAgICAgICAoX2MgPSAoX2IgPSB0aGlzLmhlZGdpbmdUaW1lcikudW5yZWYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICB9XG4gICAgc3RhcnROZXdBdHRlbXB0KCkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY2hhbm5lbC5jcmVhdGVMb2FkQmFsYW5jaW5nQ2FsbCh0aGlzLmNhbGxDb25maWcsIHRoaXMubWV0aG9kTmFtZSwgdGhpcy5ob3N0LCB0aGlzLmNyZWRlbnRpYWxzLCB0aGlzLmRlYWRsaW5lKTtcbiAgICAgICAgdGhpcy50cmFjZSgnQ3JlYXRlZCBjaGlsZCBjYWxsIFsnICtcbiAgICAgICAgICAgIGNoaWxkLmdldENhbGxOdW1iZXIoKSArXG4gICAgICAgICAgICAnXSBmb3IgYXR0ZW1wdCAnICtcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdHMpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudW5kZXJseWluZ0NhbGxzLmxlbmd0aDtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nQ2FsbHMucHVzaCh7XG4gICAgICAgICAgICBzdGF0ZTogJ0FDVElWRScsXG4gICAgICAgICAgICBjYWxsOiBjaGlsZCxcbiAgICAgICAgICAgIG5leHRNZXNzYWdlVG9TZW5kOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJldmlvdXNBdHRlbXB0cyA9IHRoaXMuYXR0ZW1wdHMgLSAxO1xuICAgICAgICBjb25zdCBpbml0aWFsTWV0YWRhdGEgPSB0aGlzLmluaXRpYWxNZXRhZGF0YS5jbG9uZSgpO1xuICAgICAgICBpZiAocHJldmlvdXNBdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgIGluaXRpYWxNZXRhZGF0YS5zZXQoUFJFVklPTlNfUlBDX0FUVEVNUFRTX01FVEFEQVRBX0tFWSwgYCR7cHJldmlvdXNBdHRlbXB0c31gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjZWl2ZWRNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICBjaGlsZC5zdGFydChpbml0aWFsTWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiBtZXRhZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgbWV0YWRhdGEgZnJvbSBjaGlsZCBbJyArIGNoaWxkLmdldENhbGxOdW1iZXIoKSArICddJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXRDYWxsKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZWNlaXZlZE1ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNBdHRlbXB0cyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuc2V0KFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVksIGAke3ByZXZpb3VzQXR0ZW1wdHN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVuZGVybHlpbmdDYWxsc1tpbmRleF0uc3RhdGUgPT09ICdBQ1RJVkUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiBtZXNzYWdlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gY2hpbGQgWycgKyBjaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0Q2FsbChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudW5kZXJseWluZ0NhbGxzW2luZGV4XS5zdGF0ZSA9PT0gJ0FDVElWRScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXM6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc3RhdHVzIGZyb20gY2hpbGQgWycgKyBjaGlsZC5nZXRDYWxsTnVtYmVyKCkgKyAnXScpO1xuICAgICAgICAgICAgICAgIGlmICghcmVjZWl2ZWRNZXRhZGF0YSAmJiBwcmV2aW91c0F0dGVtcHRzID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMubWV0YWRhdGEuc2V0KFBSRVZJT05TX1JQQ19BVFRFTVBUU19NRVRBREFUQV9LRVksIGAke3ByZXZpb3VzQXR0ZW1wdHN9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRTdGF0dXMoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kTmV4dENoaWxkTWVzc2FnZShpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLnJlYWRTdGFydGVkKSB7XG4gICAgICAgICAgICBjaGlsZC5zdGFydFJlYWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnc3RhcnQgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5pbml0aWFsTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5hdHRlbXB0cyArPSAxO1xuICAgICAgICB0aGlzLnN0YXJ0TmV3QXR0ZW1wdCgpO1xuICAgICAgICB0aGlzLm1heWJlU3RhcnRIZWRnaW5nVGltZXIoKTtcbiAgICB9XG4gICAgaGFuZGxlQ2hpbGRXcml0ZUNvbXBsZXRlZChjaGlsZEluZGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoaWxkQ2FsbCA9IHRoaXMudW5kZXJseWluZ0NhbGxzW2NoaWxkSW5kZXhdO1xuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQ7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuZ2V0QnVmZmVyRW50cnkobWVzc2FnZUluZGV4KSkuY2FsbGJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbnRNZXNzYWdlcygpO1xuICAgICAgICBjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQgKz0gMTtcbiAgICAgICAgdGhpcy5zZW5kTmV4dENoaWxkTWVzc2FnZShjaGlsZEluZGV4KTtcbiAgICB9XG4gICAgc2VuZE5leHRDaGlsZE1lc3NhZ2UoY2hpbGRJbmRleCkge1xuICAgICAgICBjb25zdCBjaGlsZENhbGwgPSB0aGlzLnVuZGVybHlpbmdDYWxsc1tjaGlsZEluZGV4XTtcbiAgICAgICAgaWYgKGNoaWxkQ2FsbC5zdGF0ZSA9PT0gJ0NPTVBMRVRFRCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZXRCdWZmZXJFbnRyeShjaGlsZENhbGwubmV4dE1lc3NhZ2VUb1NlbmQpKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJFbnRyeSA9IHRoaXMuZ2V0QnVmZmVyRW50cnkoY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kKTtcbiAgICAgICAgICAgIHN3aXRjaCAoYnVmZmVyRW50cnkuZW50cnlUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTUVTU0FHRSc6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5jYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkV3JpdGVDb21wbGV0ZWQoY2hpbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCBidWZmZXJFbnRyeS5tZXNzYWdlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdIQUxGX0NMT1NFJzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRDYWxsLm5leHRNZXNzYWdlVG9TZW5kICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkQ2FsbC5jYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdGUkVFRCc6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3QgYmUgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCB3cml0ZU9iaiA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBmbGFnczogY29udGV4dC5mbGFncyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gdGhpcy5nZXROZXh0QnVmZmVySW5kZXgoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyRW50cnkgPSB7XG4gICAgICAgICAgICBlbnRyeVR5cGU6ICdNRVNTQUdFJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IHdyaXRlT2JqLFxuICAgICAgICAgICAgYWxsb2NhdGVkOiB0aGlzLmJ1ZmZlclRyYWNrZXIuYWxsb2NhdGUobWVzc2FnZS5sZW5ndGgsIHRoaXMuY2FsbE51bWJlciksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChidWZmZXJFbnRyeSk7XG4gICAgICAgIGlmIChidWZmZXJFbnRyeS5hbGxvY2F0ZWQpIHtcbiAgICAgICAgICAgIChfYSA9IGNvbnRleHQuY2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbnRleHQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbY2FsbEluZGV4LCBjYWxsXSBvZiB0aGlzLnVuZGVybHlpbmdDYWxscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbC5zdGF0ZSA9PT0gJ0FDVElWRScgJiZcbiAgICAgICAgICAgICAgICAgICAgY2FsbC5uZXh0TWVzc2FnZVRvU2VuZCA9PT0gbWVzc2FnZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKGNhbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdENhbGxXaXRoTW9zdE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAvLyBjb21taXRDYWxsV2l0aE1vc3RNZXNzYWdlcyBjYW4gZmFpbCBpZiB3ZSBhcmUgYmV0d2VlbiBwaW5nIGF0dGVtcHRzXG4gICAgICAgICAgICBpZiAodGhpcy5jb21taXR0ZWRDYWxsSW5kZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYWxsID0gdGhpcy51bmRlcmx5aW5nQ2FsbHNbdGhpcy5jb21taXR0ZWRDYWxsSW5kZXhdO1xuICAgICAgICAgICAgYnVmZmVyRW50cnkuY2FsbGJhY2sgPSBjb250ZXh0LmNhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKGNhbGwuc3RhdGUgPT09ICdBQ1RJVkUnICYmIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgPT09IG1lc3NhZ2VJbmRleCkge1xuICAgICAgICAgICAgICAgIGNhbGwuY2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZFdyaXRlQ29tcGxldGVkKHRoaXMuY29tbWl0dGVkQ2FsbEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydFJlYWQoKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3N0YXJ0UmVhZCBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy5yZWFkU3RhcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgdW5kZXJseWluZ0NhbGwgb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMpIHtcbiAgICAgICAgICAgIGlmICgodW5kZXJseWluZ0NhbGwgPT09IG51bGwgfHwgdW5kZXJseWluZ0NhbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuZGVybHlpbmdDYWxsLnN0YXRlKSA9PT0gJ0FDVElWRScpIHtcbiAgICAgICAgICAgICAgICB1bmRlcmx5aW5nQ2FsbC5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnaGFsZkNsb3NlIGNhbGxlZCcpO1xuICAgICAgICBjb25zdCBoYWxmQ2xvc2VJbmRleCA9IHRoaXMuZ2V0TmV4dEJ1ZmZlckluZGV4KCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaCh7XG4gICAgICAgICAgICBlbnRyeVR5cGU6ICdIQUxGX0NMT1NFJyxcbiAgICAgICAgICAgIGFsbG9jYXRlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy51bmRlcmx5aW5nQ2FsbHMpIHtcbiAgICAgICAgICAgIGlmICgoY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnN0YXRlKSA9PT0gJ0FDVElWRScgJiZcbiAgICAgICAgICAgICAgICBjYWxsLm5leHRNZXNzYWdlVG9TZW5kID09PSBoYWxmQ2xvc2VJbmRleCkge1xuICAgICAgICAgICAgICAgIGNhbGwubmV4dE1lc3NhZ2VUb1NlbmQgKz0gMTtcbiAgICAgICAgICAgICAgICBjYWxsLmNhbGwuaGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMobmV3Q3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2Qgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICBnZXRNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1ldGhvZE5hbWU7XG4gICAgfVxuICAgIGdldEhvc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3Q7XG4gICAgfVxufVxuZXhwb3J0cy5SZXRyeWluZ0NhbGwgPSBSZXRyeWluZ0NhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeWluZy1jYWxsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/retrying-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst error_1 = __webpack_require__(/*! ./error */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/error.js\");\nconst TRACER_NAME = 'server_call';\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001,\n};\nconst defaultCompressionHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n    [GRPC_ENCODING_HEADER]: 'identity',\n};\nconst defaultResponseHeaders = {\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true,\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request) {\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize, encoding) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on('error', err => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    _write(chunk, encoding, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once('drain', callback);\n                return;\n            }\n        }\n        catch (err) {\n            this.emit('error', {\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL,\n            });\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: 'OK',\n            metadata: this.trailingMetadata,\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize, encoding) {\n        super({ objectMode: true });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n        this.on('error', err => {\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read =\n    ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n    ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n    ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options) {\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.cancelled = false;\n        this.deadlineTimer = null;\n        this.statusSent = false;\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once('error', (err) => {\n            /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */\n        });\n        this.stream.once('close', () => {\n            var _a;\n            trace('Request to method ' +\n                ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n                ' stream closed with rstCode ' +\n                this.stream.rstCode);\n            if (!this.statusSent) {\n                this.cancelled = true;\n                this.emit('cancelled', 'cancelled');\n                this.emit('streamEnd', false);\n                this.sendStatus({\n                    code: constants_1.Status.CANCELLED,\n                    details: 'Cancelled by client',\n                    metadata: null,\n                });\n                if (this.deadlineTimer)\n                    clearTimeout(this.deadlineTimer);\n            }\n        });\n        this.stream.on('drain', () => {\n            this.emit('drain');\n        });\n        if ('grpc.max_send_message_length' in options) {\n            this.maxSendMessageSize = options['grpc.max_send_message_length'];\n        }\n        if ('grpc.max_receive_message_length' in options) {\n            this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n        }\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */\n        if (this.stream.destroyed || this.stream.closed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    getDecompressedMessage(message, encoding) {\n        const messageContents = message.subarray(5);\n        if (encoding === 'identity') {\n            return messageContents;\n        }\n        else if (encoding === 'deflate' || encoding === 'gzip') {\n            let decompresser;\n            if (encoding === 'deflate') {\n                decompresser = zlib.createInflate();\n            }\n            else {\n                decompresser = zlib.createGunzip();\n            }\n            return new Promise((resolve, reject) => {\n                let totalLength = 0;\n                const messageParts = [];\n                decompresser.on('data', (chunk) => {\n                    messageParts.push(chunk);\n                    totalLength += chunk.byteLength;\n                    if (this.maxReceiveMessageSize !== -1 && totalLength > this.maxReceiveMessageSize) {\n                        decompresser.destroy();\n                        reject({\n                            code: constants_1.Status.RESOURCE_EXHAUSTED,\n                            details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`\n                        });\n                    }\n                });\n                decompresser.on('end', () => {\n                    resolve(Buffer.concat(messageParts));\n                });\n                decompresser.write(messageContents);\n                decompresser.end();\n            });\n        }\n        else {\n            return Promise.reject({\n                code: constants_1.Status.UNIMPLEMENTED,\n                details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n            });\n        }\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace('Request to ' +\n                this.handler.path +\n                ' received headers ' +\n                JSON.stringify(metadata.toJSON()));\n        }\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error('Invalid deadline');\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return metadata;\n            }\n            const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove('grpc-accept-encoding');\n        return metadata;\n    }\n    receiveUnaryMessage(encoding) {\n        return new Promise((resolve, reject) => {\n            const { stream } = this;\n            let receivedLength = 0;\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const call = this;\n            const body = [];\n            const limit = this.maxReceiveMessageSize;\n            this.stream.on('data', onData);\n            this.stream.on('end', onEnd);\n            this.stream.on('error', onEnd);\n            function onData(chunk) {\n                receivedLength += chunk.byteLength;\n                if (limit !== -1 && receivedLength > limit) {\n                    stream.removeListener('data', onData);\n                    stream.removeListener('end', onEnd);\n                    stream.removeListener('error', onEnd);\n                    reject({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${receivedLength} vs. ${limit})`,\n                    });\n                    return;\n                }\n                body.push(chunk);\n            }\n            function onEnd(err) {\n                stream.removeListener('data', onData);\n                stream.removeListener('end', onEnd);\n                stream.removeListener('error', onEnd);\n                if (err !== undefined) {\n                    reject({ code: constants_1.Status.INTERNAL, details: err.message });\n                    return;\n                }\n                if (receivedLength === 0) {\n                    reject({\n                        code: constants_1.Status.INTERNAL,\n                        details: 'received empty unary message',\n                    });\n                    return;\n                }\n                call.emit('receiveMessage');\n                const requestBytes = Buffer.concat(body, receivedLength);\n                const compressed = requestBytes.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : 'identity';\n                const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n                if (Buffer.isBuffer(decompressedMessage)) {\n                    resolve(call.deserializeMessageWithInternalError(decompressedMessage));\n                    return;\n                }\n                decompressedMessage.then(decompressed => resolve(call.deserializeMessageWithInternalError(decompressed)), (err) => reject(err.code\n                    ? err\n                    : {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n                    }));\n            }\n        });\n    }\n    async deserializeMessageWithInternalError(buffer) {\n        try {\n            return this.deserializeMessage(buffer);\n        }\n        catch (err) {\n            throw {\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL,\n            };\n        }\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        return this.handler.deserialize(bytes);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (metadata === undefined) {\n            metadata = null;\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({ code: constants_1.Status.OK, details: 'OK', metadata });\n        }\n        catch (err) {\n            this.sendError({\n                details: (0, error_1.getErrorMessage)(err),\n                code: constants_1.Status.INTERNAL,\n            });\n        }\n    }\n    sendStatus(statusObj) {\n        var _a, _b;\n        this.emit('callEnd', statusObj.code);\n        this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace('Request to method ' +\n            ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) +\n            ' ended with status code: ' +\n            constants_1.Status[statusObj.code] +\n            ' details: ' +\n            statusObj.details);\n        if (this.deadlineTimer)\n            clearTimeout(this.deadlineTimer);\n        if (this.stream.headersSent) {\n            if (!this.wantTrailers) {\n                this.wantTrailers = true;\n                this.stream.once('wantTrailers', () => {\n                    var _a;\n                    const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                    this.stream.sendTrailers(trailersToSend);\n                    this.statusSent = true;\n                });\n                this.stream.end();\n            }\n        }\n        else {\n            // Trailers-only response\n            const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, defaultResponseHeaders), (_b = statusObj.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\n            this.stream.respond(trailersToSend, { endStream: true });\n            this.statusSent = true;\n        }\n    }\n    sendError(error) {\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: 'message' in error ? error.message : 'Unknown Error',\n            metadata: 'metadata' in error && error.metadata !== undefined\n                ? error.metadata\n                : null,\n        };\n        if ('code' in error &&\n            typeof error.code === 'number' &&\n            Number.isInteger(error.code)) {\n            status.code = error.code;\n            if ('details' in error && typeof error.details === 'string') {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 &&\n            chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n            });\n            return;\n        }\n        this.sendMetadata();\n        this.emit('sendMessage');\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once('cancelled', reason => {\n            call.cancelled = true;\n            call.emit('cancelled', reason);\n        });\n        this.once('callEnd', status => call.emit('callEnd', status));\n    }\n    setupReadable(readable, encoding) {\n        const decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);\n        let readsDone = false;\n        let pendingMessageProcessing = false;\n        let pushedEnd = false;\n        const maybePushEnd = async () => {\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n                pushedEnd = true;\n                await this.pushOrBufferMessage(readable, null);\n            }\n        };\n        this.stream.on('data', async (data) => {\n            let messages;\n            try {\n                messages = decoder.write(data);\n            }\n            catch (e) {\n                this.sendError({\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: e.message\n                });\n                return;\n            }\n            pendingMessageProcessing = true;\n            this.stream.pause();\n            for (const message of messages) {\n                this.emit('receiveMessage');\n                const compressed = message.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : 'identity';\n                let decompressedMessage;\n                try {\n                    decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n                }\n                catch (e) {\n                    this.sendError(e);\n                    return;\n                }\n                // Encountered an error with decompression; it'll already have been propogated back\n                // Just return early\n                if (!decompressedMessage)\n                    return;\n                await this.pushOrBufferMessage(readable, decompressedMessage);\n            }\n            pendingMessageProcessing = false;\n            this.stream.resume();\n            await maybePushEnd();\n        });\n        this.stream.once('end', async () => {\n            readsDone = true;\n            await maybePushEnd();\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while (this.messagesToPush.length > 0) {\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    async pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        }\n        else {\n            await this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            trace('Received end of stream');\n            if (this.canPush) {\n                readable.push(null);\n            }\n            else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        trace('Received message of length ' + messageBytes.length);\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            }\n            else {\n                this.messagesToPush.push(deserialized);\n            }\n        }\n        catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            let code = (0, error_1.getErrorCode)(error);\n            if (code === null || code < constants_1.Status.OK || code > constants_1.Status.UNAUTHENTICATED) {\n                code = constants_1.Status.INTERNAL;\n            }\n            readable.emit('error', {\n                details: (0, error_1.getErrorMessage)(error),\n                code: code,\n            });\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            await this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        var _a;\n        const socket = (_a = this.stream.session) === null || _a === void 0 ? void 0 : _a.socket;\n        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            }\n            else {\n                return socket.remoteAddress;\n            }\n        }\n        else {\n            return 'unknown';\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getPath() {\n        return this.handler.path;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error('Deadline exceeded');\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit('cancelled', 'deadline');\n}\n//# sourceMappingURL=server-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkIsR0FBRyw4QkFBOEIsR0FBRyxnQ0FBZ0MsR0FBRyxnQ0FBZ0MsR0FBRywyQkFBMkI7QUFDbEssaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsY0FBYyxtQkFBTyxDQUFDLG9CQUFPO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDJCQUEyQjtBQUM1SCx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLFNBQVM7QUFDNUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsZ0JBQWdCLE1BQU0sTUFBTTtBQUNsRyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlEQUF5RDtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLFNBQVMsUUFBUSxVQUFVO0FBQ2hHLHFCQUFxQjtBQUNyQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0RBQXNEO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsMkZBQTJGO0FBQ3RKO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwyRkFBMkY7QUFDNUosa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWMsTUFBTSx3QkFBd0I7QUFDdEcsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUIsR0FBRyxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtID0gZXhwb3J0cy5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBzdHJlYW1fZGVjb2Rlcl8xID0gcmVxdWlyZShcIi4vc3RyZWFtLWRlY29kZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGVycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvclwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3NlcnZlcl9jYWxsJztcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSID0gJ2dycGMtYWNjZXB0LWVuY29kaW5nJztcbmNvbnN0IEdSUENfRU5DT0RJTkdfSEVBREVSID0gJ2dycGMtZW5jb2RpbmcnO1xuY29uc3QgR1JQQ19NRVNTQUdFX0hFQURFUiA9ICdncnBjLW1lc3NhZ2UnO1xuY29uc3QgR1JQQ19TVEFUVVNfSEVBREVSID0gJ2dycGMtc3RhdHVzJztcbmNvbnN0IEdSUENfVElNRU9VVF9IRUFERVIgPSAnZ3JwYy10aW1lb3V0JztcbmNvbnN0IERFQURMSU5FX1JFR0VYID0gLyhcXGR7MSw4fSlcXHMqKFtITVNtdW5dKS87XG5jb25zdCBkZWFkbGluZVVuaXRzVG9NcyA9IHtcbiAgICBIOiAzNjAwMDAwLFxuICAgIE06IDYwMDAwLFxuICAgIFM6IDEwMDAsXG4gICAgbTogMSxcbiAgICB1OiAwLjAwMSxcbiAgICBuOiAwLjAwMDAwMSxcbn07XG5jb25zdCBkZWZhdWx0Q29tcHJlc3Npb25IZWFkZXJzID0ge1xuICAgIC8vIFRPRE8oY2ppaHJpZyk6IFJlbW92ZSB0aGVzZSBlbmNvZGluZyBoZWFkZXJzIGZyb20gdGhlIGRlZmF1bHQgcmVzcG9uc2VcbiAgICAvLyBvbmNlIGNvbXByZXNzaW9uIGlzIGludGVncmF0ZWQuXG4gICAgW0dSUENfQUNDRVBUX0VOQ09ESU5HX0hFQURFUl06ICdpZGVudGl0eSxkZWZsYXRlLGd6aXAnLFxuICAgIFtHUlBDX0VOQ09ESU5HX0hFQURFUl06ICdpZGVudGl0eScsXG59O1xuY29uc3QgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyA9IHtcbiAgICBbaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9TVEFUVVNdOiBodHRwMi5jb25zdGFudHMuSFRUUF9TVEFUVVNfT0ssXG4gICAgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFXTogJ2FwcGxpY2F0aW9uL2dycGMrcHJvdG8nLFxufTtcbmNvbnN0IGRlZmF1bHRSZXNwb25zZU9wdGlvbnMgPSB7XG4gICAgd2FpdEZvclRyYWlsZXJzOiB0cnVlLFxufTtcbmNsYXNzIFNlcnZlclVuYXJ5Q2FsbEltcGwgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCByZXF1ZXN0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlclVuYXJ5Q2FsbEltcGwgPSBTZXJ2ZXJVbmFyeUNhbGxJbXBsO1xuY2xhc3MgU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuUmVhZGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCBkZXNlcmlhbGl6ZSwgZW5jb2RpbmcpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFJlYWRhYmxlKHRoaXMsIGVuY29kaW5nKTtcbiAgICB9XG4gICAgX3JlYWQoc2l6ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbC5jb25zdW1lVW5wdXNoZWRNZXNzYWdlcyh0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbC5yZXN1bWUoKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldERlYWRsaW5lKCk7XG4gICAgfVxuICAgIGdldFBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGF0aCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsID0gU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCBzZXJpYWxpemUsIHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLmNhbGwuc2VyaWFsaXplTWVzc2FnZShjaHVuayk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FsbC53cml0ZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwub25jZSgnZHJhaW4nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZGV0YWlsczogKDAsIGVycm9yXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnIpLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIF9maW5hbChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICBkZXRhaWxzOiAnT0snLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMudHJhaWxpbmdNZXRhZGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGVuZChtZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMudHJhaWxpbmdNZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlci5lbmQoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCA9IFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIFNlcnZlckR1cGxleFN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5EdXBsZXgge1xuICAgIGNvbnN0cnVjdG9yKGNhbGwsIG1ldGFkYXRhLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBlbmNvZGluZykge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuY2FsbCA9IGNhbGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFJlYWRhYmxlKHRoaXMsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBlbmQobWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZW5kKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsID0gU2VydmVyRHVwbGV4U3RyZWFtSW1wbDtcblNlcnZlckR1cGxleFN0cmVhbUltcGwucHJvdG90eXBlLl9yZWFkID1cbiAgICBTZXJ2ZXJSZWFkYWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl9yZWFkO1xuU2VydmVyRHVwbGV4U3RyZWFtSW1wbC5wcm90b3R5cGUuX3dyaXRlID1cbiAgICBTZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwucHJvdG90eXBlLl93cml0ZTtcblNlcnZlckR1cGxleFN0cmVhbUltcGwucHJvdG90eXBlLl9maW5hbCA9XG4gICAgU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsLnByb3RvdHlwZS5fZmluYWw7XG4vLyBJbnRlcm5hbCBjbGFzcyB0aGF0IHdyYXBzIHRoZSBIVFRQMiByZXF1ZXN0LlxuY2xhc3MgSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJlYW0sIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdHVzU2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlYWRsaW5lID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMud2FudFRyYWlsZXJzID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWV0YWRhdGFTZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXJlZE1lc3NhZ2VzID0gW107XG4gICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2ggPSBbXTtcbiAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgLyogV2UgbmVlZCBhbiBlcnJvciBoYW5kbGVyIHRvIGF2b2lkIHVuY2F1Z2h0IGVycm9yIGV2ZW50IGV4Y2VwdGlvbnMsIGJ1dFxuICAgICAgICAgICAgICogdGhlcmUgaXMgbm90aGluZyB3ZSBjYW4gcmVhc29uYWJseSBkbyBoZXJlLiBBbnkgZXJyb3IgZXZlbnQgc2hvdWxkXG4gICAgICAgICAgICAgKiBoYXZlIGEgY29ycmVzcG9uZGluZyBjbG9zZSBldmVudCwgd2hpY2ggaGFuZGxlcyBlbWl0dGluZyB0aGUgY2FuY2VsbGVkXG4gICAgICAgICAgICAgKiBldmVudC4gQW5kIHRoZSBzdHJlYW0gaXMgbm93IGluIGEgYmFkIHN0YXRlLCBzbyB3ZSBjYW4ndCByZWFzb25hYmx5XG4gICAgICAgICAgICAgKiBleHBlY3QgdG8gYmUgYWJsZSB0byBzZW5kIGFuIGVycm9yIG92ZXIgaXQuICovXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICtcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5oYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkgK1xuICAgICAgICAgICAgICAgICcgc3RyZWFtIGNsb3NlZCB3aXRoIHJzdENvZGUgJyArXG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucnN0Q29kZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhdHVzU2VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2NhbmNlbGxlZCcsICdjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3N0cmVhbUVuZCcsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAnQ2FuY2VsbGVkIGJ5IGNsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlYWRsaW5lVGltZXIpXG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRlYWRsaW5lVGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub24oJ2RyYWluJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQ2FuY2VsbGVkKCkge1xuICAgICAgICAvKiBJbiBzb21lIGNhc2VzIHRoZSBzdHJlYW0gY2FuIGJlY29tZSBkZXN0cm95ZWQgYmVmb3JlIHRoZSBjbG9zZSBldmVudFxuICAgICAgICAgKiBmaXJlcy4gVGhhdCBjcmVhdGVzIGEgcmFjZSBjb25kaXRpb24gdGhhdCB0aGlzIGNoZWNrIHdvcmtzIGFyb3VuZCAqL1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0uZGVzdHJveWVkIHx8IHRoaXMuc3RyZWFtLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhbmNlbGxlZDtcbiAgICB9XG4gICAgZ2V0RGVjb21wcmVzc2VkTWVzc2FnZShtZXNzYWdlLCBlbmNvZGluZykge1xuICAgICAgICBjb25zdCBtZXNzYWdlQ29udGVudHMgPSBtZXNzYWdlLnN1YmFycmF5KDUpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlQ29udGVudHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdkZWZsYXRlJyB8fCBlbmNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgICAgICBsZXQgZGVjb21wcmVzc2VyO1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSAnZGVmbGF0ZScpIHtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIgPSB6bGliLmNyZWF0ZUluZmxhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlciA9IHpsaWIuY3JlYXRlR3VuemlwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZVBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJ0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgdG90YWxMZW5ndGggKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplICE9PSAtMSAmJiB0b3RhbExlbmd0aCA+IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIHRoYXQgZGVjb21wcmVzc2VzIHRvIGEgc2l6ZSBsYXJnZXIgdGhhbiAke3RoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGVjb21wcmVzc2VyLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChtZXNzYWdlUGFydHMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIud3JpdGUobWVzc2FnZUNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICBkZWNvbXByZXNzZXIuZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgY29tcHJlc3NlZCB3aXRoIHVuc3VwcG9ydGVkIGVuY29kaW5nIFwiJHtlbmNvZGluZ31cImAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEoY3VzdG9tTWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhU2VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWV0YWRhdGFTZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY3VzdG9tID0gY3VzdG9tTWV0YWRhdGEgPyBjdXN0b21NZXRhZGF0YS50b0h0dHAySGVhZGVycygpIDogbnVsbDtcbiAgICAgICAgLy8gVE9ETyhjamlocmlnKTogSW5jbHVkZSBjb21wcmVzc2lvbiBoZWFkZXJzLlxuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRSZXNwb25zZUhlYWRlcnMpLCBkZWZhdWx0Q29tcHJlc3Npb25IZWFkZXJzKSwgY3VzdG9tKTtcbiAgICAgICAgdGhpcy5zdHJlYW0ucmVzcG9uZChoZWFkZXJzLCBkZWZhdWx0UmVzcG9uc2VPcHRpb25zKTtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKGhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIGlmIChsb2dnaW5nLmlzVHJhY2VyRW5hYmxlZChUUkFDRVJfTkFNRSkpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlci5wYXRoICtcbiAgICAgICAgICAgICAgICAnIHJlY2VpdmVkIGhlYWRlcnMgJyArXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEudG9KU09OKCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPKGNqaWhyaWcpOiBSZWNlaXZlIGNvbXByZXNzaW9uIG1ldGFkYXRhLlxuICAgICAgICBjb25zdCB0aW1lb3V0SGVhZGVyID0gbWV0YWRhdGEuZ2V0KEdSUENfVElNRU9VVF9IRUFERVIpO1xuICAgICAgICBpZiAodGltZW91dEhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRpbWVvdXRIZWFkZXJbMF0udG9TdHJpbmcoKS5tYXRjaChERUFETElORV9SRUdFWCk7XG4gICAgICAgICAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0ludmFsaWQgZGVhZGxpbmUnKTtcbiAgICAgICAgICAgICAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5PVVRfT0ZfUkFOR0U7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gKCttYXRjaFsxXSAqIGRlYWRsaW5lVW5pdHNUb01zW21hdGNoWzJdXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmUgPSBub3cuc2V0TWlsbGlzZWNvbmRzKG5vdy5nZXRNaWxsaXNlY29uZHMoKSArIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5kZWFkbGluZVRpbWVyID0gc2V0VGltZW91dChoYW5kbGVFeHBpcmVkRGVhZGxpbmUsIHRpbWVvdXQsIHRoaXMpO1xuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKEdSUENfVElNRU9VVF9IRUFERVIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBzZXZlcmFsIGhlYWRlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByb3BhZ2F0ZWQgdG8gdGhlIGFwcGxpY2F0aW9uXG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0FDQ0VQVF9FTkNPRElORyk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX1RFKTtcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKGh0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFKTtcbiAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLWFjY2VwdC1lbmNvZGluZycpO1xuICAgICAgICByZXR1cm4gbWV0YWRhdGE7XG4gICAgfVxuICAgIHJlY2VpdmVVbmFyeU1lc3NhZ2UoZW5jb2RpbmcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RyZWFtIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVkTGVuZ3RoID0gMDtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgY2FsbCA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gW107XG4gICAgICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ub24oJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ub24oJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uKCdlcnJvcicsIG9uRW5kKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uRGF0YShjaHVuaykge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkTGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSAtMSAmJiByZWNlaXZlZExlbmd0aCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FbmQpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtyZWNlaXZlZExlbmd0aH0gdnMuICR7bGltaXR9KWAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkucHVzaChjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvbkVuZChlcnIpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbkVuZCk7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7IGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgZGV0YWlsczogZXJyLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiAncmVjZWl2ZWQgZW1wdHkgdW5hcnkgbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGwuZW1pdCgncmVjZWl2ZU1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0Qnl0ZXMgPSBCdWZmZXIuY29uY2F0KGJvZHksIHJlY2VpdmVkTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gcmVxdWVzdEJ5dGVzLnJlYWRVSW50OCgwKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nID0gY29tcHJlc3NlZCA/IGVuY29kaW5nIDogJ2lkZW50aXR5JztcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZWRNZXNzYWdlID0gY2FsbC5nZXREZWNvbXByZXNzZWRNZXNzYWdlKHJlcXVlc3RCeXRlcywgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyk7XG4gICAgICAgICAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkZWNvbXByZXNzZWRNZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNhbGwuZGVzZXJpYWxpemVNZXNzYWdlV2l0aEludGVybmFsRXJyb3IoZGVjb21wcmVzc2VkTWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlY29tcHJlc3NlZE1lc3NhZ2UudGhlbihkZWNvbXByZXNzZWQgPT4gcmVzb2x2ZShjYWxsLmRlc2VyaWFsaXplTWVzc2FnZVdpdGhJbnRlcm5hbEVycm9yKGRlY29tcHJlc3NlZCkpLCAoZXJyKSA9PiByZWplY3QoZXJyLmNvZGVcbiAgICAgICAgICAgICAgICAgICAgPyBlcnJcbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgXCJncnBjLWVuY29kaW5nXCIgaGVhZGVyIFwiJHtlbmNvZGluZ31cIiBidXQgJHtlbmNvZGluZ30gZGVjb21wcmVzc2lvbiBmYWlsZWRgLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBkZXNlcmlhbGl6ZU1lc3NhZ2VXaXRoSW50ZXJuYWxFcnJvcihidWZmZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplTWVzc2FnZShidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVyciksXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXJpYWxpemVNZXNzYWdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXIgPSB0aGlzLmhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgLy8gVE9ETyhjamlocmlnKTogQ2FsbCBjb21wcmVzc2lvbiBhd2FyZSBzZXJpYWxpemVNZXNzYWdlKCkuXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBtZXNzYWdlQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlTGVuZ3RoICsgNSk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShieXRlTGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZUJ1ZmZlci5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGRlc2VyaWFsaXplTWVzc2FnZShieXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmRlc2VyaWFsaXplKGJ5dGVzKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFVuYXJ5TWVzc2FnZShlcnIsIHZhbHVlLCBtZXRhZGF0YSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCAnbWV0YWRhdGEnKSAmJiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGVyci5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy53cml0ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssIGRldGFpbHM6ICdPSycsIG1ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVyciksXG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZFN0YXR1cyhzdGF0dXNPYmopIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5lbWl0KCdjYWxsRW5kJywgc3RhdHVzT2JqLmNvZGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3N0cmVhbUVuZCcsIHN0YXR1c09iai5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spO1xuICAgICAgICBpZiAodGhpcy5jaGVja0NhbmNlbGxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ1JlcXVlc3QgdG8gbWV0aG9kICcgK1xuICAgICAgICAgICAgKChfYSA9IHRoaXMuaGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGgpICtcbiAgICAgICAgICAgICcgZW5kZWQgd2l0aCBzdGF0dXMgY29kZTogJyArXG4gICAgICAgICAgICBjb25zdGFudHNfMS5TdGF0dXNbc3RhdHVzT2JqLmNvZGVdICtcbiAgICAgICAgICAgICcgZGV0YWlsczogJyArXG4gICAgICAgICAgICBzdGF0dXNPYmouZGV0YWlscyk7XG4gICAgICAgIGlmICh0aGlzLmRlYWRsaW5lVGltZXIpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWFkbGluZVRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmhlYWRlcnNTZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud2FudFRyYWlsZXJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoJ3dhbnRUcmFpbGVycycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFpbGVyc1RvU2VuZCA9IE9iamVjdC5hc3NpZ24oeyBbR1JQQ19TVEFUVVNfSEVBREVSXTogc3RhdHVzT2JqLmNvZGUsIFtHUlBDX01FU1NBR0VfSEVBREVSXTogZW5jb2RlVVJJKHN0YXR1c09iai5kZXRhaWxzKSB9LCAoX2EgPSBzdGF0dXNPYmoubWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0h0dHAySGVhZGVycygpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0uc2VuZFRyYWlsZXJzKHRyYWlsZXJzVG9TZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNTZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyYWlsZXJzLW9ubHkgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJzVG9TZW5kID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgW0dSUENfU1RBVFVTX0hFQURFUl06IHN0YXR1c09iai5jb2RlLCBbR1JQQ19NRVNTQUdFX0hFQURFUl06IGVuY29kZVVSSShzdGF0dXNPYmouZGV0YWlscykgfSwgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyksIChfYiA9IHN0YXR1c09iai5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvSHR0cDJIZWFkZXJzKCkpO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVzcG9uZCh0cmFpbGVyc1RvU2VuZCwgeyBlbmRTdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c1NlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbmRFcnJvcihlcnJvcikge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgIGRldGFpbHM6ICdtZXNzYWdlJyBpbiBlcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBFcnJvcicsXG4gICAgICAgICAgICBtZXRhZGF0YTogJ21ldGFkYXRhJyBpbiBlcnJvciAmJiBlcnJvci5tZXRhZGF0YSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBlcnJvci5tZXRhZGF0YVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCdjb2RlJyBpbiBlcnJvciAmJlxuICAgICAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKGVycm9yLmNvZGUpKSB7XG4gICAgICAgICAgICBzdGF0dXMuY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgICAgICBpZiAoJ2RldGFpbHMnIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5kZXRhaWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzID0gZXJyb3IuZGV0YWlscztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRTdGF0dXMoc3RhdHVzKTtcbiAgICB9XG4gICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSAhPT0gLTEgJiZcbiAgICAgICAgICAgIGNodW5rLmxlbmd0aCA+IHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiBgU2VudCBtZXNzYWdlIGxhcmdlciB0aGFuIG1heCAoJHtjaHVuay5sZW5ndGh9IHZzLiAke3RoaXMubWF4U2VuZE1lc3NhZ2VTaXplfSlgLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kTWV0YWRhdGEoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzZW5kTWVzc2FnZScpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0ud3JpdGUoY2h1bmspO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgICBzZXR1cFN1cmZhY2VDYWxsKGNhbGwpIHtcbiAgICAgICAgdGhpcy5vbmNlKCdjYW5jZWxsZWQnLCByZWFzb24gPT4ge1xuICAgICAgICAgICAgY2FsbC5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbC5lbWl0KCdjYW5jZWxsZWQnLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmNlKCdjYWxsRW5kJywgc3RhdHVzID0+IGNhbGwuZW1pdCgnY2FsbEVuZCcsIHN0YXR1cykpO1xuICAgIH1cbiAgICBzZXR1cFJlYWRhYmxlKHJlYWRhYmxlLCBlbmNvZGluZykge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IHN0cmVhbV9kZWNvZGVyXzEuU3RyZWFtRGVjb2Rlcih0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSk7XG4gICAgICAgIGxldCByZWFkc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcHVzaGVkRW5kID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1heWJlUHVzaEVuZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGlmICghcHVzaGVkRW5kICYmIHJlYWRzRG9uZSAmJiAhcGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVkRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnB1c2hPckJ1ZmZlck1lc3NhZ2UocmVhZGFibGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0cmVhbS5vbignZGF0YScsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gZGVjb2Rlci53cml0ZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVjZWl2ZU1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkID0gbWVzc2FnZS5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZE1lc3NhZ2VFbmNvZGluZyA9IGNvbXByZXNzZWQgPyBlbmNvZGluZyA6ICdpZGVudGl0eSc7XG4gICAgICAgICAgICAgICAgbGV0IGRlY29tcHJlc3NlZE1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb21wcmVzc2VkTWVzc2FnZSA9IGF3YWl0IHRoaXMuZ2V0RGVjb21wcmVzc2VkTWVzc2FnZShtZXNzYWdlLCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRW5jb3VudGVyZWQgYW4gZXJyb3Igd2l0aCBkZWNvbXByZXNzaW9uOyBpdCdsbCBhbHJlYWR5IGhhdmUgYmVlbiBwcm9wb2dhdGVkIGJhY2tcbiAgICAgICAgICAgICAgICAvLyBKdXN0IHJldHVybiBlYXJseVxuICAgICAgICAgICAgICAgIGlmICghZGVjb21wcmVzc2VkTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucHVzaE9yQnVmZmVyTWVzc2FnZShyZWFkYWJsZSwgZGVjb21wcmVzc2VkTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgYXdhaXQgbWF5YmVQdXNoRW5kKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdlbmQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZWFkc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgYXdhaXQgbWF5YmVQdXNoRW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdW1lVW5wdXNoZWRNZXNzYWdlcyhyZWFkYWJsZSkge1xuICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xuICAgICAgICB3aGlsZSAodGhpcy5tZXNzYWdlc1RvUHVzaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMubWVzc2FnZXNUb1B1c2guc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhblB1c2ggPSByZWFkYWJsZS5wdXNoKG5leHRNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmIChuZXh0TWVzc2FnZSA9PT0gbnVsbCB8fCBjYW5QdXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuUHVzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNhblB1c2g7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hPckJ1ZmZlck1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcykge1xuICAgICAgICBpZiAodGhpcy5pc1B1c2hQZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwdXNoTWVzc2FnZShyZWFkYWJsZSwgbWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGlmIChtZXNzYWdlQnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWNlKCdSZWNlaXZlZCBlbmQgb2Ygc3RyZWFtJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XG4gICAgICAgICAgICAgICAgcmVhZGFibGUucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNUb1B1c2gucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUmVjZWl2ZWQgbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2VCeXRlcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkID0gYXdhaXQgdGhpcy5kZXNlcmlhbGl6ZU1lc3NhZ2UobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlYWRhYmxlLnB1c2goZGVzZXJpYWxpemVkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzVG9QdXNoLnB1c2goZGVzZXJpYWxpemVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgcmVtYWluaW5nIG1lc3NhZ2VzIHdoZW4gZXJyb3JzIG9jY3VyLlxuICAgICAgICAgICAgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBsZXQgY29kZSA9ICgwLCBlcnJvcl8xLmdldEVycm9yQ29kZSkoZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IG51bGwgfHwgY29kZSA8IGNvbnN0YW50c18xLlN0YXR1cy5PSyB8fCBjb2RlID4gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVVUSEVOVElDQVRFRCkge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkYWJsZS5lbWl0KCdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAoMCwgZXJyb3JfMS5nZXRFcnJvck1lc3NhZ2UpKGVycm9yKSxcbiAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcmVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wdXNoTWVzc2FnZShyZWFkYWJsZSwgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gKF9hID0gdGhpcy5zdHJlYW0uc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvY2tldDtcbiAgICAgICAgaWYgKHNvY2tldCA9PT0gbnVsbCB8fCBzb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvY2tldC5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LnJlbW90ZVBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c29ja2V0LnJlbW90ZUFkZHJlc3N9OiR7c29ja2V0LnJlbW90ZVBvcnR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlYWRsaW5lO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLnBhdGg7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMlNlcnZlckNhbGxTdHJlYW0gPSBIdHRwMlNlcnZlckNhbGxTdHJlYW07XG5mdW5jdGlvbiBoYW5kbGVFeHBpcmVkRGVhZGxpbmUoY2FsbCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignRGVhZGxpbmUgZXhjZWVkZWQnKTtcbiAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRDtcbiAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIGNhbGwuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBjYWxsLmVtaXQoJ2NhbmNlbGxlZCcsICdkZWFkbGluZScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerCredentials = void 0;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError('rootCerts must be null or a Buffer');\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError('keyCertPairs must be an array');\n        }\n        if (typeof checkClientCertificate !== 'boolean') {\n            throw new TypeError('checkClientCertificate must be a boolean');\n        }\n        const cert = [];\n        const key = [];\n        for (let i = 0; i < keyCertPairs.length; i++) {\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== 'object') {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            ca: rootCerts || (0, tls_helpers_1.getDefaultRootsData)() || undefined,\n            cert,\n            key,\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES,\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    _isSecure() {\n        return false;\n    }\n    _getSettings() {\n        return null;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(options) {\n        super();\n        this.options = options;\n    }\n    _isSecure() {\n        return true;\n    }\n    _getSettings() {\n        return this.options;\n    }\n}\n//# sourceMappingURL=server-credentials.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCO0FBQ3pCLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFlO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBLG1EQUFtRCxFQUFFO0FBQ3JEO0FBQ0E7QUFDQSxtREFBbUQsRUFBRTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlckNyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgdGxzX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Rscy1oZWxwZXJzXCIpO1xuY2xhc3MgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIHN0YXRpYyBjcmVhdGVJbnNlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVTc2wocm9vdENlcnRzLCBrZXlDZXJ0UGFpcnMsIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAocm9vdENlcnRzICE9PSBudWxsICYmICFCdWZmZXIuaXNCdWZmZXIocm9vdENlcnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm9vdENlcnRzIG11c3QgYmUgbnVsbCBvciBhIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlDZXJ0UGFpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXlDZXJ0UGFpcnMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaGVja0NsaWVudENlcnRpZmljYXRlIG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VydCA9IFtdO1xuICAgICAgICBjb25zdCBrZXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDZXJ0UGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBrZXlDZXJ0UGFpcnNbaV07XG4gICAgICAgICAgICBpZiAocGFpciA9PT0gbnVsbCB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBrZXlDZXJ0UGFpclske2l9XSBtdXN0IGJlIGFuIG9iamVjdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5wcml2YXRlX2tleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBrZXlDZXJ0UGFpclske2l9XS5wcml2YXRlX2tleSBtdXN0IGJlIGEgQnVmZmVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYWlyLmNlcnRfY2hhaW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0uY2VydF9jaGFpbiBtdXN0IGJlIGEgQnVmZmVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZXJ0LnB1c2gocGFpci5jZXJ0X2NoYWluKTtcbiAgICAgICAgICAgIGtleS5wdXNoKHBhaXIucHJpdmF0ZV9rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMoe1xuICAgICAgICAgICAgY2E6IHJvb3RDZXJ0cyB8fCAoMCwgdGxzX2hlbHBlcnNfMS5nZXREZWZhdWx0Um9vdHNEYXRhKSgpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlcnQsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICByZXF1ZXN0Q2VydDogY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSxcbiAgICAgICAgICAgIGNpcGhlcnM6IHRsc19oZWxwZXJzXzEuQ0lQSEVSX1NVSVRFUyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJDcmVkZW50aWFscyA9IFNlcnZlckNyZWRlbnRpYWxzO1xuY2xhc3MgSW5zZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2dldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5jbGFzcyBTZWN1cmVTZXJ2ZXJDcmVkZW50aWFscyBleHRlbmRzIFNlcnZlckNyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIF9pc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXItY3JlZGVudGlhbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = 'server';\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch(handlerType){\n        case 'unary':\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'clientStream':\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case 'serverStream':\n            return (call)=>{\n                call.emit('error', unimplementedStatusResponse);\n            };\n        case 'bidi':\n            return (call)=>{\n                call.emit('error', unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options){\n        var _a, _b, _c, _d;\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.shutdown = false;\n        this.serverAddressString = 'null';\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzServer)(()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Server created');\n        }\n        this.maxConnectionAgeMs = (_a = this.options['grpc.max_connection_age_ms']) !== null && _a !== void 0 ? _a : UNLIMITED_CONNECTION_AGE_MS;\n        this.maxConnectionAgeGraceMs = (_b = this.options['grpc.max_connection_age_grace_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n        this.keepaliveTimeMs = (_c = this.options['grpc.keepalive_time_ms']) !== null && _c !== void 0 ? _c : KEEPALIVE_MAX_TIME_MS;\n        this.keepaliveTimeoutMs = (_d = this.options['grpc.keepalive_timeout_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_TIMEOUT_MS;\n        this.trace('Server constructed');\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return ()=>{\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n                    remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n                };\n            } else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n    }\n    addProtoService() {\n        throw new Error('Not implemented. Use addService() instead');\n    }\n    addService(service, implementation) {\n        if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n            throw new Error('addService() requires two objects as arguments');\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error('Cannot add an empty service to a server');\n        }\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = 'bidi';\n                } else {\n                    methodType = 'clientStream';\n                }\n            } else {\n                if (attrs.responseStream) {\n                    methodType = 'serverStream';\n                } else {\n                    methodType = 'unary';\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === 'string') {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            } else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== 'object') {\n            throw new Error('removeService() requires object as argument');\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error('Not implemented. Use bindAsync() instead');\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (this.shutdown) {\n            throw new Error('bindAsync called after shutdown');\n        }\n        if (typeof port !== 'string') {\n            throw new TypeError('port must be a string');\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError('creds must be a ServerCredentials object');\n        }\n        if (typeof callback !== 'function') {\n            throw new TypeError('callback must be a function');\n        }\n        const initialPortUri = (0, uri_parser_1.parseUri)(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n        };\n        if ('grpc-node.max_session_memory' in this.options) {\n            serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */ serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if ('grpc.max_concurrent_streams' in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n            };\n        }\n        const deferredCallback = (error, port)=>{\n            process.nextTick(()=>callback(error, port));\n        };\n        const setupServer = ()=>{\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                secureServerOptions.enableTrace = this.options['grpc-node.tls_enable_trace'] === 1;\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on('secureConnection', (socket)=>{\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                     * according to https://github.com/nodejs/node/issues/35824 */ socket.on('error', (e)=>{\n                        this.trace('An incoming TLS connection closed with error: ' + e.message);\n                    });\n                });\n            } else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: portNum,\n                    count: previousCount\n                });\n            }\n            return Promise.all(addressList.map((address)=>{\n                this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n                let addr;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum\n                    };\n                } else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject)=>{\n                    const onError = (err)=>{\n                        this.trace('Failed to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address) + ' with error ' + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once('error', onError);\n                    http2Server.listen(addr, ()=>{\n                        if (this.shutdown) {\n                            http2Server.close();\n                            resolve(new Error('bindAsync failed because server is shutdown'));\n                            return;\n                        }\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === 'string') {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        } else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({\n                            server: http2Server,\n                            channelzRef: channelzRef\n                        });\n                        this.trace('Successfully bound ' + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                        resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener('error', onError);\n                    });\n                });\n            })).then((results)=>{\n                let count = 0;\n                for (const result of results){\n                    if (typeof result === 'number') {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error('Invalid state: multiple port numbers added from single address');\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount\n                };\n            });\n        };\n        const bindWildcardPort = (addressList)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: 0,\n                    count: 0\n                });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject)=>{\n                const onError = (err)=>{\n                    this.trace('Failed to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address) + ' with error ' + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once('error', onError);\n                http2Server.listen(address, ()=>{\n                    if (this.shutdown) {\n                        http2Server.close();\n                        resolve({\n                            port: 0,\n                            count: 0\n                        });\n                        return;\n                    }\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    const channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), ()=>{\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({\n                        server: http2Server,\n                        channelzRef: channelzRef\n                    });\n                    this.trace('Successfully bound ' + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener('error', onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError)=>{\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = ()=>{};\n                if (this.shutdown) {\n                    deferredCallback(new Error(`bindAsync failed because server is shutdown`), 0);\n                }\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    } else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                } else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult)=>{\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    } else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error)=>{\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error)=>{\n                deferredCallback(new Error(error.details), 0);\n            }\n        };\n        const resolver = (0, resolver_1.createResolver)(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        this.shutdown = true;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session)=>{\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server })=>http2Server.listening !== true)) {\n            throw new Error('server must be bound in order to start');\n        }\n        if (this.started === true) {\n            throw new Error('server is already started');\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Starting');\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error)=>{\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        this.shutdown = true;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        (0, channelz_1.unregisterChannelzRef)(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session)=>{\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error('Not yet implemented');\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n            }, {\n                endStream: true\n            });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(path) {\n        this.trace('Received call to method ' + path + ' at address ' + this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n            return null;\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once('callEnd', (code)=>{\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once('streamEnd', (success)=>{\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                } else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on('sendMessage', ()=>{\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on('receiveMessage', ()=>{\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        const path = headers[HTTP2_HEADER_PATH];\n        const handler = this._retrieveHandler(path);\n        if (!handler) {\n            this._respondWithError(getUnimplementedStatusResponse(path), stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';\n        metadata.remove('grpc-encoding');\n        const { type } = handler;\n        if (type === 'unary') {\n            handleUnary(call, handler, metadata, encoding);\n        } else if (type === 'clientStream') {\n            handleClientStreaming(call, handler, metadata, encoding);\n        } else if (type === 'serverStream') {\n            handleServerStreaming(call, handler, metadata, encoding);\n        } else if (type === 'bidi') {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        } else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = 'null';\n        if (serverAddress) {\n            if (typeof serverAddress === 'string') {\n                serverAddressString = serverAddress;\n            } else {\n                serverAddressString = serverAddress.address + ':' + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n        http2Server.on('stream', handler.bind(this));\n        http2Server.on('session', (session)=>{\n            var _a, _b, _c, _d, _e;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            const channelzRef = (0, channelz_1.registerChannelzSocket)((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            let connectionAgeTimer = null;\n            let connectionAgeGraceTimer = null;\n            let sessionClosedByServer = false;\n            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                // Apply a random jitter within a +/-10% range\n                const jitterMagnitude = this.maxConnectionAgeMs / 10;\n                const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n                connectionAgeTimer = (_c = (_b = setTimeout(()=>{\n                    var _a, _b;\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\n                    }\n                    try {\n                        session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), Buffer.from('max_age'));\n                    } catch (e) {\n                        // The goaway can't be sent because the session is already closed\n                        session.destroy();\n                        return;\n                    }\n                    session.close();\n                    /* Allow a grace period after sending the GOAWAY before forcibly\n                     * closing the connection. */ if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n                        connectionAgeGraceTimer = (_b = (_a = setTimeout(()=>{\n                            session.destroy();\n                        }, this.maxConnectionAgeGraceMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                }, this.maxConnectionAgeMs + jitter)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n            }\n            const keeapliveTimeTimer = (_e = (_d = setInterval(()=>{\n                var _a, _b;\n                const timeoutTImer = (_b = (_a = setTimeout(()=>{\n                    sessionClosedByServer = true;\n                    if (this.channelzEnabled) {\n                        this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\n                    }\n                    session.close();\n                }, this.keepaliveTimeoutMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n                try {\n                    session.ping((err, duration, payload)=>{\n                        clearTimeout(timeoutTImer);\n                    });\n                } catch (e) {\n                    // The ping can't be sent because the session is already closed\n                    session.destroy();\n                }\n            }, this.keepaliveTimeMs)).unref) === null || _e === void 0 ? void 0 : _e.call(_d);\n            session.on('close', ()=>{\n                if (this.channelzEnabled) {\n                    if (!sessionClosedByServer) {\n                        this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n                    }\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    (0, channelz_1.unregisterChannelzRef)(channelzRef);\n                }\n                if (connectionAgeTimer) {\n                    clearTimeout(connectionAgeTimer);\n                }\n                if (connectionAgeGraceTimer) {\n                    clearTimeout(connectionAgeGraceTimer);\n                }\n                if (keeapliveTimeTimer) {\n                    clearTimeout(keeapliveTimeTimer);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nasync function handleUnary(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags)=>{\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on('error', respond);\n    handler.func(stream, respond);\n}\nasync function handleServerStreaming(call, handler, metadata, encoding) {\n    try {\n        const request = await call.receiveUnaryMessage(encoding);\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    } catch (err) {\n        call.sendError(err);\n    }\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n} //# sourceMappingURL=server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7Ozs7QUFFSCx3REFBK0I7QUFJL0Isd0hBQW1EO0FBR25ELDhIQW9CdUI7QUFDdkIsbUpBQXlEO0FBRXpELHFIQUlvQjtBQUNwQixnSEFBcUM7QUFDckMsbUpBTThCO0FBQzlCLDJIQUF3QztBQUN4QyxxSEFZb0I7QUFHcEIsTUFBTSwyQkFBMkIsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEdBQUUsQ0FBQztBQUM5QyxNQUFNLHFCQUFxQixHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRSxDQUFDO0FBQ3hDLE1BQU0sb0JBQW9CLEdBQUcsS0FBSyxDQUFDO0FBRW5DLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7QUFFOUMsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDO0FBTzdCLFNBQVMsSUFBSSxJQUFVLENBQUM7QUFFeEIsU0FBUyw4QkFBOEIsQ0FDckMsVUFBa0I7SUFFbEIsT0FBTztRQUNMLElBQUksRUFBRSxrQkFBTSxDQUFDLGFBQWE7UUFDMUIsT0FBTyxFQUFFLDRDQUE0QyxVQUFVLEVBQUU7S0FDbEUsQ0FBQztBQUNKLENBQUM7QUFhRCxTQUFTLGlCQUFpQixDQUFDLFdBQXdCLEVBQUUsVUFBa0I7SUFDckUsTUFBTSwyQkFBMkIsR0FDL0IsOEJBQThCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDN0MsT0FBUSxXQUFXLEVBQUU7UUFDbkIsS0FBSyxPQUFPO1lBQ1YsT0FBTyxDQUNMLElBQStCLEVBQy9CLFFBQTRCLEVBQzVCLEVBQUU7Z0JBQ0YsUUFBUSxDQUFDLDJCQUEyQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQzlELENBQUMsQ0FBQztRQUNKLEtBQUssY0FBYztZQUNqQixPQUFPLENBQ0wsSUFBb0MsRUFDcEMsUUFBNEIsRUFDNUIsRUFBRTtnQkFDRixRQUFRLENBQUMsMkJBQTJDLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDOUQsQ0FBQyxDQUFDO1FBQ0osS0FBSyxjQUFjO1lBQ2pCLE9BQU8sQ0FBQyxJQUFvQyxFQUFFLEVBQUU7Z0JBQzlDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLDJCQUEyQixDQUFDLENBQUM7WUFDbEQsQ0FBQyxDQUFDO1FBQ0osS0FBSyxNQUFNO1lBQ1QsT0FBTyxDQUFDLElBQWtDLEVBQUUsRUFBRTtnQkFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsMkJBQTJCLENBQUMsQ0FBQztZQUNsRCxDQUFDLENBQUM7UUFDSjtZQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsdUJBQXVCLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDMUQsQ0FBQztBQUNILENBQUM7QUFXRCxNQUFhLE1BQU07SUE4QmpCLFlBQVksT0FBd0I7O1FBN0I1QixvQkFBZSxHQUdqQixFQUFFLENBQUM7UUFFRCxhQUFRLEdBQWdDLElBQUksR0FBRyxFQUdwRCxDQUFDO1FBQ0ksYUFBUSxHQUFHLElBQUksR0FBRyxFQUFpRCxDQUFDO1FBQ3BFLFlBQU8sR0FBRyxLQUFLLENBQUM7UUFDaEIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUVqQix3QkFBbUIsR0FBRyxNQUFNLENBQUM7UUFFckMsZ0JBQWdCO1FBQ0Msb0JBQWUsR0FBWSxJQUFJLENBQUM7UUFFekMsa0JBQWEsR0FBRyxJQUFJLHdCQUFhLEVBQUUsQ0FBQztRQUNwQyxnQkFBVyxHQUFHLElBQUksOEJBQW1CLEVBQUUsQ0FBQztRQUN4Qyw0QkFBdUIsR0FBRyxJQUFJLGtDQUF1QixFQUFFLENBQUM7UUFDeEQsMkJBQXNCLEdBQUcsSUFBSSxrQ0FBdUIsRUFBRSxDQUFDO1FBUzdELElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxhQUFQLE9BQU8sY0FBUCxPQUFPLEdBQUksRUFBRSxDQUFDO1FBQzdCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQy9DLElBQUksQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDO1FBQy9CLENBQUM7UUFDRCxJQUFJLENBQUMsV0FBVyxHQUFHLHVDQUNqQixHQUFHLENBQUcsQ0FBRCxHQUFLLENBQUMsZUFBZSxFQUFFLEVBQzVCLElBQUksQ0FBQyxlQUFlLENBQ3JCLENBQUM7UUFDRixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUMzRCxDQUFDO1FBQ0QsSUFBSSxDQUFDLGtCQUFrQixHQUNyQixVQUFJLENBQUMsT0FBTyxDQUFDLDZCQUE0QixNQUFDLDZCQUFJLDJCQUEyQixDQUFDO1FBQzVFLElBQUksQ0FBQyx1QkFBdUIsR0FDMUIsVUFBSSxDQUFDLE9BQU8sQ0FBQyxtQ0FBa0MsTUFBQyw2QkFDaEQsMkJBQTJCLENBQUM7UUFDOUIsSUFBSSxDQUFDLGVBQWUsR0FDbEIsVUFBSSxDQUFDLE9BQU8sQ0FBQyx5QkFBd0IsTUFBQyw2QkFBSSxxQkFBcUIsQ0FBQztRQUNsRSxJQUFJLENBQUMsa0JBQWtCLEdBQ3JCLFVBQUksQ0FBQyxPQUFPLENBQUMsNEJBQTJCLE1BQUMsNkJBQUksb0JBQW9CLENBQUM7UUFDcEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFTyxlQUFlO1FBQ3JCLE9BQU87WUFDTCxLQUFLLEVBQUUsSUFBSSxDQUFDLGFBQWE7WUFDekIsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXO1lBQzdCLGdCQUFnQixFQUFFLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxhQUFhLEVBQUU7WUFDOUQsZUFBZSxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxhQUFhLEVBQUU7U0FDN0QsQ0FBQztJQUNKLENBQUM7SUFFTyw0QkFBNEIsQ0FDbEMsT0FBaUM7UUFFakMsT0FBTyxHQUFHLEVBQUU7O1lBQ1YsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFFLENBQUM7WUFDaEQsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUNyQyxNQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsYUFBYSxHQUM3QyxvREFDRSxhQUFhLENBQUMsYUFBYSxFQUMzQixhQUFhLENBQUMsVUFBVSxDQUN6QixHQUNELElBQUksQ0FBQztZQUNULE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxZQUFZLEdBQzNDLG9EQUNFLGFBQWEsQ0FBQyxZQUFhLEVBQzNCLGFBQWEsQ0FBQyxTQUFTLENBQ3hCLEdBQ0QsSUFBSSxDQUFDO1lBQ1QsSUFBSSxPQUF1QixDQUFDO1lBQzVCLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRSxDQUFDO2dCQUN0QixNQUFNLFNBQVMsR0FBYyxhQUEwQixDQUFDO2dCQUN4RCxNQUFNLFVBQVUsR0FDZCxTQUFTLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ3hCLE1BQU0sV0FBVyxHQUFHLFNBQVMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDL0MsTUFBTSxlQUFlLEdBQUcsU0FBUyxDQUFDLGtCQUFrQixFQUFFLENBQUM7Z0JBQ3ZELE9BQU8sR0FBRztvQkFDUix1QkFBdUIsRUFBRSxnQkFBVSxDQUFDLGtCQUFZLDZCQUFJLElBQUk7b0JBQ3hELG9CQUFvQixFQUFFLFVBQVUsQ0FBQyxZQUFZLEdBQ3pDLElBQUksR0FDSixVQUFVLENBQUMsSUFBSTtvQkFDbkIsZ0JBQWdCLEVBQ2QsV0FBVyxJQUFJLEtBQUssSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUk7b0JBQzlELGlCQUFpQixFQUNmLGVBQWUsSUFBSSxLQUFLLElBQUksZUFBZSxHQUN2QyxlQUFlLENBQUMsR0FBRyxHQUNuQixJQUFJO2lCQUNYLENBQUM7WUFDSixDQUFDLE1BQU0sQ0FBQztnQkFDTixPQUFPLEdBQUcsSUFBSSxDQUFDO1lBQ2pCLENBQUM7WUFDRCxNQUFNLFVBQVUsR0FBZTtnQkFDN0IsYUFBYSxFQUFFLGFBQWE7Z0JBQzVCLFlBQVksRUFBRSxZQUFZO2dCQUMxQixRQUFRLEVBQUUsT0FBTztnQkFDakIsVUFBVSxFQUFFLElBQUk7Z0JBQ2hCLGNBQWMsRUFBRSxXQUFXLENBQUMsYUFBYSxDQUFDLFlBQVk7Z0JBQ3RELGdCQUFnQixFQUFFLFdBQVcsQ0FBQyxhQUFhLENBQUMsY0FBYztnQkFDMUQsYUFBYSxFQUFFLFdBQVcsQ0FBQyxhQUFhLENBQUMsV0FBVztnQkFDcEQsWUFBWSxFQUFFLFdBQVcsQ0FBQyxZQUFZO2dCQUN0QyxnQkFBZ0IsRUFBRSxXQUFXLENBQUMsZ0JBQWdCO2dCQUM5QyxjQUFjLEVBQUUsQ0FBQztnQkFDakIsK0JBQStCLEVBQUUsSUFBSTtnQkFDckMsZ0NBQWdDLEVBQzlCLFdBQVcsQ0FBQyxhQUFhLENBQUMsd0JBQXdCO2dCQUNwRCx3QkFBd0IsRUFBRSxXQUFXLENBQUMsd0JBQXdCO2dCQUM5RCw0QkFBNEIsRUFBRSxXQUFXLENBQUMsNEJBQTRCO2dCQUN0RSxzQkFBc0IsRUFBRSxhQUFPLENBQUMsS0FBSyxDQUFDLHFCQUFlLDZCQUFJLElBQUk7Z0JBQzdELHVCQUF1QixFQUFFLGFBQU8sQ0FBQyxLQUFLLENBQUMsc0JBQWdCLDZCQUFJLElBQUk7YUFDaEUsQ0FBQztZQUNGLE9BQU8sVUFBVSxDQUFDO1FBQ3BCLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFTyxLQUFLLENBQUMsSUFBWTtRQUN4QixPQUFPLENBQUMsS0FBSyxDQUNYLHdCQUFZLENBQUMsS0FBSyxFQUNsQixXQUFXLEVBQ1gsR0FBRyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxHQUFHLElBQUksR0FBRyxJQUFJLENBQ3hDLENBQUM7SUFDSixDQUFDO0lBRUQsZUFBZTtRQUNiLE1BQU0sSUFBSSxLQUFLLENBQUMsMkNBQTJDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQsVUFBVSxDQUNSLE9BQTBCLEVBQzFCLGNBQTRDO1FBRTVDLElBQ0UsT0FBTyxLQUFLLElBQUksSUFDaEIsT0FBTyxPQUFPLEtBQUssUUFBUSxJQUMzQixjQUFjLEtBQUssSUFBSSxJQUN2QixPQUFPLGNBQWMsS0FBSyxRQUFRLEVBQ2xDLENBQUM7WUFDRCxNQUFNLElBQUksS0FBSyxDQUFDLGdEQUFnRCxDQUFDLENBQUM7UUFDcEUsQ0FBQztRQUVELE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFekMsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMseUNBQXlDLENBQUMsQ0FBQztRQUM3RCxDQUFDO1FBRUQsV0FBVyxDQUFDLE9BQU8sRUFBQyxJQUFJLENBQUMsRUFBRTtZQUN6QixNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDNUIsSUFBSSxVQUF1QixDQUFDO1lBRTVCLElBQUksS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDO2dCQUN4QixJQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztvQkFDekIsVUFBVSxHQUFHLE1BQU0sQ0FBQztnQkFDdEIsQ0FBQyxNQUFNLENBQUM7b0JBQ04sVUFBVSxHQUFHLGNBQWMsQ0FBQztnQkFDOUIsQ0FBQztZQUNILENBQUMsTUFBTSxDQUFDO2dCQUNOLElBQUksS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO29CQUN6QixVQUFVLEdBQUcsY0FBYyxDQUFDO2dCQUM5QixDQUFDLE1BQU0sQ0FBQztvQkFDTixVQUFVLEdBQUcsT0FBTyxDQUFDO2dCQUN2QixDQUFDO1lBQ0gsQ0FBQztZQUVELElBQUksTUFBTSxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNsQyxJQUFJLElBQUksQ0FBQztZQUVULElBQUksTUFBTSxLQUFLLFNBQVMsSUFBSSxPQUFPLEtBQUssQ0FBQyxZQUFZLEtBQUssUUFBUSxFQUFFLENBQUM7Z0JBQ25FLE1BQU0sR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBQzlDLENBQUM7WUFFRCxJQUFJLE1BQU0sS0FBSyxTQUFTLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7WUFDckMsQ0FBQyxNQUFNLENBQUM7Z0JBQ04sSUFBSSxHQUFHLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUM3QyxDQUFDO1lBRUQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FDM0IsS0FBSyxDQUFDLElBQUksRUFDVixJQUF5QixFQUN6QixLQUFLLENBQUMsaUJBQWlCLEVBQ3ZCLEtBQUssQ0FBQyxrQkFBa0IsRUFDeEIsVUFBVSxDQUNYLENBQUM7WUFFRixJQUFJLE9BQU8sS0FBSyxLQUFLLEVBQUUsQ0FBQztnQkFDdEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsS0FBSyxDQUFDLElBQUksb0JBQW9CLENBQUMsQ0FBQztZQUN4RSxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsYUFBYSxDQUFDLE9BQTBCO1FBQ3RDLElBQUksT0FBTyxLQUFLLElBQUksSUFBSSxPQUFPLE9BQU8sS0FBSyxRQUFRLEVBQUUsQ0FBQztZQUNwRCxNQUFNLElBQUksS0FBSyxDQUFDLDZDQUE2QyxDQUFDLENBQUM7UUFDakUsQ0FBQztRQUVELE1BQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekMsV0FBVyxDQUFDLE9BQU8sRUFBQyxJQUFJLENBQUMsRUFBRTtZQUN6QixNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsSUFBSSxDQUFDLElBQVksRUFBRSxLQUF3QjtRQUN6QyxNQUFNLElBQUksS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7SUFDOUQsQ0FBQztJQUVELFNBQVMsQ0FDUCxJQUFZLEVBQ1osS0FBd0IsRUFDeEIsUUFBcUQ7UUFFckQsSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLElBQUksRUFBRSxDQUFDO1lBQzFCLE1BQU0sSUFBSSxLQUFLLENBQUMsMkJBQTJCLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBRUQsSUFBSSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1FBQ3JELENBQUM7UUFFRCxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRSxDQUFDO1lBQzdCLE1BQU0sSUFBSSxTQUFTLENBQUMsdUJBQXVCLENBQUMsQ0FBQztRQUMvQyxDQUFDO1FBRUQsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFLLFlBQVksdUNBQWtCLEVBQUUsQ0FBQztZQUM1RCxNQUFNLElBQUksU0FBUyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7UUFDbEUsQ0FBQztRQUVELElBQUksT0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFLENBQUM7WUFDbkMsTUFBTSxJQUFJLFNBQVMsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBQ3JELENBQUM7UUFFRCxNQUFNLGNBQWMsR0FBRywyQkFBUyxJQUFJLENBQUMsQ0FBQztRQUN0QyxJQUFJLGNBQWMsS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUM1QixNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBQ3BELENBQUM7UUFDRCxNQUFNLE9BQU8sR0FBRyxvQ0FBb0IsY0FBYyxDQUFDLENBQUM7UUFDcEQsSUFBSSxPQUFPLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyw0Q0FBNEMsSUFBSSxHQUFHLENBQUMsQ0FBQztRQUN2RSxDQUFDO1FBRUQsTUFBTSxhQUFhLEdBQXdCO1lBQ3pDLHdCQUF3QixFQUFFLE1BQU0sQ0FBQyxnQkFBZ0I7U0FDbEQsQ0FBQztRQUNGLElBQUksOEJBQThCLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ25ELGFBQWEsQ0FBQyxnQkFBZ0IsR0FDNUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1FBQ2pELENBQUMsTUFBTSxDQUFDO1lBQ047OztrREFHc0MsQ0FDdEMsYUFBYSxDQUFDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztRQUMzRCxDQUFDO1FBQ0QsSUFBSSw2QkFBNkIsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbEQsYUFBYSxDQUFDLFFBQVEsR0FBRztnQkFDdkIsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyw2QkFBNkIsQ0FBQzthQUNsRSxDQUFDO1FBQ0osQ0FBQztRQUVELE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxLQUFtQixFQUFFLElBQVksRUFBRSxFQUFFO1lBQzdELE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFHLENBQUQsT0FBUyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2hELENBQUMsQ0FBQztRQUVGLE1BQU0sV0FBVyxHQUFHLEdBQWdELEVBQUU7WUFDcEUsSUFBSSxXQUF3RCxDQUFDO1lBQzdELElBQUksS0FBSyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQUM7Z0JBQ3RCLE1BQU0sbUJBQW1CLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FDdkMsYUFBYSxFQUNiLEtBQUssQ0FBQyxZQUFZLEVBQUcsQ0FDdEIsQ0FBQztnQkFDRixtQkFBbUIsQ0FBQyxXQUFXLEdBQzdCLElBQUksQ0FBQyxPQUFPLENBQUMsNEJBQTRCLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ25ELFdBQVcsR0FBRyxLQUFLLENBQUMsa0JBQWtCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztnQkFDNUQsV0FBVyxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsRUFBRSxDQUFDLE1BQWlCLEVBQUUsRUFBRTtvQkFDdkQ7a0ZBQzhELENBQzlELE1BQU0sQ0FBQyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBUSxFQUFFLEVBQUU7d0JBQzlCLElBQUksQ0FBQyxLQUFLLENBQ1IsZ0RBQWdELEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FDN0QsQ0FBQztvQkFDSixDQUFDLENBQUMsQ0FBQztnQkFDTCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsTUFBTSxDQUFDO2dCQUNOLFdBQVcsR0FBRyxLQUFLLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ2xELENBQUM7WUFFRCxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ2pDLE9BQU8sV0FBVyxDQUFDO1FBQ3JCLENBQUMsQ0FBQztRQUVGLE1BQU0sZ0JBQWdCLEdBQUcsQ0FDdkIsV0FBZ0MsRUFDaEMsT0FBZSxFQUNmLGFBQXFCLEVBQ0EsRUFBRTtZQUN2QixJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQzdCLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBQztvQkFBRSxJQUFJLEVBQUUsT0FBTztvQkFBRSxLQUFLLEVBQUUsYUFBYTtnQkFBQSxDQUFFLENBQUMsQ0FBQztZQUNsRSxDQUFDO1lBQ0QsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUNoQixXQUFXLENBQUMsR0FBRyxFQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUN4QixJQUFJLENBQUMsS0FBSyxDQUNSLHFCQUFxQixHQUFHLG9EQUEwQixPQUFPLENBQUMsQ0FDM0QsQ0FBQztnQkFDRixJQUFJLElBQXVCLENBQUM7Z0JBQzVCLElBQUksaURBQXVCLE9BQU8sQ0FBQyxFQUFFLENBQUM7b0JBQ3BDLElBQUksR0FBRzt3QkFDTCxJQUFJLEVBQUcsT0FBZ0MsQ0FBQyxJQUFJO3dCQUM1QyxJQUFJLEVBQUUsT0FBTztxQkFDZCxDQUFDO2dCQUNKLENBQUMsTUFBTSxDQUFDO29CQUNOLElBQUksR0FBRyxPQUFPLENBQUM7Z0JBQ2pCLENBQUM7Z0JBRUQsTUFBTSxXQUFXLEdBQUcsV0FBVyxFQUFFLENBQUM7Z0JBQ2xDLE9BQU8sSUFBSSxPQUFPLENBQWlCLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO29CQUNyRCxNQUFNLE9BQU8sR0FBRyxDQUFDLEdBQVUsRUFBRSxFQUFFO3dCQUM3QixJQUFJLENBQUMsS0FBSyxDQUNSLGlCQUFpQixHQUNmLG9EQUEwQixPQUFPLENBQUMsR0FDbEMsY0FBYyxHQUNkLEdBQUcsQ0FBQyxPQUFPLENBQ2QsQ0FBQzt3QkFDRixPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQ2YsQ0FBQyxDQUFDO29CQUVGLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO29CQUVuQyxXQUFXLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxHQUFHLEVBQUU7d0JBQzVCLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDOzRCQUNsQixXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7NEJBQ3BCLE9BQU8sQ0FBQyxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxDQUFDLENBQUM7NEJBQ2xFLE9BQU87d0JBQ1QsQ0FBQzt3QkFDRCxNQUFNLFlBQVksR0FBRyxXQUFXLENBQUMsT0FBTyxFQUFHLENBQUM7d0JBQzVDLElBQUksc0JBQXlDLENBQUM7d0JBQzlDLElBQUksT0FBTyxZQUFZLEtBQUssUUFBUSxFQUFFLENBQUM7NEJBQ3JDLHNCQUFzQixHQUFHO2dDQUN2QixJQUFJLEVBQUUsWUFBWTs2QkFDbkIsQ0FBQzt3QkFDSixDQUFDLE1BQU0sQ0FBQzs0QkFDTixzQkFBc0IsR0FBRztnQ0FDdkIsSUFBSSxFQUFFLFlBQVksQ0FBQyxPQUFPO2dDQUMxQixJQUFJLEVBQUUsWUFBWSxDQUFDLElBQUk7NkJBQ3hCLENBQUM7d0JBQ0osQ0FBQzt3QkFFRCxNQUFNLFdBQVcsR0FBRyx1Q0FDbEIsa0RBQXlCLEVBQUMsc0JBQXNCLENBQUMsRUFDakQsR0FBRyxFQUFFOzRCQUNILE9BQU87Z0NBQ0wsWUFBWSxFQUFFLHNCQUFzQjtnQ0FDcEMsYUFBYSxFQUFFLElBQUk7Z0NBQ25CLFFBQVEsRUFBRSxJQUFJO2dDQUNkLFVBQVUsRUFBRSxJQUFJO2dDQUNoQixjQUFjLEVBQUUsQ0FBQztnQ0FDakIsZ0JBQWdCLEVBQUUsQ0FBQztnQ0FDbkIsYUFBYSxFQUFFLENBQUM7Z0NBQ2hCLFlBQVksRUFBRSxDQUFDO2dDQUNmLGdCQUFnQixFQUFFLENBQUM7Z0NBQ25CLGNBQWMsRUFBRSxDQUFDO2dDQUNqQiwrQkFBK0IsRUFBRSxJQUFJO2dDQUNyQyxnQ0FBZ0MsRUFBRSxJQUFJO2dDQUN0Qyx3QkFBd0IsRUFBRSxJQUFJO2dDQUM5Qiw0QkFBNEIsRUFBRSxJQUFJO2dDQUNsQyxzQkFBc0IsRUFBRSxJQUFJO2dDQUM1Qix1QkFBdUIsRUFBRSxJQUFJOzZCQUM5QixDQUFDO3dCQUNKLENBQUMsRUFDRCxJQUFJLENBQUMsZUFBZSxDQUNyQixDQUFDO3dCQUNGLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDOzRCQUN6QixJQUFJLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO3dCQUNyRCxDQUFDO3dCQUNELElBQUksQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDOzRCQUN4QixNQUFNLEVBQUUsV0FBVzs0QkFDbkIsV0FBVyxFQUFFLFdBQVc7eUJBQ3pCLENBQUMsQ0FBQzt3QkFDSCxJQUFJLENBQUMsS0FBSyxDQUNSLHFCQUFxQixHQUNuQixvREFBMEIsc0JBQXNCLENBQUMsQ0FDcEQsQ0FBQzt3QkFDRixPQUFPLENBQ0wsTUFBTSxJQUFJLHNCQUFzQixHQUM1QixzQkFBc0IsQ0FBQyxJQUFJLEdBQzNCLE9BQU8sQ0FDWixDQUFDO3dCQUNGLFdBQVcsQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO29CQUMvQyxDQUFDLENBQUMsQ0FBQztnQkFDTCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUNILENBQUMsSUFBSSxFQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNmLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztnQkFDZCxLQUFLLE1BQU0sTUFBTSxJQUFJLE9BQU8sQ0FBRSxDQUFDO29CQUM3QixJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRSxDQUFDO3dCQUMvQixLQUFLLElBQUksQ0FBQyxDQUFDO3dCQUNYLElBQUksTUFBTSxLQUFLLE9BQU8sRUFBRSxDQUFDOzRCQUN2QixNQUFNLElBQUksS0FBSyxDQUNiLGdFQUFnRSxDQUNqRSxDQUFDO3dCQUNKLENBQUM7b0JBQ0gsQ0FBQztnQkFDSCxDQUFDO2dCQUNELE9BQU87b0JBQ0wsSUFBSSxFQUFFLE9BQU87b0JBQ2IsS0FBSyxFQUFFLEtBQUssR0FBRyxhQUFhO2lCQUM3QixDQUFDO1lBQ0osQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUM7UUFFRixNQUFNLGdCQUFnQixHQUFHLENBQ3ZCLFdBQWdDLEVBQ1gsRUFBRTtZQUN2QixJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQzdCLE9BQU8sT0FBTyxDQUFDLE9BQU8sQ0FBYTtvQkFBRSxJQUFJLEVBQUUsQ0FBQztvQkFBRSxLQUFLLEVBQUUsQ0FBQztnQkFBQSxDQUFFLENBQUMsQ0FBQztZQUM1RCxDQUFDO1lBQ0QsTUFBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9CLE1BQU0sV0FBVyxHQUFHLFdBQVcsRUFBRSxDQUFDO1lBQ2xDLE9BQU8sSUFBSSxPQUFPLENBQWEsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7Z0JBQ2pELE1BQU0sT0FBTyxHQUFHLENBQUMsR0FBVSxFQUFFLEVBQUU7b0JBQzdCLElBQUksQ0FBQyxLQUFLLENBQ1IsaUJBQWlCLEdBQ2Ysb0RBQTBCLE9BQU8sQ0FBQyxHQUNsQyxjQUFjLEdBQ2QsR0FBRyxDQUFDLE9BQU8sQ0FDZCxDQUFDO29CQUNGLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDbEQsQ0FBQyxDQUFDO2dCQUVGLFdBQVcsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUVuQyxXQUFXLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUU7b0JBQy9CLElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO3dCQUNsQixXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7d0JBQ3BCLE9BQU8sQ0FBQzs0QkFBQyxJQUFJLEVBQUUsQ0FBQzs0QkFBRSxLQUFLLEVBQUUsQ0FBQzt3QkFBQSxDQUFDLENBQUMsQ0FBQzt3QkFDN0IsT0FBTztvQkFDVCxDQUFDO29CQUNELE1BQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxPQUFPLEVBQWlCLENBQUM7b0JBQzFELE1BQU0sc0JBQXNCLEdBQXNCO3dCQUNoRCxJQUFJLEVBQUUsWUFBWSxDQUFDLE9BQU87d0JBQzFCLElBQUksRUFBRSxZQUFZLENBQUMsSUFBSTtxQkFDeEIsQ0FBQztvQkFDRixNQUFNLFdBQVcsR0FBRyx1Q0FDbEIsb0RBQTBCLHNCQUFzQixDQUFDLEVBQ2pELEdBQUcsRUFBRTt3QkFDSCxPQUFPOzRCQUNMLFlBQVksRUFBRSxzQkFBc0I7NEJBQ3BDLGFBQWEsRUFBRSxJQUFJOzRCQUNuQixRQUFRLEVBQUUsSUFBSTs0QkFDZCxVQUFVLEVBQUUsSUFBSTs0QkFDaEIsY0FBYyxFQUFFLENBQUM7NEJBQ2pCLGdCQUFnQixFQUFFLENBQUM7NEJBQ25CLGFBQWEsRUFBRSxDQUFDOzRCQUNoQixZQUFZLEVBQUUsQ0FBQzs0QkFDZixnQkFBZ0IsRUFBRSxDQUFDOzRCQUNuQixjQUFjLEVBQUUsQ0FBQzs0QkFDakIsK0JBQStCLEVBQUUsSUFBSTs0QkFDckMsZ0NBQWdDLEVBQUUsSUFBSTs0QkFDdEMsd0JBQXdCLEVBQUUsSUFBSTs0QkFDOUIsNEJBQTRCLEVBQUUsSUFBSTs0QkFDbEMsc0JBQXNCLEVBQUUsSUFBSTs0QkFDNUIsdUJBQXVCLEVBQUUsSUFBSTt5QkFDOUIsQ0FBQztvQkFDSixDQUFDLEVBQ0QsSUFBSSxDQUFDLGVBQWUsQ0FDckIsQ0FBQztvQkFDRixJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQzt3QkFDekIsSUFBSSxDQUFDLHVCQUF1QixDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFDckQsQ0FBQztvQkFDRCxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQzt3QkFDeEIsTUFBTSxFQUFFLFdBQVc7d0JBQ25CLFdBQVcsRUFBRSxXQUFXO3FCQUN6QixDQUFDLENBQUM7b0JBQ0gsSUFBSSxDQUFDLEtBQUssQ0FDUixxQkFBcUIsR0FDbkIsa0RBQXlCLEVBQUMsc0JBQXNCLENBQUMsQ0FDcEQsQ0FBQztvQkFDRixPQUFPLENBQUMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3RFLFdBQVcsQ0FBQyxjQUFjLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUMvQyxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDO1FBRUYsTUFBTSxnQkFBZ0IsR0FBcUI7WUFDekMsc0JBQXNCLEVBQUUsQ0FDdEIsV0FBVyxFQUNYLGFBQWEsRUFDYixrQkFBa0IsRUFDbEIsRUFBRTtnQkFDRixpRUFBaUU7Z0JBQ2pFLGdCQUFnQixDQUFDLHNCQUFzQixHQUFHLEdBQUcsRUFBRSxDQUFHLENBQUM7Z0JBQ25ELElBQUksSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO29CQUNsQixnQkFBZ0IsQ0FDZCxJQUFJLEtBQUssQ0FBQyw2Q0FBNkMsQ0FBQyxFQUN4RCxDQUFDLENBQ0YsQ0FBQztnQkFDSixDQUFDO2dCQUNELElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztvQkFDN0IsZ0JBQWdCLENBQ2QsSUFBSSxLQUFLLENBQUMsa0NBQWtDLElBQUksRUFBRSxDQUFDLEVBQ25ELENBQUMsQ0FDRixDQUFDO29CQUNGLE9BQU87Z0JBQ1QsQ0FBQztnQkFDRCxJQUFJLGlCQUFzQyxDQUFDO2dCQUMzQyxJQUFJLGlEQUF1QixXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO29CQUMzQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUM7d0JBQzlCLGlCQUFpQixHQUFHLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUNwRCxDQUFDLE1BQU0sQ0FBQzt3QkFDTixpQkFBaUIsR0FBRyxnQkFBZ0IsQ0FDbEMsV0FBVyxFQUNYLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQ25CLENBQUMsQ0FDRixDQUFDO29CQUNKLENBQUM7Z0JBQ0gsQ0FBQyxNQUFNLENBQUM7b0JBQ04sdURBQXVEO29CQUN2RCxpQkFBaUIsR0FBRyxnQkFBZ0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUMxRCxDQUFDO2dCQUNELGlCQUFpQixDQUFDLElBQUksQ0FDcEIsVUFBVSxDQUFDLEVBQUU7b0JBQ1gsSUFBSSxVQUFVLENBQUMsS0FBSyxLQUFLLENBQUMsRUFBRSxDQUFDO3dCQUMzQixNQUFNLFdBQVcsR0FBRyxpQ0FBaUMsV0FBVyxDQUFDLE1BQU0sV0FBVyxDQUFDO3dCQUNuRixPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUFZLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO3dCQUM3QyxnQkFBZ0IsQ0FBQyxJQUFJLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDOUMsQ0FBQyxNQUFNLENBQUM7d0JBQ04sSUFBSSxVQUFVLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQzs0QkFDMUMsT0FBTyxDQUFDLEdBQUcsQ0FDVCx3QkFBWSxDQUFDLElBQUksRUFDakIsZ0JBQWdCLFVBQVUsQ0FBQyxLQUFLLGlDQUFpQyxXQUFXLENBQUMsTUFBTSxXQUFXLENBQy9GLENBQUM7d0JBQ0osQ0FBQzt3QkFDRCxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUMxQyxDQUFDO2dCQUNILENBQUMsR0FDRCxLQUFLLENBQUMsRUFBRTtvQkFDTixNQUFNLFdBQVcsR0FBRyxpQ0FBaUMsV0FBVyxDQUFDLE1BQU0sV0FBVyxDQUFDO29CQUNuRixPQUFPLENBQUMsR0FBRyxDQUFDLHdCQUFZLENBQUMsS0FBSyxFQUFFLFdBQVcsQ0FBQyxDQUFDO29CQUM3QyxnQkFBZ0IsQ0FBQyxJQUFJLEtBQUssQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDOUMsQ0FBQyxDQUNGLENBQUM7WUFDSixDQUFDO1lBQ0QsT0FBTyxHQUFFLEtBQUssQ0FBQyxFQUFFO2dCQUNmLGdCQUFnQixDQUFDLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNoRCxDQUFDO1NBQ0YsQ0FBQztRQUVGLE1BQU0sUUFBUSxHQUFHLCtCQUFlLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekUsUUFBUSxDQUFDLGdCQUFnQixFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVELGFBQWE7UUFDWCwyQ0FBMkM7UUFFM0MsS0FBSyxNQUFNLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLElBQUksSUFBSSxDQUN6RCxlQUFlLENBQUUsQ0FBQztZQUNuQixJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztnQkFDMUIsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUU7b0JBQ3JCLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO3dCQUN6QixJQUFJLENBQUMsdUJBQXVCLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUM3QyxzQ0FBc0IsR0FBRyxDQUFDLENBQUM7b0JBQzdCLENBQUM7Z0JBQ0gsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBRXJCLHdFQUF3RTtRQUN4RSxxRUFBcUU7UUFDckUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLEVBQUU7WUFDOUMsZ0VBQWdFO1lBQ2hFLGdEQUFnRDtZQUNoRCw4REFBOEQ7WUFDOUQsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLGNBQXFCLENBQUMsQ0FBQztRQUN6RCxDQUFDLENBQUMsQ0FBQztRQUNILElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDdEIsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDekIsc0NBQXNCLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUMxQyxDQUFDO0lBQ0gsQ0FBQztJQUVELFFBQVEsQ0FDTixJQUFZLEVBQ1osT0FBOEMsRUFDOUMsU0FBa0MsRUFDbEMsV0FBcUMsRUFDckMsSUFBWTtRQUVaLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztZQUM1QixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUU7WUFDdEIsSUFBSSxFQUFFLE9BQU87WUFDYixTQUFTO1lBQ1QsV0FBVztZQUNYLElBQUk7WUFDSixJQUFJLEVBQUUsSUFBSTtTQUNPLENBQUMsQ0FBQztRQUNyQixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxVQUFVLENBQUMsSUFBWTtRQUNyQixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLO1FBQ0gsSUFDRSxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQ2pDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUN4QixDQUFDLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxFQUFFLENBQUcsQ0FBRCxVQUFZLENBQUMsU0FBUyxLQUFLLElBQUksQ0FDNUQsRUFDRCxDQUFDO1lBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyx3Q0FBd0MsQ0FBQyxDQUFDO1FBQzVELENBQUM7UUFFRCxJQUFJLElBQUksQ0FBQyxPQUFPLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDMUIsTUFBTSxJQUFJLEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxDQUFDO1FBQy9DLENBQUM7UUFDRCxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDckQsQ0FBQztRQUNELElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQ3RCLENBQUM7SUFFRCxXQUFXLENBQUMsUUFBaUM7UUFDM0MsTUFBTSxlQUFlLEdBQUcsQ0FBQyxLQUFhLEVBQUUsRUFBRTtZQUN4QyxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztnQkFDekIsc0NBQXNCLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUMxQyxDQUFDO1lBQ0QsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xCLENBQUMsQ0FBQztRQUNGLElBQUksYUFBYSxHQUFHLENBQUMsQ0FBQztRQUV0QixTQUFTLGFBQWE7WUFDcEIsYUFBYSxFQUFFLENBQUM7WUFFaEIsSUFBSSxhQUFhLEtBQUssQ0FBQyxFQUFFLENBQUM7Z0JBQ3hCLGVBQWUsRUFBRSxDQUFDO1lBQ3BCLENBQUM7UUFDSCxDQUFDO1FBRUQsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBRXJCLEtBQUssTUFBTSxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLEdBQUcsRUFBRSxJQUFJLElBQUksQ0FDekQsZUFBZSxDQUFFLENBQUM7WUFDbkIsSUFBSSxXQUFXLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQzFCLGFBQWEsRUFBRSxDQUFDO2dCQUNoQixXQUFXLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRTtvQkFDckIsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7d0JBQ3pCLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7d0JBQzdDLHNDQUFzQixHQUFHLENBQUMsQ0FBQztvQkFDN0IsQ0FBQztvQkFDRCxhQUFhLEVBQUUsQ0FBQztnQkFDbEIsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsWUFBWSxFQUFFLE9BQU8sRUFBRSxFQUFFO1lBQzlDLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3BCLGFBQWEsSUFBSSxDQUFDLENBQUM7Z0JBQ25CLE9BQU8sQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDL0IsQ0FBQztRQUNILENBQUMsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxhQUFhLEtBQUssQ0FBQyxFQUFFLENBQUM7WUFDeEIsZUFBZSxFQUFFLENBQUM7UUFDcEIsQ0FBQztJQUNILENBQUM7SUFFRCxZQUFZO1FBQ1YsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7OztPQUlHLENBQ0gsY0FBYztRQUNaLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMxQixDQUFDO0lBRU8sa0JBQWtCLENBQ3hCLE1BQStCLEVBQy9CLE9BQWtDO1FBRWxDLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLHlCQUF5QixDQUFDLENBQUM7UUFFdkUsSUFDRSxPQUFPLFdBQVcsS0FBSyxRQUFRLElBQy9CLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUMzQyxDQUFDO1lBQ0QsTUFBTSxDQUFDLE9BQU8sQ0FDWjtnQkFDRSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUMsRUFDbkMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxrQ0FBa0M7YUFDckQsRUFDRDtnQkFBRSxTQUFTLEVBQUUsSUFBSTtZQUFBLENBQUUsQ0FDcEIsQ0FBQztZQUNGLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVPLGdCQUFnQixDQUFDLElBQVk7UUFDbkMsSUFBSSxDQUFDLEtBQUssQ0FDUiwwQkFBMEIsR0FDeEIsSUFBSSxHQUNKLGNBQWMsR0FDZCxJQUFJLENBQUMsbUJBQW1CLENBQzNCLENBQUM7UUFFRixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUV4QyxJQUFJLE9BQU8sS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUMxQixJQUFJLENBQUMsS0FBSyxDQUNSLG1DQUFtQyxHQUNqQyxJQUFJLEdBQ0osaUNBQWlDLENBQ3BDLENBQUM7WUFDRixPQUFPLElBQUksQ0FBQztRQUNkLENBQUM7UUFFRCxPQUFPLE9BQU8sQ0FBQztJQUNqQixDQUFDO0lBRU8saUJBQWlCLENBQ3ZCLEdBQU0sRUFDTixNQUErQixFQUMvQixzQkFBa0QsSUFBSTtRQUV0RCxNQUFNLElBQUksR0FBRyxJQUFJLG1DQUFxQixDQUFDLE1BQU0sRUFBRSxJQUFLLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXBFLElBQUksR0FBRyxDQUFDLElBQUksS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUMzQixHQUFHLENBQUMsSUFBSSxHQUFHLGtCQUFNLENBQUMsUUFBUSxDQUFDO1FBQzdCLENBQUM7UUFFRCxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztZQUN6QixJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ2pDLG1CQUFtQixhQUFuQixtQkFBbUIsdUJBQW5CLG1CQUFtQixDQUFFLGFBQWEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztRQUNyRCxDQUFDO1FBRUQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QixDQUFDO0lBRU8sZ0JBQWdCLENBQ3RCLE1BQStCLEVBQy9CLE9BQWtDO1FBRWxDLE1BQU0sbUJBQW1CLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQzNDLE1BQU0sQ0FBQyxPQUFtQyxDQUMzQyxDQUFDO1FBRUYsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLEVBQUUsQ0FBQztRQUNsQyxtQkFBbUIsYUFBbkIsbUJBQW1CLHVCQUFuQixtQkFBbUIsQ0FBRSxhQUFhLENBQUMsY0FBYyxFQUFFLENBQUM7UUFFcEQsSUFBSSxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUM5QyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ2pDLG1CQUFtQixhQUFuQixtQkFBbUIsdUJBQW5CLG1CQUFtQixDQUFFLGFBQWEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNuRCxPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sSUFBSSxHQUFHLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBVyxDQUFDO1FBRWxELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM1QyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsaUJBQWlCLENBQ3BCLDhCQUE4QixDQUFDLElBQUksQ0FBQyxFQUNwQyxNQUFNLEVBQ04sbUJBQW1CLENBQ3BCLENBQUM7WUFDRixPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sSUFBSSxHQUFHLElBQUksbUNBQXFCLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdEUsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxJQUFZLEVBQUUsRUFBRTtZQUNwQyxJQUFJLElBQUksS0FBSyxrQkFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDO2dCQUN2QixJQUFJLENBQUMsV0FBVyxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDdEMsQ0FBQyxNQUFNLENBQUM7Z0JBQ04sSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUNuQyxDQUFDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxJQUFJLG1CQUFtQixFQUFFLENBQUM7WUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFnQixFQUFFLEVBQUU7Z0JBQzFDLElBQUksT0FBTyxFQUFFLENBQUM7b0JBQ1osbUJBQW1CLENBQUMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLENBQUM7Z0JBQ3ZELENBQUMsTUFBTSxDQUFDO29CQUNOLG1CQUFtQixDQUFDLGFBQWEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQkFDcEQsQ0FBQztZQUNILENBQUMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLEVBQUUsQ0FBQyxhQUFhLEVBQUUsR0FBRyxFQUFFO2dCQUMxQixtQkFBbUIsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDO2dCQUN0QyxtQkFBbUIsQ0FBQyx3QkFBd0IsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO1lBQzVELENBQUMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxHQUFHLEVBQUU7Z0JBQzdCLG1CQUFtQixDQUFDLGdCQUFnQixJQUFJLENBQUMsQ0FBQztnQkFDMUMsbUJBQW1CLENBQUMsNEJBQTRCLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUNoRSxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNyRCxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ2pDLG1CQUFtQixhQUFuQixtQkFBbUIsdUJBQW5CLG1CQUFtQixDQUFFLGFBQWEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztZQUVuRCxJQUFJLENBQUMsU0FBUyxDQUFDO2dCQUNiLElBQUksRUFBRSxrQkFBTSxDQUFDLFFBQVE7Z0JBQ3JCLE9BQU8sRUFBRSx5QkFBeUIsT0FBTyxDQUFDLElBQUksRUFBRTthQUNqRCxDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztJQUVPLGNBQWMsQ0FDcEIsTUFBK0IsRUFDL0IsT0FBa0M7UUFFbEMsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3RELE9BQU87UUFDVCxDQUFDO1FBRUQsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLGlCQUFpQixDQUFXLENBQUM7UUFFbEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzVDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxpQkFBaUIsQ0FDcEIsOEJBQThCLENBQUMsSUFBSSxDQUFDLEVBQ3BDLE1BQU0sRUFDTixJQUFJLENBQ0wsQ0FBQztZQUNGLE9BQU87UUFDVCxDQUFDO1FBRUQsTUFBTSxJQUFJLEdBQUcsSUFBSSxtQ0FBcUIsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0RSxJQUFJLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQztZQUNyRCxJQUFJLENBQUMsU0FBUyxDQUFDO2dCQUNiLElBQUksRUFBRSxrQkFBTSxDQUFDLFFBQVE7Z0JBQ3JCLE9BQU8sRUFBRSx5QkFBeUIsT0FBTyxDQUFDLElBQUksRUFBRTthQUNqRCxDQUFDLENBQUM7UUFDTCxDQUFDO0lBQ0gsQ0FBQztJQUVPLGtCQUFrQixDQUN4QixJQUFxQyxFQUNyQyxPQUEwQixFQUMxQixPQUFrQzs7UUFFbEMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvQyxNQUFNLFFBQVEsR0FDWixNQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBQyxNQUF3Qiw2QkFBSSxVQUFVLENBQUM7UUFDekUsUUFBUSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUVqQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQ3pCLElBQUksSUFBSSxLQUFLLE9BQU8sRUFBRSxDQUFDO1lBQ3JCLFdBQVcsQ0FBQyxJQUFJLEVBQUUsT0FBOEIsRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDeEUsQ0FBQyxNQUFNLElBQUksSUFBSSxLQUFLLGNBQWMsRUFBRSxDQUFDO1lBQ25DLHFCQUFxQixDQUNuQixJQUFJLEVBQ0osT0FBd0MsRUFDeEMsUUFBUSxFQUNSLFFBQVEsQ0FDVCxDQUFDO1FBQ0osQ0FBQyxNQUFNLElBQUksSUFBSSxLQUFLLGNBQWMsRUFBRSxDQUFDO1lBQ25DLHFCQUFxQixDQUNuQixJQUFJLEVBQ0osT0FBd0MsRUFDeEMsUUFBUSxFQUNSLFFBQVEsQ0FDVCxDQUFDO1FBQ0osQ0FBQyxNQUFNLElBQUksSUFBSSxLQUFLLE1BQU0sRUFBRSxDQUFDO1lBQzNCLG1CQUFtQixDQUNqQixJQUFJLEVBQ0osT0FBc0MsRUFDdEMsUUFBUSxFQUNSLFFBQVEsQ0FDVCxDQUFDO1FBQ0osQ0FBQyxNQUFNLENBQUM7WUFDTixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUM7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFTyxjQUFjLENBQ3BCLFdBQXdEO1FBRXhELElBQUksV0FBVyxLQUFLLElBQUksRUFBRSxDQUFDO1lBQ3pCLE9BQU87UUFDVCxDQUFDO1FBRUQsTUFBTSxhQUFhLEdBQUcsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQzVDLElBQUksbUJBQW1CLEdBQUcsTUFBTSxDQUFDO1FBQ2pDLElBQUksYUFBYSxFQUFFLENBQUM7WUFDbEIsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUUsQ0FBQztnQkFDdEMsbUJBQW1CLEdBQUcsYUFBYSxDQUFDO1lBQ3RDLENBQUMsTUFBTSxDQUFDO2dCQUNOLG1CQUFtQixHQUFHLGFBQWEsQ0FBQyxPQUFPLEdBQUcsR0FBRyxHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUM7WUFDekUsQ0FBQztRQUNILENBQUM7UUFDRCxJQUFJLENBQUMsbUJBQW1CLEdBQUcsbUJBQW1CLENBQUM7UUFFL0MsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsR0FDaEMsSUFBSSxDQUFDLGdCQUFnQixHQUNyQixJQUFJLENBQUMsY0FBYyxDQUFDO1FBRXhCLFdBQVcsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUM3QyxXQUFXLENBQUMsRUFBRSxDQUFDLFNBQVMsR0FBRSxPQUFPLENBQUMsRUFBRTs7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDbEIsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUNsQixPQUFPO1lBQ1QsQ0FBQztZQUVELE1BQU0sV0FBVyxHQUFHLHVDQUNsQixhQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsbUNBQUksU0FBUyxFQUN6QyxJQUFJLENBQUMsNEJBQTRCLENBQUMsT0FBTyxDQUFDLEVBQzFDLElBQUksQ0FBQyxlQUFlLENBQ3JCLENBQUM7WUFFRixNQUFNLG1CQUFtQixHQUF3QjtnQkFDL0MsR0FBRyxFQUFFLFdBQVc7Z0JBQ2hCLGFBQWEsRUFBRSxJQUFJLDhCQUFtQixFQUFFO2dCQUN4QyxZQUFZLEVBQUUsQ0FBQztnQkFDZixnQkFBZ0IsRUFBRSxDQUFDO2dCQUNuQix3QkFBd0IsRUFBRSxJQUFJO2dCQUM5Qiw0QkFBNEIsRUFBRSxJQUFJO2FBQ25DLENBQUM7WUFFRixJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztZQUNoRCxNQUFNLGFBQWEsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQztZQUNuRCxJQUFJLElBQUksQ0FBQyxlQUFlLEVBQUUsQ0FBQztnQkFDekIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQ3pCLFNBQVMsRUFDVCxtQ0FBbUMsR0FBRyxhQUFhLENBQ3BELENBQUM7Z0JBQ0YsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNwRCxDQUFDO1lBQ0QsSUFBSSxrQkFBa0IsR0FBMEIsSUFBSSxDQUFDO1lBQ3JELElBQUksdUJBQXVCLEdBQTBCLElBQUksQ0FBQztZQUMxRCxJQUFJLHFCQUFxQixHQUFHLEtBQUssQ0FBQztZQUNsQyxJQUFJLElBQUksQ0FBQyxrQkFBa0IsS0FBSywyQkFBMkIsRUFBRSxDQUFDO2dCQUM1RCw4Q0FBOEM7Z0JBQzlDLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLENBQUM7Z0JBQ3JELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxlQUFlLEdBQUcsQ0FBQyxHQUFHLGVBQWUsQ0FBQztnQkFDckUsa0JBQWtCLEdBQUcsc0JBQVUsQ0FBQyxHQUFHLEVBQUU7O29CQUNuQyxxQkFBcUIsR0FBRyxJQUFJLENBQUM7b0JBQzdCLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO3dCQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FDekIsU0FBUyxFQUNULGdEQUFnRCxHQUFHLGFBQWEsQ0FDakUsQ0FBQztvQkFDSixDQUFDO29CQUNELElBQUksQ0FBQzt3QkFDSCxPQUFPLENBQUMsTUFBTSxDQUNaLEtBQUssQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEVBQ2hDLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRSxDQUFDLENBQ1YsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FDdkIsQ0FBQztvQkFDSixDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQzt3QkFDWCxpRUFBaUU7d0JBQ2pFLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQzt3QkFDbEIsT0FBTztvQkFDVCxDQUFDO29CQUNELE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDaEI7aURBQzZCLENBQzdCLElBQUksSUFBSSxDQUFDLHVCQUF1QixLQUFLLDJCQUEyQixFQUFFLENBQUM7d0JBQ2pFLHVCQUF1QixHQUFHLHNCQUFVLENBQUMsR0FBRyxFQUFFOzRCQUN4QyxPQUFPLENBQUMsT0FBTyxFQUFFLENBQUM7d0JBQ3BCLENBQUMsRUFBRSxJQUFJLENBQUMsd0JBQXVCLENBQUMsQ0FBQyxXQUFLLDRDQUFJLENBQUM7b0JBQzdDLENBQUM7Z0JBQ0gsQ0FBQyxFQUFFLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxPQUFNLENBQUMsQ0FBQyxXQUFLLDRDQUFJLENBQUM7WUFDakQsQ0FBQztZQUNELE1BQU0sa0JBQWtCLEdBQTBCLHVCQUFXLENBQUMsR0FBRyxFQUFFOztnQkFDakUsTUFBTSxZQUFZLEdBQUcsc0JBQVUsQ0FBQyxHQUFHLEVBQUU7b0JBQ25DLHFCQUFxQixHQUFHLElBQUksQ0FBQztvQkFDN0IsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7d0JBQ3pCLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUN6QixTQUFTLEVBQ1QsK0NBQStDLEdBQUcsYUFBYSxDQUNoRSxDQUFDO29CQUNKLENBQUM7b0JBQ0QsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO2dCQUNsQixDQUFDLEVBQUUsSUFBSSxDQUFDLG1CQUFrQixDQUFDLENBQUMsV0FBSyw0Q0FBSSxDQUFDO2dCQUN0QyxJQUFJLENBQUM7b0JBQ0gsT0FBTyxDQUFDLElBQUksQ0FDVixDQUFDLEdBQWlCLEVBQUUsUUFBZ0IsRUFBRSxPQUFlLEVBQUUsRUFBRTt3QkFDdkQsWUFBWSxDQUFDLFlBQVksQ0FBQyxDQUFDO29CQUM3QixDQUFDLENBQ0YsQ0FBQztnQkFDSixDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQztvQkFDWCwrREFBK0Q7b0JBQy9ELE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztnQkFDcEIsQ0FBQztZQUNILENBQUMsRUFBRSxJQUFJLENBQUMsZ0JBQWUsQ0FBQyxDQUFDLFdBQUssNENBQUksQ0FBQztZQUNuQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUU7Z0JBQ3ZCLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO29CQUN6QixJQUFJLENBQUMscUJBQXFCLEVBQUUsQ0FBQzt3QkFDM0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQ3pCLFNBQVMsRUFDVCwrQkFBK0IsR0FBRyxhQUFhLENBQ2hELENBQUM7b0JBQ0osQ0FBQztvQkFDRCxJQUFJLENBQUMsc0JBQXNCLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO29CQUNwRCxzQ0FBc0IsV0FBVyxDQUFDLENBQUM7Z0JBQ3JDLENBQUM7Z0JBQ0QsSUFBSSxrQkFBa0IsRUFBRSxDQUFDO29CQUN2QixZQUFZLENBQUMsa0JBQWtCLENBQUMsQ0FBQztnQkFDbkMsQ0FBQztnQkFDRCxJQUFJLHVCQUF1QixFQUFFLENBQUM7b0JBQzVCLFlBQVksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO2dCQUN4QyxDQUFDO2dCQUNELElBQUksa0JBQWtCLEVBQUUsQ0FBQztvQkFDdkIsWUFBWSxDQUFDLGtCQUFrQixDQUFDLENBQUM7Z0JBQ25DLENBQUM7Z0JBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDaEMsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7Q0FDRjtBQTNnQ0Qsd0JBMmdDQztBQUVELEtBQUssVUFBVSxXQUFXLENBQ3hCLElBQXNELEVBQ3RELE9BQWdELEVBQ2hELFFBQWtCLEVBQ2xCLFFBQWdCO0lBRWhCLElBQUksQ0FBQztRQUNILE1BQU0sT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXpELElBQUksT0FBTyxLQUFLLFNBQVMsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDNUMsT0FBTztRQUNULENBQUM7UUFFRCxNQUFNLE9BQU8sR0FBRyxJQUFJLGlDQUFtQixDQUNyQyxJQUFJLEVBQ0osUUFBUSxFQUNSLE9BQU8sQ0FDUixDQUFDO1FBRUYsT0FBTyxDQUFDLElBQUksQ0FDVixPQUFPLEVBQ1AsQ0FDRSxHQUFzRCxFQUN0RCxLQUEyQixFQUMzQixPQUFrQixFQUNsQixLQUFjLEVBQ2QsRUFBRTtZQUNGLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNwRCxDQUFDLENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUEwQixDQUFDLENBQUM7SUFDN0MsQ0FBQztBQUNILENBQUM7QUFFRCxTQUFTLHFCQUFxQixDQUM1QixJQUFzRCxFQUN0RCxPQUEwRCxFQUMxRCxRQUFrQixFQUNsQixRQUFnQjtJQUVoQixNQUFNLE1BQU0sR0FBRyxJQUFJLHNDQUF3QixDQUN6QyxJQUFJLEVBQ0osUUFBUSxFQUNSLE9BQU8sQ0FBQyxXQUFXLEVBQ25CLFFBQVEsQ0FDVCxDQUFDO0lBRUYsU0FBUyxPQUFPLENBQ2QsR0FBc0QsRUFDdEQsS0FBMkIsRUFDM0IsT0FBa0IsRUFDbEIsS0FBYztRQUVkLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNqQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVELElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ25CLE9BQU87SUFDVCxDQUFDO0lBRUQsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDNUIsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsT0FBTyxDQUFDLENBQUM7QUFDaEMsQ0FBQztBQUVELEtBQUssVUFBVSxxQkFBcUIsQ0FDbEMsSUFBc0QsRUFDdEQsT0FBMEQsRUFDMUQsUUFBa0IsRUFDbEIsUUFBZ0I7SUFFaEIsSUFBSSxDQUFDO1FBQ0gsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFekQsSUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztZQUM1QyxPQUFPO1FBQ1QsQ0FBQztRQUVELE1BQU0sTUFBTSxHQUFHLElBQUksc0NBQXdCLENBQ3pDLElBQUksRUFDSixRQUFRLEVBQ1IsT0FBTyxDQUFDLFNBQVMsRUFDakIsT0FBTyxDQUNSLENBQUM7UUFFRixPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZCLENBQUMsQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1FBQ2IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUEwQixDQUFDLENBQUM7SUFDN0MsQ0FBQztBQUNILENBQUM7QUFFRCxTQUFTLG1CQUFtQixDQUMxQixJQUFzRCxFQUN0RCxPQUF3RCxFQUN4RCxRQUFrQixFQUNsQixRQUFnQjtJQUVoQixNQUFNLE1BQU0sR0FBRyxJQUFJLG9DQUFzQixDQUN2QyxJQUFJLEVBQ0osUUFBUSxFQUNSLE9BQU8sQ0FBQyxTQUFTLEVBQ2pCLE9BQU8sQ0FBQyxXQUFXLEVBQ25CLFFBQVEsQ0FDVCxDQUFDO0lBRUYsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDbkIsT0FBTztJQUNULENBQUM7SUFFRCxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZCLENBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC9zcmMvc2VydmVyLnRzIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = exports.validateRetryThrottling = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */\n/* The any type is purposely used here. All functions validate their input at\n * runtime */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */\nconst DURATION_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */\nconst CLIENT_LANGUAGE_STRING = 'node';\nfunction validateName(obj) {\n    // In this context, and unset field and '' are considered the same\n    if ('service' in obj && obj.service !== '') {\n        if (typeof obj.service !== 'string') {\n            throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);\n        }\n        if ('method' in obj && obj.method !== '') {\n            if (typeof obj.method !== 'string') {\n                throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);\n            }\n            return {\n                service: obj.service,\n                method: obj.method,\n            };\n        }\n        else {\n            return {\n                service: obj.service,\n            };\n        }\n    }\n    else {\n        if ('method' in obj && obj.method !== undefined) {\n            throw new Error(`Invalid method config name: method set with empty or unset service`);\n        }\n        return {};\n    }\n}\nfunction validateRetryPolicy(obj) {\n    if (!('maxAttempts' in obj) ||\n        !Number.isInteger(obj.maxAttempts) ||\n        obj.maxAttempts < 2) {\n        throw new Error('Invalid method config retry policy: maxAttempts must be an integer at least 2');\n    }\n    if (!('initialBackoff' in obj) ||\n        typeof obj.initialBackoff !== 'string' ||\n        !DURATION_REGEX.test(obj.initialBackoff)) {\n        throw new Error('Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s');\n    }\n    if (!('maxBackoff' in obj) ||\n        typeof obj.maxBackoff !== 'string' ||\n        !DURATION_REGEX.test(obj.maxBackoff)) {\n        throw new Error('Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s');\n    }\n    if (!('backoffMultiplier' in obj) ||\n        typeof obj.backoffMultiplier !== 'number' ||\n        obj.backoffMultiplier <= 0) {\n        throw new Error('Invalid method config retry policy: backoffMultiplier must be a number greater than 0');\n    }\n    if (!('retryableStatusCodes' in obj && Array.isArray(obj.retryableStatusCodes))) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes is required');\n    }\n    if (obj.retryableStatusCodes.length === 0) {\n        throw new Error('Invalid method config retry policy: retryableStatusCodes must be non-empty');\n    }\n    for (const value of obj.retryableStatusCodes) {\n        if (typeof value === 'number') {\n            if (!Object.values(constants_1.Status).includes(value)) {\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not in status code range');\n            }\n        }\n        else if (typeof value === 'string') {\n            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                throw new Error('Invalid method config retry policy: retryableStatusCodes value not a status code name');\n            }\n        }\n        else {\n            throw new Error('Invalid method config retry policy: retryableStatusCodes value must be a string or number');\n        }\n    }\n    return {\n        maxAttempts: obj.maxAttempts,\n        initialBackoff: obj.initialBackoff,\n        maxBackoff: obj.maxBackoff,\n        backoffMultiplier: obj.backoffMultiplier,\n        retryableStatusCodes: obj.retryableStatusCodes,\n    };\n}\nfunction validateHedgingPolicy(obj) {\n    if (!('maxAttempts' in obj) ||\n        !Number.isInteger(obj.maxAttempts) ||\n        obj.maxAttempts < 2) {\n        throw new Error('Invalid method config hedging policy: maxAttempts must be an integer at least 2');\n    }\n    if ('hedgingDelay' in obj &&\n        (typeof obj.hedgingDelay !== 'string' ||\n            !DURATION_REGEX.test(obj.hedgingDelay))) {\n        throw new Error('Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s');\n    }\n    if ('nonFatalStatusCodes' in obj && Array.isArray(obj.nonFatalStatusCodes)) {\n        for (const value of obj.nonFatalStatusCodes) {\n            if (typeof value === 'number') {\n                if (!Object.values(constants_1.Status).includes(value)) {\n                    throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not in status code range');\n                }\n            }\n            else if (typeof value === 'string') {\n                if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {\n                    throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value not a status code name');\n                }\n            }\n            else {\n                throw new Error('Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number');\n            }\n        }\n    }\n    const result = {\n        maxAttempts: obj.maxAttempts,\n    };\n    if (obj.hedgingDelay) {\n        result.hedgingDelay = obj.hedgingDelay;\n    }\n    if (obj.nonFatalStatusCodes) {\n        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: [],\n    };\n    if (!('name' in obj) || !Array.isArray(obj.name)) {\n        throw new Error('Invalid method config: invalid name array');\n    }\n    for (const name of obj.name) {\n        result.name.push(validateName(name));\n    }\n    if ('waitForReady' in obj) {\n        if (typeof obj.waitForReady !== 'boolean') {\n            throw new Error('Invalid method config: invalid waitForReady');\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if ('timeout' in obj) {\n        if (typeof obj.timeout === 'object') {\n            if (!('seconds' in obj.timeout) ||\n                !(typeof obj.timeout.seconds === 'number')) {\n                throw new Error('Invalid method config: invalid timeout.seconds');\n            }\n            if (!('nanos' in obj.timeout) ||\n                !(typeof obj.timeout.nanos === 'number')) {\n                throw new Error('Invalid method config: invalid timeout.nanos');\n            }\n            result.timeout = obj.timeout;\n        }\n        else if (typeof obj.timeout === 'string' &&\n            DURATION_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout\n                .substring(0, obj.timeout.length - 1)\n                .split('.');\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0,\n            };\n        }\n        else {\n            throw new Error('Invalid method config: invalid timeout');\n        }\n    }\n    if ('maxRequestBytes' in obj) {\n        if (typeof obj.maxRequestBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if ('maxResponseBytes' in obj) {\n        if (typeof obj.maxResponseBytes !== 'number') {\n            throw new Error('Invalid method config: invalid maxRequestBytes');\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    if ('retryPolicy' in obj) {\n        if ('hedgingPolicy' in obj) {\n            throw new Error('Invalid method config: retryPolicy and hedgingPolicy cannot both be specified');\n        }\n        else {\n            result.retryPolicy = validateRetryPolicy(obj.retryPolicy);\n        }\n    }\n    else if ('hedgingPolicy' in obj) {\n        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);\n    }\n    return result;\n}\nfunction validateRetryThrottling(obj) {\n    if (!('maxTokens' in obj) ||\n        typeof obj.maxTokens !== 'number' ||\n        obj.maxTokens <= 0 ||\n        obj.maxTokens > 1000) {\n        throw new Error('Invalid retryThrottling: maxTokens must be a number in (0, 1000]');\n    }\n    if (!('tokenRatio' in obj) ||\n        typeof obj.tokenRatio !== 'number' ||\n        obj.tokenRatio <= 0) {\n        throw new Error('Invalid retryThrottling: tokenRatio must be a number greater than 0');\n    }\n    return {\n        maxTokens: +obj.maxTokens.toFixed(3),\n        tokenRatio: +obj.tokenRatio.toFixed(3),\n    };\n}\nexports.validateRetryThrottling = validateRetryThrottling;\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: [],\n    };\n    if ('loadBalancingPolicy' in obj) {\n        if (typeof obj.loadBalancingPolicy === 'string') {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingPolicy');\n        }\n    }\n    if ('loadBalancingConfig' in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig) {\n                result.loadBalancingConfig.push((0, load_balancer_1.validateLoadBalancingConfig)(config));\n            }\n        }\n        else {\n            throw new Error('Invalid service config: invalid loadBalancingConfig');\n        }\n    }\n    if ('methodConfig' in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig) {\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    if ('retryThrottling' in obj) {\n        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig) {\n        for (const name of methodConfig.name) {\n            for (const seenName of seenMethodNames) {\n                if (name.service === seenName.service &&\n                    name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n    if (!('serviceConfig' in obj)) {\n        throw new Error('Invalid service config choice: missing service config');\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig),\n    };\n    if ('clientLanguage' in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage) {\n                if (typeof lang === 'string') {\n                    result.clientLanguage.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientLanguage');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientLanguage');\n        }\n    }\n    if ('clientHostname' in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname) {\n                if (typeof lang === 'string') {\n                    result.clientHostname.push(lang);\n                }\n                else {\n                    throw new Error('Invalid service config choice: invalid clientHostname');\n                }\n            }\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid clientHostname');\n        }\n    }\n    if ('percentage' in obj) {\n        if (typeof obj.percentage === 'number' &&\n            0 <= obj.percentage &&\n            obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        }\n        else {\n            throw new Error('Invalid service config choice: invalid percentage');\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        'clientLanguage',\n        'percentage',\n        'clientHostname',\n        'serviceConfig',\n    ];\n    for (const field in obj) {\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error('Invalid service config list');\n    }\n    for (const config of obj) {\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */\n        if (typeof validatedConfig.percentage === 'number' &&\n            percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname) {\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage) {\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error('No matching service config found');\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */\nfunction extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord) {\n        if (record.length > 0 && record[0].startsWith('grpc_config=')) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */\n            const recordString = record.join('').substring('grpc_config='.length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig;\n//# sourceMappingURL=service-config.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQ0FBcUMsR0FBRyw2QkFBNkIsR0FBRywrQkFBK0I7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMsd0JBQXdCLG1CQUFPLENBQUMsc0ZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHLG1CQUFtQjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsbUJBQW1CO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLGFBQWEsR0FBRyxZQUFZO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZpY2UtY29uZmlnLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnID0gZXhwb3J0cy52YWxpZGF0ZVNlcnZpY2VDb25maWcgPSBleHBvcnRzLnZhbGlkYXRlUmV0cnlUaHJvdHRsaW5nID0gdm9pZCAwO1xuLyogVGhpcyBmaWxlIGltcGxlbWVudHMgZ1JGQyBBMiBhbmQgdGhlIHNlcnZpY2UgY29uZmlnIHNwZWM6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9wcm9wb3NhbC9ibG9iL21hc3Rlci9BMi1zZXJ2aWNlLWNvbmZpZ3MtaW4tZG5zLm1kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjL2Jsb2IvbWFzdGVyL2RvYy9zZXJ2aWNlX2NvbmZpZy5tZC4gRWFjaFxuICogZnVuY3Rpb24gaGVyZSB0YWtlcyBhbiBvYmplY3Qgd2l0aCB1bmtub3duIHN0cnVjdHVyZSBhbmQgcmV0dXJucyBpdHNcbiAqIHNwZWNpZmljIG9iamVjdCB0eXBlIGlmIHRoZSBpbnB1dCBoYXMgdGhlIHJpZ2h0IHN0cnVjdHVyZSwgYW5kIHRocm93cyBhblxuICogZXJyb3Igb3RoZXJ3aXNlLiAqL1xuLyogVGhlIGFueSB0eXBlIGlzIHB1cnBvc2VseSB1c2VkIGhlcmUuIEFsbCBmdW5jdGlvbnMgdmFsaWRhdGUgdGhlaXIgaW5wdXQgYXRcbiAqIHJ1bnRpbWUgKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IG9zID0gcmVxdWlyZShcIm9zXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuLyoqXG4gKiBSZWNvZ25pemVzIGEgbnVtYmVyIHdpdGggdXAgdG8gOSBkaWdpdHMgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnQsIGZvbGxvd2VkIGJ5XG4gKiBhbiBcInNcIiwgcmVwcmVzZW50aW5nIGEgbnVtYmVyIG9mIHNlY29uZHMuXG4gKi9cbmNvbnN0IERVUkFUSU9OX1JFR0VYID0gL15cXGQrKFxcLlxcZHsxLDl9KT9zJC87XG4vKipcbiAqIENsaWVudCBsYW5ndWFnZSBuYW1lIHVzZWQgZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhpcyBjbGllbnQgbWF0Y2hlcyBhXG4gKiBgU2VydmljZUNvbmZpZ0NhbmFyeUNvbmZpZ2AncyBgY2xpZW50TGFuZ3VhZ2VgIGxpc3QuXG4gKi9cbmNvbnN0IENMSUVOVF9MQU5HVUFHRV9TVFJJTkcgPSAnbm9kZSc7XG5mdW5jdGlvbiB2YWxpZGF0ZU5hbWUob2JqKSB7XG4gICAgLy8gSW4gdGhpcyBjb250ZXh0LCBhbmQgdW5zZXQgZmllbGQgYW5kICcnIGFyZSBjb25zaWRlcmVkIHRoZSBzYW1lXG4gICAgaWYgKCdzZXJ2aWNlJyBpbiBvYmogJiYgb2JqLnNlcnZpY2UgIT09ICcnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnNlcnZpY2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWV0aG9kIGNvbmZpZyBuYW1lOiBpbnZhbGlkIHNlcnZpY2U6IGV4cGVjdGVkIHR5cGUgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygb2JqLnNlcnZpY2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdtZXRob2QnIGluIG9iaiAmJiBvYmoubWV0aG9kICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmoubWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtZXRob2QgY29uZmlnIG5hbWU6IGludmFsaWQgbWV0aG9kOiBleHBlY3RlZCB0eXBlIHN0cmluZywgZ290ICR7dHlwZW9mIG9iai5zZXJ2aWNlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiBvYmouc2VydmljZSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG9iai5tZXRob2QsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZXJ2aWNlOiBvYmouc2VydmljZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICgnbWV0aG9kJyBpbiBvYmogJiYgb2JqLm1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWV0aG9kIGNvbmZpZyBuYW1lOiBtZXRob2Qgc2V0IHdpdGggZW1wdHkgb3IgdW5zZXQgc2VydmljZWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVJldHJ5UG9saWN5KG9iaikge1xuICAgIGlmICghKCdtYXhBdHRlbXB0cycgaW4gb2JqKSB8fFxuICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvYmoubWF4QXR0ZW1wdHMpIHx8XG4gICAgICAgIG9iai5tYXhBdHRlbXB0cyA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgcmV0cnkgcG9saWN5OiBtYXhBdHRlbXB0cyBtdXN0IGJlIGFuIGludGVnZXIgYXQgbGVhc3QgMicpO1xuICAgIH1cbiAgICBpZiAoISgnaW5pdGlhbEJhY2tvZmYnIGluIG9iaikgfHxcbiAgICAgICAgdHlwZW9mIG9iai5pbml0aWFsQmFja29mZiAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLmluaXRpYWxCYWNrb2ZmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IGluaXRpYWxCYWNrb2ZmIG11c3QgYmUgYSBzdHJpbmcgY29uc2lzdGluZyBvZiBhIHBvc2l0aXZlIGludGVnZXIgZm9sbG93ZWQgYnkgcycpO1xuICAgIH1cbiAgICBpZiAoISgnbWF4QmFja29mZicgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLm1heEJhY2tvZmYgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFEVVJBVElPTl9SRUdFWC50ZXN0KG9iai5tYXhCYWNrb2ZmKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IG1heEJhY2tvZmYgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieSBzJyk7XG4gICAgfVxuICAgIGlmICghKCdiYWNrb2ZmTXVsdGlwbGllcicgaW4gb2JqKSB8fFxuICAgICAgICB0eXBlb2Ygb2JqLmJhY2tvZmZNdWx0aXBsaWVyICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICBvYmouYmFja29mZk11bHRpcGxpZXIgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IGJhY2tvZmZNdWx0aXBsaWVyIG11c3QgYmUgYSBudW1iZXIgZ3JlYXRlciB0aGFuIDAnKTtcbiAgICB9XG4gICAgaWYgKCEoJ3JldHJ5YWJsZVN0YXR1c0NvZGVzJyBpbiBvYmogJiYgQXJyYXkuaXNBcnJheShvYmoucmV0cnlhYmxlU3RhdHVzQ29kZXMpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChvYmoucmV0cnlhYmxlU3RhdHVzQ29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgbXVzdCBiZSBub24tZW1wdHknKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBvYmoucmV0cnlhYmxlU3RhdHVzQ29kZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5TdGF0dXMpLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgdmFsdWUgbm90IGluIHN0YXR1cyBjb2RlIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZyByZXRyeSBwb2xpY3k6IHJldHJ5YWJsZVN0YXR1c0NvZGVzIHZhbHVlIG5vdCBhIHN0YXR1cyBjb2RlIG5hbWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIHJldHJ5IHBvbGljeTogcmV0cnlhYmxlU3RhdHVzQ29kZXMgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXInKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXhBdHRlbXB0czogb2JqLm1heEF0dGVtcHRzLFxuICAgICAgICBpbml0aWFsQmFja29mZjogb2JqLmluaXRpYWxCYWNrb2ZmLFxuICAgICAgICBtYXhCYWNrb2ZmOiBvYmoubWF4QmFja29mZixcbiAgICAgICAgYmFja29mZk11bHRpcGxpZXI6IG9iai5iYWNrb2ZmTXVsdGlwbGllcixcbiAgICAgICAgcmV0cnlhYmxlU3RhdHVzQ29kZXM6IG9iai5yZXRyeWFibGVTdGF0dXNDb2RlcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVIZWRnaW5nUG9saWN5KG9iaikge1xuICAgIGlmICghKCdtYXhBdHRlbXB0cycgaW4gb2JqKSB8fFxuICAgICAgICAhTnVtYmVyLmlzSW50ZWdlcihvYmoubWF4QXR0ZW1wdHMpIHx8XG4gICAgICAgIG9iai5tYXhBdHRlbXB0cyA8IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG1heEF0dGVtcHRzIG11c3QgYmUgYW4gaW50ZWdlciBhdCBsZWFzdCAyJyk7XG4gICAgfVxuICAgIGlmICgnaGVkZ2luZ0RlbGF5JyBpbiBvYmogJiZcbiAgICAgICAgKHR5cGVvZiBvYmouaGVkZ2luZ0RlbGF5ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgIURVUkFUSU9OX1JFR0VYLnRlc3Qob2JqLmhlZGdpbmdEZWxheSkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnIGhlZGdpbmcgcG9saWN5OiBoZWRnaW5nRGVsYXkgbXVzdCBiZSBhIHN0cmluZyBjb25zaXN0aW5nIG9mIGEgcG9zaXRpdmUgaW50ZWdlciBmb2xsb3dlZCBieSBzJyk7XG4gICAgfVxuICAgIGlmICgnbm9uRmF0YWxTdGF0dXNDb2RlcycgaW4gb2JqICYmIEFycmF5LmlzQXJyYXkob2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2Ygb2JqLm5vbkZhdGFsU3RhdHVzQ29kZXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3QudmFsdWVzKGNvbnN0YW50c18xLlN0YXR1cykuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52bGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG5vbkZhdGFsU3RhdHVzQ29kZXMgdmFsdWUgbm90IGluIHN0YXR1cyBjb2RlIHJhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5TdGF0dXMpLmluY2x1ZGVzKHZhbHVlLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52bGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG5vbkZhdGFsU3RhdHVzQ29kZXMgdmFsdWUgbm90IGEgc3RhdHVzIGNvZGUgbmFtZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52bGlkIG1ldGhvZCBjb25maWcgaGVkZ2luZyBwb2xpY3k6IG5vbkZhdGFsU3RhdHVzQ29kZXMgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvciBudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG1heEF0dGVtcHRzOiBvYmoubWF4QXR0ZW1wdHMsXG4gICAgfTtcbiAgICBpZiAob2JqLmhlZGdpbmdEZWxheSkge1xuICAgICAgICByZXN1bHQuaGVkZ2luZ0RlbGF5ID0gb2JqLmhlZGdpbmdEZWxheTtcbiAgICB9XG4gICAgaWYgKG9iai5ub25GYXRhbFN0YXR1c0NvZGVzKSB7XG4gICAgICAgIHJlc3VsdC5ub25GYXRhbFN0YXR1c0NvZGVzID0gb2JqLm5vbkZhdGFsU3RhdHVzQ29kZXM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZENvbmZpZyhvYmopIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBuYW1lOiBbXSxcbiAgICB9O1xuICAgIGlmICghKCduYW1lJyBpbiBvYmopIHx8ICFBcnJheS5pc0FycmF5KG9iai5uYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBuYW1lIGFycmF5Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBvYmoubmFtZSkge1xuICAgICAgICByZXN1bHQubmFtZS5wdXNoKHZhbGlkYXRlTmFtZShuYW1lKSk7XG4gICAgfVxuICAgIGlmICgnd2FpdEZvclJlYWR5JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoud2FpdEZvclJlYWR5ICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHdhaXRGb3JSZWFkeScpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC53YWl0Rm9yUmVhZHkgPSBvYmoud2FpdEZvclJlYWR5O1xuICAgIH1cbiAgICBpZiAoJ3RpbWVvdXQnIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai50aW1lb3V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKCEoJ3NlY29uZHMnIGluIG9iai50aW1lb3V0KSB8fFxuICAgICAgICAgICAgICAgICEodHlwZW9mIG9iai50aW1lb3V0LnNlY29uZHMgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQuc2Vjb25kcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoJ25hbm9zJyBpbiBvYmoudGltZW91dCkgfHxcbiAgICAgICAgICAgICAgICAhKHR5cGVvZiBvYmoudGltZW91dC5uYW5vcyA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dC5uYW5vcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnRpbWVvdXQgPSBvYmoudGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqLnRpbWVvdXQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBEVVJBVElPTl9SRUdFWC50ZXN0KG9iai50aW1lb3V0KSkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dFBhcnRzID0gb2JqLnRpbWVvdXRcbiAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIG9iai50aW1lb3V0Lmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IHtcbiAgICAgICAgICAgICAgICBzZWNvbmRzOiB0aW1lb3V0UGFydHNbMF0gfCAwLFxuICAgICAgICAgICAgICAgIG5hbm9zOiAoKF9hID0gdGltZW91dFBhcnRzWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSB8IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbWF4UmVxdWVzdEJ5dGVzJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubWF4UmVxdWVzdEJ5dGVzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbWF4UmVxdWVzdEJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1heFJlcXVlc3RCeXRlcyA9IG9iai5tYXhSZXF1ZXN0Qnl0ZXM7XG4gICAgfVxuICAgIGlmICgnbWF4UmVzcG9uc2VCeXRlcycgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1heFJlc3BvbnNlQnl0ZXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubWF4UmVzcG9uc2VCeXRlcyA9IG9iai5tYXhSZXNwb25zZUJ5dGVzO1xuICAgIH1cbiAgICBpZiAoJ3JldHJ5UG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKCdoZWRnaW5nUG9saWN5JyBpbiBvYmopIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiByZXRyeVBvbGljeSBhbmQgaGVkZ2luZ1BvbGljeSBjYW5ub3QgYm90aCBiZSBzcGVjaWZpZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZXRyeVBvbGljeSA9IHZhbGlkYXRlUmV0cnlQb2xpY3kob2JqLnJldHJ5UG9saWN5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgnaGVkZ2luZ1BvbGljeScgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdC5oZWRnaW5nUG9saWN5ID0gdmFsaWRhdGVIZWRnaW5nUG9saWN5KG9iai5oZWRnaW5nUG9saWN5KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmV0cnlUaHJvdHRsaW5nKG9iaikge1xuICAgIGlmICghKCdtYXhUb2tlbnMnIGluIG9iaikgfHxcbiAgICAgICAgdHlwZW9mIG9iai5tYXhUb2tlbnMgIT09ICdudW1iZXInIHx8XG4gICAgICAgIG9iai5tYXhUb2tlbnMgPD0gMCB8fFxuICAgICAgICBvYmoubWF4VG9rZW5zID4gMTAwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmV0cnlUaHJvdHRsaW5nOiBtYXhUb2tlbnMgbXVzdCBiZSBhIG51bWJlciBpbiAoMCwgMTAwMF0nKTtcbiAgICB9XG4gICAgaWYgKCEoJ3Rva2VuUmF0aW8nIGluIG9iaikgfHxcbiAgICAgICAgdHlwZW9mIG9iai50b2tlblJhdGlvICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICBvYmoudG9rZW5SYXRpbyA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXRyeVRocm90dGxpbmc6IHRva2VuUmF0aW8gbXVzdCBiZSBhIG51bWJlciBncmVhdGVyIHRoYW4gMCcpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtYXhUb2tlbnM6ICtvYmoubWF4VG9rZW5zLnRvRml4ZWQoMyksXG4gICAgICAgIHRva2VuUmF0aW86ICtvYmoudG9rZW5SYXRpby50b0ZpeGVkKDMpLFxuICAgIH07XG59XG5leHBvcnRzLnZhbGlkYXRlUmV0cnlUaHJvdHRsaW5nID0gdmFsaWRhdGVSZXRyeVRocm90dGxpbmc7XG5mdW5jdGlvbiB2YWxpZGF0ZVNlcnZpY2VDb25maWcob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBsb2FkQmFsYW5jaW5nQ29uZmlnOiBbXSxcbiAgICAgICAgbWV0aG9kQ29uZmlnOiBbXSxcbiAgICB9O1xuICAgIGlmICgnbG9hZEJhbGFuY2luZ1BvbGljeScgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLmxvYWRCYWxhbmNpbmdQb2xpY3kgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXN1bHQubG9hZEJhbGFuY2luZ1BvbGljeSA9IG9iai5sb2FkQmFsYW5jaW5nUG9saWN5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnOiBpbnZhbGlkIGxvYWRCYWxhbmNpbmdQb2xpY3knKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ2xvYWRCYWxhbmNpbmdDb25maWcnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubG9hZEJhbGFuY2luZ0NvbmZpZykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29uZmlnIG9mIG9iai5sb2FkQmFsYW5jaW5nQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmxvYWRCYWxhbmNpbmdDb25maWcucHVzaCgoMCwgbG9hZF9iYWxhbmNlcl8xLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZykoY29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWc6IGludmFsaWQgbG9hZEJhbGFuY2luZ0NvbmZpZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbWV0aG9kQ29uZmlnJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLm1ldGhvZENvbmZpZykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIG9iai5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQubWV0aG9kQ29uZmlnLnB1c2godmFsaWRhdGVNZXRob2RDb25maWcobWV0aG9kQ29uZmlnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdyZXRyeVRocm90dGxpbmcnIGluIG9iaikge1xuICAgICAgICByZXN1bHQucmV0cnlUaHJvdHRsaW5nID0gdmFsaWRhdGVSZXRyeVRocm90dGxpbmcob2JqLnJldHJ5VGhyb3R0bGluZyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIG1ldGhvZCBuYW1lIHVuaXF1ZW5lc3NcbiAgICBjb25zdCBzZWVuTWV0aG9kTmFtZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG1ldGhvZENvbmZpZyBvZiByZXN1bHQubWV0aG9kQ29uZmlnKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXRob2RDb25maWcubmFtZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZWVuTmFtZSBvZiBzZWVuTWV0aG9kTmFtZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZS5zZXJ2aWNlID09PSBzZWVuTmFtZS5zZXJ2aWNlICYmXG4gICAgICAgICAgICAgICAgICAgIG5hbWUubWV0aG9kID09PSBzZWVuTmFtZS5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHNlcnZpY2UgY29uZmlnOiBkdXBsaWNhdGUgbmFtZSAke25hbWUuc2VydmljZX0vJHtuYW1lLm1ldGhvZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWVuTWV0aG9kTmFtZXMucHVzaChuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy52YWxpZGF0ZVNlcnZpY2VDb25maWcgPSB2YWxpZGF0ZVNlcnZpY2VDb25maWc7XG5mdW5jdGlvbiB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhvYmopIHtcbiAgICBpZiAoISgnc2VydmljZUNvbmZpZycgaW4gb2JqKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBtaXNzaW5nIHNlcnZpY2UgY29uZmlnJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2VydmljZUNvbmZpZzogdmFsaWRhdGVTZXJ2aWNlQ29uZmlnKG9iai5zZXJ2aWNlQ29uZmlnKSxcbiAgICB9O1xuICAgIGlmICgnY2xpZW50TGFuZ3VhZ2UnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmouY2xpZW50TGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICByZXN1bHQuY2xpZW50TGFuZ3VhZ2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZyBvZiBvYmouY2xpZW50TGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxhbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jbGllbnRMYW5ndWFnZS5wdXNoKGxhbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRMYW5ndWFnZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50TGFuZ3VhZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoJ2NsaWVudEhvc3RuYW1lJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudEhvc3RuYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0LmNsaWVudEhvc3RuYW1lID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmcgb2Ygb2JqLmNsaWVudEhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2xpZW50SG9zdG5hbWUucHVzaChsYW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50SG9zdG5hbWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudEhvc3RuYW1lJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdwZXJjZW50YWdlJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoucGVyY2VudGFnZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIDAgPD0gb2JqLnBlcmNlbnRhZ2UgJiZcbiAgICAgICAgICAgIG9iai5wZXJjZW50YWdlIDw9IDEwMCkge1xuICAgICAgICAgICAgcmVzdWx0LnBlcmNlbnRhZ2UgPSBvYmoucGVyY2VudGFnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgcGVyY2VudGFnZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHRoYXQgbm8gdW5leHBlY3RlZCBmaWVsZHMgYXJlIHByZXNlbnRcbiAgICBjb25zdCBhbGxvd2VkRmllbGRzID0gW1xuICAgICAgICAnY2xpZW50TGFuZ3VhZ2UnLFxuICAgICAgICAncGVyY2VudGFnZScsXG4gICAgICAgICdjbGllbnRIb3N0bmFtZScsXG4gICAgICAgICdzZXJ2aWNlQ29uZmlnJyxcbiAgICBdO1xuICAgIGZvciAoY29uc3QgZmllbGQgaW4gb2JqKSB7XG4gICAgICAgIGlmICghYWxsb3dlZEZpZWxkcy5pbmNsdWRlcyhmaWVsZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IHVuZXhwZWN0ZWQgZmllbGQgJHtmaWVsZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWcob2JqLCBwZXJjZW50YWdlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGxpc3QnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjb25maWcgb2Ygb2JqKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZENvbmZpZyA9IHZhbGlkYXRlQ2FuYXJ5Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIC8qIEZvciBlYWNoIGZpZWxkLCB3ZSBjaGVjayBpZiBpdCBpcyBwcmVzZW50LCB0aGVuIG9ubHkgZGlzY2FyZCB0aGVcbiAgICAgICAgICogY29uZmlnIGlmIHRoZSBmaWVsZCB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBjbGllbnQgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0ZWRDb25maWcucGVyY2VudGFnZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHBlcmNlbnRhZ2UgPiB2YWxpZGF0ZWRDb25maWcucGVyY2VudGFnZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSkge1xuICAgICAgICAgICAgbGV0IGhvc3RuYW1lTWF0Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBob3N0bmFtZSBvZiB2YWxpZGF0ZWRDb25maWcuY2xpZW50SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaG9zdG5hbWUgPT09IG9zLmhvc3RuYW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaG9zdG5hbWVNYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhvc3RuYW1lTWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRlZENvbmZpZy5jbGllbnRMYW5ndWFnZSkpIHtcbiAgICAgICAgICAgIGxldCBsYW5ndWFnZU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGFuZ3VhZ2Ugb2YgdmFsaWRhdGVkQ29uZmlnLmNsaWVudExhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhbmd1YWdlID09PSBDTElFTlRfTEFOR1VBR0VfU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsaWRhdGVkQ29uZmlnLnNlcnZpY2VDb25maWc7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm8gbWF0Y2hpbmcgc2VydmljZSBjb25maWcgZm91bmQnKTtcbn1cbi8qKlxuICogRmluZCB0aGUgXCJncnBjX2NvbmZpZ1wiIHJlY29yZCBhbW9uZyB0aGUgVFhUIHJlY29yZHMsIHBhcnNlIGl0cyB2YWx1ZSBhcyBKU09OLCB2YWxpZGF0ZSBpdHMgY29udGVudHMsXG4gKiBhbmQgc2VsZWN0IGEgc2VydmljZSBjb25maWcgd2l0aCBzZWxlY3Rpb24gZmllbGRzIHRoYXQgYWxsIG1hdGNoIHRoaXMgY2xpZW50LiBNb3N0IG9mIHRoZXNlIHN0ZXBzXG4gKiBjYW4gZmFpbCB3aXRoIGFuIGVycm9yOyB0aGUgY2FsbGVyIG11c3QgaGFuZGxlIGFueSBlcnJvcnMgdGhyb3duIHRoaXMgd2F5LlxuICogQHBhcmFtIHR4dFJlY29yZCBUaGUgVFhUIHJlY29yZCBhcnJheSB0aGF0IGlzIG91dHB1dCBmcm9tIGEgc3VjY2Vzc2Z1bCBjYWxsIHRvIGRucy5yZXNvbHZlVHh0XG4gKiBAcGFyYW0gcGVyY2VudGFnZSBBIG51bWJlciBjaG9zZW4gZnJvbSB0aGUgcmFuZ2UgWzAsIDEwMCkgdGhhdCBpcyB1c2VkIHRvIHNlbGVjdCB3aGljaCBjb25maWcgdG8gdXNlXG4gKiBAcmV0dXJuIFRoZSBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24gdG8gdXNlLCBnaXZlbiB0aGUgcGVyY2VudGFnZSB2YWx1ZSwgb3IgbnVsbCBpZiB0aGUgc2VydmljZSBjb25maWdcbiAqICAgICBkYXRhIGhhcyBhIHZhbGlkIGZvcm1hdCBidXQgbm9uZSBvZiB0aGUgb3B0aW9ucyBtYXRjaCB0aGUgY3VycmVudCBjbGllbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnKHR4dFJlY29yZCwgcGVyY2VudGFnZSkge1xuICAgIGZvciAoY29uc3QgcmVjb3JkIG9mIHR4dFJlY29yZCkge1xuICAgICAgICBpZiAocmVjb3JkLmxlbmd0aCA+IDAgJiYgcmVjb3JkWzBdLnN0YXJ0c1dpdGgoJ2dycGNfY29uZmlnPScpKSB7XG4gICAgICAgICAgICAvKiBUcmVhdCB0aGUgbGlzdCBvZiBzdHJpbmdzIGluIHRoaXMgcmVjb3JkIGFzIGEgc2luZ2xlIHN0cmluZyBhbmQgcmVtb3ZlXG4gICAgICAgICAgICAgKiBcImdycGNfY29uZmlnPVwiIGZyb20gdGhlIGJlZ2lubmluZy4gVGhlIHJlc3Qgc2hvdWxkIGJlIGEgSlNPTiBzdHJpbmcgKi9cbiAgICAgICAgICAgIGNvbnN0IHJlY29yZFN0cmluZyA9IHJlY29yZC5qb2luKCcnKS5zdWJzdHJpbmcoJ2dycGNfY29uZmlnPScubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZEpzb24gPSBKU09OLnBhcnNlKHJlY29yZFN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWcocmVjb3JkSnNvbiwgcGVyY2VudGFnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5leHBvcnRzLmV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnID0gZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2aWNlLWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */\nclass StatusBuilder {\n    constructor() {\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */\n    withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */\n    withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */\n    withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */\n    build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder;\n//# sourceMappingURL=status-builder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IHZvaWQgMDtcbi8qKlxuICogQSBidWlsZGVyIGZvciBnUlBDIHN0YXR1cyBvYmplY3RzLlxuICovXG5jbGFzcyBTdGF0dXNCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0dXMgY29kZSB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoQ29kZShjb2RlKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGRldGFpbHMgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aERldGFpbHMoZGV0YWlscykge1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBtZXRhZGF0YSB0byB0aGUgYnVpbGRlci5cbiAgICAgKi9cbiAgICB3aXRoTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBzdGF0dXMgb2JqZWN0LlxuICAgICAqL1xuICAgIGJ1aWxkKCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY29kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSB0aGlzLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGV0YWlscyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdHVzLmRldGFpbHMgPSB0aGlzLmRldGFpbHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWV0YWRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5tZXRhZGF0YSA9IHRoaXMubWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLlN0YXR1c0J1aWxkZXIgPSBTdGF0dXNCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdHVzLWJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function (ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor(maxReadMessageLength) {\n        this.maxReadMessageLength = maxReadMessageLength;\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while (readHead < data.length) {\n            switch (this.readState) {\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {\n                            throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);\n                        }\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        }\n                        else {\n                            const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize,\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error('Unexpected read state');\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder;\n//# sourceMappingURL=stream-decoder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixzQkFBc0IsS0FBSywwQkFBMEI7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdHJlYW0tZGVjb2Rlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJlYW1EZWNvZGVyID0gdm9pZCAwO1xudmFyIFJlYWRTdGF0ZTtcbihmdW5jdGlvbiAoUmVhZFN0YXRlKSB7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIk5PX0RBVEFcIl0gPSAwXSA9IFwiTk9fREFUQVwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJSRUFESU5HX1NJWkVcIl0gPSAxXSA9IFwiUkVBRElOR19TSVpFXCI7XG4gICAgUmVhZFN0YXRlW1JlYWRTdGF0ZVtcIlJFQURJTkdfTUVTU0FHRVwiXSA9IDJdID0gXCJSRUFESU5HX01FU1NBR0VcIjtcbn0pKFJlYWRTdGF0ZSB8fCAoUmVhZFN0YXRlID0ge30pKTtcbmNsYXNzIFN0cmVhbURlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG1heFJlYWRNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMubWF4UmVhZE1lc3NhZ2VMZW5ndGggPSBtYXhSZWFkTWVzc2FnZUxlbmd0aDtcbiAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9IDQ7XG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcbiAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XG4gICAgfVxuICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlYWRIZWFkID0gMDtcbiAgICAgICAgbGV0IHRvUmVhZDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkSGVhZCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucmVhZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuTk9fREFUQTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuUkVBRElOR19TSVpFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5maWxsKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19TSVpFOlxuICAgICAgICAgICAgICAgICAgICB0b1JlYWQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIHJlYWRIZWFkLCB0aGlzLnJlYWRTaXplUmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMucmVhZFBhcnRpYWxTaXplLCA0IC0gdGhpcy5yZWFkU2l6ZVJlbWFpbmluZywgcmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZFNpemVSZW1haW5pbmcgPj0wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFNpemVSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gdGhpcy5yZWFkUGFydGlhbFNpemUucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4UmVhZE1lc3NhZ2VMZW5ndGggIT09IC0xICYmIHRoaXMucmVhZE1lc3NhZ2VTaXplID4gdGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7dGhpcy5yZWFkTWVzc2FnZVNpemV9IHZzICR7dGhpcy5tYXhSZWFkTWVzc2FnZUxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gdGhpcy5yZWFkTWVzc2FnZVNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5SRUFESU5HX01FU1NBR0U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gQnVmZmVyLmNvbmNhdChbdGhpcy5yZWFkQ29tcHJlc3NGbGFnLCB0aGlzLnJlYWRQYXJ0aWFsU2l6ZV0sIDUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLk5PX0RBVEE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19NRVNTQUdFOlxuICAgICAgICAgICAgICAgICAgICB0b1JlYWQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIHJlYWRIZWFkLCB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UucHVzaChkYXRhLnNsaWNlKHJlYWRIZWFkLCByZWFkSGVhZCArIHRvUmVhZCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nIC09IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gdG9SZWFkO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkTWVzc2FnZVJlbWFpbmluZyA+PTAgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSByZWFkIGEgZnVsbCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZWRNZXNzYWdlQnVmZmVycyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRDb21wcmVzc0ZsYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdCh0aGlzLnJlYWRQYXJ0aWFsTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmFtZWRNZXNzYWdlID0gQnVmZmVyLmNvbmNhdChmcmFtZWRNZXNzYWdlQnVmZmVycywgdGhpcy5yZWFkTWVzc2FnZVNpemUgKyA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFN0YXRlID0gUmVhZFN0YXRlLk5PX0RBVEE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmcmFtZWRNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVhZCBzdGF0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJlYW1EZWNvZGVyID0gU3RyZWFtRGVjb2Rlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmVhbS1kZWNvZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return 'port' in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n    if (!address1 && !address2) {\n        return true;\n    }\n    if (!address1 || !address2) {\n        return false;\n    }\n    if (isTcpSubchannelAddress(address1)) {\n        return (isTcpSubchannelAddress(address2) &&\n            address1.host === address2.host &&\n            address1.port === address2.port);\n    }\n    else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        return address.host + ':' + address.port;\n    }\n    else {\n        return address.path;\n    }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if ((0, net_1.isIP)(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT,\n        };\n    }\n    else {\n        return {\n            path: addressString,\n        };\n    }\n}\nexports.stringToSubchannelAddress = stringToSubchannelAddress;\n//# sourceMappingURL=subchannel-address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcsaUNBQWlDLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCO0FBQ3ZJLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyA9IGV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyA9IGV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbCA9IGV4cG9ydHMuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmZ1bmN0aW9uIGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzcykge1xuICAgIHJldHVybiAncG9ydCcgaW4gYWRkcmVzcztcbn1cbmV4cG9ydHMuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyA9IGlzVGNwU3ViY2hhbm5lbEFkZHJlc3M7XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc0VxdWFsKGFkZHJlc3MxLCBhZGRyZXNzMikge1xuICAgIGlmICghYWRkcmVzczEgJiYgIWFkZHJlc3MyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWFkZHJlc3MxIHx8ICFhZGRyZXNzMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MxKSkge1xuICAgICAgICByZXR1cm4gKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczIpICYmXG4gICAgICAgICAgICBhZGRyZXNzMS5ob3N0ID09PSBhZGRyZXNzMi5ob3N0ICYmXG4gICAgICAgICAgICBhZGRyZXNzMS5wb3J0ID09PSBhZGRyZXNzMi5wb3J0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiYgYWRkcmVzczEucGF0aCA9PT0gYWRkcmVzczIucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzRXF1YWwgPSBzdWJjaGFubmVsQWRkcmVzc0VxdWFsO1xuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSB7XG4gICAgaWYgKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MuaG9zdCArICc6JyArIGFkZHJlc3MucG9ydDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzLnBhdGg7XG4gICAgfVxufVxuZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZztcbmNvbnN0IERFRkFVTFRfUE9SVCA9IDQ0MztcbmZ1bmN0aW9uIHN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzc1N0cmluZywgcG9ydCkge1xuICAgIGlmICgoMCwgbmV0XzEuaXNJUCkoYWRkcmVzc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvc3Q6IGFkZHJlc3NTdHJpbmcsXG4gICAgICAgICAgICBwb3J0OiBwb3J0ICE9PSBudWxsICYmIHBvcnQgIT09IHZvaWQgMCA/IHBvcnQgOiBERUZBVUxUX1BPUlQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGF0aDogYWRkcmVzc1N0cmluZyxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MgPSBzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ViY2hhbm5lbC1hZGRyZXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-call.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2SubchannelCall = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = 'subchannel_call';\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)) {\n        if (num === errno) {\n            return name;\n        }\n    }\n    return 'Unknown system error ' + errno;\n}\nclass Http2SubchannelCall {\n    constructor(http2Stream, callEventTracker, listener, transport, callId) {\n        var _a;\n        this.http2Stream = http2Stream;\n        this.callEventTracker = callEventTracker;\n        this.listener = listener;\n        this.transport = transport;\n        this.callId = callId;\n        this.isReadFilterPending = false;\n        this.isPushPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */\n        this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.internalError = null;\n        const maxReceiveMessageLength = (_a = transport.getOptions()['grpc.max_receive_message_length']) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);\n        http2Stream.on('response', (headers, flags) => {\n            let headersString = '';\n            for (const header of Object.keys(headers)) {\n                headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n            }\n            this.trace('Received server headers:\\n' + headersString);\n            switch (headers[':status']) {\n                // TODO(murgatroid99): handle 100 and 101\n                case 400:\n                    this.mappedStatusCode = constants_1.Status.INTERNAL;\n                    break;\n                case 401:\n                    this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                    break;\n                case 403:\n                    this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                    break;\n                case 404:\n                    this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                    break;\n                case 429:\n                case 502:\n                case 503:\n                case 504:\n                    this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                    break;\n                default:\n                    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n            }\n            if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                this.handleTrailers(headers);\n            }\n            else {\n                let metadata;\n                try {\n                    metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                }\n                catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNKNOWN,\n                        details: error.message,\n                        metadata: new metadata_1.Metadata(),\n                    });\n                    return;\n                }\n                this.listener.onReceiveMetadata(metadata);\n            }\n        });\n        http2Stream.on('trailers', (headers) => {\n            this.handleTrailers(headers);\n        });\n        http2Stream.on('data', (data) => {\n            /* If the status has already been output, allow the http2 stream to\n             * drain without processing the data. */\n            if (this.statusOutput) {\n                return;\n            }\n            this.trace('receive HTTP/2 data frame of length ' + data.length);\n            let messages;\n            try {\n                messages = this.decoder.write(data);\n            }\n            catch (e) {\n                this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);\n                return;\n            }\n            for (const message of messages) {\n                this.trace('parsed message of length ' + message.length);\n                this.callEventTracker.addMessageReceived();\n                this.tryPush(message);\n            }\n        });\n        http2Stream.on('end', () => {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n        });\n        http2Stream.on('close', () => {\n            /* Use process.next tick to ensure that this code happens after any\n             * \"error\" event that may be emitted at about the same time, so that\n             * we can bubble up the error message from that event. */\n            process.nextTick(() => {\n                var _a;\n                this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n                /* If we have a final status with an OK status code, that means that\n                 * we have received all of the messages and we have processed the\n                 * trailers and the call completed successfully, so it doesn't matter\n                 * how the stream ends after that */\n                if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                    return;\n                }\n                let code;\n                let details = '';\n                switch (http2Stream.rstCode) {\n                    case http2.constants.NGHTTP2_NO_ERROR:\n                        /* If we get a NO_ERROR code and we already have a status, the\n                         * stream completed properly and we just haven't fully processed\n                         * it yet */\n                        if (this.finalStatus !== null) {\n                            return;\n                        }\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                        break;\n                    case http2.constants.NGHTTP2_REFUSED_STREAM:\n                        code = constants_1.Status.UNAVAILABLE;\n                        details = 'Stream refused by server';\n                        break;\n                    case http2.constants.NGHTTP2_CANCEL:\n                        code = constants_1.Status.CANCELLED;\n                        details = 'Call cancelled';\n                        break;\n                    case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                        code = constants_1.Status.RESOURCE_EXHAUSTED;\n                        details = 'Bandwidth exhausted or memory limit exceeded';\n                        break;\n                    case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                        code = constants_1.Status.PERMISSION_DENIED;\n                        details = 'Protocol not secure enough';\n                        break;\n                    case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                        code = constants_1.Status.INTERNAL;\n                        if (this.internalError === null) {\n                            /* This error code was previously handled in the default case, and\n                             * there are several instances of it online, so I wanted to\n                             * preserve the original error message so that people find existing\n                             * information in searches, but also include the more recognizable\n                             * \"Internal server error\" message. */\n                            details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n                        }\n                        else {\n                            if (this.internalError.code === 'ECONNRESET' ||\n                                this.internalError.code === 'ETIMEDOUT') {\n                                code = constants_1.Status.UNAVAILABLE;\n                                details = this.internalError.message;\n                            }\n                            else {\n                                /* The \"Received RST_STREAM with code ...\" error is preserved\n                                 * here for continuity with errors reported online, but the\n                                 * error message at the end will probably be more relevant in\n                                 * most cases. */\n                                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                            }\n                        }\n                        break;\n                    default:\n                        code = constants_1.Status.INTERNAL;\n                        details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n                }\n                // This is a no-op if trailers were received at all.\n                // This is OK, because status codes emitted here correspond to more\n                // catastrophic issues that prevent us from receiving trailers in the\n                // first place.\n                this.endCall({\n                    code,\n                    details,\n                    metadata: new metadata_1.Metadata(),\n                    rstCode: http2Stream.rstCode,\n                });\n            });\n        });\n        http2Stream.on('error', (err) => {\n            /* We need an error handler here to stop \"Uncaught Error\" exceptions\n             * from bubbling up. However, errors here should all correspond to\n             * \"close\" events, where we will handle the error more granularly */\n            /* Specifically looking for stream errors that were *not* constructed\n             * from a RST_STREAM response here:\n             * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n             */\n            if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n                this.trace('Node error event: message=' +\n                    err.message +\n                    ' code=' +\n                    err.code +\n                    ' errno=' +\n                    getSystemErrorName(err.errno) +\n                    ' syscall=' +\n                    err.syscall);\n                this.internalError = err;\n            }\n            this.callEventTracker.onStreamEnd(false);\n        });\n    }\n    onDisconnect() {\n        this.endCall({\n            code: constants_1.Status.UNAVAILABLE,\n            details: 'Connection dropped',\n            metadata: new metadata_1.Metadata(),\n        });\n    }\n    outputStatus() {\n        /* Precondition: this.finalStatus !== null */\n        if (!this.statusOutput) {\n            this.statusOutput = true;\n            this.trace('ended with status: code=' +\n                this.finalStatus.code +\n                ' details=\"' +\n                this.finalStatus.details +\n                '\"');\n            this.callEventTracker.onCallEnd(this.finalStatus);\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */\n            process.nextTick(() => {\n                this.listener.onReceiveStatus(this.finalStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */\n            this.http2Stream.resume();\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */\n    endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */\n        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */\n            if (this.finalStatus.code !== constants_1.Status.OK ||\n                (this.readsClosed &&\n                    this.unpushedReadMessages.length === 0 &&\n                    !this.isReadFilterPending &&\n                    !this.isPushPending)) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace('pushing to reader message of length ' +\n            (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        this.isPushPending = true;\n        process.nextTick(() => {\n            this.isPushPending = false;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */\n            if (this.statusOutput) {\n                return;\n            }\n            this.listener.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    tryPush(messageBytes) {\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(messageBytes);\n        }\n        else {\n            this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\n            this.unpushedReadMessages.push(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.callEventTracker.onStreamEnd(true);\n        let headersString = '';\n        for (const header of Object.keys(headers)) {\n            headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n        }\n        this.trace('Received server trailers:\\n' + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        }\n        catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN &&\n            typeof metadataMap['grpc-status'] === 'string') {\n            const receivedStatus = Number(metadataMap['grpc-status']);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace('received status code ' + receivedStatus + ' from server');\n            }\n            metadata.remove('grpc-status');\n        }\n        let details = '';\n        if (typeof metadataMap['grpc-message'] === 'string') {\n            try {\n                details = decodeURI(metadataMap['grpc-message']);\n            }\n            catch (e) {\n                details = metadataMap['grpc-message'];\n            }\n            metadata.remove('grpc-message');\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = { code, details, metadata };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (!this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */\n            let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            }\n            else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace('close http2 stream with code ' + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        return this.transport.getPeerName();\n    }\n    getCallNumber() {\n        return this.callId;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */\n        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.unpushedReadMessages.length > 0) {\n            const nextMessage = this.unpushedReadMessages.shift();\n            this.push(nextMessage);\n            return;\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit */\n        this.http2Stream.resume();\n    }\n    sendMessageWithContext(context, message) {\n        this.trace('write() called with message of length ' + message.length);\n        const cb = (error) => {\n            /* nextTick here ensures that no stream action can be taken in the call\n             * stack of the write callback, in order to hopefully work around\n             * https://github.com/nodejs/node/issues/49147 */\n            process.nextTick(() => {\n                var _a;\n                let code = constants_1.Status.UNAVAILABLE;\n                if ((error === null || error === void 0 ? void 0 : error.code) ===\n                    'ERR_STREAM_WRITE_AFTER_END') {\n                    code = constants_1.Status.INTERNAL;\n                }\n                if (error) {\n                    this.cancelWithStatus(code, `Write error: ${error.message}`);\n                }\n                (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n            });\n        };\n        this.trace('sending data chunk of length ' + message.length);\n        this.callEventTracker.addMessageSent();\n        try {\n            this.http2Stream.write(message, cb);\n        }\n        catch (error) {\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Write failed with error ${error.message}`,\n                metadata: new metadata_1.Metadata(),\n            });\n        }\n    }\n    halfClose() {\n        this.trace('end() called');\n        this.trace('calling end() on HTTP/2 stream');\n        this.http2Stream.end();\n    }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall;\n//# sourceMappingURL=subchannel-call.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1jYWxsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCO0FBQzNCLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixvQkFBb0IsbUJBQU8sQ0FBQyw4RUFBYTtBQUN6QyxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyx3RkFBa0I7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvQkFBb0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUscUJBQXFCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRSxxQkFBcUIsc0NBQXNDLDJCQUEyQjtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG9CQUFvQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0REFBNEQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGNBQWM7QUFDOUU7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYztBQUNsRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWNhbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ2FsbCA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IHN0cmVhbV9kZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9zdHJlYW0tZGVjb2RlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzIgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzdWJjaGFubmVsX2NhbGwnO1xuLyoqXG4gKiBTaG91bGQgZG8gYXBwcm94aW1hdGVseSB0aGUgc2FtZSB0aGluZyBhcyB1dGlsLmdldFN5c3RlbUVycm9yTmFtZSBidXQgdGhlXG4gKiBUeXBlU2NyaXB0IHR5cGVzIGRvbid0IGhhdmUgdGhhdCBmdW5jdGlvbiBmb3Igc29tZSByZWFzb24gc28gSSBqdXN0IG1hZGUgbXlcbiAqIG93bi5cbiAqIEBwYXJhbSBlcnJub1xuICovXG5mdW5jdGlvbiBnZXRTeXN0ZW1FcnJvck5hbWUoZXJybm8pIHtcbiAgICBmb3IgKGNvbnN0IFtuYW1lLCBudW1dIG9mIE9iamVjdC5lbnRyaWVzKG9zLmNvbnN0YW50cy5lcnJubykpIHtcbiAgICAgICAgaWYgKG51bSA9PT0gZXJybm8pIHtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnVW5rbm93biBzeXN0ZW0gZXJyb3IgJyArIGVycm5vO1xufVxuY2xhc3MgSHR0cDJTdWJjaGFubmVsQ2FsbCB7XG4gICAgY29uc3RydWN0b3IoaHR0cDJTdHJlYW0sIGNhbGxFdmVudFRyYWNrZXIsIGxpc3RlbmVyLCB0cmFuc3BvcnQsIGNhbGxJZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0gPSBodHRwMlN0cmVhbTtcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyID0gY2FsbEV2ZW50VHJhY2tlcjtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy5jYWxsSWQgPSBjYWxsSWQ7XG4gICAgICAgIHRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUHVzaFBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhbiAnZW5kJyBldmVudCBoYXMgY29tZSBmcm9tIHRoZSBodHRwMiBzdHJlYW0sIHNvIHRoZXJlXG4gICAgICAgICAqIHdpbGwgYmUgbm8gbW9yZSBkYXRhIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0dXNPdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICAvLyBTdGF0dXMgY29kZSBtYXBwZWQgZnJvbSA6c3RhdHVzLiBUbyBiZSB1c2VkIGlmIGdycGMtc3RhdHVzIGlzIG5vdCByZWNlaXZlZFxuICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTjtcbiAgICAgICAgLy8gVGhpcyBpcyBwb3B1bGF0ZWQgKG5vbi1udWxsKSBpZiBhbmQgb25seSBpZiB0aGUgY2FsbCBoYXMgZW5kZWRcbiAgICAgICAgdGhpcy5maW5hbFN0YXR1cyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvciA9IG51bGw7XG4gICAgICAgIGNvbnN0IG1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoID0gKF9hID0gdHJhbnNwb3J0LmdldE9wdGlvbnMoKVsnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgc3RyZWFtX2RlY29kZXJfMS5TdHJlYW1EZWNvZGVyKG1heFJlY2VpdmVNZXNzYWdlTGVuZ3RoKTtcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ3Jlc3BvbnNlJywgKGhlYWRlcnMsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzU3RyaW5nICs9ICdcXHRcXHQnICsgaGVhZGVyICsgJzogJyArIGhlYWRlcnNbaGVhZGVyXSArICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIGhlYWRlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXJzWyc6c3RhdHVzJ10pIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IGhhbmRsZSAxMDAgYW5kIDEwMVxuICAgICAgICAgICAgICAgIGNhc2UgNDAwOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOSU1QTEVNRU5URUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgICAgICAgIGNhc2UgNTAyOlxuICAgICAgICAgICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzICYgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbigndHJhaWxlcnMnLCAoaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVUcmFpbGVycyhoZWFkZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGh0dHAyU3RyZWFtLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaGFzIGFscmVhZHkgYmVlbiBvdXRwdXQsIGFsbG93IHRoZSBodHRwMiBzdHJlYW0gdG9cbiAgICAgICAgICAgICAqIGRyYWluIHdpdGhvdXQgcHJvY2Vzc2luZyB0aGUgZGF0YS4gKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmUgSFRUUC8yIGRhdGEgZnJhbWUgb2YgbGVuZ3RoICcgKyBkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gdGhpcy5kZWNvZGVyLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCwgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdwYXJzZWQgbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxFdmVudFRyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50cnlQdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgaHR0cDJTdHJlYW0ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgLyogVXNlIHByb2Nlc3MubmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IHRoaXMgY29kZSBoYXBwZW5zIGFmdGVyIGFueVxuICAgICAgICAgICAgICogXCJlcnJvclwiIGV2ZW50IHRoYXQgbWF5IGJlIGVtaXR0ZWQgYXQgYWJvdXQgdGhlIHNhbWUgdGltZSwgc28gdGhhdFxuICAgICAgICAgICAgICogd2UgY2FuIGJ1YmJsZSB1cCB0aGUgZXJyb3IgbWVzc2FnZSBmcm9tIHRoYXQgZXZlbnQuICovXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnSFRUUC8yIHN0cmVhbSBjbG9zZWQgd2l0aCBjb2RlICcgKyBodHRwMlN0cmVhbS5yc3RDb2RlKTtcbiAgICAgICAgICAgICAgICAvKiBJZiB3ZSBoYXZlIGEgZmluYWwgc3RhdHVzIHdpdGggYW4gT0sgc3RhdHVzIGNvZGUsIHRoYXQgbWVhbnMgdGhhdFxuICAgICAgICAgICAgICAgICAqIHdlIGhhdmUgcmVjZWl2ZWQgYWxsIG9mIHRoZSBtZXNzYWdlcyBhbmQgd2UgaGF2ZSBwcm9jZXNzZWQgdGhlXG4gICAgICAgICAgICAgICAgICogdHJhaWxlcnMgYW5kIHRoZSBjYWxsIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIHNvIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgICogaG93IHRoZSBzdHJlYW0gZW5kcyBhZnRlciB0aGF0ICovXG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmZpbmFsU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb2RlO1xuICAgICAgICAgICAgICAgIGxldCBkZXRhaWxzID0gJyc7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChodHRwMlN0cmVhbS5yc3RDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB3ZSBnZXQgYSBOT19FUlJPUiBjb2RlIGFuZCB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0dXMsIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogc3RyZWFtIGNvbXBsZXRlZCBwcm9wZXJseSBhbmQgd2UganVzdCBoYXZlbid0IGZ1bGx5IHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgeWV0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfUkVGVVNFRF9TVFJFQU06XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdTdHJlYW0gcmVmdXNlZCBieSBzZXJ2ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ0NhbGwgY2FuY2VsbGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ0JhbmR3aWR0aCBleGhhdXN0ZWQgb3IgbWVtb3J5IGxpbWl0IGV4Y2VlZGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0lOQURFUVVBVEVfU0VDVVJJVFk6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9ICdQcm90b2NvbCBub3Qgc2VjdXJlIGVub3VnaCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9JTlRFUk5BTF9FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbEVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhpcyBlcnJvciBjb2RlIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW4gdGhlIGRlZmF1bHQgY2FzZSwgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlcmUgYXJlIHNldmVyYWwgaW5zdGFuY2VzIG9mIGl0IG9ubGluZSwgc28gSSB3YW50ZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBwcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZSBzbyB0aGF0IHBlb3BsZSBmaW5kIGV4aXN0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5mb3JtYXRpb24gaW4gc2VhcmNoZXMsIGJ1dCBhbHNvIGluY2x1ZGUgdGhlIG1vcmUgcmVjb2duaXphYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIiBtZXNzYWdlLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtodHRwMlN0cmVhbS5yc3RDb2RlfSAoSW50ZXJuYWwgc2VydmVyIGVycm9yKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbEVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IHRoaXMuaW50ZXJuYWxFcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIFwiUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgLi4uXCIgZXJyb3IgaXMgcHJlc2VydmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGhlcmUgZm9yIGNvbnRpbnVpdHkgd2l0aCBlcnJvcnMgcmVwb3J0ZWQgb25saW5lLCBidXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGVycm9yIG1lc3NhZ2UgYXQgdGhlIGVuZCB3aWxsIHByb2JhYmx5IGJlIG1vcmUgcmVsZXZhbnQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbW9zdCBjYXNlcy4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke2h0dHAyU3RyZWFtLnJzdENvZGV9IHRyaWdnZXJlZCBieSBpbnRlcm5hbCBjbGllbnQgZXJyb3I6ICR7dGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gYFJlY2VpdmVkIFJTVF9TVFJFQU0gd2l0aCBjb2RlICR7aHR0cDJTdHJlYW0ucnN0Q29kZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgdHJhaWxlcnMgd2VyZSByZWNlaXZlZCBhdCBhbGwuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBPSywgYmVjYXVzZSBzdGF0dXMgY29kZXMgZW1pdHRlZCBoZXJlIGNvcnJlc3BvbmQgdG8gbW9yZVxuICAgICAgICAgICAgICAgIC8vIGNhdGFzdHJvcGhpYyBpc3N1ZXMgdGhhdCBwcmV2ZW50IHVzIGZyb20gcmVjZWl2aW5nIHRyYWlsZXJzIGluIHRoZVxuICAgICAgICAgICAgICAgIC8vIGZpcnN0IHBsYWNlLlxuICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHMsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICByc3RDb2RlOiBodHRwMlN0cmVhbS5yc3RDb2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBodHRwMlN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAvKiBXZSBuZWVkIGFuIGVycm9yIGhhbmRsZXIgaGVyZSB0byBzdG9wIFwiVW5jYXVnaHQgRXJyb3JcIiBleGNlcHRpb25zXG4gICAgICAgICAgICAgKiBmcm9tIGJ1YmJsaW5nIHVwLiBIb3dldmVyLCBlcnJvcnMgaGVyZSBzaG91bGQgYWxsIGNvcnJlc3BvbmQgdG9cbiAgICAgICAgICAgICAqIFwiY2xvc2VcIiBldmVudHMsIHdoZXJlIHdlIHdpbGwgaGFuZGxlIHRoZSBlcnJvciBtb3JlIGdyYW51bGFybHkgKi9cbiAgICAgICAgICAgIC8qIFNwZWNpZmljYWxseSBsb29raW5nIGZvciBzdHJlYW0gZXJyb3JzIHRoYXQgd2VyZSAqbm90KiBjb25zdHJ1Y3RlZFxuICAgICAgICAgICAgICogZnJvbSBhIFJTVF9TVFJFQU0gcmVzcG9uc2UgaGVyZTpcbiAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzhiODYyMGQ1ODAzMTQwNTAxNzU5ODM0MDJkZmRkZjI2NzRlOGUyMmEvbGliL2ludGVybmFsL2h0dHAyL2NvcmUuanMjTDIyNjdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSAnRVJSX0hUVFAyX1NUUkVBTV9FUlJPUicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdOb2RlIGVycm9yIGV2ZW50OiBtZXNzYWdlPScgK1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICcgY29kZT0nICtcbiAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgK1xuICAgICAgICAgICAgICAgICAgICAnIGVycm5vPScgK1xuICAgICAgICAgICAgICAgICAgICBnZXRTeXN0ZW1FcnJvck5hbWUoZXJyLmVycm5vKSArXG4gICAgICAgICAgICAgICAgICAgICcgc3lzY2FsbD0nICtcbiAgICAgICAgICAgICAgICAgICAgZXJyLnN5c2NhbGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vblN0cmVhbUVuZChmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICBkZXRhaWxzOiAnQ29ubmVjdGlvbiBkcm9wcGVkJyxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb3V0cHV0U3RhdHVzKCkge1xuICAgICAgICAvKiBQcmVjb25kaXRpb246IHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwgKi9cbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNPdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnZW5kZWQgd2l0aCBzdGF0dXM6IGNvZGU9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5maW5hbFN0YXR1cy5jb2RlICtcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbmFsU3RhdHVzLmRldGFpbHMgK1xuICAgICAgICAgICAgICAgICdcIicpO1xuICAgICAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLm9uQ2FsbEVuZCh0aGlzLmZpbmFsU3RhdHVzKTtcbiAgICAgICAgICAgIC8qIFdlIGRlbGF5IHRoZSBhY3R1YWwgYWN0aW9uIG9mIGJ1YmJsaW5nIHVwIHRoZSBzdGF0dXMgdG8gaW5zdWxhdGUgdGhlXG4gICAgICAgICAgICAgKiBjbGVhbnVwIGNvZGUgaW4gdGhpcyBjbGFzcyBmcm9tIGFueSBlcnJvcnMgdGhhdCBtYXkgYmUgdGhyb3duIGluIHRoZVxuICAgICAgICAgICAgICogdXBwZXIgbGF5ZXJzIGFzIGEgcmVzdWx0IG9mIGJ1YmJsaW5nIHVwIHRoZSBzdGF0dXMuIEluIHBhcnRpY3VsYXIsXG4gICAgICAgICAgICAgKiBpZiB0aGUgc3RhdHVzIGlzIG5vdCBPSywgdGhlIFwiZXJyb3JcIiBldmVudCBtYXkgYmUgZW1pdHRlZFxuICAgICAgICAgICAgICogc3luY2hyb25vdXNseSBhdCB0aGUgdG9wIGxldmVsLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIHRocm93biBlcnJvciBpZlxuICAgICAgICAgICAgICogdGhlIHVzZXIgZG9lcyBub3QgaGFuZGxlIHRoYXQgZXZlbnQuICovXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyh0aGlzLmZpbmFsU3RhdHVzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyogTGVhdmUgdGhlIGh0dHAyIHN0cmVhbSBpbiBmbG93aW5nIHN0YXRlIHRvIGRyYWluIGluY29taW5nIG1lc3NhZ2VzLCB0b1xuICAgICAgICAgICAgICogZW5zdXJlIHRoYXQgdGhlIHN0cmVhbSBjbG9zdXJlIGNvbXBsZXRlcy4gVGhlIGNhbGwgc3RyZWFtIGFscmVhZHkgZG9lc1xuICAgICAgICAgICAgICogbm90IHB1c2ggbW9yZSBtZXNzYWdlcyBhZnRlciB0aGUgc3RhdHVzIGlzIG91dHB1dCwgc28gdGhlIG1lc3NhZ2VzIGdvXG4gICAgICAgICAgICAgKiBub3doZXJlIGVpdGhlciB3YXkuICovXG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMi5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnWycgKyB0aGlzLmNhbGxJZCArICddICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gZmlyc3QgY2FsbCwgZW1pdHMgYSAnc3RhdHVzJyBldmVudCB3aXRoIHRoZSBnaXZlbiBTdGF0dXNPYmplY3QuXG4gICAgICogU3Vic2VxdWVudCBjYWxscyBhcmUgbm8tb3BzLlxuICAgICAqIEBwYXJhbSBzdGF0dXMgVGhlIHN0YXR1cyBvZiB0aGUgY2FsbC5cbiAgICAgKi9cbiAgICBlbmRDYWxsKHN0YXR1cykge1xuICAgICAgICAvKiBJZiB0aGUgc3RhdHVzIGlzIE9LIGFuZCBhIG5ldyBzdGF0dXMgY29tZXMgaW4gKGUuZy4gZnJvbSBhXG4gICAgICAgICAqIGRlc2VyaWFsaXphdGlvbiBmYWlsdXJlKSwgdGhhdCBuZXcgc3RhdHVzIHRha2VzIHByaW9yaXR5ICovXG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzID09PSBudWxsIHx8IHRoaXMuZmluYWxTdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdHJveUh0dHAyU3RyZWFtKCk7XG4gICAgfVxuICAgIG1heWJlT3V0cHV0U3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyogVGhlIGNvbWJpbmF0aW9uIGNoZWNrIG9mIHJlYWRzQ2xvc2VkIGFuZCB0aGF0IHRoZSB0d28gbWVzc2FnZSBidWZmZXJcbiAgICAgICAgICAgICAqIGFycmF5cyBhcmUgZW1wdHkgY2hlY2tzIHRoYXQgdGhlcmUgYWxsIGluY29taW5nIGRhdGEgaGFzIGJlZW4gZnVsbHlcbiAgICAgICAgICAgICAqIHByb2Nlc3NlZCAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMucmVhZHNDbG9zZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXNSZWFkRmlsdGVyUGVuZGluZyAmJlxuICAgICAgICAgICAgICAgICAgICAhdGhpcy5pc1B1c2hQZW5kaW5nKSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0U3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVzaChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3B1c2hpbmcgdG8gcmVhZGVyIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgaW5zdGFuY2VvZiBCdWZmZXIgPyBtZXNzYWdlLmxlbmd0aCA6IG51bGwpKTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvKiBJZiB3ZSBoYXZlIGFscmVhZHkgb3V0cHV0IHRoZSBzdGF0dXMgYW55IGxhdGVyIG1lc3NhZ2VzIHNob3VsZCBiZVxuICAgICAgICAgICAgICogaWdub3JlZCwgYW5kIGNhbiBjYXVzZSBvdXQtb2Ytb3JkZXIgb3BlcmF0aW9uIGVycm9ycyBoaWdoZXIgdXAgaW4gdGhlXG4gICAgICAgICAgICAgKiBzdGFjay4gQ2hlY2tpbmcgYXMgbGF0ZSBhcyBwb3NzaWJsZSBoZXJlIHRvIGF2b2lkIGFueSByYWNlIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyeVB1c2gobWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgndW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZUJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLnB1c2gobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVUcmFpbGVycyhoZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuY2FsbEV2ZW50VHJhY2tlci5vblN0cmVhbUVuZCh0cnVlKTtcbiAgICAgICAgbGV0IGhlYWRlcnNTdHJpbmcgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcgKz0gJ1xcdFxcdCcgKyBoZWFkZXIgKyAnOiAnICsgaGVhZGVyc1toZWFkZXJdICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIHRyYWlsZXJzOlxcbicgKyBoZWFkZXJzU3RyaW5nKTtcbiAgICAgICAgbGV0IG1ldGFkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbWV0YWRhdGEgPSBtZXRhZGF0YV8xLk1ldGFkYXRhLmZyb21IdHRwMkhlYWRlcnMoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhZGF0YU1hcCA9IG1ldGFkYXRhLmdldE1hcCgpO1xuICAgICAgICBsZXQgY29kZSA9IHRoaXMubWFwcGVkU3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKGNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOICYmXG4gICAgICAgICAgICB0eXBlb2YgbWV0YWRhdGFNYXBbJ2dycGMtc3RhdHVzJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCByZWNlaXZlZFN0YXR1cyA9IE51bWJlcihtZXRhZGF0YU1hcFsnZ3JwYy1zdGF0dXMnXSk7XG4gICAgICAgICAgICBpZiAocmVjZWl2ZWRTdGF0dXMgaW4gY29uc3RhbnRzXzEuU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IHJlY2VpdmVkU3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmVkIHN0YXR1cyBjb2RlICcgKyByZWNlaXZlZFN0YXR1cyArICcgZnJvbSBzZXJ2ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1zdGF0dXMnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGV0YWlscyA9ICcnO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscyA9IGRlY29kZVVSSShtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBkZXRhaWxzID0gbWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEucmVtb3ZlKCdncnBjLW1lc3NhZ2UnKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3JlY2VpdmVkIHN0YXR1cyBkZXRhaWxzIHN0cmluZyBcIicgKyBkZXRhaWxzICsgJ1wiIGZyb20gc2VydmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0geyBjb2RlLCBkZXRhaWxzLCBtZXRhZGF0YSB9O1xuICAgICAgICAvLyBUaGlzIGlzIGEgbm8tb3AgaWYgdGhlIGNhbGwgd2FzIGFscmVhZHkgZW5kZWQgd2hlbiBoYW5kbGluZyBoZWFkZXJzLlxuICAgICAgICB0aGlzLmVuZENhbGwoc3RhdHVzKTtcbiAgICB9XG4gICAgZGVzdHJveUh0dHAyU3RyZWFtKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFRoZSBodHRwMiBzdHJlYW0gY291bGQgYWxyZWFkeSBoYXZlIGJlZW4gZGVzdHJveWVkIGlmIGNhbmNlbFdpdGhTdGF0dXNcbiAgICAgICAgLy8gaXMgY2FsbGVkIGluIHJlc3BvbnNlIHRvIGFuIGludGVybmFsIGh0dHAyIGVycm9yLlxuICAgICAgICBpZiAoIXRoaXMuaHR0cDJTdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvKiBJZiB0aGUgY2FsbCBoYXMgZW5kZWQgd2l0aCBhbiBPSyBzdGF0dXMsIGNvbW11bmljYXRlIHRoYXQgd2hlbiBjbG9zaW5nXG4gICAgICAgICAgICAgKiB0aGUgc3RyZWFtLCBwYXJ0bHkgdG8gYXZvaWQgYSBzaXR1YXRpb24gaW4gd2hpY2ggd2UgZGV0ZWN0IGFuIGVycm9yXG4gICAgICAgICAgICAgKiBSU1RfU1RSRUFNIGFzIGEgcmVzdWx0IGFmdGVyIHdlIGhhdmUgdGhlIHN0YXR1cyAqL1xuICAgICAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX05PX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nsb3NlIGh0dHAyIHN0cmVhbSB3aXRoIGNvZGUgJyArIGNvZGUpO1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5jbG9zZShjb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWxXaXRoU3RhdHVzKHN0YXR1cywgZGV0YWlscykge1xuICAgICAgICB0aGlzLnRyYWNlKCdjYW5jZWxXaXRoU3RhdHVzIGNvZGU6ICcgKyBzdGF0dXMgKyAnIGRldGFpbHM6IFwiJyArIGRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgdGhpcy5lbmRDYWxsKHsgY29kZTogc3RhdHVzLCBkZXRhaWxzLCBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSB9KTtcbiAgICB9XG4gICAgZ2V0U3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5hbFN0YXR1cztcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmdldFBlZXJOYW1lKCk7XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxJZDtcbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICAvKiBJZiB0aGUgc3RyZWFtIGhhcyBlbmRlZCB3aXRoIGFuIGVycm9yLCB3ZSBzaG91bGQgbm90IGVtaXQgYW55IG1vcmVcbiAgICAgICAgICogbWVzc2FnZXMgYW5kIHdlIHNob3VsZCBjb21tdW5pY2F0ZSB0aGF0IHRoZSBzdHJlYW0gaGFzIGVuZGVkICovXG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsICYmIHRoaXMuZmluYWxTdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubWF5YmVPdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhblB1c2ggPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0TWVzc2FnZSA9IHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChuZXh0TWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogT25seSByZXN1bWUgcmVhZGluZyBmcm9tIHRoZSBodHRwMlN0cmVhbSBpZiB3ZSBkb24ndCBoYXZlIGFueSBwZW5kaW5nXG4gICAgICAgICAqIG1lc3NhZ2VzIHRvIGVtaXQgKi9cbiAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMudHJhY2UoJ3dyaXRlKCkgY2FsbGVkIHdpdGggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgY2IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8qIG5leHRUaWNrIGhlcmUgZW5zdXJlcyB0aGF0IG5vIHN0cmVhbSBhY3Rpb24gY2FuIGJlIHRha2VuIGluIHRoZSBjYWxsXG4gICAgICAgICAgICAgKiBzdGFjayBvZiB0aGUgd3JpdGUgY2FsbGJhY2ssIGluIG9yZGVyIHRvIGhvcGVmdWxseSB3b3JrIGFyb3VuZFxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80OTE0NyAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgIGlmICgoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLmNvZGUpID09PVxuICAgICAgICAgICAgICAgICAgICAnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29kZSwgYFdyaXRlIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IGNvbnRleHQuY2FsbGJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhY2UoJ3NlbmRpbmcgZGF0YSBjaHVuayBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5jYWxsRXZlbnRUcmFja2VyLmFkZE1lc3NhZ2VTZW50KCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLndyaXRlKG1lc3NhZ2UsIGNiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBXcml0ZSBmYWlsZWQgd2l0aCBlcnJvciAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnZW5kKCkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NhbGxpbmcgZW5kKCkgb24gSFRUUC8yIHN0cmVhbScpO1xuICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ2FsbCA9IEh0dHAyU3ViY2hhbm5lbENhbGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child) {\n        this.child = child;\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        this.child.throttleKeepalive(newKeepaliveTime);\n    }\n    ref() {\n        this.child.ref();\n    }\n    unref() {\n        this.child.unref();\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n    realSubchannelEquals(other) {\n        return this.getRealSubchannel() === other.getRealSubchannel();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper;\n//# sourceMappingURL=subchannel-interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQmFzZVN1YmNoYW5uZWxXcmFwcGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkID0gY2hpbGQ7XG4gICAgfVxuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgIH1cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgc3RhcnRDb25uZWN0aW5nKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZC5nZXRBZGRyZXNzKCk7XG4gICAgfVxuICAgIHRocm90dGxlS2VlcGFsaXZlKG5ld0tlZXBhbGl2ZVRpbWUpIHtcbiAgICAgICAgdGhpcy5jaGlsZC50aHJvdHRsZUtlZXBhbGl2ZShuZXdLZWVwYWxpdmVUaW1lKTtcbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldFJlYWxTdWJjaGFubmVsKCk7XG4gICAgfVxuICAgIHJlYWxTdWJjaGFubmVsRXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlYWxTdWJjaGFubmVsKCkgPT09IG90aGVyLmdldFJlYWxTdWJjaGFubmVsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSBCYXNlU3ViY2hhbm5lbFdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst transport_1 = __webpack_require__(/*! ./transport */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/transport.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */\nconst REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */\n    constructor() {\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */\n        this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */\n    unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */\n        // eslint-disable-disable-next-line:forin\n        for (const channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter(value => !value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */\n            this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */\n        // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */\n    ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(() => {\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */\n    getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray) {\n                if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) &&\n                    (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) &&\n                    channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel,\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */\nfunction getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    }\n    else {\n        return new SubchannelPool();\n    }\n}\nexports.getSubchannelPool = getSubchannelPool;\n//# sourceMappingURL=subchannel-pool.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsc0JBQXNCO0FBQ2xELDBCQUEwQixtQkFBTyxDQUFDLDBGQUFtQjtBQUNyRCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBYztBQUMzQyw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0Msb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLXBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U3ViY2hhbm5lbFBvb2wgPSBleHBvcnRzLlN1YmNoYW5uZWxQb29sID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF9vcHRpb25zXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLW9wdGlvbnNcIik7XG5jb25zdCBzdWJjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XG4vLyAxMCBzZWNvbmRzIGluIG1pbGxpc2Vjb25kcy4gVGhpcyB2YWx1ZSBpcyBhcmJpdHJhcnkuXG4vKipcbiAqIFRoZSBhbW91bnQgb2YgdGltZSBpbiBiZXR3ZWVuIGNoZWNrcyBmb3IgZHJvcHBpbmcgc3ViY2hhbm5lbHMgdGhhdCBoYXZlIG5vXG4gKiBvdGhlciByZWZlcmVuY2VzXG4gKi9cbmNvbnN0IFJFRl9DSEVDS19JTlRFUlZBTCA9IDEwMDAwO1xuY2xhc3MgU3ViY2hhbm5lbFBvb2wge1xuICAgIC8qKlxuICAgICAqIEEgcG9vbCBvZiBzdWJjaGFubmVscyB1c2UgZm9yIG1ha2luZyBjb25uZWN0aW9ucy4gU3ViY2hhbm5lbHMgd2l0aCB0aGVcbiAgICAgKiBleGFjdCBzYW1lIHBhcmFtZXRlcnMgd2lsbCBiZSByZXVzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucG9vbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHRpbWVyIG9mIGEgdGFzayBwZXJmb3JtaW5nIGEgcGVyaW9kaWMgc3ViY2hhbm5lbCBjbGVhbnVwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGVhbnVwVGltZXIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZnMgYWxsIHVudXNlZCBzdWJjaGFubmVscyBhbmQgY2FuY2VscyB0aGUgY2xlYW51cCB0YXNrIGlmIGFsbFxuICAgICAqIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxuICAgICAqL1xuICAgIHVucmVmVW51c2VkU3ViY2hhbm5lbHMoKSB7XG4gICAgICAgIGxldCBhbGxTdWJjaGFubmVsc1VucmVmZWQgPSB0cnVlO1xuICAgICAgICAvKiBUaGVzZSBvYmplY3RzIGFyZSBjcmVhdGVkIHdpdGggT2JqZWN0LmNyZWF0ZShudWxsKSwgc28gdGhleSBkbyBub3RcbiAgICAgICAgICogaGF2ZSBhIHByb3RvdHlwZSwgd2hpY2ggbWVhbnMgdGhhdCBmb3IgKC4uLiBpbiAuLi4pIGxvb3BzIG92ZXIgdGhlbVxuICAgICAgICAgKiBkbyBub3QgbmVlZCB0byBiZSBmaWx0ZXJlZCAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1kaXNhYmxlLW5leHQtbGluZTpmb3JpblxuICAgICAgICBmb3IgKGNvbnN0IGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsT2JqQXJyYXkgPSB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF07XG4gICAgICAgICAgICBjb25zdCByZWZlZFN1YmNoYW5uZWxzID0gc3ViY2hhbm5lbE9iakFycmF5LmZpbHRlcih2YWx1ZSA9PiAhdmFsdWUuc3ViY2hhbm5lbC51bnJlZklmT25lUmVmKCkpO1xuICAgICAgICAgICAgaWYgKHJlZmVkU3ViY2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogRm9yIGVhY2ggc3ViY2hhbm5lbCBpbiB0aGUgcG9vbCwgdHJ5IHRvIHVucmVmIGl0IGlmIGl0IGhhc1xuICAgICAgICAgICAgICogZXhhY3RseSBvbmUgcmVmICh3aGljaCBpcyB0aGUgcmVmIGZyb20gdGhlIHBvb2wgaXRzZWxmKS4gSWYgdGhhdFxuICAgICAgICAgICAgICogZG9lcyBoYXBwZW4sIHJlbW92ZSB0aGUgc3ViY2hhbm5lbCBmcm9tIHRoZSBwb29sICovXG4gICAgICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0gPSByZWZlZFN1YmNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIC8qIEN1cnJlbnRseSB3ZSBkbyBub3QgZGVsZXRlIGtleXMgd2l0aCBlbXB0eSB2YWx1ZXMuIElmIHRoYXQgcmVzdWx0c1xuICAgICAgICAgKiBpbiBzaWduaWZpY2FudCBtZW1vcnkgdXNhZ2Ugd2Ugc2hvdWxkIGNoYW5nZSBpdC4gKi9cbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxuICAgICAgICBpZiAoYWxsU3ViY2hhbm5lbHNVbnJlZmVkICYmIHRoaXMuY2xlYW51cFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGNsZWFudXAgdGFzayBpcyBzcGF3bmVkLlxuICAgICAqL1xuICAgIGVuc3VyZUNsZWFudXBUYXNrKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudW5yZWZVbnVzZWRTdWJjaGFubmVscygpO1xuICAgICAgICAgICAgfSwgUkVGX0NIRUNLX0lOVEVSVkFMKTtcbiAgICAgICAgICAgIC8vIFVucmVmIGJlY2F1c2UgdGhpcyB0aW1lciBzaG91bGQgbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgcnVubmluZy5cbiAgICAgICAgICAgIC8vIENhbGwgdW5yZWYgb25seSBpZiBpdCBleGlzdHMgdG8gYWRkcmVzcyBlbGVjdHJvbi9lbGVjdHJvbiMyMTE2MlxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jbGVhbnVwVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3ViY2hhbm5lbCBpZiBvbmUgYWxyZWFkeSBleGlzdHMgd2l0aCBleGFjdGx5IG1hdGNoaW5nIHBhcmFtZXRlcnMuXG4gICAgICogT3RoZXJ3aXNlLCBjcmVhdGUgYW5kIHNhdmUgYSBzdWJjaGFubmVsIHdpdGggdGhvc2UgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbFRhcmdldFxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsVGFyZ2V0XG4gICAgICogQHBhcmFtIGNoYW5uZWxBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0gY2hhbm5lbENyZWRlbnRpYWxzXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVTdWJjaGFubmVsKGNoYW5uZWxUYXJnZXRVcmksIHN1YmNoYW5uZWxUYXJnZXQsIGNoYW5uZWxBcmd1bWVudHMsIGNoYW5uZWxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmVuc3VyZUNsZWFudXBUYXNrKCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxUYXJnZXQgPSAoMCwgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKShjaGFubmVsVGFyZ2V0VXJpKTtcbiAgICAgICAgaWYgKGNoYW5uZWxUYXJnZXQgaW4gdGhpcy5wb29sKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsT2JqQXJyYXkgPSB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxPYmogb2Ygc3ViY2hhbm5lbE9iakFycmF5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc0VxdWFsKShzdWJjaGFubmVsVGFyZ2V0LCBzdWJjaGFubmVsT2JqLnN1YmNoYW5uZWxBZGRyZXNzKSAmJlxuICAgICAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbF9vcHRpb25zXzEuY2hhbm5lbE9wdGlvbnNFcXVhbCkoY2hhbm5lbEFyZ3VtZW50cywgc3ViY2hhbm5lbE9iai5jaGFubmVsQXJndW1lbnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhzdWJjaGFubmVsT2JqLmNoYW5uZWxDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIG5vIG1hdGNoaW5nIHN1YmNoYW5uZWwgd2FzIGZvdW5kXG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSBuZXcgc3ViY2hhbm5lbF8xLlN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzLCBuZXcgdHJhbnNwb3J0XzEuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yKGNoYW5uZWxUYXJnZXRVcmkpKTtcbiAgICAgICAgaWYgKCEoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpKSB7XG4gICAgICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0ucHVzaCh7XG4gICAgICAgICAgICBzdWJjaGFubmVsQWRkcmVzczogc3ViY2hhbm5lbFRhcmdldCxcbiAgICAgICAgICAgIGNoYW5uZWxBcmd1bWVudHMsXG4gICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICBzdWJjaGFubmVsLFxuICAgICAgICB9KTtcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWw7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJjaGFubmVsUG9vbCA9IFN1YmNoYW5uZWxQb29sO1xuY29uc3QgZ2xvYmFsU3ViY2hhbm5lbFBvb2wgPSBuZXcgU3ViY2hhbm5lbFBvb2woKTtcbi8qKlxuICogR2V0IGVpdGhlciB0aGUgZ2xvYmFsIHN1YmNoYW5uZWwgcG9vbCwgb3IgYSBuZXcgc3ViY2hhbm5lbCBwb29sLlxuICogQHBhcmFtIGdsb2JhbFxuICovXG5mdW5jdGlvbiBnZXRTdWJjaGFubmVsUG9vbChnbG9iYWwpIHtcbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxTdWJjaGFubmVsUG9vbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViY2hhbm5lbFBvb2woKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFN1YmNoYW5uZWxQb29sID0gZ2V0U3ViY2hhbm5lbFBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLXBvb2wuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Subchannel = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst TRACER_NAME = 'subchannel';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */\n    constructor(channelTarget, subchannelAddress, options, credentials, connector) {\n        var _a;\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        this.connector = connector;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */\n        this.transport = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */\n        this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */\n        this.stateListeners = new Set();\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */\n        this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        // Channelz socket info\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        const backoffOptions = {\n            initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n            maxDelay: options['grpc.max_reconnect_backoff_ms'],\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\n        if (options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n        }\n        this.trace('Subchannel constructed with options ' +\n            JSON.stringify(options, undefined, 2));\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString,\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n        }\n        else {\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */\n    startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    startConnectingInternal() {\n        let options = this.options;\n        if (options['grpc.keepalive_time_ms']) {\n            const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n            options = Object.assign(Object.assign({}, options), { 'grpc.keepalive_time_ms': adjustedKeepaliveTime });\n        }\n        this.connector\n            .connect(this.subchannelAddress, this.credentials, options)\n            .then(transport => {\n            if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\n                this.transport = transport;\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(transport.getChannelzRef());\n                }\n                transport.addDisconnectListener(tooManyPings => {\n                    this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n                    if (tooManyPings && this.keepaliveTime > 0) {\n                        this.keepaliveTime *= 2;\n                        logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n                    }\n                });\n            }\n            else {\n                /* If we can't transition from CONNECTING to READY here, we will\n                 * not be using this transport, so release its resources. */\n                transport.shutdown();\n            }\n        }, error => {\n            this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);\n        });\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */\n    transitionToState(oldStates, newState, errorMessage) {\n        var _a, _b;\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] +\n            ' -> ' +\n            connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connectivity state change to ' + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch (newState) {\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n                this.transport = null;\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n                if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(() => {\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.channelzEnabled && this.transport) {\n                    this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n                }\n                (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n                this.transport = null;\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        for (const listener of this.stateListeners) {\n            listener(this, previousState, newState, this.keepaliveTime, errorMessage);\n        }\n        return true;\n    }\n    ref() {\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n        this.refcount -= 1;\n        if (this.refcount === 0) {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n            }\n            if (this.channelzEnabled) {\n                (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n            }\n            process.nextTick(() => {\n                this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n            });\n        }\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    createCall(metadata, host, method, listener) {\n        if (!this.transport) {\n            throw new Error('Cannot create call, subchannel not READY');\n        }\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            this.streamTracker.addCallStarted();\n            statsTracker = {\n                onCallEnd: status => {\n                    if (status.code === constants_1.Status.OK) {\n                        this.callTracker.addCallSucceeded();\n                    }\n                    else {\n                        this.callTracker.addCallFailed();\n                    }\n                },\n            };\n        }\n        else {\n            statsTracker = {};\n        }\n        return this.transport.createCall(metadata, host, method, listener, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */\n    startConnecting() {\n        process.nextTick(() => {\n            /* First, try to transition from IDLE to connecting. If that doesn't happen\n             * because the state is not currently IDLE, check if it is\n             * TRANSIENT_FAILURE, and if so indicate that it should go back to\n             * connecting after the backoff timer ends. Otherwise do nothing */\n            if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n                if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                    this.continueConnecting = true;\n                }\n            }\n        });\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */\n    getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */\n    addConnectivityStateListener(listener) {\n        this.stateListeners.add(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */\n    removeConnectivityStateListener(listener) {\n        this.stateListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */\n    resetBackoff() {\n        process.nextTick(() => {\n            this.backoffTimeout.reset();\n            this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n        });\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getRealSubchannel() {\n        return this;\n    }\n    realSubchannelEquals(other) {\n        return other.getRealSubchannel() === this;\n    }\n    throttleKeepalive(newKeepaliveTime) {\n        if (newKeepaliveTime > this.keepaliveTime) {\n            this.keepaliveTime = newKeepaliveTime;\n        }\n    }\n}\nexports.Subchannel = Subchannel;\n//# sourceMappingURL=subchannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQiw2QkFBNkIsbUJBQU8sQ0FBQyxnR0FBc0I7QUFDM0QsMEJBQTBCLG1CQUFPLENBQUMsMEZBQW1CO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDBFQUFXO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLDZCQUE2QixtQkFBTyxDQUFDLGdHQUFzQjtBQUMzRCxtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGNBQWMsaURBQWlEO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLG1EQUFtRCxLQUFLLDhCQUE4QiwwRUFBMEUsb0JBQW9CO0FBQ3pRO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxxSkFBcUosTUFBTTtBQUMzSixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFNBQVM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJjaGFubmVsID0gdm9pZCAwO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzdWJjaGFubmVsJztcbi8qIHNldEludGVydmFsIGFuZCBzZXRUaW1lb3V0IG9ubHkgYWNjZXB0IHNpZ25lZCAzMiBiaXQgaW50ZWdlcnMuIEpTIGRvZXNuJ3RcbiAqIGhhdmUgYSBjb25zdGFudCBmb3IgdGhlIG1heCBzaWduZWQgMzIgYml0IGludGVnZXIsIHNvIHRoaXMgaXMgYSBzaW1wbGUgd2F5XG4gKiB0byBjYWxjdWxhdGUgaXQgKi9cbmNvbnN0IEtFRVBBTElWRV9NQVhfVElNRV9NUyA9IH4oMSA8PCAzMSk7XG5jbGFzcyBTdWJjaGFubmVsIHtcbiAgICAvKipcbiAgICAgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGNvbm5lY3Rpb24gdG8gYSBzaW5nbGUgYmFja2VuZC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbFRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZyBmb3IgdGhlIGNoYW5uZWwgYXMgYSB3aG9sZVxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsQWRkcmVzcyBUaGUgYWRkcmVzcyBmb3IgdGhlIGJhY2tlbmQgdGhhdCB0aGlzIHN1YmNoYW5uZWxcbiAgICAgKiAgICAgd2lsbCBjb25uZWN0IHRvXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNoYW5uZWwgb3B0aW9ucywgcGx1cyBhbnkgc3BlY2lmaWMgc3ViY2hhbm5lbCBvcHRpb25zXG4gICAgICogICAgIGZvciB0aGlzIHN1YmNoYW5uZWxcbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIGNoYW5uZWwgY3JlZGVudGlhbHMgdXNlZCB0byBlc3RhYmxpc2ggdGhpc1xuICAgICAqICAgICBjb25uZWN0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbFRhcmdldCwgc3ViY2hhbm5lbEFkZHJlc3MsIG9wdGlvbnMsIGNyZWRlbnRpYWxzLCBjb25uZWN0b3IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmNoYW5uZWxUYXJnZXQgPSBjaGFubmVsVGFyZ2V0O1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzID0gc3ViY2hhbm5lbEFkZHJlc3M7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjcmVkZW50aWFscztcbiAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBjb25uZWN0b3I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLiBJbnZhcmlhbnQ6IGBzZXNzaW9uYCA9PT0gYG51bGxgXG4gICAgICAgICAqIGlmIGFuZCBvbmx5IGlmIGBjb25uZWN0aXZpdHlTdGF0ZWAgaXMgSURMRSBvciBUUkFOU0lFTlRfRkFJTFVSRS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuZGVybHlpbmcgaHR0cDIgc2Vzc2lvbiB1c2VkIHRvIG1ha2UgcmVxdWVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgc3ViY2hhbm5lbCBzaG91bGQgdHJhbnNpdGlvbiBmcm9tIFRSQU5TSUVOVF9GQUlMVVJFIHRvXG4gICAgICAgICAqIENPTk5FQ1RJTkcgaW5zdGVhZCBvZiBJRExFIHdoZW4gdGhlIGJhY2tvZmYgdGltZW91dCBlbmRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBsaXN0ZW5lciBmdW5jdGlvbnMgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgY29ubmVjdGl2aXR5XG4gICAgICAgICAqIHN0YXRlIGNoYW5nZXMuIFdpbGwgYmUgbW9kaWZpZWQgYnkgYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgIGFuZFxuICAgICAgICAgKiBgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3MgY2hhbm5lbHMgYW5kIHN1YmNoYW5uZWwgcG9vbHMgd2l0aCByZWZlcmVuY2VzIHRvIHRoaXMgc3ViY2hhbm5lbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZjb3VudCA9IDA7XG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgIC8vIENoYW5uZWx6IHNvY2tldCBpbmZvXG4gICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IG9wdGlvbnNbJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICAgICAgbWF4RGVsYXk6IG9wdGlvbnNbJ2dycGMubWF4X3JlY29ubmVjdF9iYWNrb2ZmX21zJ10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQgPSBuZXcgYmFja29mZl90aW1lb3V0XzEuQmFja29mZlRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVCYWNrb2ZmVGltZXIoKTtcbiAgICAgICAgfSwgYmFja29mZk9wdGlvbnMpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnVucmVmKCk7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgPSAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZykoc3ViY2hhbm5lbEFkZHJlc3MpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWUgPSAoX2EgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xO1xuICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCkodGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZywgKCkgPT4gdGhpcy5nZXRDaGFubmVsekluZm8oKSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTdWJjaGFubmVsIGNyZWF0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKCdTdWJjaGFubmVsIGNvbnN0cnVjdGVkIHdpdGggb3B0aW9ucyAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIHVuZGVmaW5lZCwgMikpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSxcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICByZWZUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnc3ViY2hhbm5lbF9yZWZjb3VudCcsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIGhhbmRsZUJhY2tvZmZUaW1lcigpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGludWVDb25uZWN0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkVdLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIGJhY2tvZmYgdGltZXIgd2l0aCB0aGUgY3VycmVudCBuZXh0QmFja29mZiB0aW1lb3V0XG4gICAgICovXG4gICAgc3RhcnRCYWNrb2ZmKCkge1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJ1bk9uY2UoKTtcbiAgICB9XG4gICAgc3RvcEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQuc3RvcCgpO1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgfVxuICAgIHN0YXJ0Q29ubmVjdGluZ0ludGVybmFsKCkge1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnXSkge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0ZWRLZWVwYWxpdmVUaW1lID0gTWF0aC5taW4odGhpcy5rZWVwYWxpdmVUaW1lLCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgJ2dycGMua2VlcGFsaXZlX3RpbWVfbXMnOiBhZGp1c3RlZEtlZXBhbGl2ZVRpbWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0b3JcbiAgICAgICAgICAgIC5jb25uZWN0KHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MsIHRoaXMuY3JlZGVudGlhbHMsIG9wdGlvbnMpXG4gICAgICAgICAgICAudGhlbih0cmFuc3BvcnQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQodHJhbnNwb3J0LmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuYWRkRGlzY29ubmVjdExpc3RlbmVyKHRvb01hbnlQaW5ncyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29NYW55UGluZ3MgJiYgdGhpcy5rZWVwYWxpdmVUaW1lID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lICo9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBDb25uZWN0aW9uIHRvICR7KDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy5jaGFubmVsVGFyZ2V0KX0gYXQgJHt0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nfSByZWplY3RlZCBieSBzZXJ2ZXIgYmVjYXVzZSBvZiBleGNlc3MgcGluZ3MuIEluY3JlYXNpbmcgcGluZyBpbnRlcnZhbCB0byAke3RoaXMua2VlcGFsaXZlVGltZX0gbXNgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogSWYgd2UgY2FuJ3QgdHJhbnNpdGlvbiBmcm9tIENPTk5FQ1RJTkcgdG8gUkVBRFkgaGVyZSwgd2Ugd2lsbFxuICAgICAgICAgICAgICAgICAqIG5vdCBiZSB1c2luZyB0aGlzIHRyYW5zcG9ydCwgc28gcmVsZWFzZSBpdHMgcmVzb3VyY2VzLiAqL1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaHV0ZG93bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIGAke2Vycm9yfWApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgYSBzdGF0ZSB0cmFuc2l0aW9uIGZyb20gYW55IGVsZW1lbnQgb2Ygb2xkU3RhdGVzIHRvIHRoZSBuZXdcbiAgICAgKiBzdGF0ZS4gSWYgdGhlIGN1cnJlbnQgY29ubmVjdGl2aXR5U3RhdGUgaXMgbm90IGluIG9sZFN0YXRlcywgZG8gbm90aGluZy5cbiAgICAgKiBAcGFyYW0gb2xkU3RhdGVzIFRoZSBzZXQgb2Ygc3RhdGVzIHRvIHRyYW5zaXRpb24gZnJvbVxuICAgICAqIEBwYXJhbSBuZXdTdGF0ZSBUaGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0b1xuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0YXRlIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIHRyYW5zaXRpb25Ub1N0YXRlKG9sZFN0YXRlcywgbmV3U3RhdGUsIGVycm9yTWVzc2FnZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAob2xkU3RhdGVzLmluZGV4T2YodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZSB0byAnICsgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QmFja29mZigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRDb25uZWN0aW5nSW50ZXJuYWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQgJiYgdGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZCh0aGlzLnRyYW5zcG9ydC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZiB0aW1lciBoYXMgYWxyZWFkeSBlbmRlZCBieSB0aGUgdGltZSB3ZSBnZXQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgc3RhdGUsIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHkgdHJhbnNpdGlvbiBvdXQgb2ZcbiAgICAgICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSBhcyB0aG91Z2ggdGhlIGJhY2tvZmYgdGltZXIgaXMgZW5kaW5nIHJpZ2h0IG5vdyAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQgJiYgdGhpcy50cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZCh0aGlzLnRyYW5zcG9ydC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9iID0gdGhpcy50cmFuc3BvcnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0YXRlOiB1bmtub3duIENvbm5lY3Rpdml0eVN0YXRlICR7bmV3U3RhdGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLnN0YXRlTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSwgdGhpcy5rZWVwYWxpdmVUaW1lLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ3JlZmNvdW50ICcgKyB0aGlzLnJlZmNvdW50ICsgJyAtPiAnICsgKHRoaXMucmVmY291bnQgKyAxKSk7XG4gICAgICAgIHRoaXMucmVmY291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ3JlZmNvdW50ICcgKyB0aGlzLnJlZmNvdW50ICsgJyAtPiAnICsgKHRoaXMucmVmY291bnQgLSAxKSk7XG4gICAgICAgIHRoaXMucmVmY291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVmY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdTaHV0dGluZyBkb3duJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAoMCwgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYpKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVmSWZPbmVSZWYoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVmKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNyZWF0ZUNhbGwobWV0YWRhdGEsIGhvc3QsIG1ldGhvZCwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIGNhbGwsIHN1YmNoYW5uZWwgbm90IFJFQURZJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXRzVHJhY2tlcjtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIHN0YXRzVHJhY2tlciA9IHtcbiAgICAgICAgICAgICAgICBvbkNhbGxFbmQ6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdWNjZWVkZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lciwgc3RhdHNUcmFja2VyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudGx5IElETEUsIHN0YXJ0IGNvbm5lY3RpbmcgYW5kIHN3aXRjaCB0byB0aGVcbiAgICAgKiBDT05ORUNUSU5HIHN0YXRlLiBJZiB0aGUgc3ViY2hhbm5lbCBpcyBjdXJyZW50IGluIFRSQU5TSUVOVF9GQUlMVVJFLFxuICAgICAqIHRoZSBuZXh0IHRpbWUgaXQgd291bGQgdHJhbnNpdGlvbiB0byBJRExFLCBzdGFydCBjb25uZWN0aW5nIGFnYWluIGluc3RlYWQuXG4gICAgICogT3RoZXJ3aXNlLCBkbyBub3RoaW5nLlxuICAgICAqL1xuICAgIHN0YXJ0Q29ubmVjdGluZygpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAvKiBGaXJzdCwgdHJ5IHRvIHRyYW5zaXRpb24gZnJvbSBJRExFIHRvIGNvbm5lY3RpbmcuIElmIHRoYXQgZG9lc24ndCBoYXBwZW5cbiAgICAgICAgICAgICAqIGJlY2F1c2UgdGhlIHN0YXRlIGlzIG5vdCBjdXJyZW50bHkgSURMRSwgY2hlY2sgaWYgaXQgaXNcbiAgICAgICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFLCBhbmQgaWYgc28gaW5kaWNhdGUgdGhhdCBpdCBzaG91bGQgZ28gYmFjayB0b1xuICAgICAgICAgICAgICogY29ubmVjdGluZyBhZnRlciB0aGUgYmFja29mZiB0aW1lciBlbmRzLiBPdGhlcndpc2UgZG8gbm90aGluZyAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgY29ubmVjdGl2aXR5IHN0YXRlLlxuICAgICAqL1xuICAgIGdldENvbm5lY3Rpdml0eVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzdWJjaGFubmVsJ3NcbiAgICAgKiBjb25uZWN0aXZpdHkgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBBIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcGFzc2VkIHRvXG4gICAgICogICAgIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqL1xuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgYmFja29mZiB0aW1lb3V0LCBhbmQgaW1tZWRpYXRlbHkgc3RhcnQgY29ubmVjdGluZyBpZiBpbiBiYWNrb2ZmLlxuICAgICAqL1xuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmc7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWFsU3ViY2hhbm5lbEVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIuZ2V0UmVhbFN1YmNoYW5uZWwoKSA9PT0gdGhpcztcbiAgICB9XG4gICAgdGhyb3R0bGVLZWVwYWxpdmUobmV3S2VlcGFsaXZlVGltZSkge1xuICAgICAgICBpZiAobmV3S2VlcGFsaXZlVGltZSA+IHRoaXMua2VlcGFsaXZlVGltZSkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lID0gbmV3S2VlcGFsaXZlVGltZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU3ViY2hhbm5lbCA9IFN1YmNoYW5uZWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n}\nexports.getDefaultRootsData = getDefaultRootsData;\n//# sourceMappingURL=tls-helpers.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwyQkFBMkIsR0FBRyxxQkFBcUI7QUFDbkQsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3Rscy1oZWxwZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlZmF1bHRSb290c0RhdGEgPSBleHBvcnRzLkNJUEhFUl9TVUlURVMgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmV4cG9ydHMuQ0lQSEVSX1NVSVRFUyA9IHByb2Nlc3MuZW52LkdSUENfU1NMX0NJUEhFUl9TVUlURVM7XG5jb25zdCBERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCA9IHByb2Nlc3MuZW52LkdSUENfREVGQVVMVF9TU0xfUk9PVFNfRklMRV9QQVRIO1xubGV0IGRlZmF1bHRSb290c0RhdGEgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFJvb3RzRGF0YSgpIHtcbiAgICBpZiAoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRSb290c0RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSb290c0RhdGEgPSBmcy5yZWFkRmlsZVN5bmMoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Um9vdHNEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdFJvb3RzRGF0YSA9IGdldERlZmF1bHRSb290c0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10bHMtaGVscGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/transport.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/transport.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Http2SubchannelConnector = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst subchannel_call_1 = __webpack_require__(/*! ./subchannel-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-call.js\");\nconst call_number_1 = __webpack_require__(/*! ./call-number */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-number.js\");\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT, } = http2.constants;\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Http2Transport {\n    constructor(session, subchannelAddress, options, \n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    remoteName) {\n        this.session = session;\n        this.options = options;\n        this.remoteName = remoteName;\n        /**\n         * The amount of time in between sending pings\n         */\n        this.keepaliveTimeMs = -1;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */\n        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Timer reference for timeout that indicates when to send the next ping\n         */\n        this.keepaliveTimerId = null;\n        /**\n         * Indicates that the keepalive timer ran out while there were no active\n         * calls, and a ping should be sent the next time a call starts.\n         */\n        this.pendingSendKeepalivePing = false;\n        /**\n         * Timer reference tracking when the most recent ping will be considered lost\n         */\n        this.keepaliveTimeoutId = null;\n        /**\n         * Indicates whether keepalive pings should be sent without any active calls\n         */\n        this.keepaliveWithoutCalls = false;\n        this.activeCalls = new Set();\n        this.disconnectListeners = [];\n        this.disconnectHandled = false;\n        this.channelzEnabled = true;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        /* Populate subchannelAddressString and channelzRef before doing anything\n         * else, because they are used in the trace methods. */\n        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n        if (options['grpc.enable_channelz'] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n        // Build user-agent string.\n        this.userAgent = [\n            options['grpc.primary_user_agent'],\n            `grpc-node-js/${clientVersion}`,\n            options['grpc.secondary_user_agent'],\n        ]\n            .filter(e => e)\n            .join(' '); // remove falsey values first\n        if ('grpc.keepalive_time_ms' in options) {\n            this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n        }\n        if ('grpc.keepalive_timeout_ms' in options) {\n            this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n        }\n        if ('grpc.keepalive_permit_without_calls' in options) {\n            this.keepaliveWithoutCalls =\n                options['grpc.keepalive_permit_without_calls'] === 1;\n        }\n        else {\n            this.keepaliveWithoutCalls = false;\n        }\n        session.once('close', () => {\n            this.trace('session closed');\n            this.stopKeepalivePings();\n            this.handleDisconnect();\n        });\n        session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n            let tooManyPings = false;\n            /* See the last paragraph of\n             * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n            if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n                opaqueData &&\n                opaqueData.equals(tooManyPingsData)) {\n                tooManyPings = true;\n            }\n            this.trace('connection closed by GOAWAY with code ' + errorCode + ' and data ' + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));\n            this.reportDisconnectToOwner(tooManyPings);\n        });\n        session.once('error', error => {\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */\n            this.trace('connection closed with error ' + error.message);\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on('remoteSettings', (settings) => {\n                this.trace('new settings received' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n            session.on('localSettings', (settings) => {\n                this.trace('local settings acknowledged by remote' +\n                    (this.session !== session ? ' on the old connection' : '') +\n                    ': ' +\n                    JSON.stringify(settings));\n            });\n        }\n        /* Start the keepalive timer last, because this can trigger trace logs,\n         * which should only happen after everything else is set up. */\n        if (this.keepaliveWithoutCalls) {\n            this.maybeStartKeepalivePingTimer();\n        }\n    }\n    getChannelzInfo() {\n        var _a, _b, _c;\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort)\n            : null;\n        const localAddress = sessionSocket.localAddress\n            ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort)\n            : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n                remoteCertificate: peerCertificate && 'raw' in peerCertificate\n                    ? peerCertificate.raw\n                    : null,\n            };\n        }\n        else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null,\n        };\n        return socketInfo;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' +\n            this.channelzRef.id +\n            ') ' +\n            this.subchannelAddressString +\n            ' ' +\n            text);\n    }\n    /**\n     * Indicate to the owner of this object that this transport should no longer\n     * be used. That happens if the connection drops, or if the server sends a\n     * GOAWAY.\n     * @param tooManyPings If true, this was triggered by a GOAWAY with data\n     * indicating that the session was closed becaues the client sent too many\n     * pings.\n     * @returns\n     */\n    reportDisconnectToOwner(tooManyPings) {\n        if (this.disconnectHandled) {\n            return;\n        }\n        this.disconnectHandled = true;\n        this.disconnectListeners.forEach(listener => listener(tooManyPings));\n    }\n    /**\n     * Handle connection drops, but not GOAWAYs.\n     */\n    handleDisconnect() {\n        this.reportDisconnectToOwner(false);\n        /* Give calls an event loop cycle to finish naturally before reporting the\n         * disconnnection to them. */\n        setImmediate(() => {\n            for (const call of this.activeCalls) {\n                call.onDisconnect();\n            }\n        });\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.push(listener);\n    }\n    clearKeepaliveTimer() {\n        if (!this.keepaliveTimerId) {\n            return;\n        }\n        clearTimeout(this.keepaliveTimerId);\n        this.keepaliveTimerId = null;\n    }\n    clearKeepaliveTimeout() {\n        if (!this.keepaliveTimeoutId) {\n            return;\n        }\n        clearTimeout(this.keepaliveTimeoutId);\n        this.keepaliveTimeoutId = null;\n    }\n    canSendPing() {\n        return (this.keepaliveTimeMs > 0 &&\n            (this.keepaliveWithoutCalls || this.activeCalls.size > 0));\n    }\n    maybeSendPing() {\n        var _a, _b;\n        this.clearKeepaliveTimer();\n        if (!this.canSendPing()) {\n            this.pendingSendKeepalivePing = true;\n            return;\n        }\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n        if (!this.keepaliveTimeoutId) {\n            this.keepaliveTimeoutId = setTimeout(() => {\n                this.keepaliveTrace('Ping timeout passed without response');\n                this.handleDisconnect();\n            }, this.keepaliveTimeoutMs);\n            (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n        try {\n            this.session.ping((err, duration, payload) => {\n                if (err) {\n                    this.keepaliveTrace('Ping failed with error ' + err.message);\n                    this.handleDisconnect();\n                }\n                this.keepaliveTrace('Received ping response');\n                this.clearKeepaliveTimeout();\n                this.maybeStartKeepalivePingTimer();\n            });\n        }\n        catch (e) {\n            /* If we fail to send a ping, the connection is no longer functional, so\n             * we should discard it. */\n            this.handleDisconnect();\n        }\n    }\n    /**\n     * Starts the keepalive ping timer if appropriate. If the timer already ran\n     * out while there were no active requests, instead send a ping immediately.\n     * If the ping timer is already running or a ping is currently in flight,\n     * instead do nothing and wait for them to resolve.\n     */\n    maybeStartKeepalivePingTimer() {\n        var _a, _b;\n        if (!this.canSendPing()) {\n            return;\n        }\n        if (this.pendingSendKeepalivePing) {\n            this.pendingSendKeepalivePing = false;\n            this.maybeSendPing();\n        }\n        else if (!this.keepaliveTimerId && !this.keepaliveTimeoutId) {\n            this.keepaliveTrace('Starting keepalive timer for ' + this.keepaliveTimeMs + 'ms');\n            this.keepaliveTimerId = (_b = (_a = setTimeout(() => {\n                this.maybeSendPing();\n            }, this.keepaliveTimeMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n        /* Otherwise, there is already either a keepalive timer or a ping pending,\n         * wait for those to resolve. */\n    }\n    stopKeepalivePings() {\n        if (this.keepaliveTimerId) {\n            clearTimeout(this.keepaliveTimerId);\n            this.keepaliveTimerId = null;\n        }\n        this.clearKeepaliveTimeout();\n    }\n    removeActiveCall(call) {\n        this.activeCalls.delete(call);\n        if (this.activeCalls.size === 0) {\n            this.session.unref();\n        }\n    }\n    addActiveCall(call) {\n        this.activeCalls.add(call);\n        if (this.activeCalls.size === 1) {\n            this.session.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.maybeStartKeepalivePingTimer();\n            }\n        }\n    }\n    createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = host;\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n        headers[HTTP2_HEADER_METHOD] = 'POST';\n        headers[HTTP2_HEADER_PATH] = method;\n        headers[HTTP2_HEADER_TE] = 'trailers';\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */\n        try {\n            http2Stream = this.session.request(headers);\n        }\n        catch (e) {\n            this.handleDisconnect();\n            throw e;\n        }\n        this.flowControlTrace('local window size: ' +\n            this.session.state.localWindowSize +\n            ' remote window size: ' +\n            this.session.state.remoteWindowSize);\n        this.internalsTrace('session.closed=' +\n            this.session.closed +\n            ' session.destroyed=' +\n            this.session.destroyed +\n            ' session.socket.destroyed=' +\n            this.session.socket.destroyed);\n        let eventTracker;\n        // eslint-disable-next-line prefer-const\n        let call;\n        if (this.channelzEnabled) {\n            this.streamTracker.addCallStarted();\n            eventTracker = {\n                addMessageSent: () => {\n                    var _a;\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: () => {\n                    var _a;\n                    this.messagesReceived += 1;\n                    this.lastMessageReceivedTimestamp = new Date();\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: status => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: success => {\n                    var _a;\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    }\n                    else {\n                        this.streamTracker.addCallFailed();\n                    }\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                },\n            };\n        }\n        else {\n            eventTracker = {\n                addMessageSent: () => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                addMessageReceived: () => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n                },\n                onCallEnd: status => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n                    this.removeActiveCall(call);\n                },\n                onStreamEnd: success => {\n                    var _a;\n                    (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n                },\n            };\n        }\n        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n        this.addActiveCall(call);\n        return call;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getPeerName() {\n        return this.subchannelAddressString;\n    }\n    getOptions() {\n        return this.options;\n    }\n    shutdown() {\n        this.session.close();\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n}\nclass Http2SubchannelConnector {\n    constructor(channelTarget) {\n        this.channelTarget = channelTarget;\n        this.session = null;\n        this.isShutdown = false;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + ' ' + text);\n    }\n    createSession(address, credentials, options, proxyConnectionResult) {\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        return new Promise((resolve, reject) => {\n            var _a, _b, _c;\n            let remoteName;\n            if (proxyConnectionResult.realTarget) {\n                remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n                this.trace('creating HTTP/2 session through proxy to ' +\n                    (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\n            }\n            else {\n                remoteName = null;\n                this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n            }\n            const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n            let connectionOptions = credentials._getConnectionOptions() || {};\n            connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n            if ('grpc-node.max_session_memory' in options) {\n                connectionOptions.maxSessionMemory =\n                    options['grpc-node.max_session_memory'];\n            }\n            else {\n                /* By default, set a very large max session memory limit, to effectively\n                 * disable enforcement of the limit. Some testing indicates that Node's\n                 * behavior degrades badly when this limit is reached, so we solve that\n                 * by disabling the check entirely. */\n                connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n            }\n            let addressScheme = 'http://';\n            if ('secureContext' in connectionOptions) {\n                addressScheme = 'https://';\n                // If provided, the value of grpc.ssl_target_name_override should be used\n                // to override the target hostname when checking server identity.\n                // This option is used for testing only.\n                if (options['grpc.ssl_target_name_override']) {\n                    const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n                    connectionOptions.checkServerIdentity = (host, cert) => {\n                        return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n                    };\n                    connectionOptions.servername = sslTargetNameOverride;\n                }\n                else {\n                    const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n                    // We want to always set servername to support SNI\n                    connectionOptions.servername = authorityHostname;\n                }\n                if (proxyConnectionResult.socket) {\n                    /* This is part of the workaround for\n                     * https://github.com/nodejs/node/issues/32922. Without that bug,\n                     * proxyConnectionResult.socket would always be a plaintext socket and\n                     * this would say\n                     * connectionOptions.socket = proxyConnectionResult.socket; */\n                    connectionOptions.createConnection = (authority, option) => {\n                        return proxyConnectionResult.socket;\n                    };\n                }\n            }\n            else {\n                /* In all but the most recent versions of Node, http2.connect does not use\n                 * the options when establishing plaintext connections, so we need to\n                 * establish that connection explicitly. */\n                connectionOptions.createConnection = (authority, option) => {\n                    if (proxyConnectionResult.socket) {\n                        return proxyConnectionResult.socket;\n                    }\n                    else {\n                        /* net.NetConnectOpts is declared in a way that is more restrictive\n                         * than what net.connect will actually accept, so we use the type\n                         * assertion to work around that. */\n                        return net.connect(address);\n                    }\n                };\n            }\n            connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), { enableTrace: options['grpc-node.tls_enable_trace'] === 1 });\n            /* http2.connect uses the options here:\n             * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n             * The spread operator overides earlier values with later ones, so any port\n             * or host values in the options will be used rather than any values extracted\n             * from the first argument. In addition, the path overrides the host and port,\n             * as documented for plaintext connections here:\n             * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n             * and for TLS connections here:\n             * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n             * earlier versions of Node, http2.connect passes these options to\n             * tls.connect but not net.connect, so in the insecure case we still need\n             * to set the createConnection option above to create the connection\n             * explicitly. We cannot do that in the TLS case because http2.connect\n             * passes necessary additional options to tls.connect.\n             * The first argument just needs to be parseable as a URL and the scheme\n             * determines whether the connection will be established over TLS or not.\n             */\n            const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n            this.session = session;\n            let errorMessage = 'Failed to connect';\n            session.unref();\n            session.once('connect', () => {\n                session.removeAllListeners();\n                resolve(new Http2Transport(session, address, options, remoteName));\n                this.session = null;\n            });\n            session.once('close', () => {\n                this.session = null;\n                // Leave time for error event to happen before rejecting\n                setImmediate(() => {\n                    reject(`${errorMessage} (${new Date().toISOString()})`);\n                });\n            });\n            session.once('error', error => {\n                errorMessage = error.message;\n                this.trace('connection failed with error ' + errorMessage);\n            });\n        });\n    }\n    connect(address, credentials, options) {\n        var _a, _b;\n        if (this.isShutdown) {\n            return Promise.reject();\n        }\n        /* Pass connection options through to the proxy so that it's able to\n         * upgrade it's connection to support tls if needed.\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n        const connectionOptions = credentials._getConnectionOptions() || {};\n        if ('secureContext' in connectionOptions) {\n            connectionOptions.ALPNProtocols = ['h2'];\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (options['grpc.ssl_target_name_override']) {\n                const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n                connectionOptions.checkServerIdentity = (host, cert) => {\n                    return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            }\n            else {\n                if ('grpc.http_connect_target' in options) {\n                    /* This is more or less how servername will be set in createSession\n                     * if a connection is successfully established through the proxy.\n                     * If the proxy is not used, these connectionOptions are discarded\n                     * anyway */\n                    const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n                        path: 'localhost',\n                    });\n                    const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n                }\n            }\n            if (options['grpc-node.tls_enable_trace']) {\n                connectionOptions.enableTrace = true;\n            }\n        }\n        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));\n    }\n    shutdown() {\n        var _a;\n        this.isShutdown = true;\n        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n        this.session = null;\n    }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector;\n//# sourceMappingURL=transport.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0NBQWdDO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxvQkFBTztBQUM3QixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsb0JBQW9CLG1CQUFPLENBQUMsOEVBQWE7QUFDekMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQWM7QUFDM0MsZ0JBQWdCLG1CQUFPLENBQUMsMEVBQVc7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsNEVBQVk7QUFDdkMsNkJBQTZCLG1CQUFPLENBQUMsZ0dBQXNCO0FBQzNELHFCQUFxQixtQkFBTyxDQUFDLGdGQUFjO0FBQzNDLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QiwwQkFBMEIsbUJBQU8sQ0FBQywwRkFBbUI7QUFDckQsc0JBQXNCLG1CQUFPLENBQUMsa0ZBQWU7QUFDN0M7QUFDQTtBQUNBLHNCQUFzQiwwR0FBcUM7QUFDM0QsUUFBUSx1SUFBdUk7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGNBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGtDQUFrQywwREFBMEQ7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYyxHQUFHLHlCQUF5QjtBQUN4RSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdHJhbnNwb3J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIzIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHAyU3ViY2hhbm5lbENvbm5lY3RvciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBuZXQgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9jYWxsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWNhbGxcIik7XG5jb25zdCBjYWxsX251bWJlcl8xID0gcmVxdWlyZShcIi4vY2FsbC1udW1iZXJcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICd0cmFuc3BvcnQnO1xuY29uc3QgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FID0gJ3RyYW5zcG9ydF9mbG93Y3RybCc7XG5jb25zdCBjbGllbnRWZXJzaW9uID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmNvbnN0IHsgSFRUUDJfSEVBREVSX0FVVEhPUklUWSwgSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSwgSFRUUDJfSEVBREVSX01FVEhPRCwgSFRUUDJfSEVBREVSX1BBVEgsIEhUVFAyX0hFQURFUl9URSwgSFRUUDJfSEVBREVSX1VTRVJfQUdFTlQsIH0gPSBodHRwMi5jb25zdGFudHM7XG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9NUyA9IDIwMDAwO1xuY29uc3QgdG9vTWFueVBpbmdzRGF0YSA9IEJ1ZmZlci5mcm9tKCd0b29fbWFueV9waW5ncycsICdhc2NpaScpO1xuY2xhc3MgSHR0cDJUcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKHNlc3Npb24sIHN1YmNoYW5uZWxBZGRyZXNzLCBvcHRpb25zLCBcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSByZW1vdGUgc2VydmVyLCBpZiBpdCBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHN1YmNoYW5uZWxcbiAgICAgKiBhZGRyZXNzLCBpLmUuIGlmIGNvbm5lY3RpbmcgdGhyb3VnaCBhbiBIVFRQIENPTk5FQ1QgcHJveHkuXG4gICAgICovXG4gICAgcmVtb3RlTmFtZSkge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnJlbW90ZU5hbWUgPSByZW1vdGVOYW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0aW1lIGluIGJldHdlZW4gc2VuZGluZyBwaW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdGltZSB0byB3YWl0IGZvciBhbiBhY2tub3dsZWRnZW1lbnQgYWZ0ZXIgc2VuZGluZyBhIHBpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dE1zID0gS0VFUEFMSVZFX1RJTUVPVVRfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lciByZWZlcmVuY2UgZm9yIHRpbWVvdXQgdGhhdCBpbmRpY2F0ZXMgd2hlbiB0byBzZW5kIHRoZSBuZXh0IHBpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXJJZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUga2VlcGFsaXZlIHRpbWVyIHJhbiBvdXQgd2hpbGUgdGhlcmUgd2VyZSBubyBhY3RpdmVcbiAgICAgICAgICogY2FsbHMsIGFuZCBhIHBpbmcgc2hvdWxkIGJlIHNlbnQgdGhlIG5leHQgdGltZSBhIGNhbGwgc3RhcnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWVyIHJlZmVyZW5jZSB0cmFja2luZyB3aGVuIHRoZSBtb3N0IHJlY2VudCBwaW5nIHdpbGwgYmUgY29uc2lkZXJlZCBsb3N0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBrZWVwYWxpdmUgcGluZ3Mgc2hvdWxkIGJlIHNlbnQgd2l0aG91dCBhbnkgYWN0aXZlIGNhbGxzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbGxzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0SGFuZGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICAvKiBQb3B1bGF0ZSBzdWJjaGFubmVsQWRkcmVzc1N0cmluZyBhbmQgY2hhbm5lbHpSZWYgYmVmb3JlIGRvaW5nIGFueXRoaW5nXG4gICAgICAgICAqIGVsc2UsIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbiB0aGUgdHJhY2UgbWV0aG9kcy4gKi9cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyA9ICgwLCBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKShzdWJjaGFubmVsQWRkcmVzcyk7XG4gICAgICAgIGlmIChvcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSAoMCwgY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KSh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIC8vIEJ1aWxkIHVzZXItYWdlbnQgc3RyaW5nLlxuICAgICAgICB0aGlzLnVzZXJBZ2VudCA9IFtcbiAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMucHJpbWFyeV91c2VyX2FnZW50J10sXG4gICAgICAgICAgICBgZ3JwYy1ub2RlLWpzLyR7Y2xpZW50VmVyc2lvbn1gLFxuICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5zZWNvbmRhcnlfdXNlcl9hZ2VudCddLFxuICAgICAgICBdXG4gICAgICAgICAgICAuZmlsdGVyKGUgPT4gZSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7IC8vIHJlbW92ZSBmYWxzZXkgdmFsdWVzIGZpcnN0XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9XG4gICAgICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnXSA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3Nlc3Npb24gY2xvc2VkJyk7XG4gICAgICAgICAgICB0aGlzLnN0b3BLZWVwYWxpdmVQaW5ncygpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uLm9uY2UoJ2dvYXdheScsIChlcnJvckNvZGUsIGxhc3RTdHJlYW1JRCwgb3BhcXVlRGF0YSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRvb01hbnlQaW5ncyA9IGZhbHNlO1xuICAgICAgICAgICAgLyogU2VlIHRoZSBsYXN0IHBhcmFncmFwaCBvZlxuICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTgtY2xpZW50LXNpZGUta2VlcGFsaXZlLm1kI2Jhc2ljLWtlZXBhbGl2ZSAqL1xuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRU5IQU5DRV9ZT1VSX0NBTE0gJiZcbiAgICAgICAgICAgICAgICBvcGFxdWVEYXRhICYmXG4gICAgICAgICAgICAgICAgb3BhcXVlRGF0YS5lcXVhbHModG9vTWFueVBpbmdzRGF0YSkpIHtcbiAgICAgICAgICAgICAgICB0b29NYW55UGluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQgYnkgR09BV0FZIHdpdGggY29kZSAnICsgZXJyb3JDb2RlICsgJyBhbmQgZGF0YSAnICsgKG9wYXF1ZURhdGEgPT09IG51bGwgfHwgb3BhcXVlRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BhcXVlRGF0YS50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydERpc2Nvbm5lY3RUb093bmVyKHRvb01hbnlQaW5ncyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uLm9uY2UoJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAgICAgLyogRG8gbm90aGluZyBoZXJlLiBBbnkgZXJyb3Igc2hvdWxkIGFsc28gdHJpZ2dlciBhIGNsb3NlIGV2ZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgICogd2hlcmUgd2Ugd2FudCB0byBoYW5kbGUgdGhhdC4gICovXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGNsb3NlZCB3aXRoIGVycm9yICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb2dnaW5nLmlzVHJhY2VyRW5hYmxlZChUUkFDRVJfTkFNRSkpIHtcbiAgICAgICAgICAgIHNlc3Npb24ub24oJ3JlbW90ZVNldHRpbmdzJywgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnbmV3IHNldHRpbmdzIHJlY2VpdmVkJyArXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnNlc3Npb24gIT09IHNlc3Npb24gPyAnIG9uIHRoZSBvbGQgY29ubmVjdGlvbicgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2V0dGluZ3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2Vzc2lvbi5vbignbG9jYWxTZXR0aW5ncycsIChzZXR0aW5ncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2xvY2FsIHNldHRpbmdzIGFja25vd2xlZGdlZCBieSByZW1vdGUnICtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Vzc2lvbiAhPT0gc2Vzc2lvbiA/ICcgb24gdGhlIG9sZCBjb25uZWN0aW9uJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyogU3RhcnQgdGhlIGtlZXBhbGl2ZSB0aW1lciBsYXN0LCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXIgdHJhY2UgbG9ncyxcbiAgICAgICAgICogd2hpY2ggc2hvdWxkIG9ubHkgaGFwcGVuIGFmdGVyIGV2ZXJ5dGhpbmcgZWxzZSBpcyBzZXQgdXAuICovXG4gICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHRoaXMuc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgIGNvbnN0IHJlbW90ZUFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3NcbiAgICAgICAgICAgID8gKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3MpKHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcywgc2Vzc2lvblNvY2tldC5yZW1vdGVQb3J0KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjb25zdCBsb2NhbEFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzc1xuICAgICAgICAgICAgPyAoMCwgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcykoc2Vzc2lvblNvY2tldC5sb2NhbEFkZHJlc3MsIHNlc3Npb25Tb2NrZXQubG9jYWxQb3J0KVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBsZXQgdGxzSW5mbztcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbi5lbmNyeXB0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRsc1NvY2tldCA9IHNlc3Npb25Tb2NrZXQ7XG4gICAgICAgICAgICBjb25zdCBjaXBoZXJJbmZvID0gdGxzU29ja2V0LmdldENpcGhlcigpO1xuICAgICAgICAgICAgY29uc3QgY2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0Q2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHBlZXJDZXJ0aWZpY2F0ZSA9IHRsc1NvY2tldC5nZXRQZWVyQ2VydGlmaWNhdGUoKTtcbiAgICAgICAgICAgIHRsc0luZm8gPSB7XG4gICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVTdGFuZGFyZE5hbWU6IChfYSA9IGNpcGhlckluZm8uc3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlT3RoZXJOYW1lOiBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSA/IG51bGwgOiBjaXBoZXJJbmZvLm5hbWUsXG4gICAgICAgICAgICAgICAgbG9jYWxDZXJ0aWZpY2F0ZTogY2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gY2VydGlmaWNhdGUgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNlcnRpZmljYXRlOiBwZWVyQ2VydGlmaWNhdGUgJiYgJ3JhdycgaW4gcGVlckNlcnRpZmljYXRlXG4gICAgICAgICAgICAgICAgICAgID8gcGVlckNlcnRpZmljYXRlLnJhd1xuICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGxzSW5mbyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0SW5mbyA9IHtcbiAgICAgICAgICAgIHJlbW90ZUFkZHJlc3M6IHJlbW90ZUFkZHJlc3MsXG4gICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgIHNlY3VyaXR5OiB0bHNJbmZvLFxuICAgICAgICAgICAgcmVtb3RlTmFtZTogdGhpcy5yZW1vdGVOYW1lLFxuICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IHRoaXMuc3RyZWFtVHJhY2tlci5jYWxsc1N0YXJ0ZWQsXG4gICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IHRoaXMubWVzc2FnZXNTZW50LFxuICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogdGhpcy5tZXNzYWdlc1JlY2VpdmVkLFxuICAgICAgICAgICAga2VlcEFsaXZlc1NlbnQ6IHRoaXMua2VlcGFsaXZlc1NlbnQsXG4gICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiB0aGlzLnN0cmVhbVRyYWNrZXIubGFzdENhbGxTdGFydGVkVGltZXN0YW1wLFxuICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wLFxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcDogdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxuICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogKF9iID0gdGhpcy5zZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbnVsbCxcbiAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiAoX2MgPSB0aGlzLnNlc3Npb24uc3RhdGUucmVtb3RlV2luZG93U2l6ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgfVxuICAgIHRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCAnKCcgK1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselJlZi5pZCArXG4gICAgICAgICAgICAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgIHRleHQpO1xuICAgIH1cbiAgICBrZWVwYWxpdmVUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAna2VlcGFsaXZlJywgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgZmxvd0NvbnRyb2xUcmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUsICcoJyArXG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6UmVmLmlkICtcbiAgICAgICAgICAgICcpICcgK1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgdGV4dCk7XG4gICAgfVxuICAgIGludGVybmFsc1RyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICd0cmFuc3BvcnRfaW50ZXJuYWxzJywgJygnICtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpSZWYuaWQgK1xuICAgICAgICAgICAgJykgJyArXG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICB0ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgdG8gdGhlIG93bmVyIG9mIHRoaXMgb2JqZWN0IHRoYXQgdGhpcyB0cmFuc3BvcnQgc2hvdWxkIG5vIGxvbmdlclxuICAgICAqIGJlIHVzZWQuIFRoYXQgaGFwcGVucyBpZiB0aGUgY29ubmVjdGlvbiBkcm9wcywgb3IgaWYgdGhlIHNlcnZlciBzZW5kcyBhXG4gICAgICogR09BV0FZLlxuICAgICAqIEBwYXJhbSB0b29NYW55UGluZ3MgSWYgdHJ1ZSwgdGhpcyB3YXMgdHJpZ2dlcmVkIGJ5IGEgR09BV0FZIHdpdGggZGF0YVxuICAgICAqIGluZGljYXRpbmcgdGhhdCB0aGUgc2Vzc2lvbiB3YXMgY2xvc2VkIGJlY2F1ZXMgdGhlIGNsaWVudCBzZW50IHRvbyBtYW55XG4gICAgICogcGluZ3MuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICByZXBvcnREaXNjb25uZWN0VG9Pd25lcih0b29NYW55UGluZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzY29ubmVjdEhhbmRsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIodG9vTWFueVBpbmdzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBjb25uZWN0aW9uIGRyb3BzLCBidXQgbm90IEdPQVdBWXMuXG4gICAgICovXG4gICAgaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5yZXBvcnREaXNjb25uZWN0VG9Pd25lcihmYWxzZSk7XG4gICAgICAgIC8qIEdpdmUgY2FsbHMgYW4gZXZlbnQgbG9vcCBjeWNsZSB0byBmaW5pc2ggbmF0dXJhbGx5IGJlZm9yZSByZXBvcnRpbmcgdGhlXG4gICAgICAgICAqIGRpc2Nvbm5uZWN0aW9uIHRvIHRoZW0uICovXG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGwgb2YgdGhpcy5hY3RpdmVDYWxscykge1xuICAgICAgICAgICAgICAgIGNhbGwub25EaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGREaXNjb25uZWN0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBjbGVhcktlZXBhbGl2ZVRpbWVyKCkge1xuICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlVGltZXJJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVySWQpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVySWQgPSBudWxsO1xuICAgIH1cbiAgICBjbGVhcktlZXBhbGl2ZVRpbWVvdXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIGNhblNlbmRQaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMua2VlcGFsaXZlVGltZU1zID4gMCAmJlxuICAgICAgICAgICAgKHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzIHx8IHRoaXMuYWN0aXZlQ2FsbHMuc2l6ZSA+IDApKTtcbiAgICB9XG4gICAgbWF5YmVTZW5kUGluZygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jbGVhcktlZXBhbGl2ZVRpbWVyKCk7XG4gICAgICAgIGlmICghdGhpcy5jYW5TZW5kUGluZygpKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdTZW5kS2VlcGFsaXZlUGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZXNTZW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnU2VuZGluZyBwaW5nIHdpdGggdGltZW91dCAnICsgdGhpcy5rZWVwYWxpdmVUaW1lb3V0TXMgKyAnbXMnKTtcbiAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHRpbWVvdXQgcGFzc2VkIHdpdGhvdXQgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH0sIHRoaXMua2VlcGFsaXZlVGltZW91dE1zKTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMua2VlcGFsaXZlVGltZW91dElkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucGluZygoZXJyLCBkdXJhdGlvbiwgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUGluZyBmYWlsZWQgd2l0aCBlcnJvciAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnUmVjZWl2ZWQgcGluZyByZXNwb25zZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogSWYgd2UgZmFpbCB0byBzZW5kIGEgcGluZywgdGhlIGNvbm5lY3Rpb24gaXMgbm8gbG9uZ2VyIGZ1bmN0aW9uYWwsIHNvXG4gICAgICAgICAgICAgKiB3ZSBzaG91bGQgZGlzY2FyZCBpdC4gKi9cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUga2VlcGFsaXZlIHBpbmcgdGltZXIgaWYgYXBwcm9wcmlhdGUuIElmIHRoZSB0aW1lciBhbHJlYWR5IHJhblxuICAgICAqIG91dCB3aGlsZSB0aGVyZSB3ZXJlIG5vIGFjdGl2ZSByZXF1ZXN0cywgaW5zdGVhZCBzZW5kIGEgcGluZyBpbW1lZGlhdGVseS5cbiAgICAgKiBJZiB0aGUgcGluZyB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcgb3IgYSBwaW5nIGlzIGN1cnJlbnRseSBpbiBmbGlnaHQsXG4gICAgICogaW5zdGVhZCBkbyBub3RoaW5nIGFuZCB3YWl0IGZvciB0aGVtIHRvIHJlc29sdmUuXG4gICAgICovXG4gICAgbWF5YmVTdGFydEtlZXBhbGl2ZVBpbmdUaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCF0aGlzLmNhblNlbmRQaW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nU2VuZEtlZXBhbGl2ZVBpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1NlbmRLZWVwYWxpdmVQaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm1heWJlU2VuZFBpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5rZWVwYWxpdmVUaW1lcklkICYmICF0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUcmFjZSgnU3RhcnRpbmcga2VlcGFsaXZlIHRpbWVyIGZvciAnICsgdGhpcy5rZWVwYWxpdmVUaW1lTXMgKyAnbXMnKTtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZXJJZCA9IChfYiA9IChfYSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVTZW5kUGluZygpO1xuICAgICAgICAgICAgfSwgdGhpcy5rZWVwYWxpdmVUaW1lTXMpKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9XG4gICAgICAgIC8qIE90aGVyd2lzZSwgdGhlcmUgaXMgYWxyZWFkeSBlaXRoZXIgYSBrZWVwYWxpdmUgdGltZXIgb3IgYSBwaW5nIHBlbmRpbmcsXG4gICAgICAgICAqIHdhaXQgZm9yIHRob3NlIHRvIHJlc29sdmUuICovXG4gICAgfVxuICAgIHN0b3BLZWVwYWxpdmVQaW5ncygpIHtcbiAgICAgICAgaWYgKHRoaXMua2VlcGFsaXZlVGltZXJJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZXJJZCk7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVySWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJLZWVwYWxpdmVUaW1lb3V0KCk7XG4gICAgfVxuICAgIHJlbW92ZUFjdGl2ZUNhbGwoY2FsbCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUNhbGxzLmRlbGV0ZShjYWxsKTtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQWN0aXZlQ2FsbChjYWxsKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2FsbHMuYWRkKGNhbGwpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVDYWxscy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVmKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZVN0YXJ0S2VlcGFsaXZlUGluZ1RpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlQ2FsbChtZXRhZGF0YSwgaG9zdCwgbWV0aG9kLCBsaXN0ZW5lciwgc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1ldGFkYXRhLnRvSHR0cDJIZWFkZXJzKCk7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX0FVVEhPUklUWV0gPSBob3N0O1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9VU0VSX0FHRU5UXSA9IHRoaXMudXNlckFnZW50O1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdID0gJ2FwcGxpY2F0aW9uL2dycGMnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gJ1BPU1QnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IG1ldGhvZDtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfVEVdID0gJ3RyYWlsZXJzJztcbiAgICAgICAgbGV0IGh0dHAyU3RyZWFtO1xuICAgICAgICAvKiBJbiB0aGVvcnksIGlmIGFuIGVycm9yIGlzIHRocm93biBieSBzZXNzaW9uLnJlcXVlc3QgYmVjYXVzZSBzZXNzaW9uIGhhc1xuICAgICAgICAgKiBiZWNvbWUgdW51c2FibGUgKGUuZy4gYmVjYXVzZSBpdCBoYXMgcmVjZWl2ZWQgYSBnb2F3YXkpLCB0aGlzIHN1YmNoYW5uZWxcbiAgICAgICAgICogc2hvdWxkIHNvb24gc2VlIHRoZSBjb3JyZXNwb25kaW5nIGNsb3NlIG9yIGdvYXdheSBldmVudCBhbnl3YXkgYW5kIGxlYXZlXG4gICAgICAgICAqIFJFQURZLiBCdXQgd2UgaGF2ZSBzZWVuIHJlcG9ydHMgdGhhdCB0aGlzIGRvZXMgbm90IGhhcHBlblxuICAgICAgICAgKiAoaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZWFwaXMvbm9kZWpzLWZpcmVzdG9yZS9pc3N1ZXMvMTAyMyNpc3N1ZWNvbW1lbnQtNjUzMjA0MDk2KVxuICAgICAgICAgKiBzbyBmb3IgZGVmZW5zZSBpbiBkZXB0aCwgd2UganVzdCBkaXNjYXJkIHRoZSBzZXNzaW9uIHdoZW4gd2Ugc2VlIGFuXG4gICAgICAgICAqIGVycm9yIGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaHR0cDJTdHJlYW0gPSB0aGlzLnNlc3Npb24ucmVxdWVzdChoZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxvd0NvbnRyb2xUcmFjZSgnbG9jYWwgd2luZG93IHNpemU6ICcgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnN0YXRlLmxvY2FsV2luZG93U2l6ZSArXG4gICAgICAgICAgICAnIHJlbW90ZSB3aW5kb3cgc2l6ZTogJyArXG4gICAgICAgICAgICB0aGlzLnNlc3Npb24uc3RhdGUucmVtb3RlV2luZG93U2l6ZSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxzVHJhY2UoJ3Nlc3Npb24uY2xvc2VkPScgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uZGVzdHJveWVkPScgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLmRlc3Ryb3llZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uc29ja2V0LmRlc3Ryb3llZD0nICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zb2NrZXQuZGVzdHJveWVkKTtcbiAgICAgICAgbGV0IGV2ZW50VHJhY2tlcjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1jb25zdFxuICAgICAgICBsZXQgY2FsbDtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIGV2ZW50VHJhY2tlciA9IHtcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlU2VudDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNTZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVNlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFkZE1lc3NhZ2VSZWNlaXZlZDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlUmVjZWl2ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2FsbEVuZDogc3RhdHVzID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5vbkNhbGxFbmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLCBzdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZUNhbGwoY2FsbCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblN0cmVhbUVuZDogc3VjY2VzcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uU3RyZWFtRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBldmVudFRyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlci5hZGRNZXNzYWdlU2VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIuYWRkTWVzc2FnZVJlY2VpdmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlcik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNhbGxFbmQ6IHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gc3ViY2hhbm5lbENhbGxTdGF0c1RyYWNrZXIub25DYWxsRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBY3RpdmVDYWxsKGNhbGwpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdHJlYW1FbmQ6IHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHN1YmNoYW5uZWxDYWxsU3RhdHNUcmFja2VyLm9uU3RyZWFtRW5kKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChzdWJjaGFubmVsQ2FsbFN0YXRzVHJhY2tlciwgc3VjY2Vzcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FsbCA9IG5ldyBzdWJjaGFubmVsX2NhbGxfMS5IdHRwMlN1YmNoYW5uZWxDYWxsKGh0dHAyU3RyZWFtLCBldmVudFRyYWNrZXIsIGxpc3RlbmVyLCB0aGlzLCAoMCwgY2FsbF9udW1iZXJfMS5nZXROZXh0Q2FsbE51bWJlcikoKSk7XG4gICAgICAgIHRoaXMuYWRkQWN0aXZlQ2FsbChjYWxsKTtcbiAgICAgICAgcmV0dXJuIGNhbGw7XG4gICAgfVxuICAgIGdldENoYW5uZWx6UmVmKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVselJlZjtcbiAgICB9XG4gICAgZ2V0UGVlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uLmNsb3NlKCk7XG4gICAgICAgICgwLCBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZikodGhpcy5jaGFubmVselJlZik7XG4gICAgfVxufVxuY2xhc3MgSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNTaHV0ZG93biA9IGZhbHNlO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykodGhpcy5jaGFubmVsVGFyZ2V0KSArICcgJyArIHRleHQpO1xuICAgIH1cbiAgICBjcmVhdGVTZXNzaW9uKGFkZHJlc3MsIGNyZWRlbnRpYWxzLCBvcHRpb25zLCBwcm94eUNvbm5lY3Rpb25SZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaHV0ZG93bikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgbGV0IHJlbW90ZU5hbWU7XG4gICAgICAgICAgICBpZiAocHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZW1vdGVOYW1lID0gKDAsIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZykocHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0aW5nIEhUVFAvMiBzZXNzaW9uIHRocm91Z2ggcHJveHkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICgwLCB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcpKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdGVOYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdjcmVhdGluZyBIVFRQLzIgc2Vzc2lvbiB0byAnICsgKDAsIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcpKGFkZHJlc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEF1dGhvcml0eSA9ICgwLCByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkpKChfYSA9IHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNoYW5uZWxUYXJnZXQpO1xuICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb25PcHRpb25zID0gY3JlZGVudGlhbHMuX2dldENvbm5lY3Rpb25PcHRpb25zKCkgfHwge307XG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgICAgIGlmICgnZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zWydncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5J107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBCeSBkZWZhdWx0LCBzZXQgYSB2ZXJ5IGxhcmdlIG1heCBzZXNzaW9uIG1lbW9yeSBsaW1pdCwgdG8gZWZmZWN0aXZlbHlcbiAgICAgICAgICAgICAgICAgKiBkaXNhYmxlIGVuZm9yY2VtZW50IG9mIHRoZSBsaW1pdC4gU29tZSB0ZXN0aW5nIGluZGljYXRlcyB0aGF0IE5vZGUnc1xuICAgICAgICAgICAgICAgICAqIGJlaGF2aW9yIGRlZ3JhZGVzIGJhZGx5IHdoZW4gdGhpcyBsaW1pdCBpcyByZWFjaGVkLCBzbyB3ZSBzb2x2ZSB0aGF0XG4gICAgICAgICAgICAgICAgICogYnkgZGlzYWJsaW5nIHRoZSBjaGVjayBlbnRpcmVseS4gKi9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWRkcmVzc1NjaGVtZSA9ICdodHRwOi8vJztcbiAgICAgICAgICAgIGlmICgnc2VjdXJlQ29udGV4dCcgaW4gY29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzU2NoZW1lID0gJ2h0dHBzOi8vJztcbiAgICAgICAgICAgICAgICAvLyBJZiBwcm92aWRlZCwgdGhlIHZhbHVlIG9mIGdycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlIHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAgICAgLy8gdG8gb3ZlcnJpZGUgdGhlIHRhcmdldCBob3N0bmFtZSB3aGVuIGNoZWNraW5nIHNlcnZlciBpZGVudGl0eS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIG9wdGlvbiBpcyB1c2VkIGZvciB0ZXN0aW5nIG9ubHkuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3NsVGFyZ2V0TmFtZU92ZXJyaWRlID0gb3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9IChob3N0LCBjZXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHRsc18xLmNoZWNrU2VydmVySWRlbnRpdHkpKHNzbFRhcmdldE5hbWVPdmVycmlkZSwgY2VydCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBzc2xUYXJnZXROYW1lT3ZlcnJpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpdHlIb3N0bmFtZSA9IChfYyA9IChfYiA9ICgwLCB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCkodGFyZ2V0QXV0aG9yaXR5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhvc3QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdsb2NhbGhvc3QnO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIGFsd2F5cyBzZXQgc2VydmVybmFtZSB0byBzdXBwb3J0IFNOSVxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gYXV0aG9yaXR5SG9zdG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoaXMgaXMgcGFydCBvZiB0aGUgd29ya2Fyb3VuZCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMi4gV2l0aG91dCB0aGF0IGJ1ZyxcbiAgICAgICAgICAgICAgICAgICAgICogcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCB3b3VsZCBhbHdheXMgYmUgYSBwbGFpbnRleHQgc29ja2V0IGFuZFxuICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIHdvdWxkIHNheVxuICAgICAgICAgICAgICAgICAgICAgKiBjb25uZWN0aW9uT3B0aW9ucy5zb2NrZXQgPSBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0OyAqL1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jcmVhdGVDb25uZWN0aW9uID0gKGF1dGhvcml0eSwgb3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldDtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBJbiBhbGwgYnV0IHRoZSBtb3N0IHJlY2VudCB2ZXJzaW9ucyBvZiBOb2RlLCBodHRwMi5jb25uZWN0IGRvZXMgbm90IHVzZVxuICAgICAgICAgICAgICAgICAqIHRoZSBvcHRpb25zIHdoZW4gZXN0YWJsaXNoaW5nIHBsYWludGV4dCBjb25uZWN0aW9ucywgc28gd2UgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAqIGVzdGFibGlzaCB0aGF0IGNvbm5lY3Rpb24gZXhwbGljaXRseS4gKi9cbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jcmVhdGVDb25uZWN0aW9uID0gKGF1dGhvcml0eSwgb3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIG5ldC5OZXRDb25uZWN0T3B0cyBpcyBkZWNsYXJlZCBpbiBhIHdheSB0aGF0IGlzIG1vcmUgcmVzdHJpY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoYW4gd2hhdCBuZXQuY29ubmVjdCB3aWxsIGFjdHVhbGx5IGFjY2VwdCwgc28gd2UgdXNlIHRoZSB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhc3NlcnRpb24gdG8gd29yayBhcm91bmQgdGhhdC4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXQuY29ubmVjdChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25uZWN0aW9uT3B0aW9ucyksIGFkZHJlc3MpLCB7IGVuYWJsZVRyYWNlOiBvcHRpb25zWydncnBjLW5vZGUudGxzX2VuYWJsZV90cmFjZSddID09PSAxIH0pO1xuICAgICAgICAgICAgLyogaHR0cDIuY29ubmVjdCB1c2VzIHRoZSBvcHRpb25zIGhlcmU6XG4gICAgICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi83MGMzMmE2ZDE5MGUyYjVkN2I5ZmY5ZDViNmE0NTlkMTRlOGI3ZDU5L2xpYi9pbnRlcm5hbC9odHRwMi9jb3JlLmpzI0wzMDI4LUwzMDM2XG4gICAgICAgICAgICAgKiBUaGUgc3ByZWFkIG9wZXJhdG9yIG92ZXJpZGVzIGVhcmxpZXIgdmFsdWVzIHdpdGggbGF0ZXIgb25lcywgc28gYW55IHBvcnRcbiAgICAgICAgICAgICAqIG9yIGhvc3QgdmFsdWVzIGluIHRoZSBvcHRpb25zIHdpbGwgYmUgdXNlZCByYXRoZXIgdGhhbiBhbnkgdmFsdWVzIGV4dHJhY3RlZFxuICAgICAgICAgICAgICogZnJvbSB0aGUgZmlyc3QgYXJndW1lbnQuIEluIGFkZGl0aW9uLCB0aGUgcGF0aCBvdmVycmlkZXMgdGhlIGhvc3QgYW5kIHBvcnQsXG4gICAgICAgICAgICAgKiBhcyBkb2N1bWVudGVkIGZvciBwbGFpbnRleHQgY29ubmVjdGlvbnMgaGVyZTpcbiAgICAgICAgICAgICAqIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvbmV0Lmh0bWwjbmV0X3NvY2tldF9jb25uZWN0X29wdGlvbnNfY29ubmVjdGxpc3RlbmVyXG4gICAgICAgICAgICAgKiBhbmQgZm9yIFRMUyBjb25uZWN0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90bHMuaHRtbCN0bHNfdGxzX2Nvbm5lY3Rfb3B0aW9uc19jYWxsYmFjay4gSW5cbiAgICAgICAgICAgICAqIGVhcmxpZXIgdmVyc2lvbnMgb2YgTm9kZSwgaHR0cDIuY29ubmVjdCBwYXNzZXMgdGhlc2Ugb3B0aW9ucyB0b1xuICAgICAgICAgICAgICogdGxzLmNvbm5lY3QgYnV0IG5vdCBuZXQuY29ubmVjdCwgc28gaW4gdGhlIGluc2VjdXJlIGNhc2Ugd2Ugc3RpbGwgbmVlZFxuICAgICAgICAgICAgICogdG8gc2V0IHRoZSBjcmVhdGVDb25uZWN0aW9uIG9wdGlvbiBhYm92ZSB0byBjcmVhdGUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAqIGV4cGxpY2l0bHkuIFdlIGNhbm5vdCBkbyB0aGF0IGluIHRoZSBUTFMgY2FzZSBiZWNhdXNlIGh0dHAyLmNvbm5lY3RcbiAgICAgICAgICAgICAqIHBhc3NlcyBuZWNlc3NhcnkgYWRkaXRpb25hbCBvcHRpb25zIHRvIHRscy5jb25uZWN0LlxuICAgICAgICAgICAgICogVGhlIGZpcnN0IGFyZ3VtZW50IGp1c3QgbmVlZHMgdG8gYmUgcGFyc2VhYmxlIGFzIGEgVVJMIGFuZCB0aGUgc2NoZW1lXG4gICAgICAgICAgICAgKiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBlc3RhYmxpc2hlZCBvdmVyIFRMUyBvciBub3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGFkZHJlc3NTY2hlbWUgKyB0YXJnZXRBdXRob3JpdHksIGNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJ0ZhaWxlZCB0byBjb25uZWN0JztcbiAgICAgICAgICAgIHNlc3Npb24udW5yZWYoKTtcbiAgICAgICAgICAgIHNlc3Npb24ub25jZSgnY29ubmVjdCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEh0dHAyVHJhbnNwb3J0KHNlc3Npb24sIGFkZHJlc3MsIG9wdGlvbnMsIHJlbW90ZU5hbWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gTGVhdmUgdGltZSBmb3IgZXJyb3IgZXZlbnQgdG8gaGFwcGVuIGJlZm9yZSByZWplY3RpbmdcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoYCR7ZXJyb3JNZXNzYWdlfSAoJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9KWApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uY2UoJ2Vycm9yJywgZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBmYWlsZWQgd2l0aCBlcnJvciAnICsgZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdChhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5pc1NodXRkb3duKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBQYXNzIGNvbm5lY3Rpb24gb3B0aW9ucyB0aHJvdWdoIHRvIHRoZSBwcm94eSBzbyB0aGF0IGl0J3MgYWJsZSB0b1xuICAgICAgICAgKiB1cGdyYWRlIGl0J3MgY29ubmVjdGlvbiB0byBzdXBwb3J0IHRscyBpZiBuZWVkZWQuXG4gICAgICAgICAqIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzMyOTIyXG4gICAgICAgICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JwYy9ncnBjLW5vZGUvcHVsbC8xMzY5IGZvciBtb3JlIGluZm8uICovXG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25PcHRpb25zID0gY3JlZGVudGlhbHMuX2dldENvbm5lY3Rpb25PcHRpb25zKCkgfHwge307XG4gICAgICAgIGlmICgnc2VjdXJlQ29udGV4dCcgaW4gY29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLkFMUE5Qcm90b2NvbHMgPSBbJ2gyJ107XG4gICAgICAgICAgICAvLyBJZiBwcm92aWRlZCwgdGhlIHZhbHVlIG9mIGdycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlIHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAvLyB0byBvdmVycmlkZSB0aGUgdGFyZ2V0IGhvc3RuYW1lIHdoZW4gY2hlY2tpbmcgc2VydmVyIGlkZW50aXR5LlxuICAgICAgICAgICAgLy8gVGhpcyBvcHRpb24gaXMgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxuICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlJ10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzc2xUYXJnZXROYW1lT3ZlcnJpZGUgPSBvcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSAoaG9zdCwgY2VydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHRsc18xLmNoZWNrU2VydmVySWRlbnRpdHkpKHNzbFRhcmdldE5hbWVPdmVycmlkZSwgY2VydCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gc3NsVGFyZ2V0TmFtZU92ZXJyaWRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogVGhpcyBpcyBtb3JlIG9yIGxlc3MgaG93IHNlcnZlcm5hbWUgd2lsbCBiZSBzZXQgaW4gY3JlYXRlU2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICAgKiBpZiBhIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIHRocm91Z2ggdGhlIHByb3h5LlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgcHJveHkgaXMgbm90IHVzZWQsIHRoZXNlIGNvbm5lY3Rpb25PcHRpb25zIGFyZSBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgICAgICAgICogYW55d2F5ICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSAoMCwgcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KSgoX2EgPSAoMCwgdXJpX3BhcnNlcl8xLnBhcnNlVXJpKShvcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdsb2NhbGhvc3QnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9zdFBvcnQgPSAoMCwgdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQpKHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gKF9iID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRhcmdldFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ2dycGMtbm9kZS50bHNfZW5hYmxlX3RyYWNlJ10pIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5lbmFibGVUcmFjZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBodHRwX3Byb3h5XzEuZ2V0UHJveGllZENvbm5lY3Rpb24pKGFkZHJlc3MsIG9wdGlvbnMsIGNvbm5lY3Rpb25PcHRpb25zKS50aGVuKHJlc3VsdCA9PiB0aGlzLmNyZWF0ZVNlc3Npb24oYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMsIHJlc3VsdCkpO1xuICAgIH1cbiAgICBzaHV0ZG93bigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmlzU2h1dGRvd24gPSB0cnVlO1xuICAgICAgICAoX2EgPSB0aGlzLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yID0gSHR0cDJTdWJjaGFubmVsQ29ubmVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNwb3J0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/transport.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */\nconst URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3],\n    };\n}\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith('[')) {\n        const hostEnd = path.indexOf(']');\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */\n        if (host.indexOf(':') === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === ':') {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString,\n                    };\n                }\n                else {\n                    return null;\n                }\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host,\n            };\n        }\n    }\n    else {\n        const splitPath = path.split(':');\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */\n        if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1],\n                };\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return {\n                host: path,\n            };\n        }\n    }\n}\nexports.splitHostPort = splitHostPort;\nfunction uriToString(uri) {\n    let result = '';\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + ':';\n    }\n    if (uri.authority !== undefined) {\n        result += '//' + uri.authority + '/';\n    }\n    result += uri.path;\n    return result;\n}\nexports.uriToString = uriToString;\n//# sourceMappingURL=uri-parser.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLHFCQUFxQixHQUFHLGdCQUFnQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CIiwic291cmNlcyI6WyIvVXNlcnMvY3Jpc3RpYW5iZXJiZWNhcnUvUHJvamVjdHMvTU5DL0RldmVsb3AvdmliZS1jb2RpbmcvbG9va2FnYWluL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy91cmktcGFyc2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnVyaVRvU3RyaW5nID0gZXhwb3J0cy5zcGxpdEhvc3RQb3J0ID0gZXhwb3J0cy5wYXJzZVVyaSA9IHZvaWQgMDtcbi8qXG4gKiBUaGUgZ3JvdXBzIGNvcnJlc3BvbmQgdG8gVVJJIHBhcnRzIGFzIGZvbGxvd3M6XG4gKiAxLiBzY2hlbWVcbiAqIDIuIGF1dGhvcml0eVxuICogMy4gcGF0aFxuICovXG5jb25zdCBVUklfUkVHRVggPSAvXig/OihbQS1aYS16MC05Ky4tXSspOik/KD86XFwvXFwvKFteL10qKVxcLyk/KC4rKSQvO1xuZnVuY3Rpb24gcGFyc2VVcmkodXJpU3RyaW5nKSB7XG4gICAgY29uc3QgcGFyc2VkVXJpID0gVVJJX1JFR0VYLmV4ZWModXJpU3RyaW5nKTtcbiAgICBpZiAocGFyc2VkVXJpID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWU6IHBhcnNlZFVyaVsxXSxcbiAgICAgICAgYXV0aG9yaXR5OiBwYXJzZWRVcmlbMl0sXG4gICAgICAgIHBhdGg6IHBhcnNlZFVyaVszXSxcbiAgICB9O1xufVxuZXhwb3J0cy5wYXJzZVVyaSA9IHBhcnNlVXJpO1xuY29uc3QgTlVNQkVSX1JFR0VYID0gL15cXGQrJC87XG5mdW5jdGlvbiBzcGxpdEhvc3RQb3J0KHBhdGgpIHtcbiAgICBpZiAocGF0aC5zdGFydHNXaXRoKCdbJykpIHtcbiAgICAgICAgY29uc3QgaG9zdEVuZCA9IHBhdGguaW5kZXhPZignXScpO1xuICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3QgPSBwYXRoLnN1YnN0cmluZygxLCBob3N0RW5kKTtcbiAgICAgICAgLyogT25seSBhbiBJUHY2IGFkZHJlc3Mgc2hvdWxkIGJlIGluIGJyYWNrZXRlZCBub3RhdGlvbiwgYW5kIGFuIElQdjZcbiAgICAgICAgICogYWRkcmVzcyBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgY29sb24gKi9cbiAgICAgICAgaWYgKGhvc3QuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gaG9zdEVuZCArIDEpIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2hvc3RFbmQgKyAxXSA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9ydFN0cmluZyA9IHBhdGguc3Vic3RyaW5nKGhvc3RFbmQgKyAyKTtcbiAgICAgICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3QocG9ydFN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiArcG9ydFN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3BsaXRQYXRoID0gcGF0aC5zcGxpdCgnOicpO1xuICAgICAgICAvKiBFeGFjdGx5IG9uZSBjb2xvbiBtZWFucyB0aGF0IHRoaXMgaXMgaG9zdDpwb3J0LiBaZXJvIGNvbG9ucyBtZWFucyB0aGF0XG4gICAgICAgICAqIHRoZXJlIGlzIG5vIHBvcnQuIEFuZCBtdWx0aXBsZSBjb2xvbnMgbWVhbnMgdGhhdCB0aGlzIGlzIGEgYmFyZSBJUHY2XG4gICAgICAgICAqIGFkZHJlc3Mgd2l0aCBubyBwb3J0ICovXG4gICAgICAgIGlmIChzcGxpdFBhdGgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoTlVNQkVSX1JFR0VYLnRlc3Qoc3BsaXRQYXRoWzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHNwbGl0UGF0aFswXSxcbiAgICAgICAgICAgICAgICAgICAgcG9ydDogK3NwbGl0UGF0aFsxXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhvc3Q6IHBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5zcGxpdEhvc3RQb3J0ID0gc3BsaXRIb3N0UG9ydDtcbmZ1bmN0aW9uIHVyaVRvU3RyaW5nKHVyaSkge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBpZiAodXJpLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSB1cmkuc2NoZW1lICsgJzonO1xuICAgIH1cbiAgICBpZiAodXJpLmF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdCArPSAnLy8nICsgdXJpLmF1dGhvcml0eSArICcvJztcbiAgICB9XG4gICAgcmVzdWx0ICs9IHVyaS5wYXRoO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVyaVRvU3RyaW5nID0gdXJpVG9TdHJpbmc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmktcGFyc2VyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"@grpc/grpc-js","version":"1.9.15","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":"^8.13.0 || >=10.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@types/gulp":"^4.0.6","@types/gulp-mocha":"0.0.32","@types/lodash":"^4.14.186","@types/mocha":"^5.2.6","@types/ncp":"^2.0.1","@types/pify":"^3.0.2","@types/semver":"^7.3.9","@typescript-eslint/eslint-plugin":"^5.59.11","@typescript-eslint/parser":"^5.59.11","@typescript-eslint/typescript-estree":"^5.59.11","clang-format":"^1.0.55","eslint":"^8.42.0","eslint-config-prettier":"^8.8.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^4.2.1","execa":"^2.0.3","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.4","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","prettier":"^2.8.8","rimraf":"^3.0.2","semver":"^7.3.5","ts-node":"^10.9.1","typescript":"^5.1.3"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"eslint src/*.ts test/*.ts","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"npm run lint","fix":"eslint --fix src/*.ts test/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.8","@types/node":">=12.12.47"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(ssr)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(ssr)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return ('@type' in obj) && (typeof obj['@type'] === 'string');\n}\nexports.isAnyExtension = isAnyExtension;\nvar IdempotencyLevel;\n(function (IdempotencyLevel) {\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction mapMethodOptions(options) {\n    return (options || []).reduce((obj, item) => {\n        for (const [key, value] of Object.entries(item)) {\n            switch (key) {\n                case 'uninterpreted_option':\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\n                    break;\n                default:\n                    obj[key] = value;\n            }\n        }\n        return obj;\n    }, {\n        deprecated: false,\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\n        uninterpreted_option: [],\n    });\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n        options: mapMethodOptions(method.parsedOptions),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then(loadedRoot => {\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)();\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsdUNBQXVDLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLHdCQUF3QixHQUFHLHNCQUFzQixHQUFHLFlBQVk7QUFDek0sa0JBQWtCLG1CQUFPLENBQUMsd0VBQWtCO0FBQzVDLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDLG1CQUFtQixtQkFBTyxDQUFDLDBGQUEyQjtBQUN0RCxlQUFlLG1CQUFPLENBQUMseUVBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLG9EQUFNO0FBQzNCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtELHdCQUF3QixLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFVBQVU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9jcmlzdGlhbmJlcmJlY2FydS9Qcm9qZWN0cy9NTkMvRGV2ZWxvcC92aWJlLWNvZGluZy9sb29rYWdhaW4vbm9kZV9tb2R1bGVzL0BncnBjL3Byb3RvLWxvYWRlci9idWlsZC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0ID0gZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyID0gZXhwb3J0cy5mcm9tSlNPTiA9IGV4cG9ydHMubG9hZFN5bmMgPSBleHBvcnRzLmxvYWQgPSBleHBvcnRzLklkZW1wb3RlbmN5TGV2ZWwgPSBleHBvcnRzLmlzQW55RXh0ZW5zaW9uID0gZXhwb3J0cy5Mb25nID0gdm9pZCAwO1xuY29uc3QgY2FtZWxDYXNlID0gcmVxdWlyZShcImxvZGFzaC5jYW1lbGNhc2VcIik7XG5jb25zdCBQcm90b2J1ZiA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzXCIpO1xuY29uc3QgZGVzY3JpcHRvciA9IHJlcXVpcmUoXCJwcm90b2J1ZmpzL2V4dC9kZXNjcmlwdG9yXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbmNvbnN0IExvbmcgPSByZXF1aXJlKFwibG9uZ1wiKTtcbmV4cG9ydHMuTG9uZyA9IExvbmc7XG5mdW5jdGlvbiBpc0FueUV4dGVuc2lvbihvYmopIHtcbiAgICByZXR1cm4gKCdAdHlwZScgaW4gb2JqKSAmJiAodHlwZW9mIG9ialsnQHR5cGUnXSA9PT0gJ3N0cmluZycpO1xufVxuZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGlzQW55RXh0ZW5zaW9uO1xudmFyIElkZW1wb3RlbmN5TGV2ZWw7XG4oZnVuY3Rpb24gKElkZW1wb3RlbmN5TGV2ZWwpIHtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOQ1lfVU5LTk9XTlwiXSA9IFwiSURFTVBPVEVOQ1lfVU5LTk9XTlwiO1xuICAgIElkZW1wb3RlbmN5TGV2ZWxbXCJOT19TSURFX0VGRkVDVFNcIl0gPSBcIk5PX1NJREVfRUZGRUNUU1wiO1xuICAgIElkZW1wb3RlbmN5TGV2ZWxbXCJJREVNUE9URU5UXCJdID0gXCJJREVNUE9URU5UXCI7XG59KShJZGVtcG90ZW5jeUxldmVsID0gZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsIHx8IChleHBvcnRzLklkZW1wb3RlbmN5TGV2ZWwgPSB7fSkpO1xuY29uc3QgZGVzY3JpcHRvck9wdGlvbnMgPSB7XG4gICAgbG9uZ3M6IFN0cmluZyxcbiAgICBlbnVtczogU3RyaW5nLFxuICAgIGJ5dGVzOiBTdHJpbmcsXG4gICAgZGVmYXVsdHM6IHRydWUsXG4gICAgb25lb2ZzOiB0cnVlLFxuICAgIGpzb246IHRydWUsXG59O1xuZnVuY3Rpb24gam9pbk5hbWUoYmFzZU5hbWUsIG5hbWUpIHtcbiAgICBpZiAoYmFzZU5hbWUgPT09ICcnKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOYW1lICsgJy4nICsgbmFtZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0KG9iaikge1xuICAgIHJldHVybiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuU2VydmljZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5UeXBlIHx8XG4gICAgICAgIG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLkVudW0pO1xufVxuZnVuY3Rpb24gaXNOYW1lc3BhY2VCYXNlKG9iaikge1xuICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5OYW1lc3BhY2UgfHwgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuUm9vdDtcbn1cbmZ1bmN0aW9uIGdldEFsbEhhbmRsZWRSZWZsZWN0aW9uT2JqZWN0cyhvYmosIHBhcmVudE5hbWUpIHtcbiAgICBjb25zdCBvYmpOYW1lID0gam9pbk5hbWUocGFyZW50TmFtZSwgb2JqLm5hbWUpO1xuICAgIGlmIChpc0hhbmRsZWRSZWZsZWN0aW9uT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIFtbb2JqTmFtZSwgb2JqXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXNOYW1lc3BhY2VCYXNlKG9iaikgJiYgdHlwZW9mIG9iai5uZXN0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqLm5lc3RlZClcbiAgICAgICAgICAgICAgICAubWFwKG5hbWUgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLm5lc3RlZFtuYW1lXSwgb2JqTmFtZSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yLmNvbmNhdChjdXJyZW50VmFsdWUpLCBbXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzZXJpYWxpemVyKGNscywgb3B0aW9ucykge1xuICAgIHJldHVybiBmdW5jdGlvbiBkZXNlcmlhbGl6ZShhcmdCdWYpIHtcbiAgICAgICAgcmV0dXJuIGNscy50b09iamVjdChjbHMuZGVjb2RlKGFyZ0J1ZiksIG9wdGlvbnMpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXJpYWxpemVyKGNscykge1xuICAgIHJldHVybiBmdW5jdGlvbiBzZXJpYWxpemUoYXJnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNlcmlhbGl6ZSBtZXNzYWdlOiBleHBlY3RlZCBvYmplY3Qgd2l0aCAke2Nscy5uYW1lfSBzdHJ1Y3R1cmUsIGdvdCBhcnJheSBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNscy5mcm9tT2JqZWN0KGFyZyk7XG4gICAgICAgIHJldHVybiBjbHMuZW5jb2RlKG1lc3NhZ2UpLmZpbmlzaCgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXBNZXRob2RPcHRpb25zKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKG9wdGlvbnMgfHwgW10pLnJlZHVjZSgob2JqLCBpdGVtKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGl0ZW0pKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VuaW50ZXJwcmV0ZWRfb3B0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgb2JqLnVuaW50ZXJwcmV0ZWRfb3B0aW9uLnB1c2goaXRlbS51bmludGVycHJldGVkX29wdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9LCB7XG4gICAgICAgIGRlcHJlY2F0ZWQ6IGZhbHNlLFxuICAgICAgICBpZGVtcG90ZW5jeV9sZXZlbDogSWRlbXBvdGVuY3lMZXZlbC5JREVNUE9URU5DWV9VTktOT1dOLFxuICAgICAgICB1bmludGVycHJldGVkX29wdGlvbjogW10sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVNZXRob2REZWZpbml0aW9uKG1ldGhvZCwgc2VydmljZU5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIC8qIFRoaXMgaXMgb25seSBldmVyIGNhbGxlZCBhZnRlciB0aGUgY29ycmVzcG9uZGluZyByb290LnJlc29sdmVBbGwoKSwgc28gd2VcbiAgICAgKiBjYW4gYXNzdW1lIHRoYXQgdGhlIHJlc29sdmVkIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHR5cGVzIGFyZSBub24tbnVsbCAqL1xuICAgIGNvbnN0IHJlcXVlc3RUeXBlID0gbWV0aG9kLnJlc29sdmVkUmVxdWVzdFR5cGU7XG4gICAgY29uc3QgcmVzcG9uc2VUeXBlID0gbWV0aG9kLnJlc29sdmVkUmVzcG9uc2VUeXBlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6ICcvJyArIHNlcnZpY2VOYW1lICsgJy8nICsgbWV0aG9kLm5hbWUsXG4gICAgICAgIHJlcXVlc3RTdHJlYW06ICEhbWV0aG9kLnJlcXVlc3RTdHJlYW0sXG4gICAgICAgIHJlc3BvbnNlU3RyZWFtOiAhIW1ldGhvZC5yZXNwb25zZVN0cmVhbSxcbiAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogY3JlYXRlU2VyaWFsaXplcihyZXF1ZXN0VHlwZSksXG4gICAgICAgIHJlcXVlc3REZXNlcmlhbGl6ZTogY3JlYXRlRGVzZXJpYWxpemVyKHJlcXVlc3RUeXBlLCBvcHRpb25zKSxcbiAgICAgICAgcmVzcG9uc2VTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVzcG9uc2VUeXBlKSxcbiAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogY3JlYXRlRGVzZXJpYWxpemVyKHJlc3BvbnNlVHlwZSwgb3B0aW9ucyksXG4gICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogRmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXNcbiAgICAgICAgb3JpZ2luYWxOYW1lOiBjYW1lbENhc2UobWV0aG9kLm5hbWUpLFxuICAgICAgICByZXF1ZXN0VHlwZTogY3JlYXRlTWVzc2FnZURlZmluaXRpb24ocmVxdWVzdFR5cGUsIGZpbGVEZXNjcmlwdG9ycyksXG4gICAgICAgIHJlc3BvbnNlVHlwZTogY3JlYXRlTWVzc2FnZURlZmluaXRpb24ocmVzcG9uc2VUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICBvcHRpb25zOiBtYXBNZXRob2RPcHRpb25zKG1ldGhvZC5wYXJzZWRPcHRpb25zKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VydmljZURlZmluaXRpb24oc2VydmljZSwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZGVmID0ge307XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2Ygc2VydmljZS5tZXRob2RzQXJyYXkpIHtcbiAgICAgICAgZGVmW21ldGhvZC5uYW1lXSA9IGNyZWF0ZU1ldGhvZERlZmluaXRpb24obWV0aG9kLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZURlZmluaXRpb24obWVzc2FnZSwgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgbWVzc2FnZURlc2NyaXB0b3IgPSBtZXNzYWdlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiAnUHJvdG9jb2wgQnVmZmVyIDMgRGVzY3JpcHRvclByb3RvJyxcbiAgICAgICAgdHlwZTogbWVzc2FnZURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QobWVzc2FnZURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRW51bURlZmluaXRpb24oZW51bVR5cGUsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGVudW1EZXNjcmlwdG9yID0gZW51bVR5cGUudG9EZXNjcmlwdG9yKCdwcm90bzMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBFbnVtRGVzY3JpcHRvclByb3RvJyxcbiAgICAgICAgdHlwZTogZW51bURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QoZW51bURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcbiAgICB9O1xufVxuLyoqXG4gKiBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuU2VydmljZSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOlxuICogT3B0aW9ucyk6IFNlcnZpY2VEZWZpbml0aW9uOyBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuVHlwZSxcbiAqIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6IE1lc3NhZ2VUeXBlRGVmaW5pdGlvbjsgZnVuY3Rpb25cbiAqIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5FbnVtLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOlxuICogRW51bVR5cGVEZWZpbml0aW9uO1xuICovXG5mdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWVzc2FnZURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbnVtRGVmaW5pdGlvbihvYmosIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbWlzbWF0Y2ggaW4gcmVmbGVjdGlvbiBvYmplY3QgaGFuZGxpbmcnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmID0ge307XG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgY29uc3QgZGVzY3JpcHRvckxpc3QgPSByb290LnRvRGVzY3JpcHRvcigncHJvdG8zJykuZmlsZTtcbiAgICBjb25zdCBidWZmZXJMaXN0ID0gZGVzY3JpcHRvckxpc3QubWFwKHZhbHVlID0+IEJ1ZmZlci5mcm9tKGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JQcm90by5lbmNvZGUodmFsdWUpLmZpbmlzaCgpKSk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgb2JqXSBvZiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMocm9vdCwgJycpKSB7XG4gICAgICAgIGRlZltuYW1lXSA9IGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBidWZmZXJMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByb290ID0gUHJvdG9idWYuUm9vdC5mcm9tRGVzY3JpcHRvcihkZWNvZGVkRGVzY3JpcHRvclNldCk7XG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKHJvb3QsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBMb2FkIGEgLnByb3RvIGZpbGUgd2l0aCB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuXG4gKiBAcGFyYW0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGUgcGF0aHMgdG8gbG9hZC4gQ2FuIGJlIGFuIGFic29sdXRlIHBhdGhcbiAqICAgICBvciByZWxhdGl2ZSB0byBhbiBpbmNsdWRlIHBhdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5rZWVwQ2FzZSBQcmVzZXJ2ZSBmaWVsZCBuYW1lcy4gVGhlIGRlZmF1bHQgaXMgdG8gY2hhbmdlIHRoZW1cbiAqICAgICB0byBjYW1lbCBjYXNlLlxuICogQHBhcmFtIG9wdGlvbnMubG9uZ3MgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGxvbmdgIHZhbHVlcy5cbiAqICAgICBWYWxpZCBvcHRpb25zIGFyZSBgTnVtYmVyYCBhbmQgYFN0cmluZ2AuIERlZmF1bHRzIHRvIGEgYExvbmdgIG9iamVjdCB0eXBlXG4gKiAgICAgZnJvbSBhIGxpYnJhcnkuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbnVtcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgZW51bWAgdmFsdWVzLlxuICogICAgIFRoZSBvbmx5IHZhbGlkIG9wdGlvbiBpcyBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gdGhlIG51bWVyaWMgdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucy5ieXRlcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgYnl0ZXNgXG4gKiAgICAgdmFsdWVzLiBWYWxpZCBvcHRpb25zIGFyZSBgQXJyYXlgIGFuZCBgU3RyaW5nYC4gVGhlIGRlZmF1bHQgaXMgdG8gdXNlXG4gKiAgICAgYEJ1ZmZlcmAuXG4gKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0cyBTZXQgZGVmYXVsdCB2YWx1ZXMgb24gb3V0cHV0IG9iamVjdHMuIERlZmF1bHRzIHRvXG4gKiAgICAgYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLmFycmF5cyBTZXQgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIGFycmF5IHZhbHVlcyBldmVuIGlmXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMub2JqZWN0cyBTZXQgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBvYmplY3QgdmFsdWVzIGV2ZW4gaWZcbiAqICAgICBgZGVmYXVsdHNgIGlzIGBmYWxzZWAuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5vbmVvZnMgU2V0IHZpcnR1YWwgb25lb2YgcHJvcGVydGllcyB0byB0aGUgcHJlc2VudCBmaWVsZCdzXG4gKiAgICAgbmFtZVxuICogQHBhcmFtIG9wdGlvbnMuanNvbiBSZXByZXNlbnQgSW5maW5pdHkgYW5kIE5hTiBhcyBzdHJpbmdzIGluIGZsb2F0IGZpZWxkcyxcbiAqICAgICBhbmQgYXV0b21hdGljYWxseSBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLkFueSB2YWx1ZXMuXG4gKiBAcGFyYW0gb3B0aW9ucy5pbmNsdWRlRGlycyBQYXRocyB0byBzZWFyY2ggZm9yIGltcG9ydGVkIGAucHJvdG9gIGZpbGVzLlxuICovXG5mdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zKShmaWxlbmFtZSwgb3B0aW9ucykudGhlbihsb2FkZWRSb290ID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmZ1bmN0aW9uIGxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9ICgwLCB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYykoZmlsZW5hbWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZFN5bmMgPSBsb2FkU3luYztcbmZ1bmN0aW9uIGZyb21KU09OKGpzb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBsb2FkZWRSb290ID0gUHJvdG9idWYuUm9vdC5mcm9tSlNPTihqc29uKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmZyb21KU09OID0gZnJvbUpTT047XG5mdW5jdGlvbiBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyKGRlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWNvZGVkRGVzY3JpcHRvclNldCA9IGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JTZXQuZGVjb2RlKGRlc2NyaXB0b3JTZXQpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXI7XG5mdW5jdGlvbiBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0KGRlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWNvZGVkRGVzY3JpcHRvclNldCA9IGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JTZXQuZnJvbU9iamVjdChkZXNjcmlwdG9yU2V0KTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0O1xuKDAsIHV0aWxfMS5hZGRDb21tb25Qcm90b3MpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target) => {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths) {\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error('The includeDirs option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */\nfunction addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsR0FBRyxpQ0FBaUMsR0FBRyw2QkFBNkI7QUFDM0YsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLDREQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVEsd0NBQXdDLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxxR0FBcUM7QUFDdkUsaUNBQWlDLG1CQUFPLENBQUMsbUhBQTRDO0FBQ3JGLG9DQUFvQyxtQkFBTyxDQUFDLDJIQUFnRDtBQUM1RiwyQkFBMkIsbUJBQU8sQ0FBQyx1R0FBc0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2NyaXN0aWFuYmVyYmVjYXJ1L1Byb2plY3RzL01OQy9EZXZlbG9wL3ZpYmUtY29kaW5nL2xvb2thZ2Fpbi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkQ29tbW9uUHJvdG9zID0gZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jID0gZXhwb3J0cy5sb2FkUHJvdG9zV2l0aE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IFByb3RvYnVmID0gcmVxdWlyZShcInByb3RvYnVmanNcIik7XG5mdW5jdGlvbiBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIGluY2x1ZGVQYXRocykge1xuICAgIGNvbnN0IG9yaWdpbmFsUmVzb2x2ZVBhdGggPSByb290LnJlc29sdmVQYXRoO1xuICAgIHJvb3QucmVzb2x2ZVBhdGggPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcbiAgICAgICAgaWYgKHBhdGguaXNBYnNvbHV0ZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZGlyZWN0b3J5IG9mIGluY2x1ZGVQYXRocykge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCB0YXJnZXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmcy5hY2Nlc3NTeW5jKGZ1bGxQYXRoLCBmcy5jb25zdGFudHMuUl9PSyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bGxQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoYCR7dGFyZ2V0fSBub3QgZm91bmQgaW4gYW55IG9mIHRoZSBpbmNsdWRlIHBhdGhzICR7aW5jbHVkZVBhdGhzfWApO1xuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZXNvbHZlUGF0aChvcmlnaW4sIHRhcmdldCk7XG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRQcm90b3NXaXRoT3B0aW9ucyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUaGUgaW5jbHVkZURpcnMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkSW5jbHVkZVBhdGhSZXNvbHZlcihyb290LCBvcHRpb25zLmluY2x1ZGVEaXJzKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IGF3YWl0IHJvb3QubG9hZChmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGxvYWRlZFJvb3Q7XG59XG5leHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IGxvYWRQcm90b3NXaXRoT3B0aW9ucztcbmZ1bmN0aW9uIGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByb290ID0gbmV3IFByb3RvYnVmLlJvb3QoKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoISFvcHRpb25zLmluY2x1ZGVEaXJzKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLmluY2x1ZGVEaXJzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgaW5jbHVkZURpcnMgb3B0aW9uIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gcm9vdC5sb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGxvYWRlZFJvb3Q7XG59XG5leHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jO1xuLyoqXG4gKiBMb2FkIEdvb2dsZSdzIHdlbGwta25vd24gcHJvdG8gZmlsZXMgdGhhdCBhcmVuJ3QgZXhwb3NlZCBieSBQcm90b2J1Zi5qcy5cbiAqL1xuZnVuY3Rpb24gYWRkQ29tbW9uUHJvdG9zKCkge1xuICAgIC8vIFByb3RvYnVmLmpzIGV4cG9zZXM6IGFueSwgZHVyYXRpb24sIGVtcHR5LCBmaWVsZF9tYXNrLCBzdHJ1Y3QsIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd3JhcHBlcnMuIGNvbXBpbGVyL3BsdWdpbiBpcyBleGNsdWRlZCBpbiBQcm90b2J1Zi5qcyBhbmQgaGVyZS5cbiAgICAvLyBVc2luZyBjb25zdGFudCBzdHJpbmdzIGZvciBjb21wYXRpYmlsaXR5IHdpdGggdG9vbHMgbGlrZSBXZWJwYWNrXG4gICAgY29uc3QgYXBpRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2FwaS5qc29uJyk7XG4gICAgY29uc3QgZGVzY3JpcHRvckRlc2NyaXB0b3IgPSByZXF1aXJlKCdwcm90b2J1ZmpzL2dvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLmpzb24nKTtcbiAgICBjb25zdCBzb3VyY2VDb250ZXh0RGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL3NvdXJjZV9jb250ZXh0Lmpzb24nKTtcbiAgICBjb25zdCB0eXBlRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL3R5cGUuanNvbicpO1xuICAgIFByb3RvYnVmLmNvbW1vbignYXBpJywgYXBpRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xuICAgIFByb3RvYnVmLmNvbW1vbignZGVzY3JpcHRvcicsIGRlc2NyaXB0b3JEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdzb3VyY2VfY29udGV4dCcsIHNvdXJjZUNvbnRleHREZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCd0eXBlJywgdHlwZURlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbn1cbmV4cG9ydHMuYWRkQ29tbW9uUHJvdG9zID0gYWRkQ29tbW9uUHJvdG9zO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ })

};
;